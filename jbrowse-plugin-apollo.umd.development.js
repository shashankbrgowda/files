(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jbrowse/core/Plugin'), require('@jbrowse/core/util'), require('@jbrowse/core/configuration'), require('@jbrowse/core/pluggableElementTypes'), require('@mui/material/utils'), require('react/jsx-runtime'), require('mobx'), require('mobx-state-tree'), require('@mui/material'), require('react'), require('tss-react/mui'), require('@jbrowse/core/ui'), require('mobx-react'), require('@jbrowse/core/util/types/mst'), require('@jbrowse/core/util/io'), require('@mui/material/Checkbox'), require('@mui/material/FormControlLabel'), require('@mui/material/LinearProgress'), require('@mui/x-data-grid'), require('@mui/material/Box'), require('@mui/material/Collapse'), require('@mui/material/IconButton'), require('@mui/material/Paper'), require('@mui/material/Table'), require('@mui/material/TableBody'), require('@mui/material/TableCell'), require('@mui/material/TableContainer'), require('@mui/material/TableFooter'), require('@mui/material/TableHead'), require('@mui/material/TablePagination'), require('@mui/material/TableRow'), require('@mui/material/Typography'), require('@mui/material/styles'), require('@jbrowse/core/pluggableElementTypes/AdapterType'), require('@jbrowse/core/data_adapters/BaseAdapter'), require('@jbrowse/core/util/rxjs'), require('@jbrowse/core/util/tracks')) :
	typeof define === 'function' && define.amd ? define(['exports', '@jbrowse/core/Plugin', '@jbrowse/core/util', '@jbrowse/core/configuration', '@jbrowse/core/pluggableElementTypes', '@mui/material/utils', 'react/jsx-runtime', 'mobx', 'mobx-state-tree', '@mui/material', 'react', 'tss-react/mui', '@jbrowse/core/ui', 'mobx-react', '@jbrowse/core/util/types/mst', '@jbrowse/core/util/io', '@mui/material/Checkbox', '@mui/material/FormControlLabel', '@mui/material/LinearProgress', '@mui/x-data-grid', '@mui/material/Box', '@mui/material/Collapse', '@mui/material/IconButton', '@mui/material/Paper', '@mui/material/Table', '@mui/material/TableBody', '@mui/material/TableCell', '@mui/material/TableContainer', '@mui/material/TableFooter', '@mui/material/TableHead', '@mui/material/TablePagination', '@mui/material/TableRow', '@mui/material/Typography', '@mui/material/styles', '@jbrowse/core/pluggableElementTypes/AdapterType', '@jbrowse/core/data_adapters/BaseAdapter', '@jbrowse/core/util/rxjs', '@jbrowse/core/util/tracks'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.JBrowsePluginApollo = {}, global.JBrowseExports["@jbrowse/core/Plugin"], global.JBrowseExports["@jbrowse/core/util"], global.JBrowseExports["@jbrowse/core/configuration"], global.JBrowseExports["@jbrowse/core/pluggableElementTypes"], global.JBrowseExports["@mui/material/utils"], global.JBrowseExports["react/jsx-runtime"], global.JBrowseExports.mobx, global.JBrowseExports["mobx-state-tree"], global.JBrowseExports["@mui/material"], global.JBrowseExports.react, global.JBrowseExports["tss-react/mui"], global.JBrowseExports["@jbrowse/core/ui"], global.JBrowseExports["mobx-react"], global.JBrowseExports["@jbrowse/core/util/types/mst"], global.JBrowseExports["@jbrowse/core/util/io"], global.JBrowseExports["@mui/material/Checkbox"], global.JBrowseExports["@mui/material/FormControlLabel"], global.JBrowseExports["@mui/material/LinearProgress"], global.JBrowseExports["@mui/x-data-grid"], global.JBrowseExports["@mui/material/Box"], global.JBrowseExports["@mui/material/Collapse"], global.JBrowseExports["@mui/material/IconButton"], global.JBrowseExports["@mui/material/Paper"], global.JBrowseExports["@mui/material/Table"], global.JBrowseExports["@mui/material/TableBody"], global.JBrowseExports["@mui/material/TableCell"], global.JBrowseExports["@mui/material/TableContainer"], global.JBrowseExports["@mui/material/TableFooter"], global.JBrowseExports["@mui/material/TableHead"], global.JBrowseExports["@mui/material/TablePagination"], global.JBrowseExports["@mui/material/TableRow"], global.JBrowseExports["@mui/material/Typography"], global.JBrowseExports["@mui/material/styles"], global.JBrowseExports["@jbrowse/core/pluggableElementTypes/AdapterType"], global.JBrowseExports["@jbrowse/core/data_adapters/BaseAdapter"], global.JBrowseExports["@jbrowse/core/util/rxjs"], global.JBrowseExports["@jbrowse/core/util/tracks"]));
})(this, (function (exports, require$$1$1, require$$1$2, configuration, pluggableElementTypes, require$$0$2, require$$2$1, mobx, require$$1$3, material, React, mui, ui, mobxReact, mst, io, Checkbox, FormControlLabel, LinearProgress, xDataGrid, Box, Collapse, IconButton, Paper, Table, TableBody, TableCell, TableContainer, TableFooter, TableHead, TablePagination, TableRow, Typography, styles, AdapterType, BaseAdapter, rxjs, tracks) { 'use strict';

	function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	function _interopNamespace(e) {
		if (e && e.__esModule) return e;
		var n = Object.create(null);
		if (e) {
			Object.keys(e).forEach(function (k) {
				if (k !== 'default') {
					var d = Object.getOwnPropertyDescriptor(e, k);
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: function () { return e[k]; }
					});
				}
			});
		}
		n["default"] = e;
		return n;
	}

	var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1$1);
	var require$$1__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$1$2);
	var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$2);
	var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2$1);
	var require$$1__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$1$3);
	var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
	var React__namespace = /*#__PURE__*/_interopNamespace(React);
	var Checkbox__default = /*#__PURE__*/_interopDefaultLegacy(Checkbox);
	var FormControlLabel__default = /*#__PURE__*/_interopDefaultLegacy(FormControlLabel);
	var LinearProgress__default = /*#__PURE__*/_interopDefaultLegacy(LinearProgress);
	var Box__default = /*#__PURE__*/_interopDefaultLegacy(Box);
	var Collapse__default = /*#__PURE__*/_interopDefaultLegacy(Collapse);
	var IconButton__default = /*#__PURE__*/_interopDefaultLegacy(IconButton);
	var Paper__default = /*#__PURE__*/_interopDefaultLegacy(Paper);
	var Table__default = /*#__PURE__*/_interopDefaultLegacy(Table);
	var TableBody__default = /*#__PURE__*/_interopDefaultLegacy(TableBody);
	var TableCell__default = /*#__PURE__*/_interopDefaultLegacy(TableCell);
	var TableContainer__default = /*#__PURE__*/_interopDefaultLegacy(TableContainer);
	var TableFooter__default = /*#__PURE__*/_interopDefaultLegacy(TableFooter);
	var TableHead__default = /*#__PURE__*/_interopDefaultLegacy(TableHead);
	var TablePagination__default = /*#__PURE__*/_interopDefaultLegacy(TablePagination);
	var TableRow__default = /*#__PURE__*/_interopDefaultLegacy(TableRow);
	var Typography__default = /*#__PURE__*/_interopDefaultLegacy(Typography);
	var AdapterType__default = /*#__PURE__*/_interopDefaultLegacy(AdapterType);

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getAugmentedNamespace(n) {
		if (n.__esModule) return n;
		var a = Object.defineProperty({}, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	function commonjsRequire (path) {
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}

	var dist$3 = {};

	function _AsyncGenerator(e) {
	  var r, t;
	  function resume(r, t) {
	    try {
	      var n = e[r](t),
	        o = n.value,
	        u = o instanceof _OverloadYield;
	      Promise.resolve(u ? o.v : o).then(function (t) {
	        if (u) {
	          var i = "return" === r ? "return" : "next";
	          if (!o.k || t.done) return resume(i, t);
	          t = e[i](t).value;
	        }
	        settle(n.done ? "return" : "normal", t);
	      }, function (e) {
	        resume("throw", e);
	      });
	    } catch (e) {
	      settle("throw", e);
	    }
	  }
	  function settle(e, n) {
	    switch (e) {
	      case "return":
	        r.resolve({
	          value: n,
	          done: !0
	        });
	        break;
	      case "throw":
	        r.reject(n);
	        break;
	      default:
	        r.resolve({
	          value: n,
	          done: !1
	        });
	    }
	    (r = r.next) ? resume(r.key, r.arg) : t = null;
	  }
	  this._invoke = function (e, n) {
	    return new Promise(function (o, u) {
	      var i = {
	        key: e,
	        arg: n,
	        resolve: o,
	        reject: u,
	        next: null
	      };
	      t ? t = t.next = i : (r = t = i, resume(e, n));
	    });
	  }, "function" != typeof e.return && (this.return = void 0);
	}
	_AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () {
	  return this;
	}, _AsyncGenerator.prototype.next = function (e) {
	  return this._invoke("next", e);
	}, _AsyncGenerator.prototype.throw = function (e) {
	  return this._invoke("throw", e);
	}, _AsyncGenerator.prototype.return = function (e) {
	  return this._invoke("return", e);
	};
	function _OverloadYield(t, e) {
	  this.v = t, this.k = e;
	}
	function _asyncIterator(r) {
	  var n,
	    t,
	    o,
	    e = 2;
	  for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) {
	    if (t && null != (n = r[t])) return n.call(r);
	    if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));
	    t = "@@asyncIterator", o = "@@iterator";
	  }
	  throw new TypeError("Object is not async iterable");
	}
	function AsyncFromSyncIterator(r) {
	  function AsyncFromSyncIteratorContinuation(r) {
	    if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
	    var n = r.done;
	    return Promise.resolve(r.value).then(function (r) {
	      return {
	        value: r,
	        done: n
	      };
	    });
	  }
	  return AsyncFromSyncIterator = function (r) {
	    this.s = r, this.n = r.next;
	  }, AsyncFromSyncIterator.prototype = {
	    s: null,
	    n: null,
	    next: function () {
	      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
	    },
	    return: function (r) {
	      var n = this.s.return;
	      return void 0 === n ? Promise.resolve({
	        value: r,
	        done: !0
	      }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));
	    },
	    throw: function (r) {
	      var n = this.s.return;
	      return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));
	    }
	  }, new AsyncFromSyncIterator(r);
	}
	function _awaitAsyncGenerator(e) {
	  return new _OverloadYield(e, 0);
	}
	function _iterableToArrayLimit(r, l) {
	  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
	  if (null != t) {
	    var e,
	      n,
	      i,
	      u,
	      a = [],
	      f = !0,
	      o = !1;
	    try {
	      if (i = (t = t.call(r)).next, 0 === l) {
	        if (Object(t) !== t) return;
	        f = !1;
	      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
	    } catch (r) {
	      o = !0, n = r;
	    } finally {
	      try {
	        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
	      } finally {
	        if (o) throw n;
	      }
	    }
	    return a;
	  }
	}
	function ownKeys(e, r) {
	  var t = Object.keys(e);
	  if (Object.getOwnPropertySymbols) {
	    var o = Object.getOwnPropertySymbols(e);
	    r && (o = o.filter(function (r) {
	      return Object.getOwnPropertyDescriptor(e, r).enumerable;
	    })), t.push.apply(t, o);
	  }
	  return t;
	}
	function _objectSpread2(e) {
	  for (var r = 1; r < arguments.length; r++) {
	    var t = null != arguments[r] ? arguments[r] : {};
	    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
	      _defineProperty(e, r, t[r]);
	    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
	      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
	    });
	  }
	  return e;
	}
	function _regeneratorRuntime() {
	  _regeneratorRuntime = function () {
	    return e;
	  };
	  var t,
	    e = {},
	    r = Object.prototype,
	    n = r.hasOwnProperty,
	    o = Object.defineProperty || function (t, e, r) {
	      t[e] = r.value;
	    },
	    i = "function" == typeof Symbol ? Symbol : {},
	    a = i.iterator || "@@iterator",
	    c = i.asyncIterator || "@@asyncIterator",
	    u = i.toStringTag || "@@toStringTag";
	  function define(t, e, r) {
	    return Object.defineProperty(t, e, {
	      value: r,
	      enumerable: !0,
	      configurable: !0,
	      writable: !0
	    }), t[e];
	  }
	  try {
	    define({}, "");
	  } catch (t) {
	    define = function (t, e, r) {
	      return t[e] = r;
	    };
	  }
	  function wrap(t, e, r, n) {
	    var i = e && e.prototype instanceof Generator ? e : Generator,
	      a = Object.create(i.prototype),
	      c = new Context(n || []);
	    return o(a, "_invoke", {
	      value: makeInvokeMethod(t, r, c)
	    }), a;
	  }
	  function tryCatch(t, e, r) {
	    try {
	      return {
	        type: "normal",
	        arg: t.call(e, r)
	      };
	    } catch (t) {
	      return {
	        type: "throw",
	        arg: t
	      };
	    }
	  }
	  e.wrap = wrap;
	  var h = "suspendedStart",
	    l = "suspendedYield",
	    f = "executing",
	    s = "completed",
	    y = {};
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	  var p = {};
	  define(p, a, function () {
	    return this;
	  });
	  var d = Object.getPrototypeOf,
	    v = d && d(d(values([])));
	  v && v !== r && n.call(v, a) && (p = v);
	  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
	  function defineIteratorMethods(t) {
	    ["next", "throw", "return"].forEach(function (e) {
	      define(t, e, function (t) {
	        return this._invoke(e, t);
	      });
	    });
	  }
	  function AsyncIterator(t, e) {
	    function invoke(r, o, i, a) {
	      var c = tryCatch(t[r], t, o);
	      if ("throw" !== c.type) {
	        var u = c.arg,
	          h = u.value;
	        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
	          invoke("next", t, i, a);
	        }, function (t) {
	          invoke("throw", t, i, a);
	        }) : e.resolve(h).then(function (t) {
	          u.value = t, i(u);
	        }, function (t) {
	          return invoke("throw", t, i, a);
	        });
	      }
	      a(c.arg);
	    }
	    var r;
	    o(this, "_invoke", {
	      value: function (t, n) {
	        function callInvokeWithMethodAndArg() {
	          return new e(function (e, r) {
	            invoke(t, n, e, r);
	          });
	        }
	        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
	      }
	    });
	  }
	  function makeInvokeMethod(e, r, n) {
	    var o = h;
	    return function (i, a) {
	      if (o === f) throw new Error("Generator is already running");
	      if (o === s) {
	        if ("throw" === i) throw a;
	        return {
	          value: t,
	          done: !0
	        };
	      }
	      for (n.method = i, n.arg = a;;) {
	        var c = n.delegate;
	        if (c) {
	          var u = maybeInvokeDelegate(c, n);
	          if (u) {
	            if (u === y) continue;
	            return u;
	          }
	        }
	        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
	          if (o === h) throw o = s, n.arg;
	          n.dispatchException(n.arg);
	        } else "return" === n.method && n.abrupt("return", n.arg);
	        o = f;
	        var p = tryCatch(e, r, n);
	        if ("normal" === p.type) {
	          if (o = n.done ? s : l, p.arg === y) continue;
	          return {
	            value: p.arg,
	            done: n.done
	          };
	        }
	        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
	      }
	    };
	  }
	  function maybeInvokeDelegate(e, r) {
	    var n = r.method,
	      o = e.iterator[n];
	    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
	    var i = tryCatch(o, e.iterator, r.arg);
	    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
	    var a = i.arg;
	    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
	  }
	  function pushTryEntry(t) {
	    var e = {
	      tryLoc: t[0]
	    };
	    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
	  }
	  function resetTryEntry(t) {
	    var e = t.completion || {};
	    e.type = "normal", delete e.arg, t.completion = e;
	  }
	  function Context(t) {
	    this.tryEntries = [{
	      tryLoc: "root"
	    }], t.forEach(pushTryEntry, this), this.reset(!0);
	  }
	  function values(e) {
	    if (e || "" === e) {
	      var r = e[a];
	      if (r) return r.call(e);
	      if ("function" == typeof e.next) return e;
	      if (!isNaN(e.length)) {
	        var o = -1,
	          i = function next() {
	            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
	            return next.value = t, next.done = !0, next;
	          };
	        return i.next = i;
	      }
	    }
	    throw new TypeError(typeof e + " is not iterable");
	  }
	  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
	    value: GeneratorFunctionPrototype,
	    configurable: !0
	  }), o(GeneratorFunctionPrototype, "constructor", {
	    value: GeneratorFunction,
	    configurable: !0
	  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
	    var e = "function" == typeof t && t.constructor;
	    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
	  }, e.mark = function (t) {
	    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
	  }, e.awrap = function (t) {
	    return {
	      __await: t
	    };
	  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
	    return this;
	  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
	    void 0 === i && (i = Promise);
	    var a = new AsyncIterator(wrap(t, r, n, o), i);
	    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
	      return t.done ? t.value : a.next();
	    });
	  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
	    return this;
	  }), define(g, "toString", function () {
	    return "[object Generator]";
	  }), e.keys = function (t) {
	    var e = Object(t),
	      r = [];
	    for (var n in e) r.push(n);
	    return r.reverse(), function next() {
	      for (; r.length;) {
	        var t = r.pop();
	        if (t in e) return next.value = t, next.done = !1, next;
	      }
	      return next.done = !0, next;
	    };
	  }, e.values = values, Context.prototype = {
	    constructor: Context,
	    reset: function (e) {
	      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
	    },
	    stop: function () {
	      this.done = !0;
	      var t = this.tryEntries[0].completion;
	      if ("throw" === t.type) throw t.arg;
	      return this.rval;
	    },
	    dispatchException: function (e) {
	      if (this.done) throw e;
	      var r = this;
	      function handle(n, o) {
	        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
	      }
	      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
	        var i = this.tryEntries[o],
	          a = i.completion;
	        if ("root" === i.tryLoc) return handle("end");
	        if (i.tryLoc <= this.prev) {
	          var c = n.call(i, "catchLoc"),
	            u = n.call(i, "finallyLoc");
	          if (c && u) {
	            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
	            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
	          } else if (c) {
	            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
	          } else {
	            if (!u) throw new Error("try statement without catch or finally");
	            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
	          }
	        }
	      }
	    },
	    abrupt: function (t, e) {
	      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
	        var o = this.tryEntries[r];
	        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
	          var i = o;
	          break;
	        }
	      }
	      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
	      var a = i ? i.completion : {};
	      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
	    },
	    complete: function (t, e) {
	      if ("throw" === t.type) throw t.arg;
	      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
	    },
	    finish: function (t) {
	      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
	        var r = this.tryEntries[e];
	        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
	      }
	    },
	    catch: function (t) {
	      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
	        var r = this.tryEntries[e];
	        if (r.tryLoc === t) {
	          var n = r.completion;
	          if ("throw" === n.type) {
	            var o = n.arg;
	            resetTryEntry(r);
	          }
	          return o;
	        }
	      }
	      throw new Error("illegal catch attempt");
	    },
	    delegateYield: function (e, r, n) {
	      return this.delegate = {
	        iterator: values(e),
	        resultName: r,
	        nextLoc: n
	      }, "next" === this.method && (this.arg = t), y;
	    }
	  }, e;
	}
	function _typeof(o) {
	  "@babel/helpers - typeof";

	  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
	    return typeof o;
	  } : function (o) {
	    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
	  }, _typeof(o);
	}
	function _wrapAsyncGenerator(fn) {
	  return function () {
	    return new _AsyncGenerator(fn.apply(this, arguments));
	  };
	}
	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }
	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}
	function _asyncToGenerator(fn) {
	  return function () {
	    var self = this,
	      args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);
	      function _next(value) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
	      }
	      function _throw(err) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
	      }
	      _next(undefined);
	    });
	  };
	}
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
	  }
	}
	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  Object.defineProperty(Constructor, "prototype", {
	    writable: false
	  });
	  return Constructor;
	}
	function _defineProperty(obj, key, value) {
	  key = _toPropertyKey(key);
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	  return obj;
	}
	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }
	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  Object.defineProperty(subClass, "prototype", {
	    writable: false
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}
	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}
	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };
	  return _setPrototypeOf(o, p);
	}
	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;
	  try {
	    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}
	function _construct(Parent, args, Class) {
	  if (_isNativeReflectConstruct()) {
	    _construct = Reflect.construct.bind();
	  } else {
	    _construct = function _construct(Parent, args, Class) {
	      var a = [null];
	      a.push.apply(a, args);
	      var Constructor = Function.bind.apply(Parent, a);
	      var instance = new Constructor();
	      if (Class) _setPrototypeOf(instance, Class.prototype);
	      return instance;
	    };
	  }
	  return _construct.apply(null, arguments);
	}
	function _isNativeFunction(fn) {
	  return Function.toString.call(fn).indexOf("[native code]") !== -1;
	}
	function _wrapNativeSuper(Class) {
	  var _cache = typeof Map === "function" ? new Map() : undefined;
	  _wrapNativeSuper = function _wrapNativeSuper(Class) {
	    if (Class === null || !_isNativeFunction(Class)) return Class;
	    if (typeof Class !== "function") {
	      throw new TypeError("Super expression must either be null or a function");
	    }
	    if (typeof _cache !== "undefined") {
	      if (_cache.has(Class)) return _cache.get(Class);
	      _cache.set(Class, Wrapper);
	    }
	    function Wrapper() {
	      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
	    }
	    Wrapper.prototype = Object.create(Class.prototype, {
	      constructor: {
	        value: Wrapper,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    return _setPrototypeOf(Wrapper, Class);
	  };
	  return _wrapNativeSuper(Class);
	}
	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;
	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }
	  return target;
	}
	function _objectWithoutProperties(source, excluded) {
	  if (source == null) return {};
	  var target = _objectWithoutPropertiesLoose(source, excluded);
	  var key, i;
	  if (Object.getOwnPropertySymbols) {
	    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
	    for (i = 0; i < sourceSymbolKeys.length; i++) {
	      key = sourceSymbolKeys[i];
	      if (excluded.indexOf(key) >= 0) continue;
	      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
	      target[key] = source[key];
	    }
	  }
	  return target;
	}
	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	  return self;
	}
	function _possibleConstructorReturn(self, call) {
	  if (call && (typeof call === "object" || typeof call === "function")) {
	    return call;
	  } else if (call !== void 0) {
	    throw new TypeError("Derived constructors may only return object or undefined");
	  }
	  return _assertThisInitialized(self);
	}
	function _createSuper(Derived) {
	  var hasNativeReflectConstruct = _isNativeReflectConstruct();
	  return function _createSuperInternal() {
	    var Super = _getPrototypeOf(Derived),
	      result;
	    if (hasNativeReflectConstruct) {
	      var NewTarget = _getPrototypeOf(this).constructor;
	      result = Reflect.construct(Super, arguments, NewTarget);
	    } else {
	      result = Super.apply(this, arguments);
	    }
	    return _possibleConstructorReturn(this, result);
	  };
	}
	function _superPropBase(object, property) {
	  while (!Object.prototype.hasOwnProperty.call(object, property)) {
	    object = _getPrototypeOf(object);
	    if (object === null) break;
	  }
	  return object;
	}
	function _get() {
	  if (typeof Reflect !== "undefined" && Reflect.get) {
	    _get = Reflect.get.bind();
	  } else {
	    _get = function _get(target, property, receiver) {
	      var base = _superPropBase(target, property);
	      if (!base) return;
	      var desc = Object.getOwnPropertyDescriptor(base, property);
	      if (desc.get) {
	        return desc.get.call(arguments.length < 3 ? target : receiver);
	      }
	      return desc.value;
	    };
	  }
	  return _get.apply(this, arguments);
	}
	function _slicedToArray(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
	}
	function _toArray(arr) {
	  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
	}
	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}
	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	}
	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}
	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
	}
	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}
	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;
	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	  return arr2;
	}
	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}
	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}
	function _createForOfIteratorHelper(o, allowArrayLike) {
	  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
	  if (!it) {
	    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
	      if (it) o = it;
	      var i = 0;
	      var F = function () {};
	      return {
	        s: F,
	        n: function () {
	          if (i >= o.length) return {
	            done: true
	          };
	          return {
	            done: false,
	            value: o[i++]
	          };
	        },
	        e: function (e) {
	          throw e;
	        },
	        f: F
	      };
	    }
	    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	  }
	  var normalCompletion = true,
	    didErr = false,
	    err;
	  return {
	    s: function () {
	      it = it.call(o);
	    },
	    n: function () {
	      var step = it.next();
	      normalCompletion = step.done;
	      return step;
	    },
	    e: function (e) {
	      didErr = true;
	      err = e;
	    },
	    f: function () {
	      try {
	        if (!normalCompletion && it.return != null) it.return();
	      } finally {
	        if (didErr) throw err;
	      }
	    }
	  };
	}
	function _toPrimitive(input, hint) {
	  if (typeof input !== "object" || input === null) return input;
	  var prim = input[Symbol.toPrimitive];
	  if (prim !== undefined) {
	    var res = prim.call(input, hint || "default");
	    if (typeof res !== "object") return res;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return (hint === "string" ? String : Number)(input);
	}
	function _toPropertyKey(arg) {
	  var key = _toPrimitive(arg, "string");
	  return typeof key === "symbol" ? key : String(key);
	}

	/******************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	/* global Reflect, Promise, SuppressedError, Symbol */

	var _extendStatics = function extendStatics(d, b) {
	  _extendStatics = Object.setPrototypeOf || {
	    __proto__: []
	  } instanceof Array && function (d, b) {
	    d.__proto__ = b;
	  } || function (d, b) {
	    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	  };
	  return _extendStatics(d, b);
	};
	function __extends$g(d, b) {
	  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	  _extendStatics(d, b);
	  function __() {
	    this.constructor = d;
	  }
	  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}
	var _assign = function __assign() {
	  _assign = Object.assign || function __assign(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];
	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }
	    return t;
	  };
	  return _assign.apply(this, arguments);
	};
	function __rest(s, e) {
	  var t = {};
	  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
	  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
	  }
	  return t;
	}
	function __decorate(decorators, target, key, desc) {
	  var c = arguments.length,
	    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	    d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	}
	function __param(paramIndex, decorator) {
	  return function (target, key) {
	    decorator(target, key, paramIndex);
	  };
	}
	function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
	  function accept(f) {
	    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
	    return f;
	  }
	  var kind = contextIn.kind,
	    key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
	  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
	  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
	  var _,
	    done = false;
	  for (var i = decorators.length - 1; i >= 0; i--) {
	    var context = {};
	    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
	    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
	    context.addInitializer = function (f) {
	      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
	      extraInitializers.push(accept(f || null));
	    };
	    var result = (0, decorators[i])(kind === "accessor" ? {
	      get: descriptor.get,
	      set: descriptor.set
	    } : descriptor[key], context);
	    if (kind === "accessor") {
	      if (result === void 0) continue;
	      if (result === null || _typeof(result) !== "object") throw new TypeError("Object expected");
	      if (_ = accept(result.get)) descriptor.get = _;
	      if (_ = accept(result.set)) descriptor.set = _;
	      if (_ = accept(result.init)) initializers.unshift(_);
	    } else if (_ = accept(result)) {
	      if (kind === "field") initializers.unshift(_);else descriptor[key] = _;
	    }
	  }
	  if (target) Object.defineProperty(target, contextIn.name, descriptor);
	  done = true;
	}
	function __runInitializers(thisArg, initializers, value) {
	  var useValue = arguments.length > 2;
	  for (var i = 0; i < initializers.length; i++) {
	    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
	  }
	  return useValue ? value : void 0;
	}
	function __propKey(x) {
	  return _typeof(x) === "symbol" ? x : "".concat(x);
	}
	function __setFunctionName(f, name, prefix) {
	  if (_typeof(name) === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
	  return Object.defineProperty(f, "name", {
	    configurable: true,
	    value: prefix ? "".concat(prefix, " ", name) : name
	  });
	}
	function __metadata(metadataKey, metadataValue) {
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
	}
	function __awaiter$1(thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }
	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }
	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }
	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }
	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	}
	function __generator$3(thisArg, body) {
	  var _ = {
	      label: 0,
	      sent: function sent() {
	        if (t[0] & 1) throw t[1];
	        return t[1];
	      },
	      trys: [],
	      ops: []
	    },
	    f,
	    y,
	    t,
	    g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
	    return this;
	  }), g;
	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }
	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");
	    while (g && (g = 0, op[0] && (_ = 0)), _) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];
	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;
	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };
	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;
	        case 7:
	          op = _.ops.pop();
	          _.trys.pop();
	          continue;
	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }
	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }
	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }
	          if (t && _.label < t[2]) {
	            _.label = t[2];
	            _.ops.push(op);
	            break;
	          }
	          if (t[2]) _.ops.pop();
	          _.trys.pop();
	          continue;
	      }
	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }
	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	}
	var __createBinding = Object.create ? function (o, m, k, k2) {
	  if (k2 === undefined) k2 = k;
	  var desc = Object.getOwnPropertyDescriptor(m, k);
	  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	    desc = {
	      enumerable: true,
	      get: function get() {
	        return m[k];
	      }
	    };
	  }
	  Object.defineProperty(o, k2, desc);
	} : function (o, m, k, k2) {
	  if (k2 === undefined) k2 = k;
	  o[k2] = m[k];
	};
	function __exportStar(m, o) {
	  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
	}
	function __values$9(o) {
	  var s = typeof Symbol === "function" && Symbol.iterator,
	    m = s && o[s],
	    i = 0;
	  if (m) return m.call(o);
	  if (o && typeof o.length === "number") return {
	    next: function next() {
	      if (o && i >= o.length) o = void 0;
	      return {
	        value: o && o[i++],
	        done: !o
	      };
	    }
	  };
	  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	}
	function __read$i(o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	}

	/** @deprecated */
	function __spread() {
	  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read$i(arguments[i]));
	  return ar;
	}

	/** @deprecated */
	function __spreadArrays() {
	  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
	  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
	  return r;
	}
	function __spreadArray$h(to, from, pack) {
	  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	    if (ar || !(i in from)) {
	      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	      ar[i] = from[i];
	    }
	  }
	  return to.concat(ar || Array.prototype.slice.call(from));
	}
	function __await$1(v) {
	  return this instanceof __await$1 ? (this.v = v, this) : new __await$1(v);
	}
	function __asyncGenerator$1(thisArg, _arguments, generator) {
	  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	  var g = generator.apply(thisArg, _arguments || []),
	    i,
	    q = [];
	  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
	    return this;
	  }, i;
	  function verb(n) {
	    if (g[n]) i[n] = function (v) {
	      return new Promise(function (a, b) {
	        q.push([n, v, a, b]) > 1 || resume(n, v);
	      });
	    };
	  }
	  function resume(n, v) {
	    try {
	      step(g[n](v));
	    } catch (e) {
	      settle(q[0][3], e);
	    }
	  }
	  function step(r) {
	    r.value instanceof __await$1 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
	  }
	  function fulfill(value) {
	    resume("next", value);
	  }
	  function reject(value) {
	    resume("throw", value);
	  }
	  function settle(f, v) {
	    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
	  }
	}
	function __asyncDelegator(o) {
	  var i, p;
	  return i = {}, verb("next"), verb("throw", function (e) {
	    throw e;
	  }), verb("return"), i[Symbol.iterator] = function () {
	    return this;
	  }, i;
	  function verb(n, f) {
	    i[n] = o[n] ? function (v) {
	      return (p = !p) ? {
	        value: __await$1(o[n](v)),
	        done: false
	      } : f ? f(v) : v;
	    } : f;
	  }
	}
	function __asyncValues$1(o) {
	  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	  var m = o[Symbol.asyncIterator],
	    i;
	  return m ? m.call(o) : (o = typeof __values$9 === "function" ? __values$9(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
	    return this;
	  }, i);
	  function verb(n) {
	    i[n] = o[n] && function (v) {
	      return new Promise(function (resolve, reject) {
	        v = o[n](v), settle(resolve, reject, v.done, v.value);
	      });
	    };
	  }
	  function settle(resolve, reject, d, v) {
	    Promise.resolve(v).then(function (v) {
	      resolve({
	        value: v,
	        done: d
	      });
	    }, reject);
	  }
	}
	function __makeTemplateObject(cooked, raw) {
	  if (Object.defineProperty) {
	    Object.defineProperty(cooked, "raw", {
	      value: raw
	    });
	  } else {
	    cooked.raw = raw;
	  }
	  return cooked;
	}
	var __setModuleDefault = Object.create ? function (o, v) {
	  Object.defineProperty(o, "default", {
	    enumerable: true,
	    value: v
	  });
	} : function (o, v) {
	  o["default"] = v;
	};
	function __importStar(mod) {
	  if (mod && mod.__esModule) return mod;
	  var result = {};
	  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	  __setModuleDefault(result, mod);
	  return result;
	}
	function __importDefault(mod) {
	  return mod && mod.__esModule ? mod : {
	    "default": mod
	  };
	}
	function __classPrivateFieldGet(receiver, state, kind, f) {
	  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
	}
	function __classPrivateFieldSet(receiver, state, value, kind, f) {
	  if (kind === "m") throw new TypeError("Private method is not writable");
	  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
	}
	function __classPrivateFieldIn(state, receiver) {
	  if (receiver === null || _typeof(receiver) !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
	  return typeof state === "function" ? receiver === state : state.has(receiver);
	}
	function __addDisposableResource(env, value, async) {
	  if (value !== null && value !== void 0) {
	    if (_typeof(value) !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
	    var dispose;
	    if (async) {
	      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
	      dispose = value[Symbol.asyncDispose];
	    }
	    if (dispose === void 0) {
	      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
	      dispose = value[Symbol.dispose];
	    }
	    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
	    env.stack.push({
	      value: value,
	      dispose: dispose,
	      async: async
	    });
	  } else if (async) {
	    env.stack.push({
	      async: true
	    });
	  }
	  return value;
	}
	var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
	  var e = new Error(message);
	  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
	};
	function __disposeResources(env) {
	  function fail(e) {
	    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
	    env.hasError = true;
	  }
	  function next() {
	    while (env.stack.length) {
	      var rec = env.stack.pop();
	      try {
	        var result = rec.dispose && rec.dispose.call(rec.value);
	        if (rec.async) return Promise.resolve(result).then(next, function (e) {
	          fail(e);
	          return next();
	        });
	      } catch (e) {
	        fail(e);
	      }
	    }
	    if (env.hasError) throw env.error;
	  }
	  return next();
	}
	var tslib_es6 = {
	  __extends: __extends$g,
	  __assign: _assign,
	  __rest: __rest,
	  __decorate: __decorate,
	  __param: __param,
	  __metadata: __metadata,
	  __awaiter: __awaiter$1,
	  __generator: __generator$3,
	  __createBinding: __createBinding,
	  __exportStar: __exportStar,
	  __values: __values$9,
	  __read: __read$i,
	  __spread: __spread,
	  __spreadArrays: __spreadArrays,
	  __spreadArray: __spreadArray$h,
	  __await: __await$1,
	  __asyncGenerator: __asyncGenerator$1,
	  __asyncDelegator: __asyncDelegator,
	  __asyncValues: __asyncValues$1,
	  __makeTemplateObject: __makeTemplateObject,
	  __importStar: __importStar,
	  __importDefault: __importDefault,
	  __classPrivateFieldGet: __classPrivateFieldGet,
	  __classPrivateFieldSet: __classPrivateFieldSet,
	  __classPrivateFieldIn: __classPrivateFieldIn,
	  __addDisposableResource: __addDisposableResource,
	  __disposeResources: __disposeResources
	};

	var tslib_es6$1 = {
		__proto__: null,
		__extends: __extends$g,
		get __assign () { return _assign; },
		__rest: __rest,
		__decorate: __decorate,
		__param: __param,
		__esDecorate: __esDecorate,
		__runInitializers: __runInitializers,
		__propKey: __propKey,
		__setFunctionName: __setFunctionName,
		__metadata: __metadata,
		__awaiter: __awaiter$1,
		__generator: __generator$3,
		__createBinding: __createBinding,
		__exportStar: __exportStar,
		__values: __values$9,
		__read: __read$i,
		__spread: __spread,
		__spreadArrays: __spreadArrays,
		__spreadArray: __spreadArray$h,
		__await: __await$1,
		__asyncGenerator: __asyncGenerator$1,
		__asyncDelegator: __asyncDelegator,
		__asyncValues: __asyncValues$1,
		__makeTemplateObject: __makeTemplateObject,
		__importStar: __importStar,
		__importDefault: __importDefault,
		__classPrivateFieldGet: __classPrivateFieldGet,
		__classPrivateFieldSet: __classPrivateFieldSet,
		__classPrivateFieldIn: __classPrivateFieldIn,
		__addDisposableResource: __addDisposableResource,
		__disposeResources: __disposeResources,
		'default': tslib_es6
	};

	var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(tslib_es6$1);

	var ApolloPlugin$4 = {};

	Object.defineProperty(ApolloPlugin$4, "__esModule", {
	  value: true
	});
	ApolloPlugin$4.ApolloPlugin = void 0;
	var tslib_1$7 = require$$0$1;
	var Plugin_1$1 = /*#__PURE__*/tslib_1$7.__importDefault(require$$1__default["default"]);
	var ApolloPlugin$3 = /*#__PURE__*/function (_Plugin_1$default) {
	  _inherits(ApolloPlugin, _Plugin_1$default);
	  var _super = /*#__PURE__*/_createSuper(ApolloPlugin);
	  function ApolloPlugin() {
	    _classCallCheck(this, ApolloPlugin);
	    return _super.apply(this, arguments);
	  }
	  _createClass(ApolloPlugin, [{
	    key: "apolloInstall",
	    value:
	    // eslint-disable-next-line @typescript-eslint/no-empty-function
	    function apolloInstall(_pluginManager) {}
	  }]);
	  return ApolloPlugin;
	}(Plugin_1$1["default"]);
	ApolloPlugin$4.ApolloPlugin = ApolloPlugin$3;

	var AssemblySpecificChange$3 = {};

	var Change$3 = {};

	var ChangeTypeRegistry$3 = {};

	Object.defineProperty(ChangeTypeRegistry$3, "__esModule", {
	  value: true
	});
	ChangeTypeRegistry$3.changeRegistry = void 0;
	var ChangeTypeRegistry$2 = /*#__PURE__*/function () {
	  function ChangeTypeRegistry() {
	    _classCallCheck(this, ChangeTypeRegistry);
	    this.changes = new Map();
	  }
	  _createClass(ChangeTypeRegistry, [{
	    key: "registerChange",
	    value: function registerChange(name, changeType) {
	      if (this.changes.has(name)) {
	        throw new Error("change type \"".concat(name, "\" has already been registered"));
	      }
	      this.changes.set(name, changeType);
	    }
	  }, {
	    key: "getChangeType",
	    value: function getChangeType(name) {
	      var RegisteredChangeType = this.changes.get(name);
	      if (!RegisteredChangeType) {
	        throw new Error("No change constructor registered for \"".concat(name, "\""));
	      }
	      return RegisteredChangeType;
	    }
	  }]);
	  return ChangeTypeRegistry;
	}();
	/** global singleton of all known types of changes */
	ChangeTypeRegistry$3.changeRegistry = /*#__PURE__*/new ChangeTypeRegistry$2();

	var Operation$3 = {};

	Object.defineProperty(Operation$3, "__esModule", {
	  value: true
	});
	Operation$3.Operation = void 0;
	var Operation$2 = /*#__PURE__*/function () {
	  function Operation(json, options) {
	    _classCallCheck(this, Operation);
	    var _a;
	    this.logger = (_a = options === null || options === void 0 ? void 0 : options.logger) !== null && _a !== void 0 ? _a : console;
	  }
	  _createClass(Operation, [{
	    key: "execute",
	    value: function () {
	      var _execute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var backendType, initialResult;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              backendType = backend.typeName;
	              if (!(backendType === 'Server')) {
	                _context.next = 4;
	                break;
	              }
	              initialResult = this.executeOnServer(backend);
	              return _context.abrupt("return", backend.pluginsService.evaluateExtensionPoint("".concat(this.typeName, "-transformResults"), initialResult, {
	                operation: this,
	                backend: backend
	              }));
	            case 4:
	              if (!(backendType === 'LocalGFF3')) {
	                _context.next = 6;
	                break;
	              }
	              return _context.abrupt("return", this.executeOnLocalGFF3(backend));
	            case 6:
	              throw new Error("no operation implementation for backend type '".concat(backendType, "'"));
	            case 7:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this);
	      }));
	      function execute(_x) {
	        return _execute.apply(this, arguments);
	      }
	      return execute;
	    }()
	  }]);
	  return Operation;
	}();
	Operation$3.Operation = Operation$2;

	Object.defineProperty(Change$3, "__esModule", {
	  value: true
	});
	Change$3.Change = void 0;
	Change$3.isChange = isChange$1;
	var ChangeTypeRegistry_1$1 = ChangeTypeRegistry$3;
	var Operation_1$1 = Operation$3;
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	function isChange$1(thing) {
	  return thing.executeOnClient !== undefined;
	}
	var Change$2 = /*#__PURE__*/function (_Operation_1$Operatio) {
	  _inherits(Change, _Operation_1$Operatio);
	  var _super = /*#__PURE__*/_createSuper(Change);
	  function Change() {
	    _classCallCheck(this, Change);
	    return _super.apply(this, arguments);
	  }
	  _createClass(Change, [{
	    key: "notification",
	    get:
	    /**
	     * If a non-empty string, a snackbar will display in JBrowse with this message
	     * when a successful response is received from the server.
	     */
	    // eslint-disable-next-line @typescript-eslint/class-literal-property-style
	    function get() {
	      return '';
	    }
	  }, {
	    key: "execute",
	    value: function () {
	      var _execute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var backendType;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              backendType = backend.typeName;
	              if (!(backendType === 'LocalGFF3' || backendType === 'Server')) {
	                _context.next = 3;
	                break;
	              }
	              return _context.abrupt("return", _get(_getPrototypeOf(Change.prototype), "execute", this).call(this, backend));
	            case 3:
	              if (!(backendType === 'Client')) {
	                _context.next = 5;
	                break;
	              }
	              return _context.abrupt("return", this.executeOnClient(backend));
	            case 5:
	              throw new Error("no change implementation for backend type '".concat(backendType, "'"));
	            case 6:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this);
	      }));
	      function execute(_x) {
	        return _execute.apply(this, arguments);
	      }
	      return execute;
	    }()
	  }], [{
	    key: "fromJSON",
	    value: function fromJSON(json, options) {
	      var ChangeType = ChangeTypeRegistry_1$1.changeRegistry.getChangeType(json.typeName);
	      return new ChangeType(json, (options === null || options === void 0 ? void 0 : options.logger) && {
	        logger: options.logger
	      });
	    }
	  }]);
	  return Change;
	}(Operation_1$1.Operation);
	Change$3.Change = Change$2;

	Object.defineProperty(AssemblySpecificChange$3, "__esModule", {
	  value: true
	});
	AssemblySpecificChange$3.AssemblySpecificChange = void 0;
	AssemblySpecificChange$3.isAssemblySpecificChange = isAssemblySpecificChange$1;
	/* eslint-disable @typescript-eslint/no-unnecessary-condition */
	var Change_1$1 = Change$3;
	function isAssemblySpecificChange$1(
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	thing) {
	  return (0, Change_1$1.isChange)(thing) && thing.assembly !== undefined;
	}
	var AssemblySpecificChange$2 = /*#__PURE__*/function (_Change_1$Change) {
	  _inherits(AssemblySpecificChange, _Change_1$Change);
	  var _super = /*#__PURE__*/_createSuper(AssemblySpecificChange);
	  function AssemblySpecificChange(json, options) {
	    var _this;
	    _classCallCheck(this, AssemblySpecificChange);
	    _this = _super.call(this, json, options);
	    _this.assembly = json.assembly;
	    return _this;
	  }
	  return _createClass(AssemblySpecificChange);
	}(Change_1$1.Change);
	AssemblySpecificChange$3.AssemblySpecificChange = AssemblySpecificChange$2;

	var Check$3 = {};

	Object.defineProperty(Check$3, "__esModule", {
	  value: true
	});
	Check$3.Check = void 0;
	var Check$2 = /*#__PURE__*/_createClass(function Check() {
	  _classCallCheck(this, Check);
	});
	Check$3.Check = Check$2;

	var CheckRegistry$3 = {};

	Object.defineProperty(CheckRegistry$3, "__esModule", {
	  value: true
	});
	CheckRegistry$3.checkRegistry = void 0;
	var CheckRegistry$2 = /*#__PURE__*/function () {
	  function CheckRegistry() {
	    _classCallCheck(this, CheckRegistry);
	    this.checks = new Map();
	  }
	  _createClass(CheckRegistry, [{
	    key: "registerCheck",
	    value: function registerCheck(name, check) {
	      if (this.checks.has(name)) {
	        throw new Error("check \"".concat(name, "\" has already been registered"));
	      }
	      this.checks.set(name, check);
	    }
	  }, {
	    key: "getCheck",
	    value: function getCheck(name) {
	      var registeredCheck = this.checks.get(name);
	      if (!registeredCheck) {
	        throw new Error("No check constructor registered for \"".concat(name, "\""));
	      }
	      return registeredCheck;
	    }
	  }, {
	    key: "getChecks",
	    value: function getChecks() {
	      return this.checks;
	    }
	  }]);
	  return CheckRegistry;
	}();
	/** global singleton of all known checks */
	CheckRegistry$3.checkRegistry = /*#__PURE__*/new CheckRegistry$2();

	var FeatureChange$3 = {};

	var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

	// shim for using process in browser
	// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

	function defaultSetTimout() {
	  throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout() {
	  throw new Error('clearTimeout has not been defined');
	}
	var cachedSetTimeout = defaultSetTimout;
	var cachedClearTimeout = defaultClearTimeout;
	if (typeof global$1.setTimeout === 'function') {
	  cachedSetTimeout = setTimeout;
	}
	if (typeof global$1.clearTimeout === 'function') {
	  cachedClearTimeout = clearTimeout;
	}
	function runTimeout(fun) {
	  if (cachedSetTimeout === setTimeout) {
	    //normal enviroments in sane situations
	    return setTimeout(fun, 0);
	  }
	  // if setTimeout wasn't available but was latter defined
	  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	    cachedSetTimeout = setTimeout;
	    return setTimeout(fun, 0);
	  }
	  try {
	    // when when somebody has screwed with setTimeout but no I.E. maddness
	    return cachedSetTimeout(fun, 0);
	  } catch (e) {
	    try {
	      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	      return cachedSetTimeout.call(null, fun, 0);
	    } catch (e) {
	      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	      return cachedSetTimeout.call(this, fun, 0);
	    }
	  }
	}
	function runClearTimeout(marker) {
	  if (cachedClearTimeout === clearTimeout) {
	    //normal enviroments in sane situations
	    return clearTimeout(marker);
	  }
	  // if clearTimeout wasn't available but was latter defined
	  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	    cachedClearTimeout = clearTimeout;
	    return clearTimeout(marker);
	  }
	  try {
	    // when when somebody has screwed with setTimeout but no I.E. maddness
	    return cachedClearTimeout(marker);
	  } catch (e) {
	    try {
	      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	      return cachedClearTimeout.call(null, marker);
	    } catch (e) {
	      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	      return cachedClearTimeout.call(this, marker);
	    }
	  }
	}
	var queue$1 = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	function cleanUpNextTick() {
	  if (!draining || !currentQueue) {
	    return;
	  }
	  draining = false;
	  if (currentQueue.length) {
	    queue$1 = currentQueue.concat(queue$1);
	  } else {
	    queueIndex = -1;
	  }
	  if (queue$1.length) {
	    drainQueue();
	  }
	}
	function drainQueue() {
	  if (draining) {
	    return;
	  }
	  var timeout = runTimeout(cleanUpNextTick);
	  draining = true;
	  var len = queue$1.length;
	  while (len) {
	    currentQueue = queue$1;
	    queue$1 = [];
	    while (++queueIndex < len) {
	      if (currentQueue) {
	        currentQueue[queueIndex].run();
	      }
	    }
	    queueIndex = -1;
	    len = queue$1.length;
	  }
	  currentQueue = null;
	  draining = false;
	  runClearTimeout(timeout);
	}
	function nextTick$1(fun) {
	  var args = new Array(arguments.length - 1);
	  if (arguments.length > 1) {
	    for (var i = 1; i < arguments.length; i++) {
	      args[i - 1] = arguments[i];
	    }
	  }
	  queue$1.push(new Item(fun, args));
	  if (queue$1.length === 1 && !draining) {
	    runTimeout(drainQueue);
	  }
	}
	// v8 likes predictible objects
	function Item(fun, array) {
	  this.fun = fun;
	  this.array = array;
	}
	Item.prototype.run = function () {
	  this.fun.apply(null, this.array);
	};
	var title = 'browser';
	var platform = 'browser';
	var browser = true;
	var env = {};
	var argv = [];
	var version$1 = ''; // empty string to avoid regexp issues
	var versions = {};
	var release = {};
	var config$1 = {};
	function noop$2() {}
	var on$1 = noop$2;
	var addListener = noop$2;
	var once = noop$2;
	var off = noop$2;
	var removeListener = noop$2;
	var removeAllListeners = noop$2;
	var emit = noop$2;
	function binding(name) {
	  throw new Error('process.binding is not supported');
	}
	function cwd() {
	  return '/';
	}
	function chdir(dir) {
	  throw new Error('process.chdir is not supported');
	}
	function umask() {
	  return 0;
	}

	// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
	var performance$1 = global$1.performance || {};
	var performanceNow = performance$1.now || performance$1.mozNow || performance$1.msNow || performance$1.oNow || performance$1.webkitNow || function () {
	  return new Date().getTime();
	};

	// generate timestamp or delta
	// see http://nodejs.org/api/process.html#process_process_hrtime
	function hrtime(previousTimestamp) {
	  var clocktime = performanceNow.call(performance$1) * 1e-3;
	  var seconds = Math.floor(clocktime);
	  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
	  if (previousTimestamp) {
	    seconds = seconds - previousTimestamp[0];
	    nanoseconds = nanoseconds - previousTimestamp[1];
	    if (nanoseconds < 0) {
	      seconds--;
	      nanoseconds += 1e9;
	    }
	  }
	  return [seconds, nanoseconds];
	}
	var startTime = /*#__PURE__*/new Date();
	function uptime() {
	  var currentTime = new Date();
	  var dif = currentTime - startTime;
	  return dif / 1000;
	}
	var process$1 = {
	  nextTick: nextTick$1,
	  title: title,
	  browser: browser,
	  env: env,
	  argv: argv,
	  version: version$1,
	  versions: versions,
	  on: on$1,
	  addListener: addListener,
	  once: once,
	  off: off,
	  removeListener: removeListener,
	  removeAllListeners: removeAllListeners,
	  emit: emit,
	  binding: binding,
	  cwd: cwd,
	  chdir: chdir,
	  umask: umask,
	  hrtime: hrtime,
	  platform: platform,
	  release: release,
	  config: config$1,
	  uptime: uptime
	};

	var lookup$2 = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	var inited = false;
	function init() {
	  inited = true;
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	  for (var i = 0, len = code.length; i < len; ++i) {
	    lookup$2[i] = code[i];
	    revLookup[code.charCodeAt(i)] = i;
	  }
	  revLookup['-'.charCodeAt(0)] = 62;
	  revLookup['_'.charCodeAt(0)] = 63;
	}
	function toByteArray(b64) {
	  if (!inited) {
	    init();
	  }
	  var i, j, l, tmp, placeHolders, arr;
	  var len = b64.length;
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4');
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

	  // base64 is 4/3 + up to two characters of the original data
	  arr = new Arr(len * 3 / 4 - placeHolders);

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len;
	  var L = 0;
	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
	    arr[L++] = tmp >> 16 & 0xFF;
	    arr[L++] = tmp >> 8 & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }
	  if (placeHolders === 2) {
	    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
	    arr[L++] = tmp & 0xFF;
	  } else if (placeHolders === 1) {
	    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
	    arr[L++] = tmp >> 8 & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }
	  return arr;
	}
	function tripletToBase64(num) {
	  return lookup$2[num >> 18 & 0x3F] + lookup$2[num >> 12 & 0x3F] + lookup$2[num >> 6 & 0x3F] + lookup$2[num & 0x3F];
	}
	function encodeChunk(uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('');
	}
	function fromByteArray(uint8) {
	  if (!inited) {
	    init();
	  }
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var output = '';
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    output += lookup$2[tmp >> 2];
	    output += lookup$2[tmp << 4 & 0x3F];
	    output += '==';
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
	    output += lookup$2[tmp >> 10];
	    output += lookup$2[tmp >> 4 & 0x3F];
	    output += lookup$2[tmp << 2 & 0x3F];
	    output += '=';
	  }
	  parts.push(output);
	  return parts.join('');
	}

	function read(buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? nBytes - 1 : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];
	  i += d;
	  e = s & (1 << -nBits) - 1;
	  s >>= -nBits;
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : (s ? -1 : 1) * Infinity;
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
	}
	function write(buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
	  var i = isLE ? 0 : nBytes - 1;
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
	  value = Math.abs(value);
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }
	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	  e = e << mLen | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	  buffer[offset + i - d] |= s * 128;
	}

	var toString$3 = {}.toString;
	var isArray$4 = Array.isArray || function (arr) {
	  return toString$3.call(arr) == '[object Array]';
	};

	var INSPECT_MAX_BYTES = 50;

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;

	function kMaxLength() {
	  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
	}
	function createBuffer(that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length');
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length);
	    that.__proto__ = Buffer.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length);
	    }
	    that.length = length;
	  }
	  return that;
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer(arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length);
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error('If encoding is specified then the first argument must be a string');
	    }
	    return allocUnsafe(this, arg);
	  }
	  return from$3(this, arg, encodingOrOffset, length);
	}
	Buffer.poolSize = 8192; // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype;
	  return arr;
	};
	function from$3(that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number');
	  }
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length);
	  }
	  if (typeof value === 'string') {
	    return fromString$1(that, value, encodingOrOffset);
	  }
	  return fromObject(that, value);
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from$3(null, value, encodingOrOffset, length);
	};
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype;
	  Buffer.__proto__ = Uint8Array;
	}
	function assertSize(size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number');
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative');
	  }
	}
	function alloc$1(that, size, fill, encoding) {
	  assertSize(size);
	  if (size <= 0) {
	    return createBuffer(that, size);
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
	  }
	  return createBuffer(that, size);
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc$1(null, size, fill, encoding);
	};
	function allocUnsafe(that, size) {
	  assertSize(size);
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0;
	    }
	  }
	  return that;
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size);
	};
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size);
	};
	function fromString$1(that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8';
	  }
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding');
	  }
	  var length = byteLength$1(string, encoding) | 0;
	  that = createBuffer(that, length);
	  var actual = that.write(string, encoding);
	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual);
	  }
	  return that;
	}
	function fromArrayLike$1(that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0;
	  that = createBuffer(that, length);
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that;
	}
	function fromArrayBuffer(that, array, byteOffset, length) {

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds');
	  }
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds');
	  }
	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array);
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset);
	  } else {
	    array = new Uint8Array(array, byteOffset, length);
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array;
	    that.__proto__ = Buffer.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike$1(that, array);
	  }
	  return that;
	}
	function fromObject(that, obj) {
	  if (internalIsBuffer(obj)) {
	    var len = checked(obj.length) | 0;
	    that = createBuffer(that, len);
	    if (that.length === 0) {
	      return that;
	    }
	    obj.copy(that, 0, 0, len);
	    return that;
	  }
	  if (obj) {
	    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0);
	      }
	      return fromArrayLike$1(that, obj);
	    }
	    if (obj.type === 'Buffer' && isArray$4(obj.data)) {
	      return fromArrayLike$1(that, obj.data);
	    }
	  }
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
	}
	function checked(length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
	  }
	  return length | 0;
	}
	Buffer.isBuffer = isBuffer$1;
	function internalIsBuffer(b) {
	  return !!(b != null && b._isBuffer);
	}
	Buffer.compare = function compare(a, b) {
	  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers');
	  }
	  if (a === b) return 0;
	  var x = a.length;
	  var y = b.length;
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }
	  if (x < y) return -1;
	  if (y < x) return 1;
	  return 0;
	};
	Buffer.isEncoding = function isEncoding(encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true;
	    default:
	      return false;
	  }
	};
	Buffer.concat = function concat(list, length) {
	  if (!isArray$4(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers');
	  }
	  if (list.length === 0) {
	    return Buffer.alloc(0);
	  }
	  var i;
	  if (length === undefined) {
	    length = 0;
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length;
	    }
	  }
	  var buffer = Buffer.allocUnsafe(length);
	  var pos = 0;
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i];
	    if (!internalIsBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers');
	    }
	    buf.copy(buffer, pos);
	    pos += buf.length;
	  }
	  return buffer;
	};
	function byteLength$1(string, encoding) {
	  if (internalIsBuffer(string)) {
	    return string.length;
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength;
	  }
	  if (typeof string !== 'string') {
	    string = '' + string;
	  }
	  var len = string.length;
	  if (len === 0) return 0;

	  // Use a for loop to avoid recursion
	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len;
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length;
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2;
	      case 'hex':
	        return len >>> 1;
	      case 'base64':
	        return base64ToBytes(string).length;
	      default:
	        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	}
	Buffer.byteLength = byteLength$1;
	function slowToString(encoding, start, end) {
	  var loweredCase = false;

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0;
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return '';
	  }
	  if (end === undefined || end > this.length) {
	    end = this.length;
	  }
	  if (end <= 0) {
	    return '';
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0;
	  start >>>= 0;
	  if (end <= start) {
	    return '';
	  }
	  if (!encoding) encoding = 'utf8';
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end);
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end);
	      case 'ascii':
	        return asciiSlice(this, start, end);
	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end);
	      case 'base64':
	        return base64Slice(this, start, end);
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end);
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
	        encoding = (encoding + '').toLowerCase();
	        loweredCase = true;
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true;
	function swap(b, n, m) {
	  var i = b[n];
	  b[n] = b[m];
	  b[m] = i;
	}
	Buffer.prototype.swap16 = function swap16() {
	  var len = this.length;
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits');
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1);
	  }
	  return this;
	};
	Buffer.prototype.swap32 = function swap32() {
	  var len = this.length;
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits');
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3);
	    swap(this, i + 1, i + 2);
	  }
	  return this;
	};
	Buffer.prototype.swap64 = function swap64() {
	  var len = this.length;
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits');
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7);
	    swap(this, i + 1, i + 6);
	    swap(this, i + 2, i + 5);
	    swap(this, i + 3, i + 4);
	  }
	  return this;
	};
	Buffer.prototype.toString = function toString() {
	  var length = this.length | 0;
	  if (length === 0) return '';
	  if (arguments.length === 0) return utf8Slice(this, 0, length);
	  return slowToString.apply(this, arguments);
	};
	Buffer.prototype.equals = function equals(b) {
	  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');
	  if (this === b) return true;
	  return Buffer.compare(this, b) === 0;
	};
	Buffer.prototype.inspect = function inspect() {
	  var str = '';
	  var max = INSPECT_MAX_BYTES;
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
	    if (this.length > max) str += ' ... ';
	  }
	  return '<Buffer ' + str + '>';
	};
	Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
	  if (!internalIsBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer');
	  }
	  if (start === undefined) {
	    start = 0;
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0;
	  }
	  if (thisStart === undefined) {
	    thisStart = 0;
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length;
	  }
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index');
	  }
	  if (thisStart >= thisEnd && start >= end) {
	    return 0;
	  }
	  if (thisStart >= thisEnd) {
	    return -1;
	  }
	  if (start >= end) {
	    return 1;
	  }
	  start >>>= 0;
	  end >>>= 0;
	  thisStart >>>= 0;
	  thisEnd >>>= 0;
	  if (this === target) return 0;
	  var x = thisEnd - thisStart;
	  var y = end - start;
	  var len = Math.min(x, y);
	  var thisCopy = this.slice(thisStart, thisEnd);
	  var targetCopy = target.slice(start, end);
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i];
	      y = targetCopy[i];
	      break;
	    }
	  }
	  if (x < y) return -1;
	  if (y < x) return 1;
	  return 0;
	};

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1;

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset;
	    byteOffset = 0;
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff;
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000;
	  }
	  byteOffset = +byteOffset; // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : buffer.length - 1;
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1;else byteOffset = buffer.length - 1;
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0;else return -1;
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding);
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (internalIsBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1;
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
	  } else if (typeof val === 'number') {
	    val = val & 0xFF; // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
	      }
	    }
	    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
	  }
	  throw new TypeError('val must be string, number or Buffer');
	}
	function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1;
	  var arrLength = arr.length;
	  var valLength = val.length;
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase();
	    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1;
	      }
	      indexSize = 2;
	      arrLength /= 2;
	      valLength /= 2;
	      byteOffset /= 2;
	    }
	  }
	  function read(buf, i) {
	    if (indexSize === 1) {
	      return buf[i];
	    } else {
	      return buf.readUInt16BE(i * indexSize);
	    }
	  }
	  var i;
	  if (dir) {
	    var foundIndex = -1;
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i;
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex;
	        foundIndex = -1;
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true;
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false;
	          break;
	        }
	      }
	      if (found) return i;
	    }
	  }
	  return -1;
	}
	Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1;
	};
	Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
	};
	Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
	};
	function hexWrite(buf, string, offset, length) {
	  offset = Number(offset) || 0;
	  var remaining = buf.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = Number(length);
	    if (length > remaining) {
	      length = remaining;
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length;
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');
	  if (length > strLen / 2) {
	    length = strLen / 2;
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16);
	    if (isNaN(parsed)) return i;
	    buf[offset + i] = parsed;
	  }
	  return i;
	}
	function utf8Write(buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
	}
	function asciiWrite(buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length);
	}
	function latin1Write(buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length);
	}
	function base64Write(buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length);
	}
	function ucs2Write(buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
	}
	Buffer.prototype.write = function write(string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8';
	    length = this.length;
	    offset = 0;
	    // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset;
	    length = this.length;
	    offset = 0;
	    // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0;
	    if (isFinite(length)) {
	      length = length | 0;
	      if (encoding === undefined) encoding = 'utf8';
	    } else {
	      encoding = length;
	      length = undefined;
	    }
	    // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
	  }
	  var remaining = this.length - offset;
	  if (length === undefined || length > remaining) length = remaining;
	  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds');
	  }
	  if (!encoding) encoding = 'utf8';
	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length);
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length);
	      case 'ascii':
	        return asciiWrite(this, string, offset, length);
	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length);
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length);
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length);
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	};
	Buffer.prototype.toJSON = function toJSON() {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  };
	};
	function base64Slice(buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return fromByteArray(buf);
	  } else {
	    return fromByteArray(buf.slice(start, end));
	  }
	}
	function utf8Slice(buf, start, end) {
	  end = Math.min(buf.length, end);
	  var res = [];
	  var i = start;
	  while (i < end) {
	    var firstByte = buf[i];
	    var codePoint = null;
	    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint;
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte;
	          }
	          break;
	        case 2:
	          secondByte = buf[i + 1];
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break;
	        case 3:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break;
	        case 4:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          fourthByte = buf[i + 3];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint;
	            }
	          }
	      }
	    }
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD;
	      bytesPerSequence = 1;
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000;
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	      codePoint = 0xDC00 | codePoint & 0x3FF;
	    }
	    res.push(codePoint);
	    i += bytesPerSequence;
	  }
	  return decodeCodePointsArray(res);
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000;
	function decodeCodePointsArray(codePoints) {
	  var len = codePoints.length;
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = '';
	  var i = 0;
	  while (i < len) {
	    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
	  }
	  return res;
	}
	function asciiSlice(buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F);
	  }
	  return ret;
	}
	function latin1Slice(buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i]);
	  }
	  return ret;
	}
	function hexSlice(buf, start, end) {
	  var len = buf.length;
	  if (!start || start < 0) start = 0;
	  if (!end || end < 0 || end > len) end = len;
	  var out = '';
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i]);
	  }
	  return out;
	}
	function utf16leSlice(buf, start, end) {
	  var bytes = buf.slice(start, end);
	  var res = '';
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	  }
	  return res;
	}
	Buffer.prototype.slice = function slice(start, end) {
	  var len = this.length;
	  start = ~~start;
	  end = end === undefined ? len : ~~end;
	  if (start < 0) {
	    start += len;
	    if (start < 0) start = 0;
	  } else if (start > len) {
	    start = len;
	  }
	  if (end < 0) {
	    end += len;
	    if (end < 0) end = 0;
	  } else if (end > len) {
	    end = len;
	  }
	  if (end < start) end = start;
	  var newBuf;
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end);
	    newBuf.__proto__ = Buffer.prototype;
	  } else {
	    var sliceLen = end - start;
	    newBuf = new Buffer(sliceLen, undefined);
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start];
	    }
	  }
	  return newBuf;
	};

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset(offset, ext, length) {
	  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
	}
	Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);
	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }
	  return val;
	};
	Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length);
	  }
	  var val = this[offset + --byteLength];
	  var mul = 1;
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul;
	  }
	  return val;
	};
	Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  return this[offset];
	};
	Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return this[offset] | this[offset + 1] << 8;
	};
	Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return this[offset] << 8 | this[offset + 1];
	};
	Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
	};
	Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
	};
	Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);
	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }
	  mul *= 0x80;
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
	  return val;
	};
	Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);
	  var i = byteLength;
	  var mul = 1;
	  var val = this[offset + --i];
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul;
	  }
	  mul *= 0x80;
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
	  return val;
	};
	Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  if (!(this[offset] & 0x80)) return this[offset];
	  return (0xff - this[offset] + 1) * -1;
	};
	Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset] | this[offset + 1] << 8;
	  return val & 0x8000 ? val | 0xFFFF0000 : val;
	};
	Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset + 1] | this[offset] << 8;
	  return val & 0x8000 ? val | 0xFFFF0000 : val;
	};
	Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
	};
	Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
	};
	Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, true, 23, 4);
	};
	Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, false, 23, 4);
	};
	Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, true, 52, 8);
	};
	Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, false, 52, 8);
	};
	function checkInt(buf, value, offset, ext, max, min) {
	  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
	  if (offset + ext > buf.length) throw new RangeError('Index out of range');
	}
	Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }
	  var mul = 1;
	  var i = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = value / mul & 0xFF;
	  }
	  return offset + byteLength;
	};
	Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }
	  var i = byteLength - 1;
	  var mul = 1;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = value / mul & 0xFF;
	  }
	  return offset + byteLength;
	};
	Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  this[offset] = value & 0xff;
	  return offset + 1;
	};
	function objectWriteUInt16(buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
	  }
	}
	Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value & 0xff;
	    this[offset + 1] = value >>> 8;
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2;
	};
	Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value >>> 8;
	    this[offset + 1] = value & 0xff;
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2;
	};
	function objectWriteUInt32(buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
	  }
	}
	Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = value >>> 24;
	    this[offset + 2] = value >>> 16;
	    this[offset + 1] = value >>> 8;
	    this[offset] = value & 0xff;
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4;
	};
	Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value >>> 24;
	    this[offset + 1] = value >>> 16;
	    this[offset + 2] = value >>> 8;
	    this[offset + 3] = value & 0xff;
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4;
	};
	Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);
	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }
	  var i = 0;
	  var mul = 1;
	  var sub = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
	  }
	  return offset + byteLength;
	};
	Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);
	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }
	  var i = byteLength - 1;
	  var mul = 1;
	  var sub = 0;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
	  }
	  return offset + byteLength;
	};
	Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  if (value < 0) value = 0xff + value + 1;
	  this[offset] = value & 0xff;
	  return offset + 1;
	};
	Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value & 0xff;
	    this[offset + 1] = value >>> 8;
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2;
	};
	Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value >>> 8;
	    this[offset + 1] = value & 0xff;
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2;
	};
	Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value & 0xff;
	    this[offset + 1] = value >>> 8;
	    this[offset + 2] = value >>> 16;
	    this[offset + 3] = value >>> 24;
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4;
	};
	Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (value < 0) value = 0xffffffff + value + 1;
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value >>> 24;
	    this[offset + 1] = value >>> 16;
	    this[offset + 2] = value >>> 8;
	    this[offset + 3] = value & 0xff;
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4;
	};
	function checkIEEE754(buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range');
	  if (offset < 0) throw new RangeError('Index out of range');
	}
	function writeFloat(buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4);
	  }
	  write(buf, value, offset, littleEndian, 23, 4);
	  return offset + 4;
	}
	Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert);
	};
	Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert);
	};
	function writeDouble(buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8);
	  }
	  write(buf, value, offset, littleEndian, 52, 8);
	  return offset + 8;
	}
	Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert);
	};
	Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert);
	};

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy(target, targetStart, start, end) {
	  if (!start) start = 0;
	  if (!end && end !== 0) end = this.length;
	  if (targetStart >= target.length) targetStart = target.length;
	  if (!targetStart) targetStart = 0;
	  if (end > 0 && end < start) end = start;

	  // Copy 0 bytes; we're done
	  if (end === start) return 0;
	  if (target.length === 0 || this.length === 0) return 0;

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds');
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
	  if (end < 0) throw new RangeError('sourceEnd out of bounds');

	  // Are we oob?
	  if (end > this.length) end = this.length;
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start;
	  }
	  var len = end - start;
	  var i;
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else {
	    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
	  }
	  return len;
	};

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill(val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start;
	      start = 0;
	      end = this.length;
	    } else if (typeof end === 'string') {
	      encoding = end;
	      end = this.length;
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0);
	      if (code < 256) {
	        val = code;
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string');
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding);
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255;
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index');
	  }
	  if (end <= start) {
	    return this;
	  }
	  start = start >>> 0;
	  end = end === undefined ? this.length : end >>> 0;
	  if (!val) val = 0;
	  var i;
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val;
	    }
	  } else {
	    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
	    var len = bytes.length;
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len];
	    }
	  }
	  return this;
	};

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
	function base64clean(str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return '';
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '=';
	  }
	  return str;
	}
	function stringtrim(str) {
	  if (str.trim) return str.trim();
	  return str.replace(/^\s+|\s+$/g, '');
	}
	function toHex(n) {
	  if (n < 16) return '0' + n.toString(16);
	  return n.toString(16);
	}
	function utf8ToBytes(string, units) {
	  units = units || Infinity;
	  var codePoint;
	  var length = string.length;
	  var leadSurrogate = null;
	  var bytes = [];
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i);

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue;
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue;
	        }

	        // valid lead
	        leadSurrogate = codePoint;
	        continue;
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	        leadSurrogate = codePoint;
	        continue;
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	    }
	    leadSurrogate = null;

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break;
	      bytes.push(codePoint);
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break;
	      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break;
	      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break;
	      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
	    } else {
	      throw new Error('Invalid code point');
	    }
	  }
	  return bytes;
	}
	function asciiToBytes(str) {
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF);
	  }
	  return byteArray;
	}
	function utf16leToBytes(str, units) {
	  var c, hi, lo;
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break;
	    c = str.charCodeAt(i);
	    hi = c >> 8;
	    lo = c % 256;
	    byteArray.push(lo);
	    byteArray.push(hi);
	  }
	  return byteArray;
	}
	function base64ToBytes(str) {
	  return toByteArray(base64clean(str));
	}
	function blitBuffer(src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if (i + offset >= dst.length || i >= src.length) break;
	    dst[i + offset] = src[i];
	  }
	  return i;
	}
	function isnan(val) {
	  return val !== val; // eslint-disable-line no-self-compare
	}

	// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	function isBuffer$1(obj) {
	  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
	}
	function isFastBuffer(obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer(obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));
	}

	var MACHINE_ID = /*#__PURE__*/Math.floor( /*#__PURE__*/Math.random() * 0xFFFFFF);
	var index = ObjectID.index = /*#__PURE__*/parseInt( /*#__PURE__*/Math.random() * 0xFFFFFF, 10);
	var pid = (typeof process$1 === 'undefined' || typeof process$1.pid !== 'number' ? /*#__PURE__*/Math.floor( /*#__PURE__*/Math.random() * 100000) : process$1.pid) % 0xFFFF;
	// <https://github.com/williamkapke/bson-objectid/pull/51>
	// Attempt to fallback Buffer if _Buffer is undefined (e.g. for Node.js).
	// Worst case fallback to null and handle with null checking before using.
	var BufferCtr = /*#__PURE__*/function () {
	  try {
	    return _Buffer;
	  } catch (_) {
	    try {
	      return Buffer;
	    } catch (_) {
	      return null;
	    }
	  }
	}();

	/**
	 * Determine if an object is Buffer
	 *
	 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * License:  MIT
	 *
	 */
	var isBuffer = function isBuffer(obj) {
	  return !!(obj != null && obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj));
	};

	// Precomputed hex table enables speedy hex string conversion
	var hexTable = [];
	for (var i$1 = 0; i$1 < 256; i$1++) {
	  hexTable[i$1] = (i$1 <= 15 ? '0' : '') + /*#__PURE__*/i$1.toString(16);
	}

	// Regular expression that checks for hex value
	var checkForHexRegExp = /*#__PURE__*/new RegExp('^[0-9a-fA-F]{24}$');

	// Lookup tables
	var decodeLookup = [];
	i$1 = 0;
	while (i$1 < 10) decodeLookup[0x30 + i$1] = i$1++;
	while (i$1 < 16) decodeLookup[0x41 - 10 + i$1] = decodeLookup[0x61 - 10 + i$1] = i$1++;

	/**
	 * Create a new immutable ObjectID instance
	 *
	 * @class Represents the BSON ObjectID type
	 * @param {String|Number} id Can be a 24 byte hex string, 12 byte binary string or a Number.
	 * @return {Object} instance of ObjectID.
	 */
	function ObjectID(id) {
	  if (!(this instanceof ObjectID)) return new ObjectID(id);
	  if (id && (id instanceof ObjectID || id._bsontype === "ObjectID")) return id;
	  this._bsontype = 'ObjectID';

	  // The most common usecase (blank id, new objectId instance)
	  if (id == null || typeof id === 'number') {
	    // Generate a new id
	    this.id = this.generate(id);
	    // Return the object
	    return;
	  }

	  // Check if the passed in id is valid
	  var valid = ObjectID.isValid(id);

	  // Throw an error if it's not a valid setup
	  if (!valid && id != null) {
	    throw new Error('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');
	  } else if (valid && typeof id === 'string' && id.length === 24) {
	    return ObjectID.createFromHexString(id);
	  } else if (id != null && id.length === 12) {
	    // assume 12 byte string
	    this.id = id;
	  } else if (id != null && typeof id.toHexString === 'function') {
	    // Duck-typing to support ObjectId from different npm packages
	    return id;
	  } else {
	    throw new Error('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');
	  }
	}
	var objectid = ObjectID;
	ObjectID["default"] = ObjectID;

	/**
	 * Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.
	 *
	 * @param {Number} time an integer number representing a number of seconds.
	 * @return {ObjectID} return the created ObjectID
	 * @api public
	 */
	ObjectID.createFromTime = function (time) {
	  time = parseInt(time, 10) % 0xFFFFFFFF;
	  return new ObjectID(hex(8, time) + "0000000000000000");
	};

	/**
	 * Creates an ObjectID from a hex string representation of an ObjectID.
	 *
	 * @param {String} hexString create a ObjectID from a passed in 24 byte hexstring.
	 * @return {ObjectID} return the created ObjectID
	 * @api public
	 */
	ObjectID.createFromHexString = function (hexString) {
	  // Throw an error if it's not a valid setup
	  if (typeof hexString === 'undefined' || hexString != null && hexString.length !== 24) {
	    throw new Error('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');
	  }

	  // Calculate lengths
	  var data = '';
	  var i = 0;
	  while (i < 24) {
	    data += String.fromCharCode(decodeLookup[hexString.charCodeAt(i++)] << 4 | decodeLookup[hexString.charCodeAt(i++)]);
	  }
	  return new ObjectID(data);
	};

	/**
	 * Checks if a value is a valid bson ObjectId
	 *
	 * @param {String} objectid Can be a 24 byte hex string or an instance of ObjectID.
	 * @return {Boolean} return true if the value is a valid bson ObjectID, return false otherwise.
	 * @api public
	 *
	 * THE NATIVE DOCUMENTATION ISN'T CLEAR ON THIS GUY!
	 * http://mongodb.github.io/node-mongodb-native/api-bson-generated/objectid.html#objectid-isvalid
	 */
	ObjectID.isValid = function (id) {
	  if (id == null) return false;
	  if (typeof id === 'number') {
	    return true;
	  }
	  if (typeof id === 'string') {
	    return id.length === 12 || id.length === 24 && checkForHexRegExp.test(id);
	  }
	  if (id instanceof ObjectID) {
	    return true;
	  }

	  // <https://github.com/williamkapke/bson-objectid/issues/53>
	  if (isBuffer(id)) {
	    return ObjectID.isValid(id.toString('hex'));
	  }

	  // Duck-Typing detection of ObjectId like objects
	  // <https://github.com/williamkapke/bson-objectid/pull/51>
	  if (typeof id.toHexString === 'function') {
	    if (BufferCtr && (id.id instanceof BufferCtr || typeof id.id === 'string')) {
	      return id.id.length === 12 || id.id.length === 24 && checkForHexRegExp.test(id.id);
	    }
	  }
	  return false;
	};
	ObjectID.prototype = {
	  constructor: ObjectID,
	  /**
	   * Return the ObjectID id as a 24 byte hex string representation
	   *
	   * @return {String} return the 24 byte hex string representation.
	   * @api public
	   */
	  toHexString: function toHexString() {
	    if (!this.id || !this.id.length) {
	      throw new Error('invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [' + JSON.stringify(this.id) + ']');
	    }
	    if (this.id.length === 24) {
	      return this.id;
	    }
	    if (isBuffer(this.id)) {
	      return this.id.toString('hex');
	    }
	    var hexString = '';
	    for (var i = 0; i < this.id.length; i++) {
	      hexString += hexTable[this.id.charCodeAt(i)];
	    }
	    return hexString;
	  },
	  /**
	   * Compares the equality of this ObjectID with `otherID`.
	   *
	   * @param {Object} otherId ObjectID instance to compare against.
	   * @return {Boolean} the result of comparing two ObjectID's
	   * @api public
	   */
	  equals: function equals(otherId) {
	    if (otherId instanceof ObjectID) {
	      return this.toString() === otherId.toString();
	    } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 12 && isBuffer(this.id)) {
	      return otherId === this.id.toString('binary');
	    } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 24) {
	      return otherId.toLowerCase() === this.toHexString();
	    } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 12) {
	      return otherId === this.id;
	    } else if (otherId != null && (otherId instanceof ObjectID || otherId.toHexString)) {
	      return otherId.toHexString() === this.toHexString();
	    } else {
	      return false;
	    }
	  },
	  /**
	   * Returns the generation date (accurate up to the second) that this ID was generated.
	   *
	   * @return {Date} the generation date
	   * @api public
	   */
	  getTimestamp: function getTimestamp() {
	    var timestamp = new Date();
	    var time;
	    if (isBuffer(this.id)) {
	      time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
	    } else {
	      time = this.id.charCodeAt(3) | this.id.charCodeAt(2) << 8 | this.id.charCodeAt(1) << 16 | this.id.charCodeAt(0) << 24;
	    }
	    timestamp.setTime(Math.floor(time) * 1000);
	    return timestamp;
	  },
	  /**
	  * Generate a 12 byte id buffer used in ObjectID's
	  *
	  * @method
	  * @param {number} [time] optional parameter allowing to pass in a second based timestamp.
	  * @return {string} return the 12 byte id buffer string.
	  */
	  generate: function generate(time) {
	    if ('number' !== typeof time) {
	      time = ~~(Date.now() / 1000);
	    }

	    //keep it in the ring!
	    time = parseInt(time, 10) % 0xFFFFFFFF;
	    var inc = next$1();
	    return String.fromCharCode(time >> 24 & 0xFF, time >> 16 & 0xFF, time >> 8 & 0xFF, time & 0xFF, MACHINE_ID >> 16 & 0xFF, MACHINE_ID >> 8 & 0xFF, MACHINE_ID & 0xFF, pid >> 8 & 0xFF, pid & 0xFF, inc >> 16 & 0xFF, inc >> 8 & 0xFF, inc & 0xFF);
	  }
	};
	function next$1() {
	  return index = (index + 1) % 0xFFFFFF;
	}
	function hex(length, n) {
	  n = n.toString(16);
	  return n.length === length ? n : "00000000".substring(n.length, length) + n;
	}
	var inspect$1 = Symbol && Symbol["for"] && /*#__PURE__*/Symbol["for"]('nodejs.util.inspect.custom') || 'inspect';

	/**
	 * Converts to a string representation of this Id.
	 *
	 * @return {String} return the 24 byte hex string representation.
	 * @api private
	 */
	ObjectID.prototype[inspect$1] = function () {
	  return "ObjectID(" + this + ")";
	};
	ObjectID.prototype.toJSON = ObjectID.prototype.toHexString;
	ObjectID.prototype.toString = ObjectID.prototype.toHexString;

	Object.defineProperty(FeatureChange$3, "__esModule", {
	  value: true
	});
	FeatureChange$3.FeatureChange = void 0;
	FeatureChange$3.isFeatureChange = isFeatureChange$1;
	var tslib_1$6 = require$$0$1;
	var bson_objectid_1$3 = /*#__PURE__*/tslib_1$6.__importDefault(objectid);
	var AssemblySpecificChange_1$1 = AssemblySpecificChange$3;
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	function isFeatureChange$1(thing) {
	  return (0, AssemblySpecificChange_1$1.isAssemblySpecificChange)(thing) && thing.changedIds !== undefined;
	}
	var FeatureChange$2 = /*#__PURE__*/function (_AssemblySpecificChan) {
	  _inherits(FeatureChange, _AssemblySpecificChan);
	  var _super = /*#__PURE__*/_createSuper(FeatureChange);
	  function FeatureChange(json, options) {
	    var _this;
	    _classCallCheck(this, FeatureChange);
	    _this = _super.call(this, json, options);
	    _this.changedIds = json.changedIds;
	    return _this;
	  }
	  /**
	   * Get single feature by featureId
	   * @param feature -
	   * @param featureId -
	   * @returns
	   */
	  _createClass(FeatureChange, [{
	    key: "getFeatureFromId",
	    value: function getFeatureFromId(feature, featureId) {
	      var _a, _b, _c, _d;
	      var logger = this.logger;
	      (_a = logger.verbose) === null || _a === void 0 ? void 0 : _a.call(logger, "Entry=".concat(JSON.stringify(feature)));
	      if (feature._id.equals(featureId)) {
	        (_b = logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, "Top level featureId matches in the object ".concat(JSON.stringify(feature)));
	        return feature;
	      }
	      // Check if there is also childFeatures in parent feature and it's not empty
	      // Let's get featureId from recursive method
	      (_c = logger.debug) === null || _c === void 0 ? void 0 : _c.call(logger, 'FeatureId was not found on top level so lets make recursive call...');
	      var _iterator = _createForOfIteratorHelper((_d = feature.children) !== null && _d !== void 0 ? _d : new Map()),
	        _step;
	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var _step$value = _slicedToArray(_step.value, 2),
	            childFeature = _step$value[1];
	          var subFeature = this.getFeatureFromId(childFeature, featureId);
	          if (subFeature) {
	            return subFeature;
	          }
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }
	      return null;
	    }
	    /**
	     * Get children's feature ids
	     * @param feature - parent feature
	     * @returns
	     */
	  }, {
	    key: "getChildFeatureIds",
	    value: function getChildFeatureIds(feature) {
	      if (!feature.children) {
	        return [];
	      }
	      var featureIds = [];
	      var children = feature.children instanceof Map ? feature.children : new Map(Object.entries(feature.children));
	      var _iterator2 = _createForOfIteratorHelper(children || new Map()),
	        _step2;
	      try {
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          var _step2$value = _slicedToArray(_step2.value, 2),
	            childFeatureId = _step2$value[0],
	            childFeature = _step2$value[1];
	          featureIds.push.apply(featureIds, [childFeatureId].concat(_toConsumableArray(this.getChildFeatureIds(childFeature))));
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }
	      return featureIds;
	    }
	    /**
	     * Recursively assign new IDs to a feature
	     * @param feature - Parent feature
	     * @param featureIds -
	     */
	  }, {
	    key: "generateNewIds",
	    value: function generateNewIds(feature, featureIds) {
	      var newId = new bson_objectid_1$3["default"]().toHexString();
	      featureIds.push(newId);
	      var children = {};
	      if (feature.children) {
	        for (var _i = 0, _Object$values = Object.values(feature.children); _i < _Object$values.length; _i++) {
	          var child = _Object$values[_i];
	          var newChild = this.generateNewIds(child, featureIds);
	          children[newChild._id] = newChild;
	        }
	      }
	      var refSeq = typeof feature.refSeq === 'string' ? feature.refSeq : feature.refSeq.toHexString();
	      return _objectSpread2(_objectSpread2({}, feature), {}, {
	        refSeq: refSeq,
	        children: feature.children && children,
	        _id: newId
	      });
	    }
	  }, {
	    key: "addChild",
	    value: function addChild(parentFeature, child) {
	      var _a;
	      if (!((_a = parentFeature.attributes) === null || _a === void 0 ? void 0 : _a._id)) {
	        var attributes = parentFeature.attributes;
	        if (!attributes) {
	          attributes = {};
	        }
	        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
	        attributes = _objectSpread2({
	          _id: [parentFeature._id.toString()]
	        }, JSON.parse(JSON.stringify(attributes)));
	        parentFeature.attributes = attributes;
	      }
	      var _id = child._id;
	      if (!parentFeature.children) {
	        parentFeature.children = new Map();
	      }
	      parentFeature.children.set(_id, _objectSpread2(_objectSpread2({
	        allIds: []
	      }, child), {}, {
	        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
	        // @ts-expect-error
	        _id: _id
	      }));
	      // Child features should be sorted for click and drag of gene glyphs to work properly
	      parentFeature.children = new Map(_toConsumableArray(parentFeature.children.entries()).sort(function (a, b) {
	        return a[1].min - b[1].min;
	      }));
	    }
	    /**
	     * Delete feature's subfeatures that match an ID and return the IDs of any
	     * sub-subfeatures that were deleted
	     * @param feature -
	     * @param featureIdToDelete -
	     * @returns - list of deleted feature IDs
	     */
	  }, {
	    key: "findAndDeleteChildFeature",
	    value: function findAndDeleteChildFeature(feature, featureIdToDelete) {
	      if (!feature.children) {
	        throw new Error("Feature ".concat(feature._id.toHexString(), " has no children"));
	      }
	      var _id = feature._id,
	        children = feature.children;
	      var child = children.get(featureIdToDelete);
	      if (child) {
	        var deletedIds = this.getChildFeatureIds(child);
	        children["delete"](featureIdToDelete);
	        return deletedIds;
	      }
	      var _iterator3 = _createForOfIteratorHelper(children),
	        _step3;
	      try {
	        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	          var _step3$value = _slicedToArray(_step3.value, 2),
	            childFeature = _step3$value[1];
	          try {
	            return this.findAndDeleteChildFeature(childFeature, featureIdToDelete);
	          } catch (_unused) {
	            // pass
	          }
	        }
	      } catch (err) {
	        _iterator3.e(err);
	      } finally {
	        _iterator3.f();
	      }
	      throw new Error("Feature \"".concat(featureIdToDelete, "\" not found in ").concat(_id.toHexString()));
	    }
	  }]);
	  return FeatureChange;
	}(AssemblySpecificChange_1$1.AssemblySpecificChange);
	FeatureChange$3.FeatureChange = FeatureChange$2;

	var OperationTypeRegistry$3 = {};

	Object.defineProperty(OperationTypeRegistry$3, "__esModule", {
	  value: true
	});
	OperationTypeRegistry$3.operationRegistry = void 0;
	var OperationTypeRegistry$2 = /*#__PURE__*/function () {
	  function OperationTypeRegistry() {
	    _classCallCheck(this, OperationTypeRegistry);
	    this.operations = new Map();
	  }
	  _createClass(OperationTypeRegistry, [{
	    key: "registerOperation",
	    value: function registerOperation(name, operationType) {
	      if (this.operations.has(name)) {
	        throw new Error("operation type \"".concat(name, "\" has already been registered"));
	      }
	      this.operations.set(name, operationType);
	    }
	  }, {
	    key: "getOperationType",
	    value: function getOperationType(name) {
	      var RegisteredOperationType = this.operations.get(name);
	      if (!RegisteredOperationType) {
	        throw new Error("No operation constructor registered for \"".concat(name, "\""));
	      }
	      return RegisteredOperationType;
	    }
	  }]);
	  return OperationTypeRegistry;
	}();
	/** global singleton of all known types of operations */
	OperationTypeRegistry$3.operationRegistry = /*#__PURE__*/new OperationTypeRegistry$2();

	var Validation$5 = {};

	Object.defineProperty(Validation$5, "__esModule", {
	  value: true
	});
	Validation$5.Validation = void 0;
	Validation$5.isContext = isContext$2;
	function isContext$2(thing) {
	  return 'context' in thing && 'reflector' in thing;
	}
	var Validation$4 = /*#__PURE__*/function () {
	  function Validation() {
	    _classCallCheck(this, Validation);
	  }
	  _createClass(Validation, [{
	    key: "frontendPreValidate",
	    value: function () {
	      var _frontendPreValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_change) {
	        return _regeneratorRuntime().wrap(function _callee$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", {
	                validationName: this.name
	              });
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee, this);
	      }));
	      function frontendPreValidate(_x) {
	        return _frontendPreValidate.apply(this, arguments);
	      }
	      return frontendPreValidate;
	    }()
	  }, {
	    key: "frontendPostValidate",
	    value: function () {
	      var _frontendPostValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_change, _dataStore) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              return _context3.abrupt("return", {
	                validationName: this.name
	              });
	            case 1:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee2, this);
	      }));
	      function frontendPostValidate(_x2, _x3) {
	        return _frontendPostValidate.apply(this, arguments);
	      }
	      return frontendPostValidate;
	    }()
	  }, {
	    key: "backendPreValidate",
	    value: function () {
	      var _backendPreValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_changeOrContext) {
	        return _regeneratorRuntime().wrap(function _callee3$(_context4) {
	          while (1) switch (_context4.prev = _context4.next) {
	            case 0:
	              return _context4.abrupt("return", {
	                validationName: this.name
	              });
	            case 1:
	            case "end":
	              return _context4.stop();
	          }
	        }, _callee3, this);
	      }));
	      function backendPreValidate(_x4) {
	        return _backendPreValidate.apply(this, arguments);
	      }
	      return backendPreValidate;
	    }()
	  }, {
	    key: "backendPostValidate",
	    value: function () {
	      var _backendPostValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_change, _context) {
	        return _regeneratorRuntime().wrap(function _callee4$(_context5) {
	          while (1) switch (_context5.prev = _context5.next) {
	            case 0:
	              return _context5.abrupt("return", {
	                validationName: this.name
	              });
	            case 1:
	            case "end":
	              return _context5.stop();
	          }
	        }, _callee4, this);
	      }));
	      function backendPostValidate(_x5, _x6) {
	        return _backendPostValidate.apply(this, arguments);
	      }
	      return backendPostValidate;
	    }()
	  }, {
	    key: "possibleValues",
	    value: function () {
	      var _possibleValues = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_key) {
	        return _regeneratorRuntime().wrap(function _callee5$(_context6) {
	          while (1) switch (_context6.prev = _context6.next) {
	            case 0:
	              return _context6.abrupt("return", undefined);
	            case 1:
	            case "end":
	              return _context6.stop();
	          }
	        }, _callee5);
	      }));
	      function possibleValues(_x7) {
	        return _possibleValues.apply(this, arguments);
	      }
	      return possibleValues;
	    }()
	  }]);
	  return Validation;
	}();
	Validation$5.Validation = Validation$4;

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var tslib_1 = require$$0$1;
	  tslib_1.__exportStar(ApolloPlugin$4, exports);
	  tslib_1.__exportStar(AssemblySpecificChange$3, exports);
	  tslib_1.__exportStar(Change$3, exports);
	  tslib_1.__exportStar(ChangeTypeRegistry$3, exports);
	  tslib_1.__exportStar(Check$3, exports);
	  tslib_1.__exportStar(CheckRegistry$3, exports);
	  tslib_1.__exportStar(FeatureChange$3, exports);
	  tslib_1.__exportStar(Operation$3, exports);
	  tslib_1.__exportStar(OperationTypeRegistry$3, exports);
	  tslib_1.__exportStar(Validation$5, exports);
	})(dist$3);

	var dist$2 = {};

	var Changes = {};

	var AddAssemblyAliasesChange$1 = {};

	var dist$1 = {};

	var ApolloPlugin$2 = {};

	Object.defineProperty(ApolloPlugin$2, "__esModule", {
	  value: true
	});
	ApolloPlugin$2.ApolloPlugin = void 0;
	var tslib_1$5 = require$$0$1;
	var Plugin_1 = /*#__PURE__*/tslib_1$5.__importDefault(require$$1__default["default"]);
	var ApolloPlugin$1 = /*#__PURE__*/function (_Plugin_1$default) {
	  _inherits(ApolloPlugin, _Plugin_1$default);
	  var _super = /*#__PURE__*/_createSuper(ApolloPlugin);
	  function ApolloPlugin() {
	    _classCallCheck(this, ApolloPlugin);
	    return _super.apply(this, arguments);
	  }
	  _createClass(ApolloPlugin, [{
	    key: "apolloInstall",
	    value:
	    // eslint-disable-next-line @typescript-eslint/no-empty-function
	    function apolloInstall(_pluginManager) {}
	  }]);
	  return ApolloPlugin;
	}(Plugin_1["default"]);
	ApolloPlugin$2.ApolloPlugin = ApolloPlugin$1;

	var AssemblySpecificChange$1 = {};

	var Change$1 = {};

	var ChangeTypeRegistry$1 = {};

	Object.defineProperty(ChangeTypeRegistry$1, "__esModule", {
	  value: true
	});
	ChangeTypeRegistry$1.changeRegistry = void 0;
	var ChangeTypeRegistry = /*#__PURE__*/function () {
	  function ChangeTypeRegistry() {
	    _classCallCheck(this, ChangeTypeRegistry);
	    this.changes = new Map();
	  }
	  _createClass(ChangeTypeRegistry, [{
	    key: "registerChange",
	    value: function registerChange(name, changeType) {
	      if (this.changes.has(name)) {
	        throw new Error("change type \"".concat(name, "\" has already been registered"));
	      }
	      this.changes.set(name, changeType);
	    }
	  }, {
	    key: "getChangeType",
	    value: function getChangeType(name) {
	      var RegisteredChangeType = this.changes.get(name);
	      if (!RegisteredChangeType) {
	        throw new Error("No change constructor registered for \"".concat(name, "\""));
	      }
	      return RegisteredChangeType;
	    }
	  }]);
	  return ChangeTypeRegistry;
	}();
	/** global singleton of all known types of changes */
	ChangeTypeRegistry$1.changeRegistry = /*#__PURE__*/new ChangeTypeRegistry();

	var Operation$1 = {};

	Object.defineProperty(Operation$1, "__esModule", {
	  value: true
	});
	Operation$1.Operation = void 0;
	var Operation = /*#__PURE__*/function () {
	  function Operation(json, options) {
	    _classCallCheck(this, Operation);
	    var _a;
	    this.logger = (_a = options === null || options === void 0 ? void 0 : options.logger) !== null && _a !== void 0 ? _a : console;
	  }
	  _createClass(Operation, [{
	    key: "execute",
	    value: function () {
	      var _execute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var backendType, initialResult;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              backendType = backend.typeName;
	              if (!(backendType === 'Server')) {
	                _context.next = 4;
	                break;
	              }
	              initialResult = this.executeOnServer(backend);
	              return _context.abrupt("return", backend.pluginsService.evaluateExtensionPoint("".concat(this.typeName, "-transformResults"), initialResult, {
	                operation: this,
	                backend: backend
	              }));
	            case 4:
	              if (!(backendType === 'LocalGFF3')) {
	                _context.next = 6;
	                break;
	              }
	              return _context.abrupt("return", this.executeOnLocalGFF3(backend));
	            case 6:
	              throw new Error("no operation implementation for backend type '".concat(backendType, "'"));
	            case 7:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this);
	      }));
	      function execute(_x) {
	        return _execute.apply(this, arguments);
	      }
	      return execute;
	    }()
	  }]);
	  return Operation;
	}();
	Operation$1.Operation = Operation;

	Object.defineProperty(Change$1, "__esModule", {
	  value: true
	});
	Change$1.Change = void 0;
	Change$1.isChange = isChange;
	var ChangeTypeRegistry_1 = ChangeTypeRegistry$1;
	var Operation_1 = Operation$1;
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	function isChange(thing) {
	  return thing.executeOnClient !== undefined;
	}
	var Change = /*#__PURE__*/function (_Operation_1$Operatio) {
	  _inherits(Change, _Operation_1$Operatio);
	  var _super = /*#__PURE__*/_createSuper(Change);
	  function Change() {
	    _classCallCheck(this, Change);
	    return _super.apply(this, arguments);
	  }
	  _createClass(Change, [{
	    key: "notification",
	    get:
	    /**
	     * If a non-empty string, a snackbar will display in JBrowse with this message
	     * when a successful response is received from the server.
	     */
	    // eslint-disable-next-line @typescript-eslint/class-literal-property-style
	    function get() {
	      return '';
	    }
	  }, {
	    key: "execute",
	    value: function () {
	      var _execute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var backendType;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              backendType = backend.typeName;
	              if (!(backendType === 'LocalGFF3' || backendType === 'Server')) {
	                _context.next = 3;
	                break;
	              }
	              return _context.abrupt("return", _get(_getPrototypeOf(Change.prototype), "execute", this).call(this, backend));
	            case 3:
	              if (!(backendType === 'Client')) {
	                _context.next = 5;
	                break;
	              }
	              return _context.abrupt("return", this.executeOnClient(backend));
	            case 5:
	              throw new Error("no change implementation for backend type '".concat(backendType, "'"));
	            case 6:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this);
	      }));
	      function execute(_x) {
	        return _execute.apply(this, arguments);
	      }
	      return execute;
	    }()
	  }], [{
	    key: "fromJSON",
	    value: function fromJSON(json, options) {
	      var ChangeType = ChangeTypeRegistry_1.changeRegistry.getChangeType(json.typeName);
	      return new ChangeType(json, (options === null || options === void 0 ? void 0 : options.logger) && {
	        logger: options.logger
	      });
	    }
	  }]);
	  return Change;
	}(Operation_1.Operation);
	Change$1.Change = Change;

	Object.defineProperty(AssemblySpecificChange$1, "__esModule", {
	  value: true
	});
	AssemblySpecificChange$1.AssemblySpecificChange = void 0;
	AssemblySpecificChange$1.isAssemblySpecificChange = isAssemblySpecificChange;
	/* eslint-disable @typescript-eslint/no-unnecessary-condition */
	var Change_1 = Change$1;
	function isAssemblySpecificChange(
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	thing) {
	  return (0, Change_1.isChange)(thing) && thing.assembly !== undefined;
	}
	var AssemblySpecificChange = /*#__PURE__*/function (_Change_1$Change) {
	  _inherits(AssemblySpecificChange, _Change_1$Change);
	  var _super = /*#__PURE__*/_createSuper(AssemblySpecificChange);
	  function AssemblySpecificChange(json, options) {
	    var _this;
	    _classCallCheck(this, AssemblySpecificChange);
	    _this = _super.call(this, json, options);
	    _this.assembly = json.assembly;
	    return _this;
	  }
	  return _createClass(AssemblySpecificChange);
	}(Change_1.Change);
	AssemblySpecificChange$1.AssemblySpecificChange = AssemblySpecificChange;

	var Check$1 = {};

	Object.defineProperty(Check$1, "__esModule", {
	  value: true
	});
	Check$1.Check = void 0;
	var Check = /*#__PURE__*/_createClass(function Check() {
	  _classCallCheck(this, Check);
	});
	Check$1.Check = Check;

	var CheckRegistry$1 = {};

	Object.defineProperty(CheckRegistry$1, "__esModule", {
	  value: true
	});
	CheckRegistry$1.checkRegistry = void 0;
	var CheckRegistry = /*#__PURE__*/function () {
	  function CheckRegistry() {
	    _classCallCheck(this, CheckRegistry);
	    this.checks = new Map();
	  }
	  _createClass(CheckRegistry, [{
	    key: "registerCheck",
	    value: function registerCheck(name, check) {
	      if (this.checks.has(name)) {
	        throw new Error("check \"".concat(name, "\" has already been registered"));
	      }
	      this.checks.set(name, check);
	    }
	  }, {
	    key: "getCheck",
	    value: function getCheck(name) {
	      var registeredCheck = this.checks.get(name);
	      if (!registeredCheck) {
	        throw new Error("No check constructor registered for \"".concat(name, "\""));
	      }
	      return registeredCheck;
	    }
	  }, {
	    key: "getChecks",
	    value: function getChecks() {
	      return this.checks;
	    }
	  }]);
	  return CheckRegistry;
	}();
	/** global singleton of all known checks */
	CheckRegistry$1.checkRegistry = /*#__PURE__*/new CheckRegistry();

	var FeatureChange$1 = {};

	Object.defineProperty(FeatureChange$1, "__esModule", {
	  value: true
	});
	FeatureChange$1.FeatureChange = void 0;
	FeatureChange$1.isFeatureChange = isFeatureChange;
	var tslib_1$4 = require$$0$1;
	var bson_objectid_1$2 = /*#__PURE__*/tslib_1$4.__importDefault(objectid);
	var AssemblySpecificChange_1 = AssemblySpecificChange$1;
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	function isFeatureChange(thing) {
	  return (0, AssemblySpecificChange_1.isAssemblySpecificChange)(thing) && thing.changedIds !== undefined;
	}
	var FeatureChange = /*#__PURE__*/function (_AssemblySpecificChan) {
	  _inherits(FeatureChange, _AssemblySpecificChan);
	  var _super = /*#__PURE__*/_createSuper(FeatureChange);
	  function FeatureChange(json, options) {
	    var _this;
	    _classCallCheck(this, FeatureChange);
	    _this = _super.call(this, json, options);
	    _this.changedIds = json.changedIds;
	    return _this;
	  }
	  /**
	   * Get single feature by featureId
	   * @param feature -
	   * @param featureId -
	   * @returns
	   */
	  _createClass(FeatureChange, [{
	    key: "getFeatureFromId",
	    value: function getFeatureFromId(feature, featureId) {
	      var _a, _b, _c, _d;
	      var logger = this.logger;
	      (_a = logger.verbose) === null || _a === void 0 ? void 0 : _a.call(logger, "Entry=".concat(JSON.stringify(feature)));
	      if (feature._id.equals(featureId)) {
	        (_b = logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, "Top level featureId matches in the object ".concat(JSON.stringify(feature)));
	        return feature;
	      }
	      // Check if there is also childFeatures in parent feature and it's not empty
	      // Let's get featureId from recursive method
	      (_c = logger.debug) === null || _c === void 0 ? void 0 : _c.call(logger, 'FeatureId was not found on top level so lets make recursive call...');
	      var _iterator = _createForOfIteratorHelper((_d = feature.children) !== null && _d !== void 0 ? _d : new Map()),
	        _step;
	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var _step$value = _slicedToArray(_step.value, 2),
	            childFeature = _step$value[1];
	          var subFeature = this.getFeatureFromId(childFeature, featureId);
	          if (subFeature) {
	            return subFeature;
	          }
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }
	      return null;
	    }
	    /**
	     * Get children's feature ids
	     * @param feature - parent feature
	     * @returns
	     */
	  }, {
	    key: "getChildFeatureIds",
	    value: function getChildFeatureIds(feature) {
	      if (!feature.children) {
	        return [];
	      }
	      var featureIds = [];
	      var children = feature.children instanceof Map ? feature.children : new Map(Object.entries(feature.children));
	      var _iterator2 = _createForOfIteratorHelper(children || new Map()),
	        _step2;
	      try {
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          var _step2$value = _slicedToArray(_step2.value, 2),
	            childFeatureId = _step2$value[0],
	            childFeature = _step2$value[1];
	          featureIds.push.apply(featureIds, [childFeatureId].concat(_toConsumableArray(this.getChildFeatureIds(childFeature))));
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }
	      return featureIds;
	    }
	    /**
	     * Recursively assign new IDs to a feature
	     * @param feature - Parent feature
	     * @param featureIds -
	     */
	  }, {
	    key: "generateNewIds",
	    value: function generateNewIds(feature, featureIds) {
	      var newId = new bson_objectid_1$2["default"]().toHexString();
	      featureIds.push(newId);
	      var children = {};
	      if (feature.children) {
	        for (var _i = 0, _Object$values = Object.values(feature.children); _i < _Object$values.length; _i++) {
	          var child = _Object$values[_i];
	          var newChild = this.generateNewIds(child, featureIds);
	          children[newChild._id] = newChild;
	        }
	      }
	      var refSeq = typeof feature.refSeq === 'string' ? feature.refSeq : feature.refSeq.toHexString();
	      return _objectSpread2(_objectSpread2({}, feature), {}, {
	        refSeq: refSeq,
	        children: feature.children && children,
	        _id: newId
	      });
	    }
	  }, {
	    key: "addChild",
	    value: function addChild(parentFeature, child) {
	      var _a;
	      if (!((_a = parentFeature.attributes) === null || _a === void 0 ? void 0 : _a._id)) {
	        var attributes = parentFeature.attributes;
	        if (!attributes) {
	          attributes = {};
	        }
	        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
	        attributes = _objectSpread2({
	          _id: [parentFeature._id.toString()]
	        }, JSON.parse(JSON.stringify(attributes)));
	        parentFeature.attributes = attributes;
	      }
	      var _id = child._id;
	      if (!parentFeature.children) {
	        parentFeature.children = new Map();
	      }
	      parentFeature.children.set(_id, _objectSpread2(_objectSpread2({
	        allIds: []
	      }, child), {}, {
	        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
	        // @ts-expect-error
	        _id: _id
	      }));
	      // Child features should be sorted for click and drag of gene glyphs to work properly
	      parentFeature.children = new Map(_toConsumableArray(parentFeature.children.entries()).sort(function (a, b) {
	        return a[1].min - b[1].min;
	      }));
	    }
	    /**
	     * Delete feature's subfeatures that match an ID and return the IDs of any
	     * sub-subfeatures that were deleted
	     * @param feature -
	     * @param featureIdToDelete -
	     * @returns - list of deleted feature IDs
	     */
	  }, {
	    key: "findAndDeleteChildFeature",
	    value: function findAndDeleteChildFeature(feature, featureIdToDelete) {
	      if (!feature.children) {
	        throw new Error("Feature ".concat(feature._id.toHexString(), " has no children"));
	      }
	      var _id = feature._id,
	        children = feature.children;
	      var child = children.get(featureIdToDelete);
	      if (child) {
	        var deletedIds = this.getChildFeatureIds(child);
	        children["delete"](featureIdToDelete);
	        return deletedIds;
	      }
	      var _iterator3 = _createForOfIteratorHelper(children),
	        _step3;
	      try {
	        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	          var _step3$value = _slicedToArray(_step3.value, 2),
	            childFeature = _step3$value[1];
	          try {
	            return this.findAndDeleteChildFeature(childFeature, featureIdToDelete);
	          } catch (_unused) {
	            // pass
	          }
	        }
	      } catch (err) {
	        _iterator3.e(err);
	      } finally {
	        _iterator3.f();
	      }
	      throw new Error("Feature \"".concat(featureIdToDelete, "\" not found in ").concat(_id.toHexString()));
	    }
	  }]);
	  return FeatureChange;
	}(AssemblySpecificChange_1.AssemblySpecificChange);
	FeatureChange$1.FeatureChange = FeatureChange;

	var OperationTypeRegistry$1 = {};

	Object.defineProperty(OperationTypeRegistry$1, "__esModule", {
	  value: true
	});
	OperationTypeRegistry$1.operationRegistry = void 0;
	var OperationTypeRegistry = /*#__PURE__*/function () {
	  function OperationTypeRegistry() {
	    _classCallCheck(this, OperationTypeRegistry);
	    this.operations = new Map();
	  }
	  _createClass(OperationTypeRegistry, [{
	    key: "registerOperation",
	    value: function registerOperation(name, operationType) {
	      if (this.operations.has(name)) {
	        throw new Error("operation type \"".concat(name, "\" has already been registered"));
	      }
	      this.operations.set(name, operationType);
	    }
	  }, {
	    key: "getOperationType",
	    value: function getOperationType(name) {
	      var RegisteredOperationType = this.operations.get(name);
	      if (!RegisteredOperationType) {
	        throw new Error("No operation constructor registered for \"".concat(name, "\""));
	      }
	      return RegisteredOperationType;
	    }
	  }]);
	  return OperationTypeRegistry;
	}();
	/** global singleton of all known types of operations */
	OperationTypeRegistry$1.operationRegistry = /*#__PURE__*/new OperationTypeRegistry();

	var Validation$3 = {};

	Object.defineProperty(Validation$3, "__esModule", {
	  value: true
	});
	Validation$3.Validation = void 0;
	Validation$3.isContext = isContext$1;
	function isContext$1(thing) {
	  return 'context' in thing && 'reflector' in thing;
	}
	var Validation$2 = /*#__PURE__*/function () {
	  function Validation() {
	    _classCallCheck(this, Validation);
	  }
	  _createClass(Validation, [{
	    key: "frontendPreValidate",
	    value: function () {
	      var _frontendPreValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_change) {
	        return _regeneratorRuntime().wrap(function _callee$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", {
	                validationName: this.name
	              });
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee, this);
	      }));
	      function frontendPreValidate(_x) {
	        return _frontendPreValidate.apply(this, arguments);
	      }
	      return frontendPreValidate;
	    }()
	  }, {
	    key: "frontendPostValidate",
	    value: function () {
	      var _frontendPostValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_change, _dataStore) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              return _context3.abrupt("return", {
	                validationName: this.name
	              });
	            case 1:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee2, this);
	      }));
	      function frontendPostValidate(_x2, _x3) {
	        return _frontendPostValidate.apply(this, arguments);
	      }
	      return frontendPostValidate;
	    }()
	  }, {
	    key: "backendPreValidate",
	    value: function () {
	      var _backendPreValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_changeOrContext) {
	        return _regeneratorRuntime().wrap(function _callee3$(_context4) {
	          while (1) switch (_context4.prev = _context4.next) {
	            case 0:
	              return _context4.abrupt("return", {
	                validationName: this.name
	              });
	            case 1:
	            case "end":
	              return _context4.stop();
	          }
	        }, _callee3, this);
	      }));
	      function backendPreValidate(_x4) {
	        return _backendPreValidate.apply(this, arguments);
	      }
	      return backendPreValidate;
	    }()
	  }, {
	    key: "backendPostValidate",
	    value: function () {
	      var _backendPostValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_change, _context) {
	        return _regeneratorRuntime().wrap(function _callee4$(_context5) {
	          while (1) switch (_context5.prev = _context5.next) {
	            case 0:
	              return _context5.abrupt("return", {
	                validationName: this.name
	              });
	            case 1:
	            case "end":
	              return _context5.stop();
	          }
	        }, _callee4, this);
	      }));
	      function backendPostValidate(_x5, _x6) {
	        return _backendPostValidate.apply(this, arguments);
	      }
	      return backendPostValidate;
	    }()
	  }, {
	    key: "possibleValues",
	    value: function () {
	      var _possibleValues = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_key) {
	        return _regeneratorRuntime().wrap(function _callee5$(_context6) {
	          while (1) switch (_context6.prev = _context6.next) {
	            case 0:
	              return _context6.abrupt("return", undefined);
	            case 1:
	            case "end":
	              return _context6.stop();
	          }
	        }, _callee5);
	      }));
	      function possibleValues(_x7) {
	        return _possibleValues.apply(this, arguments);
	      }
	      return possibleValues;
	    }()
	  }]);
	  return Validation;
	}();
	Validation$3.Validation = Validation$2;

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var tslib_1 = require$$0$1;
	  tslib_1.__exportStar(ApolloPlugin$2, exports);
	  tslib_1.__exportStar(AssemblySpecificChange$1, exports);
	  tslib_1.__exportStar(Change$1, exports);
	  tslib_1.__exportStar(ChangeTypeRegistry$1, exports);
	  tslib_1.__exportStar(Check$1, exports);
	  tslib_1.__exportStar(CheckRegistry$1, exports);
	  tslib_1.__exportStar(FeatureChange$1, exports);
	  tslib_1.__exportStar(Operation$1, exports);
	  tslib_1.__exportStar(OperationTypeRegistry$1, exports);
	  tslib_1.__exportStar(Validation$3, exports);
	})(dist$1);

	Object.defineProperty(AddAssemblyAliasesChange$1, "__esModule", {
	  value: true
	});
	AddAssemblyAliasesChange$1.AddAssemblyAliasesChange = void 0;
	var common_1$n = dist$1;
	var util_1$7 = require$$1__default$1["default"];
	var AddAssemblyAliasesChange = /*#__PURE__*/function (_common_1$AssemblySpe) {
	  _inherits(AddAssemblyAliasesChange, _common_1$AssemblySpe);
	  var _super = /*#__PURE__*/_createSuper(AddAssemblyAliasesChange);
	  function AddAssemblyAliasesChange(json, options) {
	    var _this;
	    _classCallCheck(this, AddAssemblyAliasesChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'AddAssemblyAliasesChange');
	    _defineProperty(_assertThisInitialized(_this), "aliases", void 0);
	    _this.aliases = json.aliases;
	    return _this;
	  }
	  _createClass(AddAssemblyAliasesChange, [{
	    key: "executeOnClient",
	    value: function executeOnClient(clientDataStore) {
	      var _ref = (0, util_1$7.getSession)(clientDataStore),
	        assemblyManager = _ref.assemblyManager;
	      var assembly = assemblyManager.get(this.assembly);
	      if (!assembly) {
	        throw new Error("assembly ".concat(this.assembly, " not found"));
	      }
	      // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access
	      assembly.configuration.aliases.set(this.aliases);
	      return Promise.resolve();
	    }
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      throw new Error('Method not implemented.');
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        aliases = this.aliases,
	        typeName = this.typeName;
	      return {
	        assembly: assembly,
	        typeName: typeName,
	        aliases: aliases
	      };
	    }
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var _logger$debug;
	        var assemblyModel, assembly, logger, aliases, asm;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              assemblyModel = backend.assemblyModel;
	              assembly = this.assembly, logger = this.logger, aliases = this.aliases;
	              (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, "Updating assembly aliases for assembly: ".concat(assembly, ", aliases: ").concat(JSON.stringify(aliases)));
	              _context.next = 5;
	              return assemblyModel.findById(assembly);
	            case 5:
	              asm = _context.sent;
	              if (asm) {
	                _context.next = 8;
	                break;
	              }
	              throw new Error("Assembly with ID ".concat(assembly, " not found"));
	            case 8:
	              asm.aliases = aliases;
	              _context.next = 11;
	              return asm.save();
	            case 11:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function executeOnLocalGFF3(_backend) {
	      throw new Error('Method not implemented.');
	    }
	    // eslint-disable-next-line @typescript-eslint/class-literal-property-style
	  }, {
	    key: "notification",
	    get: function get() {
	      return 'Assembly aliases have been added.';
	    }
	  }]);
	  return AddAssemblyAliasesChange;
	}(common_1$n.AssemblySpecificChange);
	AddAssemblyAliasesChange$1.AddAssemblyAliasesChange = AddAssemblyAliasesChange;

	var AddAssemblyAndFeaturesFromFileChange$1 = {};

	var FromFileBaseChange$1 = {};

	var GFF3 = {};

	var annotationFeatureToGFF3$1 = {};

	/* eslint-disable @typescript-eslint/no-unsafe-assignment */
	Object.defineProperty(annotationFeatureToGFF3$1, "__esModule", {
	  value: true
	});
	annotationFeatureToGFF3$1.annotationFeatureToGFF3 = annotationFeatureToGFF3;
	var util_1$6 = require$$1__default$1["default"];
	function annotationFeatureToGFF3(feature, parentId, refSeqNames) {
	  var _feature$attributes, _feature$attributes$g, _feature$attributes2, _feature$attributes3;
	  // eslint-disable-next-line unicorn/prefer-structured-clone
	  var attributes = JSON.parse(JSON.stringify((_feature$attributes = feature.attributes) !== null && _feature$attributes !== void 0 ? _feature$attributes : {}));
	  var ontologyTerms = [];
	  var source = (_feature$attributes$g = (_feature$attributes2 = feature.attributes) === null || _feature$attributes2 === void 0 || (_feature$attributes2 = _feature$attributes2.gff_source) === null || _feature$attributes2 === void 0 ? void 0 : _feature$attributes2[0]) !== null && _feature$attributes$g !== void 0 ? _feature$attributes$g : null;
	  delete attributes.gff_source;
	  if (parentId) {
	    attributes.Parent = [parentId];
	  }
	  if (attributes.gff_id) {
	    attributes.ID = attributes.gff_id;
	    delete attributes.gff_id;
	  } else if (feature.children) {
	    attributes.ID = [feature._id];
	  }
	  if (attributes.gff_name) {
	    attributes.Name = attributes.gff_name;
	    delete attributes.gff_name;
	  }
	  if (attributes.gff_alias) {
	    attributes.Alias = attributes.gff_alias;
	    delete attributes.gff_alias;
	  }
	  if (attributes.gff_target) {
	    attributes.Target = attributes.gff_target;
	    delete attributes.gff_target;
	  }
	  if (attributes.gff_gap) {
	    attributes.Gap = attributes.gff_gap;
	    delete attributes.gff_gap;
	  }
	  if (attributes.gff_derives_from) {
	    attributes.Derives_from = attributes.gff_derives_from;
	    delete attributes.gff_derives_from;
	  }
	  if (attributes.gff_note) {
	    attributes.Note = attributes.gff_note;
	    delete attributes.gff_note;
	  }
	  if (attributes.gff_dbxref) {
	    attributes.Dbxref = attributes.gff_dbxref;
	    delete attributes.gff_dbxref;
	  }
	  if (attributes.gff_is_circular) {
	    attributes.Is_circular = attributes.gff_is_circular;
	    delete attributes.gff_is_circular;
	  }
	  if (attributes.gff_ontology_term) {
	    ontologyTerms.push.apply(ontologyTerms, _toConsumableArray(attributes.gff_ontology_term));
	    delete attributes.gff_ontology_term;
	  }
	  if (attributes['Gene Ontology']) {
	    ontologyTerms.push.apply(ontologyTerms, _toConsumableArray(attributes['Gene Ontology']));
	    delete attributes['Gene Ontology'];
	  }
	  if (attributes['Sequence Ontology']) {
	    ontologyTerms.push.apply(ontologyTerms, _toConsumableArray(attributes['Sequence Ontology']));
	    delete attributes['Sequence Ontology'];
	  }
	  if (ontologyTerms.length > 0) {
	    attributes.Ontology_term = ontologyTerms;
	  }
	  var gff_score = (_feature$attributes3 = feature.attributes) === null || _feature$attributes3 === void 0 ? void 0 : _feature$attributes3.gff_score;
	  var score = null;
	  if (gff_score && gff_score.length > 0) {
	    if (gff_score[0]) {
	      score = Number(gff_score[0]);
	      if (Number.isNaN(score)) {
	        score = null;
	      }
	    }
	    delete attributes.gff_score;
	  }
	  var locations = [{
	    start: feature.min,
	    end: feature.max
	  }];
	  return locations.map(function (location) {
	    var _refSeqNames$feature$, _attributes$ID;
	    return {
	      start: Number(location.start) + 1,
	      end: Number(location.end),
	      seq_id: refSeqNames ? (_refSeqNames$feature$ = refSeqNames[feature.refSeq]) !== null && _refSeqNames$feature$ !== void 0 ? _refSeqNames$feature$ : null : feature.refSeq,
	      source: source,
	      type: feature.type,
	      score: score,
	      strand: feature.strand ? feature.strand === 1 ? '+' : '-' : null,
	      phase: null,
	      attributes: Object.keys(attributes).length > 0 ? attributes : null,
	      derived_features: [],
	      child_features: prepareChildFeatures(feature, (_attributes$ID = attributes.ID) === null || _attributes$ID === void 0 ? void 0 : _attributes$ID[0], refSeqNames)
	    };
	  });
	}
	function prepareChildFeatures(feature, parentID, refSeqNames) {
	  if (!feature.children) {
	    return [];
	  }
	  if (feature.type === 'mRNA') {
	    var child_features = [];
	    var cdsLocations = getCdsLocations(feature);
	    var cds_idx = 0;
	    for (var _i = 0, _Object$values = Object.values(feature.children); _i < _Object$values.length; _i++) {
	      var child = _Object$values[_i];
	      var gffChild = annotationFeatureToGFF3(child, parentID, refSeqNames);
	      if (child.type === 'CDS') {
	        var _iterator = _createForOfIteratorHelper(cdsLocations[cds_idx]),
	          _step;
	        try {
	          for (_iterator.s(); !(_step = _iterator.n()).done;) {
	            var loc = _step.value;
	            // eslint-disable-next-line unicorn/prefer-structured-clone
	            var gffCds = JSON.parse(JSON.stringify(gffChild));
	            if (gffCds.length != 1) {
	              // Do we need this check?
	              throw new Error("Unexpected CDS: ".concat(JSON.stringify(gffCds, null, 2)));
	            }
	            gffCds[0].start = loc.min + 1;
	            gffCds[0].end = loc.max;
	            gffCds[0].phase = loc.phase.toString();
	            gffCds[0].type = loc.type; // Do we need this?
	            child_features.push(gffCds);
	          }
	        } catch (err) {
	          _iterator.e(err);
	        } finally {
	          _iterator.f();
	        }
	        cds_idx++;
	      } else {
	        child_features.push(gffChild);
	      }
	    }
	    return child_features;
	  }
	  return Object.values(feature.children).map(function (child) {
	    return annotationFeatureToGFF3(child, parentID, refSeqNames);
	  });
	}
	function getTranscriptParts(feature) {
	  if (feature.type !== 'mRNA') {
	    throw new Error('Only features of type "mRNA" or equivalent can calculate CDS locations');
	  }
	  if (!feature.children) {
	    throw new Error('no CDS or exons in mRNA');
	  }
	  // In AnnotationFeatureModel we have `children.values()`
	  var children = Object.values(feature.children);
	  var cdsChildren = children.filter(function (child) {
	    return child.type === 'CDS';
	  });
	  if (cdsChildren.length === 0) {
	    throw new Error('no CDS in mRNA');
	  }
	  var transcriptParts = [];
	  var _iterator2 = _createForOfIteratorHelper(cdsChildren),
	    _step2;
	  try {
	    var _loop = function _loop() {
	      var cds = _step2.value;
	      var cdsMax = cds.max,
	        cdsMin = cds.min;
	      var parts = [];
	      var hasIntersected = false;
	      var exonLocations = [];
	      for (var _i2 = 0, _children = children; _i2 < _children.length; _i2++) {
	        var child = _children[_i2];
	        if (child.type === 'exon') {
	          exonLocations.push({
	            min: child.min,
	            max: child.max
	          });
	        }
	      }
	      exonLocations.sort(function (_ref, _ref2) {
	        var a = _ref.min;
	        var b = _ref2.min;
	        return a - b;
	      });
	      for (var _i3 = 0, _exonLocations = exonLocations; _i3 < _exonLocations.length; _i3++) {
	        var _child = _exonLocations[_i3];
	        var lastPart = parts.at(-1);
	        if (lastPart) {
	          parts.push({
	            min: lastPart.max,
	            max: _child.min,
	            type: 'intron'
	          });
	        }
	        var _ref3 = (0, util_1$6.intersection2)(cdsMin, cdsMax, _child.min, _child.max),
	          _ref4 = _slicedToArray(_ref3, 2),
	          start = _ref4[0],
	          end = _ref4[1];
	        var utrType = void 0;
	        if (hasIntersected) {
	          utrType = feature.strand === 1 ? 'threePrimeUTR' : 'fivePrimeUTR';
	        } else {
	          utrType = feature.strand === 1 ? 'fivePrimeUTR' : 'threePrimeUTR';
	        }
	        if (start !== undefined && end !== undefined) {
	          hasIntersected = true;
	          if (start === _child.min && end === _child.max) {
	            parts.push({
	              min: start,
	              max: end,
	              phase: 0,
	              type: 'CDS'
	            });
	          } else if (start === _child.min) {
	            parts.push({
	              min: start,
	              max: end,
	              phase: 0,
	              type: 'CDS'
	            }, {
	              min: end,
	              max: _child.max,
	              type: utrType
	            });
	          } else if (end === _child.max) {
	            parts.push({
	              min: _child.min,
	              max: start,
	              type: utrType
	            }, {
	              min: start,
	              max: end,
	              phase: 0,
	              type: 'CDS'
	            });
	          } else {
	            parts.push({
	              min: _child.min,
	              max: start,
	              type: utrType
	            }, {
	              min: start,
	              max: end,
	              phase: 0,
	              type: 'CDS'
	            }, {
	              min: end,
	              max: _child.max,
	              type: utrType === 'fivePrimeUTR' ? 'threePrimeUTR' : 'fivePrimeUTR'
	            });
	          }
	        } else {
	          parts.push({
	            min: _child.min,
	            max: _child.max,
	            type: utrType
	          });
	        }
	      }
	      parts.sort(function (_ref5, _ref6) {
	        var a = _ref5.min;
	        var b = _ref6.min;
	        return a - b;
	      });
	      if (feature.strand === -1) {
	        parts.reverse();
	      }
	      var nextPhase = 0;
	      var phasedParts = parts.map(function (loc) {
	        if (loc.type !== 'CDS') {
	          return loc;
	        }
	        var phase = nextPhase;
	        nextPhase = (3 - (loc.max - loc.min - phase + 3) % 3) % 3;
	        return _objectSpread2(_objectSpread2({}, loc), {}, {
	          phase: phase
	        });
	      });
	      transcriptParts.push(phasedParts);
	    };
	    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	      _loop();
	    }
	  } catch (err) {
	    _iterator2.e(err);
	  } finally {
	    _iterator2.f();
	  }
	  return transcriptParts;
	}
	function getCdsLocations(feature) {
	  var transcriptParts = [];
	  try {
	    transcriptParts = getTranscriptParts(feature);
	  } catch (_unused) {
	    return [];
	  }
	  return transcriptParts.map(function (transcript) {
	    return transcript.filter(function (transcriptPart) {
	      return transcriptPart.type === 'CDS';
	    });
	  });
	}

	var gffReservedKeys = {};

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.gffInternalToColumn = exports.gffColumnToInternal = exports.internalToGFF = exports.gffToInternal = void 0;
	  exports.isGFFReservedAttribute = isGFFReservedAttribute;
	  exports.isGFFInternalAttribute = isGFFInternalAttribute;
	  exports.isGFFColumn = isGFFColumn;
	  exports.isGFFColumnInternal = isGFFColumnInternal;
	  exports.gffToInternal = {
	    ID: 'gff_id',
	    Name: 'gff_name',
	    Alias: 'gff_alias',
	    Parent: 'gff_parent',
	    Target: 'gff_target',
	    Gap: 'gff_gap',
	    Derives_from: 'gff_derives_from',
	    Note: 'gff_note',
	    Dbxref: 'gff_dbxref',
	    Ontology_term: 'gff_ontology_term',
	    Is_circular: 'gff_is_circular'
	  };
	  function isGFFReservedAttribute(attribute) {
	    return attribute in exports.gffToInternal;
	  }
	  exports.internalToGFF = {
	    gff_id: 'ID',
	    gff_name: 'Name',
	    gff_alias: 'Alias',
	    gff_parent: 'Parent',
	    gff_target: 'Target',
	    gff_gap: 'Gap',
	    gff_derives_from: 'Derives_from',
	    gff_note: 'Note',
	    gff_dbxref: 'Dbxref',
	    gff_ontology_term: 'Ontology_term',
	    gff_is_circular: 'Is_circular'
	  };
	  function isGFFInternalAttribute(attribute) {
	    return attribute in exports.internalToGFF;
	  }
	  exports.gffColumnToInternal = {
	    score: 'gff_score',
	    source: 'gff_source'
	  };
	  function isGFFColumn(attribute) {
	    return attribute in exports.gffColumnToInternal;
	  }
	  exports.gffInternalToColumn = {
	    gff_score: 'score',
	    gff_source: 'source'
	  };
	  function isGFFColumnInternal(column) {
	    return column in exports.gffInternalToColumn;
	  }
	})(gffReservedKeys);

	var gff3ToAnnotationFeature$1 = {};

	Object.defineProperty(gff3ToAnnotationFeature$1, "__esModule", {
	  value: true
	});
	gff3ToAnnotationFeature$1.gff3ToAnnotationFeature = gff3ToAnnotationFeature;
	var tslib_1$3 = require$$0$1;
	var util_1$5 = require$$1__default$1["default"];
	var bson_objectid_1$1 = /*#__PURE__*/tslib_1$3.__importDefault(objectid);
	var gffReservedKeys_1 = gffReservedKeys;
	function gff3ToAnnotationFeature(gff3Feature, refSeq, featureIds) {
	  var _gff3Feature = _slicedToArray(gff3Feature, 1),
	    firstFeature = _gff3Feature[0];
	  var end = firstFeature.end,
	    refName = firstFeature.seq_id,
	    start = firstFeature.start,
	    strand = firstFeature.strand,
	    type = firstFeature.type;
	  if (!refName) {
	    throw new Error("feature does not have seq_id: ".concat(JSON.stringify(firstFeature)));
	  }
	  if (!type) {
	    throw new Error("feature does not have type: ".concat(JSON.stringify(firstFeature)));
	  }
	  if (start === null) {
	    throw new Error("feature does not have start: ".concat(JSON.stringify(firstFeature)));
	  }
	  if (end === null) {
	    throw new Error("feature does not have end: ".concat(JSON.stringify(firstFeature)));
	  }
	  var _getFeatureMinMax = getFeatureMinMax(gff3Feature),
	    _getFeatureMinMax2 = _slicedToArray(_getFeatureMinMax, 2),
	    min = _getFeatureMinMax2[0],
	    max = _getFeatureMinMax2[1];
	  var convertedChildren = convertChildren(gff3Feature, refSeq, featureIds);
	  var convertedAttributes = convertFeatureAttributes$1(gff3Feature);
	  var feature = {
	    _id: new bson_objectid_1$1["default"]().toHexString(),
	    refSeq: refSeq !== null && refSeq !== void 0 ? refSeq : refName,
	    type: type,
	    min: min,
	    max: max
	  };
	  if (strand) {
	    if (strand === '+') {
	      feature.strand = 1;
	    } else if (strand === '-') {
	      feature.strand = -1;
	    } else {
	      throw new Error("Unknown strand: \"".concat(strand, "\""));
	    }
	  }
	  if (convertedChildren) {
	    feature.children = convertedChildren;
	  }
	  if (convertedAttributes) {
	    feature.attributes = convertedAttributes;
	  }
	  if (featureIds) {
	    featureIds.push(feature._id);
	  }
	  return feature;
	}
	function getFeatureMinMax(gff3Feature) {
	  if (gff3Feature.length > 1 && !gff3Feature.every(function (f) {
	    return f.type === 'CDS';
	  })) {
	    throw new Error('GFF3 features has multiple locations but is not a CDS');
	  }
	  var mins = gff3Feature.map(function (f) {
	    return f.start;
	  }).filter(function (m) {
	    return m !== null;
	  });
	  var maxes = gff3Feature.map(function (f) {
	    return f.end;
	  }).filter(function (m) {
	    return m !== null;
	  });
	  var min = Math.min.apply(Math, _toConsumableArray(mins));
	  var max = Math.max.apply(Math, _toConsumableArray(maxes));
	  return [min - 1, max];
	}
	function convertFeatureAttributes$1(gff3Feature) {
	  var convertedAttributes = {};
	  var scores = gff3Feature.map(function (f) {
	    return f.score;
	  }).filter(function (score) {
	    return score !== null;
	  });
	  var sources = gff3Feature.map(function (f) {
	    return f.source;
	  }).filter(function (source) {
	    return source !== null;
	  });
	  var attributesCollections = gff3Feature.map(function (f) {
	    return f.attributes;
	  }).filter(function (attributes) {
	    return attributes !== null;
	  });
	  if (scores.length > 0) {
	    var _scores = _slicedToArray(scores, 1),
	      score = _scores[0];
	    if (scores.length > 1) {
	      var scoresSum = scores.reduce(function (accumulator, currentValue) {
	        return accumulator + currentValue;
	      }, 0);
	      // Average score
	      score = scoresSum / scores.length;
	    }
	    convertedAttributes.gff_score = [String(score)];
	  }
	  if (sources.length > 0) {
	    var _sources = _slicedToArray(sources, 1),
	      source = _sources[0];
	    if (sources.length > 1) {
	      var sourceSet = new Set(sources);
	      source = _toConsumableArray(sourceSet).join(',');
	    }
	    convertedAttributes.gff_source = [source];
	  }
	  if (attributesCollections.length > 0) {
	    var _iterator = _createForOfIteratorHelper(attributesCollections),
	      _step;
	    try {
	      for (_iterator.s(); !(_step = _iterator.n()).done;) {
	        var attributesCollection = _step.value;
	        for (var _i = 0, _Object$entries = Object.entries(attributesCollection); _i < _Object$entries.length; _i++) {
	          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
	            key = _Object$entries$_i[0],
	            val = _Object$entries$_i[1];
	          if (!val || key === 'Parent') {
	            continue;
	          }
	          var newKey = (0, gffReservedKeys_1.isGFFReservedAttribute)(key) ? gffReservedKeys_1.gffToInternal[key] : key;
	          var existingVal = convertedAttributes[newKey];
	          if (existingVal) {
	            // if (JSON.stringify(existingVal) === JSON.stringify(val)) {
	            //   continue
	            // }
	            var valSet = new Set([].concat(_toConsumableArray(existingVal), _toConsumableArray(val)));
	            convertedAttributes[newKey] = _toConsumableArray(valSet);
	          } else {
	            convertedAttributes[newKey] = val;
	          }
	        }
	      }
	    } catch (err) {
	      _iterator.e(err);
	    } finally {
	      _iterator.f();
	    }
	  }
	  if (Object.keys(convertedAttributes).length > 0) {
	    return convertedAttributes;
	  }
	  return;
	}
	function convertChildren(gff3Feature, refSeq, featureIds) {
	  var convertedChildren = {};
	  var locationsWithChildren = gff3Feature.filter(function (feature) {
	    return feature.child_features.length > 0;
	  });
	  if (locationsWithChildren.length > 1) {
	    throw new Error('Features with multiple locations may not have children');
	  }
	  if (locationsWithChildren.length === 0) {
	    return;
	  }
	  var _locationsWithChildre = _slicedToArray(locationsWithChildren, 1),
	    firstFeature = _locationsWithChildre[0];
	  var childFeatures = firstFeature.child_features;
	  var cdsFeatures = [];
	  var exonFeatures = [];
	  var utrFeatures = [];
	  var _iterator2 = _createForOfIteratorHelper(childFeatures),
	    _step2;
	  try {
	    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	      var childFeature = _step2.value;
	      var _childFeature = _slicedToArray(childFeature, 1),
	        firstChildFeatureLocation = _childFeature[0];
	      if (firstChildFeatureLocation.type === 'exon') {
	        exonFeatures.push(childFeature);
	      }
	      if (firstChildFeatureLocation.type === 'three_prime_UTR' || firstChildFeatureLocation.type === 'five_prime_UTR') {
	        utrFeatures.push(childFeature);
	      }
	      if (firstChildFeatureLocation.type === 'three_prime_UTR' || firstChildFeatureLocation.type === 'five_prime_UTR' || firstChildFeatureLocation.type === 'intron' || firstChildFeatureLocation.type === 'start_codon' || firstChildFeatureLocation.type === 'stop_codon') {
	        continue;
	      }
	      if (firstChildFeatureLocation.type === 'CDS') {
	        cdsFeatures.push(childFeature);
	      } else {
	        var child = gff3ToAnnotationFeature(childFeature, refSeq, featureIds);
	        convertedChildren[child._id] = child;
	      }
	    }
	  } catch (err) {
	    _iterator2.e(err);
	  } finally {
	    _iterator2.f();
	  }
	  if (cdsFeatures.length > 0) {
	    var processedCDS = processCDS(cdsFeatures, refSeq, featureIds);
	    var _iterator3 = _createForOfIteratorHelper(processedCDS),
	      _step3;
	    try {
	      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	        var cds = _step3.value;
	        convertedChildren[cds._id] = cds;
	      }
	    } catch (err) {
	      _iterator3.e(err);
	    } finally {
	      _iterator3.f();
	    }
	    var missingExons = inferMissingExons(cdsFeatures, exonFeatures, utrFeatures, processedCDS[0].refSeq, featureIds);
	    var _iterator4 = _createForOfIteratorHelper(missingExons),
	      _step4;
	    try {
	      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
	        var exon = _step4.value;
	        convertedChildren[exon._id] = exon;
	      }
	    } catch (err) {
	      _iterator4.e(err);
	    } finally {
	      _iterator4.f();
	    }
	  }
	  if (Object.keys(convertedChildren).length > 0) {
	    return convertedChildren;
	  }
	  return;
	}
	function inferMissingExons(cdsFeatures, existingExons, utrFeatures, refSeq, featureIds) {
	  // Convert utrFeatures from GFF3Feature to AnnotationFeatureSnapshot
	  var utrExons = [];
	  var _iterator5 = _createForOfIteratorHelper(utrFeatures),
	    _step5;
	  try {
	    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
	      var utrs = _step5.value;
	      var _iterator8 = _createForOfIteratorHelper(utrs),
	        _step8;
	      try {
	        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
	          var utr = _step8.value;
	          if (!utr.start || !utr.end) {
	            throw new Error("UTR has undefined start and/or end\n: ".concat(JSON.stringify(utr, null, 2)));
	          }
	          var strand = undefined;
	          if (utr.strand === '+') {
	            strand = 1;
	          } else if (utr.strand === '-') {
	            strand = -1;
	          }
	          utrExons.push({
	            _id: new bson_objectid_1$1["default"]().toHexString(),
	            refSeq: refSeq,
	            type: 'exon',
	            min: utr.start - 1,
	            max: utr.end,
	            strand: strand
	          });
	        }
	      } catch (err) {
	        _iterator8.e(err);
	      } finally {
	        _iterator8.f();
	      }
	    }
	  } catch (err) {
	    _iterator5.e(err);
	  } finally {
	    _iterator5.f();
	  }
	  utrExons.sort(function (a, b) {
	    return a.min - b.min;
	  });
	  var missingExons = [];
	  var _iterator6 = _createForOfIteratorHelper(cdsFeatures),
	    _step6;
	  try {
	    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
	      var protein = _step6.value;
	      protein.sort(function (a, b) {
	        if (!a.start || !b.start) {
	          throw new Error('CDS has undefined start');
	        }
	        return a.start - b.start;
	      });
	      for (var cdsIdx = 0; cdsIdx < protein.length; cdsIdx++) {
	        var cds = protein[cdsIdx];
	        // For CDS check if there is an exon containing it. If not, create an exon with same coords as the CDS.
	        var exonFound = false;
	        var _iterator9 = _createForOfIteratorHelper(existingExons),
	          _step9;
	        try {
	          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
	            var x = _step9.value;
	            if (x.length != 1) {
	              throw new Error('Unexpected number of exons');
	            }
	            var _x = _slicedToArray(x, 1),
	              _exon = _x[0];
	            if (_exon.start && _exon.end && cds.start && cds.end && _exon.start <= cds.start && _exon.end >= cds.end) {
	              exonFound = true;
	              break;
	            }
	          }
	        } catch (err) {
	          _iterator9.e(err);
	        } finally {
	          _iterator9.f();
	        }
	        if (!exonFound) {
	          if (!cds.start || !cds.end) {
	            throw new Error("CDS has undefined start and/or end: ".concat(JSON.stringify(cds, null, 2)));
	          }
	          var _strand = undefined;
	          if (cds.strand === '+') {
	            _strand = 1;
	          } else if (cds.strand === '-') {
	            _strand = -1;
	          }
	          var newExon = {
	            _id: new bson_objectid_1$1["default"]().toHexString(),
	            refSeq: refSeq,
	            type: 'exon',
	            min: cds.start - 1,
	            max: cds.end,
	            strand: _strand
	          };
	          if (cdsIdx === 0) {
	            // If this CDS is the leftmost (or the only CDS in this protein), check if we need to add UTRs before it
	            var _iterator10 = _createForOfIteratorHelper(utrExons),
	              _step10;
	            try {
	              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
	                var _utr = _step10.value;
	                if (_utr.max > newExon.min) {
	                  break;
	                }
	                if (_utr.max === newExon.min) {
	                  // UTR ends where exon begins: Extend the exon to include this UTR
	                  newExon.min = _utr.min;
	                } else {
	                  missingExons.push(_utr);
	                }
	              }
	            } catch (err) {
	              _iterator10.e(err);
	            } finally {
	              _iterator10.f();
	            }
	          }
	          if (cdsIdx === protein.length - 1) {
	            // If this CDS is the rightmost (or the only CDS in this protein), check if we need to add UTRs after it
	            var _iterator11 = _createForOfIteratorHelper(utrExons),
	              _step11;
	            try {
	              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
	                var _utr2 = _step11.value;
	                if (_utr2.min < newExon.max) {
	                  continue;
	                }
	                if (_utr2.min === newExon.max) {
	                  // UTR begins where exon end: Extend the exon to include this UTR
	                  newExon.max = _utr2.max;
	                } else {
	                  missingExons.push(_utr2);
	                }
	              }
	            } catch (err) {
	              _iterator11.e(err);
	            } finally {
	              _iterator11.f();
	            }
	          }
	          missingExons.push(newExon);
	        }
	      }
	    }
	  } catch (err) {
	    _iterator6.e(err);
	  } finally {
	    _iterator6.f();
	  }
	  var mergedExons = mergeAnnotationFeatures(missingExons);
	  if (featureIds) {
	    var _iterator7 = _createForOfIteratorHelper(mergedExons),
	      _step7;
	    try {
	      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
	        var exon = _step7.value;
	        if (!featureIds.includes(exon._id)) {
	          featureIds.push(exon._id);
	        }
	      }
	    } catch (err) {
	      _iterator7.e(err);
	    } finally {
	      _iterator7.f();
	    }
	  }
	  return mergedExons;
	}
	function mergeAnnotationFeatures(features) {
	  if (features.length === 0) {
	    return [];
	  }
	  features.sort(function (a, b) {
	    return a.min - b.min;
	  });
	  var res = [];
	  res.push(features[0]);
	  for (var i = 1; i < features.length; i++) {
	    var last = res.at(-1);
	    var curr = features[i];
	    // If current interval overlaps with the last merged interval, merge them
	    if (last && curr.min <= last.max) {
	      last.max = Math.max(last.max, curr.max);
	    } else {
	      res.push(curr);
	    }
	  }
	  return res;
	}
	/**
	 * If a GFF3 file has CDS features that either (1) don't have an ID or (2) have
	 * different IDs for each CDS, we have to do a bit of guessing about how they
	 * should be represented in our internal structure
	 * @param cdsFeatures -
	 */
	function processCDS(cdsFeatures, refSeq, featureIds) {
	  var locationCounts = cdsFeatures.map(function (cds) {
	    return cds.length;
	  });
	  // If any CDS have multiple locations, assume it really is multiple CDS
	  // (e.g. the mRNA has multiple alternative translational start sites)
	  // and process normally.
	  if (locationCounts.some(function (count) {
	    return count > 1;
	  })) {
	    return cdsFeatures.map(function (cds) {
	      return gff3ToAnnotationFeature(cds, refSeq, featureIds);
	    });
	  }
	  // If all CDS have a single location, we guess that this GFF3 represented CDS
	  // as multiple features instead of a single feature with multiple locations.
	  // To figure out if it's actually representing one vs. multiple CDS features,
	  // first check to see if any of the CDS overlap
	  var sortedCDSLocations = cdsFeatures.map(function (cds) {
	    return cds[0];
	  }).filter(function (cds) {
	    return cds.start !== null && cds.end !== null;
	  })
	  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	  .sort(function (cdsA, cdsB) {
	    return cdsA.start - cdsB.start;
	  });
	  var overlapping = sortedCDSLocations.some(function (loc, idx) {
	    var nextLoc = sortedCDSLocations.at(idx + 1);
	    if (!nextLoc) {
	      return false;
	    }
	    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	    return (0, util_1$5.doesIntersect2)(loc.start, loc.end, nextLoc.start, nextLoc.end);
	  });
	  // If no overlaps, assume it's a single CDS feature
	  if (!overlapping) {
	    return [gff3ToAnnotationFeature(sortedCDSLocations, refSeq, featureIds)];
	  }
	  // Some CDS locations overlap, the best we can do is use the original order to
	  // guess how to group the locations into features
	  var cdsLocations = cdsFeatures.map(function (cds) {
	    return cds[0];
	  });
	  var groupedLocations = [];
	  var _iterator12 = _createForOfIteratorHelper(cdsLocations),
	    _step12;
	  try {
	    var _loop = function _loop() {
	      var location = _step12.value;
	      var lastGroup = groupedLocations.at(-1);
	      if (!lastGroup) {
	        groupedLocations.push([location]);
	        return 1; // continue
	      }
	      var overlaps = lastGroup.some(function (lastGroupLoc) {
	        return (0, util_1$5.doesIntersect2)( /* eslint-disable @typescript-eslint/no-non-null-assertion */
	        lastGroupLoc.start, lastGroupLoc.end, location.start, location.end);
	      });
	      if (overlaps) {
	        groupedLocations.push([location]);
	      } else {
	        lastGroup.push(location);
	      }
	    };
	    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
	      if (_loop()) continue;
	    }
	  } catch (err) {
	    _iterator12.e(err);
	  } finally {
	    _iterator12.f();
	  }
	  return groupedLocations.map(function (group) {
	    return gff3ToAnnotationFeature(group, refSeq, featureIds);
	  });
	}

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var tslib_1 = require$$0$1;
	  tslib_1.__exportStar(annotationFeatureToGFF3$1, exports);
	  tslib_1.__exportStar(gffReservedKeys, exports);
	  tslib_1.__exportStar(gff3ToAnnotationFeature$1, exports);
	})(GFF3);

	Object.defineProperty(FromFileBaseChange$1, "__esModule", {
	  value: true
	});
	FromFileBaseChange$1.FromFileBaseChange = void 0;
	/* eslint-disable @typescript-eslint/restrict-plus-operands */
	/* eslint-disable @typescript-eslint/no-unsafe-assignment */
	/* eslint-disable @typescript-eslint/no-unsafe-member-access */
	/* eslint-disable @typescript-eslint/no-unsafe-call */
	/* eslint-disable @typescript-eslint/no-unsafe-argument */
	var common_1$m = dist$1;
	var GFF3_1 = GFF3;
	var FromFileBaseChange = /*#__PURE__*/function (_common_1$AssemblySpe) {
	  _inherits(FromFileBaseChange, _common_1$AssemblySpe);
	  var _super = /*#__PURE__*/_createSuper(FromFileBaseChange);
	  function FromFileBaseChange() {
	    var _this;
	    _classCallCheck(this, FromFileBaseChange);
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    _this = _super.call.apply(_super, [this].concat(args));
	    _defineProperty(_assertThisInitialized(_this), "refSeqCache", new Map());
	    return _this;
	  }
	  _createClass(FromFileBaseChange, [{
	    key: "addRefSeqIntoDb",
	    value: function () {
	      var _addRefSeqIntoDb = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(fileDoc, assembly, backend) {
	        var _logger$debug;
	        var logger, filesService, refSeqChunkModel, refSeqModel, user, CHUNK_SIZE, customChunkSize, chunkIndex, refSeqLen, refSeqDoc, fastaInfoStarted, sequenceStream, sequenceBuffer, incompleteLine, lastLineIsIncomplete, parsingStarted, lineCount, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, data, chunk, lines, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, line, _logger$debug2, refSeqInfoLine, _logger$debug3, _refSeqDoc, _logger$debug4, name, description, _yield$refSeqModel$cr, _yield$refSeqModel$cr2, newRefSeqDoc, _refSeqDoc2, _id, chunkSize, sequence, _logger$verbose, _logger$debug5;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              logger = this.logger;
	              filesService = backend.filesService, refSeqChunkModel = backend.refSeqChunkModel, refSeqModel = backend.refSeqModel, user = backend.user;
	              CHUNK_SIZE = process$1.env.CHUNK_SIZE;
	              customChunkSize = CHUNK_SIZE && Number(CHUNK_SIZE);
	              chunkIndex = 0;
	              refSeqLen = 0;
	              fastaInfoStarted = fileDoc.type !== 'text/x-gff3'; // Read data from compressed file and parse the content
	              sequenceStream = filesService.getFileStream(fileDoc);
	              sequenceBuffer = '';
	              incompleteLine = '';
	              lastLineIsIncomplete = true;
	              parsingStarted = false;
	              (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, 'starting sequence stream');
	              lineCount = 0;
	              _iteratorAbruptCompletion = false;
	              _didIteratorError = false;
	              _context.prev = 16;
	              _iterator = _asyncIterator(sequenceStream);
	            case 18:
	              _context.next = 20;
	              return _iterator.next();
	            case 20:
	              if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {
	                _context.next = 102;
	                break;
	              }
	              data = _step.value;
	              chunk = data.toString();
	              lastLineIsIncomplete = !chunk.endsWith('\n');
	              // chunk is small enough that you can split the whole thing into lines without having to make it into smaller chunks first.
	              lines = chunk.split(/\r?\n/);
	              if (incompleteLine) {
	                lines[0] = "".concat(incompleteLine).concat(lines[0]);
	                incompleteLine = '';
	              }
	              if (lastLineIsIncomplete) {
	                incompleteLine = lines.pop() || '';
	              }
	              _iteratorAbruptCompletion2 = false;
	              _didIteratorError2 = false;
	              _context.prev = 29;
	              _iterator2 = _asyncIterator(lines);
	            case 31:
	              _context.next = 33;
	              return _iterator2.next();
	            case 33:
	              if (!(_iteratorAbruptCompletion2 = !(_step2 = _context.sent).done)) {
	                _context.next = 83;
	                break;
	              }
	              line = _step2.value;
	              lineCount++;
	              if (lineCount % 1000000 === 0) {
	                (_logger$debug2 = logger.debug) === null || _logger$debug2 === void 0 || _logger$debug2.call(logger, "Processed ".concat(lineCount, " lines"));
	              }
	              // In case of GFF3 file we start to read sequence after '##FASTA' is found
	              if (fastaInfoStarted) {
	                _context.next = 40;
	                break;
	              }
	              if (line.trim() === '##FASTA') {
	                fastaInfoStarted = true;
	              }
	              return _context.abrupt("continue", 80);
	            case 40:
	              refSeqInfoLine = /^>\s*(\S+)\s*(.*)/.exec(line); // Add new ref sequence info if we are reference seq info line
	              if (!refSeqInfoLine) {
	                _context.next = 66;
	                break;
	              }
	              parsingStarted = true;
	              (_logger$debug3 = logger.debug) === null || _logger$debug3 === void 0 || _logger$debug3.call(logger, "Reference sequence information line \"".concat(refSeqInfoLine[0], "\""));
	              // If there is sequence from previous reference sequence then we need to add it to previous ref seq
	              if (!(sequenceBuffer !== '')) {
	                _context.next = 51;
	                break;
	              }
	              if (refSeqDoc) {
	                _context.next = 47;
	                break;
	              }
	              throw new Error('No refSeq document found');
	            case 47:
	              refSeqLen += sequenceBuffer.length;
	              // We cannot use Mongo 'session' / transaction here because Mongo has 16 MB limit for transaction
	              _context.next = 50;
	              return refSeqChunkModel.create([{
	                refSeq: refSeqDoc._id,
	                n: chunkIndex,
	                sequence: sequenceBuffer,
	                user: user,
	                status: -1
	              }]);
	            case 50:
	              sequenceBuffer = '';
	            case 51:
	              _context.next = 53;
	              return (_refSeqDoc = refSeqDoc) === null || _refSeqDoc === void 0 ? void 0 : _refSeqDoc.updateOne({
	                length: refSeqLen
	              });
	            case 53:
	              // await refSeqDoc?.updateOne({ length: refSeqLen }, { session })
	              refSeqLen = 0;
	              chunkIndex = 0;
	              name = refSeqInfoLine[1].trim();
	              description = refSeqInfoLine[2] ? refSeqInfoLine[2].trim() : ''; // We cannot use Mongo 'session' / transaction here because Mongo has 16 MB limit for transaction
	              _context.next = 59;
	              return refSeqModel.create([_objectSpread2(_objectSpread2({
	                name: name,
	                description: description,
	                assembly: assembly,
	                length: 0
	              }, customChunkSize ? {
	                chunkSize: customChunkSize
	              } : null), {}, {
	                user: user,
	                status: -1
	              })]);
	            case 59:
	              _yield$refSeqModel$cr = _context.sent;
	              _yield$refSeqModel$cr2 = _slicedToArray(_yield$refSeqModel$cr, 1);
	              newRefSeqDoc = _yield$refSeqModel$cr2[0];
	              (_logger$debug4 = logger.debug) === null || _logger$debug4 === void 0 || _logger$debug4.call(logger, "Added new refSeq \"".concat(name, "\", desc \"").concat(description, "\", docId \"").concat(newRefSeqDoc._id, "\""));
	              refSeqDoc = newRefSeqDoc;
	              _context.next = 80;
	              break;
	            case 66:
	              if (!/\S/.test(line)) {
	                _context.next = 80;
	                break;
	              }
	              if (refSeqDoc) {
	                _context.next = 69;
	                break;
	              }
	              throw new Error('No refSeq document found');
	            case 69:
	              _refSeqDoc2 = refSeqDoc, _id = _refSeqDoc2._id, chunkSize = _refSeqDoc2.chunkSize;
	              sequenceBuffer += line.replaceAll(/\s/g, '');
	              // If sequence block > chunk size then save chunk into Mongo
	            case 71:
	              if (!(sequenceBuffer.length >= chunkSize)) {
	                _context.next = 80;
	                break;
	              }
	              sequence = sequenceBuffer.slice(0, chunkSize);
	              refSeqLen += sequence.length;
	              // We cannot use Mongo 'session' / transaction here because Mongo has 16 MB limit for transaction
	              _context.next = 76;
	              return refSeqChunkModel.create([{
	                refSeq: _id,
	                n: chunkIndex,
	                sequence: sequence,
	                user: user,
	                status: -1
	              }]);
	            case 76:
	              chunkIndex++;
	              // Set remaining sequence
	              sequenceBuffer = sequenceBuffer.slice(chunkSize);
	              _context.next = 71;
	              break;
	            case 80:
	              _iteratorAbruptCompletion2 = false;
	              _context.next = 31;
	              break;
	            case 83:
	              _context.next = 89;
	              break;
	            case 85:
	              _context.prev = 85;
	              _context.t0 = _context["catch"](29);
	              _didIteratorError2 = true;
	              _iteratorError2 = _context.t0;
	            case 89:
	              _context.prev = 89;
	              _context.prev = 90;
	              if (!(_iteratorAbruptCompletion2 && _iterator2["return"] != null)) {
	                _context.next = 94;
	                break;
	              }
	              _context.next = 94;
	              return _iterator2["return"]();
	            case 94:
	              _context.prev = 94;
	              if (!_didIteratorError2) {
	                _context.next = 97;
	                break;
	              }
	              throw _iteratorError2;
	            case 97:
	              return _context.finish(94);
	            case 98:
	              return _context.finish(89);
	            case 99:
	              _iteratorAbruptCompletion = false;
	              _context.next = 18;
	              break;
	            case 102:
	              _context.next = 108;
	              break;
	            case 104:
	              _context.prev = 104;
	              _context.t1 = _context["catch"](16);
	              _didIteratorError = true;
	              _iteratorError = _context.t1;
	            case 108:
	              _context.prev = 108;
	              _context.prev = 109;
	              if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
	                _context.next = 113;
	                break;
	              }
	              _context.next = 113;
	              return _iterator["return"]();
	            case 113:
	              _context.prev = 113;
	              if (!_didIteratorError) {
	                _context.next = 116;
	                break;
	              }
	              throw _iteratorError;
	            case 116:
	              return _context.finish(113);
	            case 117:
	              return _context.finish(108);
	            case 118:
	              if (parsingStarted) {
	                _context.next = 120;
	                break;
	              }
	              throw new Error('No reference sequences found in file');
	            case 120:
	              if (!(sequenceBuffer || lastLineIsIncomplete)) {
	                _context.next = 131;
	                break;
	              }
	              if (refSeqDoc) {
	                _context.next = 123;
	                break;
	              }
	              throw new Error('No refSeq document found');
	            case 123:
	              // If the file did not end with line break so the last line is incomplete
	              if (lastLineIsIncomplete) {
	                sequenceBuffer += incompleteLine;
	              }
	              refSeqLen += sequenceBuffer.length;
	              (_logger$verbose = logger.verbose) === null || _logger$verbose === void 0 || _logger$verbose.call(logger, "*** Add the very last chunk to ref seq (\"".concat(refSeqDoc._id, "\", index ").concat(chunkIndex, " and total length for ref seq is ").concat(refSeqLen, "): \"").concat(sequenceBuffer, "\""));
	              (_logger$debug5 = logger.debug) === null || _logger$debug5 === void 0 || _logger$debug5.call(logger, "Creating refSeq chunk number ".concat(chunkIndex, " of \"").concat(refSeqDoc._id, "\""));
	              // We cannot use Mongo 'session' / transaction here because Mongo has 16 MB limit for transaction
	              _context.next = 129;
	              return refSeqChunkModel.create([{
	                refSeq: refSeqDoc._id,
	                n: chunkIndex,
	                sequence: sequenceBuffer,
	                user: user,
	                status: -1
	              }]);
	            case 129:
	              _context.next = 131;
	              return refSeqDoc.updateOne({
	                length: refSeqLen
	              });
	            case 131:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this, [[16, 104, 108, 118], [29, 85, 89, 99], [90,, 94, 98], [109,, 113, 117]]);
	      }));
	      function addRefSeqIntoDb(_x, _x2, _x3) {
	        return _addRefSeqIntoDb.apply(this, arguments);
	      }
	      return addRefSeqIntoDb;
	    }()
	  }, {
	    key: "removeExistingFeatures",
	    value: function () {
	      var _removeExistingFeatures = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(backend) {
	        var _logger$debug6;
	        var featureModel, refSeqModel, assembly, logger, refSeqs, _iterator3, _step3, refSeq;
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              featureModel = backend.featureModel, refSeqModel = backend.refSeqModel;
	              assembly = this.assembly, logger = this.logger;
	              (_logger$debug6 = logger.debug) === null || _logger$debug6 === void 0 || _logger$debug6.call(logger, "Removing existing features for assembly = ".concat(assembly));
	              _context2.next = 5;
	              return refSeqModel.find({
	                assembly: assembly
	              }).exec();
	            case 5:
	              refSeqs = _context2.sent;
	              _iterator3 = _createForOfIteratorHelper(refSeqs);
	              _context2.prev = 7;
	              _iterator3.s();
	            case 9:
	              if ((_step3 = _iterator3.n()).done) {
	                _context2.next = 15;
	                break;
	              }
	              refSeq = _step3.value;
	              _context2.next = 13;
	              return featureModel.deleteMany({
	                refSeq: refSeq._id
	              });
	            case 13:
	              _context2.next = 9;
	              break;
	            case 15:
	              _context2.next = 20;
	              break;
	            case 17:
	              _context2.prev = 17;
	              _context2.t0 = _context2["catch"](7);
	              _iterator3.e(_context2.t0);
	            case 20:
	              _context2.prev = 20;
	              _iterator3.f();
	              return _context2.finish(20);
	            case 23:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2, this, [[7, 17, 20, 23]]);
	      }));
	      function removeExistingFeatures(_x4) {
	        return _removeExistingFeatures.apply(this, arguments);
	      }
	      return removeExistingFeatures;
	    }()
	  }, {
	    key: "addFeatureIntoDb",
	    value: function () {
	      var _addFeatureIntoDb = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(gff3Feature, backend) {
	        var featureModel, refSeqModel, user, assembly, refSeqCache, _gff3Feature, refName, refSeqDoc, _yield$refSeqModel$fi, featureIds, newFeature;
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              featureModel = backend.featureModel, refSeqModel = backend.refSeqModel, user = backend.user;
	              assembly = this.assembly, refSeqCache = this.refSeqCache;
	              _gff3Feature = _slicedToArray(gff3Feature, 1), refName = _gff3Feature[0].seq_id;
	              if (refName) {
	                _context3.next = 5;
	                break;
	              }
	              throw new Error("Valid seq_id not found in feature ".concat(JSON.stringify(gff3Feature)));
	            case 5:
	              refSeqDoc = refSeqCache.get(refName);
	              if (refSeqDoc) {
	                _context3.next = 20;
	                break;
	              }
	              _context3.next = 9;
	              return refSeqModel.findOne({
	                assembly: assembly,
	                name: refName
	              }).exec();
	            case 9:
	              _context3.t1 = _yield$refSeqModel$fi = _context3.sent;
	              _context3.t0 = _context3.t1 !== null;
	              if (!_context3.t0) {
	                _context3.next = 13;
	                break;
	              }
	              _context3.t0 = _yield$refSeqModel$fi !== void 0;
	            case 13:
	              if (!_context3.t0) {
	                _context3.next = 17;
	                break;
	              }
	              _context3.t2 = _yield$refSeqModel$fi;
	              _context3.next = 18;
	              break;
	            case 17:
	              _context3.t2 = undefined;
	            case 18:
	              refSeqDoc = _context3.t2;
	              if (refSeqDoc) {
	                refSeqCache.set(refName, refSeqDoc);
	              }
	            case 20:
	              if (refSeqDoc) {
	                _context3.next = 22;
	                break;
	              }
	              throw new Error("RefSeq was not found by assembly \"".concat(assembly, "\" and seq_id \"").concat(refName, "\" not found"));
	            case 22:
	              // Let's add featureId to parent feature
	              featureIds = [];
	              newFeature = (0, GFF3_1.gff3ToAnnotationFeature)(gff3Feature, refSeqDoc._id, featureIds); // Add into Mongo
	              // We cannot use Mongo 'session' / transaction here because Mongo has 16 MB limit for transaction
	              _context3.next = 26;
	              return featureModel.create([_objectSpread2(_objectSpread2({
	                allIds: featureIds
	              }, newFeature), {}, {
	                user: user,
	                status: -1
	              })]);
	            case 26:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this);
	      }));
	      function addFeatureIntoDb(_x5, _x6) {
	        return _addFeatureIntoDb.apply(this, arguments);
	      }
	      return addFeatureIntoDb;
	    }()
	  }]);
	  return FromFileBaseChange;
	}(common_1$m.AssemblySpecificChange);
	FromFileBaseChange$1.FromFileBaseChange = FromFileBaseChange;

	/* eslint-disable @typescript-eslint/require-await */
	Object.defineProperty(AddAssemblyAndFeaturesFromFileChange$1, "__esModule", {
	  value: true
	});
	AddAssemblyAndFeaturesFromFileChange$1.AddAssemblyAndFeaturesFromFileChange = void 0;
	var FromFileBaseChange_1$2 = FromFileBaseChange$1;
	var AddAssemblyAndFeaturesFromFileChange = /*#__PURE__*/function (_FromFileBaseChange_) {
	  _inherits(AddAssemblyAndFeaturesFromFileChange, _FromFileBaseChange_);
	  var _super = /*#__PURE__*/_createSuper(AddAssemblyAndFeaturesFromFileChange);
	  function AddAssemblyAndFeaturesFromFileChange(json, options) {
	    var _this;
	    _classCallCheck(this, AddAssemblyAndFeaturesFromFileChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'AddAssemblyAndFeaturesFromFileChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    return _this;
	  }
	  _createClass(AddAssemblyAndFeaturesFromFileChange, [{
	    key: "notification",
	    get: function get() {
	      return "Assembly \"".concat(this.changes[0].assemblyName, "\" added successfully. To use it, please refresh the page.");
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        changes = this.changes,
	        typeName = this.typeName;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          _changes$ = _changes[0],
	          assemblyName = _changes$.assemblyName,
	          fileIds = _changes$.fileIds;
	        return {
	          typeName: typeName,
	          assembly: assembly,
	          assemblyName: assemblyName,
	          fileIds: fileIds
	        };
	      }
	      return {
	        typeName: typeName,
	        assembly: assembly,
	        changes: changes
	      };
	    }
	    /**
	     * Applies the required change to database
	     * @param backend - parameters from backend
	     * @returns
	     */
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var assemblyModel, checkModel, fileModel, filesService, user, assembly, changes, logger, _iterator2, _step2, _logger$debug, _logger$debug2, _logger$debug3, _logger$debug4, change, assemblyName, fileIds, fileId, FILE_UPLOAD_FOLDER, fileDoc, assemblyDoc, checkDocs, checks, _yield$assemblyModel$, _yield$assemblyModel$2, newAssemblyDoc, featureStream, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, f, _logger$verbose, gff3Feature;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              assemblyModel = backend.assemblyModel, checkModel = backend.checkModel, fileModel = backend.fileModel, filesService = backend.filesService, user = backend.user;
	              assembly = this.assembly, changes = this.changes, logger = this.logger;
	              _iterator2 = _createForOfIteratorHelper(changes);
	              _context.prev = 3;
	              _iterator2.s();
	            case 5:
	              if ((_step2 = _iterator2.n()).done) {
	                _context.next = 71;
	                break;
	              }
	              change = _step2.value;
	              assemblyName = change.assemblyName, fileIds = change.fileIds;
	              fileId = fileIds.fa;
	              FILE_UPLOAD_FOLDER = process$1.env.FILE_UPLOAD_FOLDER;
	              if (FILE_UPLOAD_FOLDER) {
	                _context.next = 12;
	                break;
	              }
	              throw new Error('No FILE_UPLOAD_FOLDER found in .env file');
	            case 12:
	              _context.next = 14;
	              return fileModel.findById(fileId).exec();
	            case 14:
	              fileDoc = _context.sent;
	              if (fileDoc) {
	                _context.next = 17;
	                break;
	              }
	              throw new Error("File \"".concat(fileId, "\" not found in Mongo"));
	            case 17:
	              (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, "FileId \"".concat(fileId, "\", checksum \"").concat(fileDoc.checksum, "\""));
	              // Check and add new assembly
	              _context.next = 20;
	              return assemblyModel.findOne({
	                name: assemblyName
	              }).exec();
	            case 20:
	              assemblyDoc = _context.sent;
	              if (!assemblyDoc) {
	                _context.next = 23;
	                break;
	              }
	              throw new Error("Assembly \"".concat(assemblyName, "\" already exists"));
	            case 23:
	              _context.next = 25;
	              return checkModel.find({
	                "default": true
	              }).exec();
	            case 25:
	              checkDocs = _context.sent;
	              checks = checkDocs.map(function (checkDoc) {
	                return checkDoc._id.toHexString();
	              }); // Add assembly
	              _context.next = 29;
	              return assemblyModel.create([{
	                _id: assembly,
	                name: assemblyName,
	                user: user,
	                status: -1,
	                fileId: fileId,
	                checks: checks
	              }]);
	            case 29:
	              _yield$assemblyModel$ = _context.sent;
	              _yield$assemblyModel$2 = _slicedToArray(_yield$assemblyModel$, 1);
	              newAssemblyDoc = _yield$assemblyModel$2[0];
	              (_logger$debug2 = logger.debug) === null || _logger$debug2 === void 0 || _logger$debug2.call(logger, "Added new assembly \"".concat(assemblyName, "\", docId \"").concat(newAssemblyDoc._id.toHexString(), "\""));
	              (_logger$debug3 = logger.debug) === null || _logger$debug3 === void 0 || _logger$debug3.call(logger, "File type: \"".concat(fileDoc.type, "\""));
	              // Add refSeqs
	              // We cannot use Mongo 'session' / transaction here because Mongo has 16 MB limit for transaction
	              _context.next = 36;
	              return this.addRefSeqIntoDb(fileDoc, newAssemblyDoc._id.toString(), backend);
	            case 36:
	              // Loop all features
	              (_logger$debug4 = logger.debug) === null || _logger$debug4 === void 0 || _logger$debug4.call(logger, "**************** LOOPATAAN KAIKKI FEATURET SEURAAVAKSI File type: \"".concat(fileDoc.type, "\""));
	              featureStream = filesService.parseGFF3(filesService.getFileStream(fileDoc));
	              _iteratorAbruptCompletion = false;
	              _didIteratorError = false;
	              _context.prev = 40;
	              _iterator = _asyncIterator(featureStream);
	            case 42:
	              _context.next = 44;
	              return _iterator.next();
	            case 44:
	              if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {
	                _context.next = 53;
	                break;
	              }
	              f = _step.value;
	              gff3Feature = f;
	              (_logger$verbose = logger.verbose) === null || _logger$verbose === void 0 || _logger$verbose.call(logger, "ENTRY=".concat(JSON.stringify(gff3Feature)));
	              // Add new feature into database
	              _context.next = 50;
	              return this.addFeatureIntoDb(gff3Feature, backend);
	            case 50:
	              _iteratorAbruptCompletion = false;
	              _context.next = 42;
	              break;
	            case 53:
	              _context.next = 59;
	              break;
	            case 55:
	              _context.prev = 55;
	              _context.t0 = _context["catch"](40);
	              _didIteratorError = true;
	              _iteratorError = _context.t0;
	            case 59:
	              _context.prev = 59;
	              _context.prev = 60;
	              if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
	                _context.next = 64;
	                break;
	              }
	              _context.next = 64;
	              return _iterator["return"]();
	            case 64:
	              _context.prev = 64;
	              if (!_didIteratorError) {
	                _context.next = 67;
	                break;
	              }
	              throw _iteratorError;
	            case 67:
	              return _context.finish(64);
	            case 68:
	              return _context.finish(59);
	            case 69:
	              _context.next = 5;
	              break;
	            case 71:
	              _context.next = 76;
	              break;
	            case 73:
	              _context.prev = 73;
	              _context.t1 = _context["catch"](3);
	              _iterator2.e(_context.t1);
	            case 76:
	              _context.prev = 76;
	              _iterator2.f();
	              return _context.finish(76);
	            case 79:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this, [[3, 73, 76, 79], [40, 55, 59, 69], [60,, 64, 68]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }() // eslint-disable-next-line @typescript-eslint/no-empty-function
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_dataStore) {
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var assembly = this.assembly,
	        changes = this.changes,
	        logger = this.logger,
	        typeName = this.typeName;
	      return new AddAssemblyAndFeaturesFromFileChange({
	        typeName: typeName,
	        changes: changes,
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return AddAssemblyAndFeaturesFromFileChange;
	}(FromFileBaseChange_1$2.FromFileBaseChange);
	AddAssemblyAndFeaturesFromFileChange$1.AddAssemblyAndFeaturesFromFileChange = AddAssemblyAndFeaturesFromFileChange;

	var AddAssemblyFromExternalChange$1 = {};

	var LocalFile = {};

	var RemoteFile = /*#__PURE__*/function () {
	  function RemoteFile(source) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    _classCallCheck(this, RemoteFile);
	    this.baseOverrides = {};
	    this.url = source;
	    var fetch = opts.fetch || globalThis.fetch.bind(globalThis);
	    if (!fetch) {
	      throw new TypeError("no fetch function supplied, and none found in global environment");
	    }
	    if (opts.overrides) {
	      this.baseOverrides = opts.overrides;
	    }
	    this.fetchImplementation = fetch;
	  }
	  _createClass(RemoteFile, [{
	    key: "getBufferFromResponse",
	    value: function () {
	      var _getBufferFromResponse = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(response) {
	        var resp;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              if (!(typeof response.buffer === 'function')) {
	                _context.next = 4;
	                break;
	              }
	              return _context.abrupt("return", response.buffer());
	            case 4:
	              if (!(typeof response.arrayBuffer === 'function')) {
	                _context.next = 11;
	                break;
	              }
	              _context.next = 7;
	              return response.arrayBuffer();
	            case 7:
	              resp = _context.sent;
	              return _context.abrupt("return", Buffer.from(resp));
	            case 11:
	              throw new TypeError('invalid HTTP response object, has no buffer method, and no arrayBuffer method');
	            case 12:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee);
	      }));
	      function getBufferFromResponse(_x) {
	        return _getBufferFromResponse.apply(this, arguments);
	      }
	      return getBufferFromResponse;
	    }()
	  }, {
	    key: "fetch",
	    value: function () {
	      var _fetch = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(input, init) {
	        var response;
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              _context2.prev = 0;
	              _context2.next = 3;
	              return this.fetchImplementation(input, init);
	            case 3:
	              response = _context2.sent;
	              _context2.next = 16;
	              break;
	            case 6:
	              _context2.prev = 6;
	              _context2.t0 = _context2["catch"](0);
	              if (!"".concat(_context2.t0).includes('Failed to fetch')) {
	                _context2.next = 15;
	                break;
	              }
	              // refetch to to help work around a chrome bug (discussed in
	              // generic-filehandle issue #72) in which the chrome cache returns a
	              // CORS error for content in its cache.  see also
	              // https://github.com/GMOD/jbrowse-components/pull/1511
	              console.warn("generic-filehandle: refetching ".concat(input, " to attempt to work around chrome CORS header caching bug"));
	              _context2.next = 12;
	              return this.fetchImplementation(input, _objectSpread2(_objectSpread2({}, init), {}, {
	                cache: 'reload'
	              }));
	            case 12:
	              response = _context2.sent;
	              _context2.next = 16;
	              break;
	            case 15:
	              throw _context2.t0;
	            case 16:
	              return _context2.abrupt("return", response);
	            case 17:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2, this, [[0, 6]]);
	      }));
	      function fetch(_x2, _x3) {
	        return _fetch.apply(this, arguments);
	      }
	      return fetch;
	    }()
	  }, {
	    key: "read",
	    value: function () {
	      var _read = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(buffer) {
	        var offset,
	          length,
	          position,
	          opts,
	          _opts$headers,
	          headers,
	          signal,
	          _opts$overrides,
	          overrides,
	          args,
	          response,
	          responseData,
	          bytesCopied,
	          res,
	          sizeMatch,
	          _args3 = arguments;
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              offset = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 0;
	              length = _args3.length > 2 ? _args3[2] : undefined;
	              position = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : 0;
	              opts = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : {};
	              _opts$headers = opts.headers, headers = _opts$headers === void 0 ? {} : _opts$headers, signal = opts.signal, _opts$overrides = opts.overrides, overrides = _opts$overrides === void 0 ? {} : _opts$overrides;
	              if (length < Infinity) {
	                headers.range = "bytes=".concat(position, "-").concat(position + length);
	              } else if (length === Infinity && position !== 0) {
	                headers.range = "bytes=".concat(position, "-");
	              }
	              args = _objectSpread2(_objectSpread2(_objectSpread2({}, this.baseOverrides), overrides), {}, {
	                headers: _objectSpread2(_objectSpread2(_objectSpread2({}, headers), overrides.headers), this.baseOverrides.headers),
	                method: 'GET',
	                redirect: 'follow',
	                mode: 'cors',
	                signal: signal
	              });
	              _context3.next = 9;
	              return this.fetch(this.url, args);
	            case 9:
	              response = _context3.sent;
	              if (response.ok) {
	                _context3.next = 12;
	                break;
	              }
	              throw new Error("HTTP ".concat(response.status, " ").concat(response.statusText, " ").concat(this.url));
	            case 12:
	              if (!(response.status === 200 && position === 0 || response.status === 206)) {
	                _context3.next = 21;
	                break;
	              }
	              _context3.next = 15;
	              return this.getBufferFromResponse(response);
	            case 15:
	              responseData = _context3.sent;
	              bytesCopied = responseData.copy(buffer, offset, 0, Math.min(length, responseData.length)); // try to parse out the size of the remote file
	              res = response.headers.get('content-range');
	              sizeMatch = /\/(\d+)$/.exec(res || '');
	              if (sizeMatch && sizeMatch[1]) {
	                this._stat = {
	                  size: parseInt(sizeMatch[1], 10)
	                };
	              }
	              return _context3.abrupt("return", {
	                bytesRead: bytesCopied,
	                buffer: buffer
	              });
	            case 21:
	              if (!(response.status === 200)) {
	                _context3.next = 23;
	                break;
	              }
	              throw new Error('${this.url} fetch returned status 200, expected 206');
	            case 23:
	              throw new Error("HTTP ".concat(response.status, " fetching ").concat(this.url));
	            case 24:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this);
	      }));
	      function read(_x4) {
	        return _read.apply(this, arguments);
	      }
	      return read;
	    }()
	  }, {
	    key: "readFile",
	    value: function () {
	      var _readFile = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
	        var options,
	          encoding,
	          opts,
	          _opts,
	          _opts$headers2,
	          headers,
	          signal,
	          _opts$overrides2,
	          overrides,
	          args,
	          response,
	          _args4 = arguments;
	        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
	          while (1) switch (_context4.prev = _context4.next) {
	            case 0:
	              options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};
	              if (typeof options === 'string') {
	                encoding = options;
	                opts = {};
	              } else {
	                encoding = options.encoding;
	                opts = options;
	                delete opts.encoding;
	              }
	              _opts = opts, _opts$headers2 = _opts.headers, headers = _opts$headers2 === void 0 ? {} : _opts$headers2, signal = _opts.signal, _opts$overrides2 = _opts.overrides, overrides = _opts$overrides2 === void 0 ? {} : _opts$overrides2;
	              args = _objectSpread2(_objectSpread2({
	                headers: headers,
	                method: 'GET',
	                redirect: 'follow',
	                mode: 'cors',
	                signal: signal
	              }, this.baseOverrides), overrides);
	              _context4.next = 6;
	              return this.fetch(this.url, args);
	            case 6:
	              response = _context4.sent;
	              if (response) {
	                _context4.next = 9;
	                break;
	              }
	              throw new Error('generic-filehandle failed to fetch');
	            case 9:
	              if (!(response.status !== 200)) {
	                _context4.next = 11;
	                break;
	              }
	              throw Object.assign(new Error("HTTP ".concat(response.status, " fetching ").concat(this.url)), {
	                status: response.status
	              });
	            case 11:
	              if (!(encoding === 'utf8')) {
	                _context4.next = 13;
	                break;
	              }
	              return _context4.abrupt("return", response.text());
	            case 13:
	              if (!encoding) {
	                _context4.next = 15;
	                break;
	              }
	              throw new Error("unsupported encoding: ".concat(encoding));
	            case 15:
	              return _context4.abrupt("return", this.getBufferFromResponse(response));
	            case 16:
	            case "end":
	              return _context4.stop();
	          }
	        }, _callee4, this);
	      }));
	      function readFile() {
	        return _readFile.apply(this, arguments);
	      }
	      return readFile;
	    }()
	  }, {
	    key: "stat",
	    value: function () {
	      var _stat = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
	        var buf;
	        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
	          while (1) switch (_context5.prev = _context5.next) {
	            case 0:
	              if (this._stat) {
	                _context5.next = 6;
	                break;
	              }
	              buf = Buffer.allocUnsafe(10);
	              _context5.next = 4;
	              return this.read(buf, 0, 10, 0);
	            case 4:
	              if (this._stat) {
	                _context5.next = 6;
	                break;
	              }
	              throw new Error("unable to determine size of file at ".concat(this.url));
	            case 6:
	              return _context5.abrupt("return", this._stat);
	            case 7:
	            case "end":
	              return _context5.stop();
	          }
	        }, _callee5, this);
	      }));
	      function stat() {
	        return _stat.apply(this, arguments);
	      }
	      return stat;
	    }()
	  }, {
	    key: "close",
	    value: function () {
	      var _close = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
	        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
	          while (1) switch (_context6.prev = _context6.next) {
	            case 0:
	              return _context6.abrupt("return");
	            case 1:
	            case "end":
	              return _context6.stop();
	          }
	        }, _callee6);
	      }));
	      function close() {
	        return _close.apply(this, arguments);
	      }
	      return close;
	    }()
	  }]);
	  return RemoteFile;
	}();

	// Using this you can "await" the file like a normal promise
	// https://blog.shovonhasan.com/using-promises-with-filereader/
	function readBlobAsArrayBuffer(blob) {
	  var fileReader = new FileReader();
	  return new Promise(function (resolve, reject) {
	    fileReader.onerror = function () {
	      fileReader.abort();
	      reject(new Error('problem reading blob'));
	    };
	    fileReader.onabort = function () {
	      reject(new Error('blob reading was aborted'));
	    };
	    fileReader.onload = function () {
	      if (fileReader.result && typeof fileReader.result !== 'string') {
	        resolve(fileReader.result);
	      } else {
	        reject(new Error('unknown error reading blob'));
	      }
	    };
	    fileReader.readAsArrayBuffer(blob);
	  });
	}
	function readBlobAsText(blob) {
	  var fileReader = new FileReader();
	  return new Promise(function (resolve, reject) {
	    fileReader.onerror = function () {
	      fileReader.abort();
	      reject(new Error('problem reading blob'));
	    };
	    fileReader.onabort = function () {
	      reject(new Error('blob reading was aborted'));
	    };
	    fileReader.onload = function () {
	      if (fileReader.result && typeof fileReader.result === 'string') {
	        resolve(fileReader.result);
	      } else {
	        reject(new Error('unknown error reading blob'));
	      }
	    };
	    fileReader.readAsText(blob);
	  });
	}
	/**
	 * Blob of binary data fetched from a local file (with FileReader).
	 *
	 * Adapted by Robert Buels and Garrett Stevens from the BlobFetchable object in
	 * the Dalliance Genome Explorer, which is copyright Thomas Down 2006-2011.
	 */
	var BlobFile = /*#__PURE__*/function () {
	  function BlobFile(blob) {
	    _classCallCheck(this, BlobFile);
	    this.blob = blob;
	    this.size = blob.size;
	  }
	  _createClass(BlobFile, [{
	    key: "read",
	    value: function () {
	      var _read = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(buffer) {
	        var offset,
	          length,
	          position,
	          start,
	          end,
	          result,
	          resultBuffer,
	          bytesCopied,
	          _args = arguments;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              offset = _args.length > 1 && _args[1] !== undefined ? _args[1] : 0;
	              length = _args.length > 2 ? _args[2] : undefined;
	              position = _args.length > 3 && _args[3] !== undefined ? _args[3] : 0;
	              if (length) {
	                _context.next = 5;
	                break;
	              }
	              return _context.abrupt("return", {
	                bytesRead: 0,
	                buffer: buffer
	              });
	            case 5:
	              start = position;
	              end = start + length;
	              _context.next = 9;
	              return readBlobAsArrayBuffer(this.blob.slice(start, end));
	            case 9:
	              result = _context.sent;
	              resultBuffer = Buffer.from(result);
	              bytesCopied = resultBuffer.copy(buffer, offset);
	              return _context.abrupt("return", {
	                bytesRead: bytesCopied,
	                buffer: resultBuffer
	              });
	            case 13:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this);
	      }));
	      function read(_x) {
	        return _read.apply(this, arguments);
	      }
	      return read;
	    }()
	  }, {
	    key: "readFile",
	    value: function () {
	      var _readFile = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options) {
	        var encoding, result;
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              if (typeof options === 'string') {
	                encoding = options;
	              } else {
	                encoding = options && options.encoding;
	              }
	              if (!(encoding === 'utf8')) {
	                _context2.next = 3;
	                break;
	              }
	              return _context2.abrupt("return", readBlobAsText(this.blob));
	            case 3:
	              if (!encoding) {
	                _context2.next = 5;
	                break;
	              }
	              throw new Error("unsupported encoding: ".concat(encoding));
	            case 5:
	              _context2.next = 7;
	              return readBlobAsArrayBuffer(this.blob);
	            case 7:
	              result = _context2.sent;
	              return _context2.abrupt("return", Buffer.from(result));
	            case 9:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2, this);
	      }));
	      function readFile(_x2) {
	        return _readFile.apply(this, arguments);
	      }
	      return readFile;
	    }()
	  }, {
	    key: "stat",
	    value: function () {
	      var _stat = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              return _context3.abrupt("return", {
	                size: this.size
	              });
	            case 1:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this);
	      }));
	      function stat() {
	        return _stat.apply(this, arguments);
	      }
	      return stat;
	    }()
	  }, {
	    key: "close",
	    value: function () {
	      var _close = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
	        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
	          while (1) switch (_context4.prev = _context4.next) {
	            case 0:
	              return _context4.abrupt("return");
	            case 1:
	            case "end":
	              return _context4.stop();
	          }
	        }, _callee4);
	      }));
	      function close() {
	        return _close.apply(this, arguments);
	      }
	      return close;
	    }()
	  }]);
	  return BlobFile;
	}();

	function fromUrl(source) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  return new RemoteFile(source, opts);
	}
	function open$1(maybeUrl, maybePath, maybeFilehandle) {
	  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	  if (maybeFilehandle !== undefined) {
	    return maybeFilehandle;
	  }
	  if (maybeUrl !== undefined) {
	    return fromUrl(maybeUrl, opts);
	  }
	  if (maybePath !== undefined) {
	    return new LocalFile(maybePath, opts);
	  }
	  throw new Error('no url, path, or filehandle provided, cannot open');
	}

	var esm$1 = {
		__proto__: null,
		open: open$1,
		fromUrl: fromUrl,
		RemoteFile: RemoteFile,
		LocalFile: LocalFile,
		BlobFile: BlobFile
	};

	var common = {};

	(function (exports) {

	  var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';
	  function _has(obj, key) {
	    return Object.prototype.hasOwnProperty.call(obj, key);
	  }
	  exports.assign = function (obj /*from1, from2, from3, ...*/) {
	    var sources = Array.prototype.slice.call(arguments, 1);
	    while (sources.length) {
	      var source = sources.shift();
	      if (!source) {
	        continue;
	      }
	      if (_typeof(source) !== 'object') {
	        throw new TypeError(source + 'must be non-object');
	      }
	      for (var p in source) {
	        if (_has(source, p)) {
	          obj[p] = source[p];
	        }
	      }
	    }
	    return obj;
	  };

	  // reduce buffer size, avoiding mem copy
	  exports.shrinkBuf = function (buf, size) {
	    if (buf.length === size) {
	      return buf;
	    }
	    if (buf.subarray) {
	      return buf.subarray(0, size);
	    }
	    buf.length = size;
	    return buf;
	  };
	  var fnTyped = {
	    arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
	      if (src.subarray && dest.subarray) {
	        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
	        return;
	      }
	      // Fallback to ordinary array
	      for (var i = 0; i < len; i++) {
	        dest[dest_offs + i] = src[src_offs + i];
	      }
	    },
	    // Join array of chunks to single array.
	    flattenChunks: function flattenChunks(chunks) {
	      var i, l, len, pos, chunk, result;

	      // calculate data length
	      len = 0;
	      for (i = 0, l = chunks.length; i < l; i++) {
	        len += chunks[i].length;
	      }

	      // join chunks
	      result = new Uint8Array(len);
	      pos = 0;
	      for (i = 0, l = chunks.length; i < l; i++) {
	        chunk = chunks[i];
	        result.set(chunk, pos);
	        pos += chunk.length;
	      }
	      return result;
	    }
	  };
	  var fnUntyped = {
	    arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
	      for (var i = 0; i < len; i++) {
	        dest[dest_offs + i] = src[src_offs + i];
	      }
	    },
	    // Join array of chunks to single array.
	    flattenChunks: function flattenChunks(chunks) {
	      return [].concat.apply([], chunks);
	    }
	  };

	  // Enable/Disable typed arrays use, for testing
	  //
	  exports.setTyped = function (on) {
	    if (on) {
	      exports.Buf8 = Uint8Array;
	      exports.Buf16 = Uint16Array;
	      exports.Buf32 = Int32Array;
	      exports.assign(exports, fnTyped);
	    } else {
	      exports.Buf8 = Array;
	      exports.Buf16 = Array;
	      exports.Buf32 = Array;
	      exports.assign(exports, fnUntyped);
	    }
	  };
	  exports.setTyped(TYPED_OK);
	})(common);

	var deflate$4 = {};

	var deflate$3 = {};

	var trees$1 = {};

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	/* eslint-disable space-unary-ops */

	var utils$6 = common;

	/* Public constants ==========================================================*/
	/* ===========================================================================*/

	//var Z_FILTERED          = 1;
	//var Z_HUFFMAN_ONLY      = 2;
	//var Z_RLE               = 3;
	var Z_FIXED$1 = 4;
	//var Z_DEFAULT_STRATEGY  = 0;

	/* Possible values of the data_type field (though see inflate()) */
	var Z_BINARY = 0;
	var Z_TEXT = 1;
	//var Z_ASCII             = 1; // = Z_TEXT
	var Z_UNKNOWN$1 = 2;

	/*============================================================================*/

	function zero$1(buf) {
	  var len = buf.length;
	  while (--len >= 0) {
	    buf[len] = 0;
	  }
	}

	// From zutil.h

	var STORED_BLOCK = 0;
	var STATIC_TREES = 1;
	var DYN_TREES = 2;
	/* The three kinds of block type */

	var MIN_MATCH$1 = 3;
	var MAX_MATCH$1 = 258;
	/* The minimum and maximum match lengths */

	// From deflate.h
	/* ===========================================================================
	 * Internal compression state.
	 */

	var LENGTH_CODES$1 = 29;
	/* number of length codes, not counting the special END_BLOCK code */

	var LITERALS$1 = 256;
	/* number of literal bytes 0..255 */

	var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
	/* number of Literal or Length codes, including the END_BLOCK code */

	var D_CODES$1 = 30;
	/* number of distance codes */

	var BL_CODES$1 = 19;
	/* number of codes used to transfer the bit lengths */

	var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
	/* maximum heap size */

	var MAX_BITS$1 = 15;
	/* All codes must not exceed MAX_BITS bits */

	var Buf_size = 16;
	/* size of bit buffer in bi_buf */

	/* ===========================================================================
	 * Constants
	 */

	var MAX_BL_BITS = 7;
	/* Bit length codes must not exceed MAX_BL_BITS bits */

	var END_BLOCK = 256;
	/* end of block literal code */

	var REP_3_6 = 16;
	/* repeat previous bit length 3-6 times (2 bits of repeat count) */

	var REPZ_3_10 = 17;
	/* repeat a zero length 3-10 times  (3 bits of repeat count) */

	var REPZ_11_138 = 18;
	/* repeat a zero length 11-138 times  (7 bits of repeat count) */

	/* eslint-disable comma-spacing,array-bracket-spacing */
	var extra_lbits = /* extra bits for each length code */
	[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
	var extra_dbits = /* extra bits for each distance code */
	[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
	var extra_blbits = /* extra bits for each bit length code */
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
	var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
	/* eslint-enable comma-spacing,array-bracket-spacing */

	/* The lengths of the bit length codes are sent in order of decreasing
	 * probability, to avoid transmitting the lengths for unused bit length codes.
	 */

	/* ===========================================================================
	 * Local data. These are initialized only once.
	 */

	// We pre-fill arrays with 0 to avoid uninitialized gaps

	var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

	// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
	var static_ltree = /*#__PURE__*/new Array((L_CODES$1 + 2) * 2);
	zero$1(static_ltree);
	/* The static literal tree. Since the bit lengths are imposed, there is no
	 * need for the L_CODES extra codes used during heap construction. However
	 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
	 * below).
	 */

	var static_dtree = /*#__PURE__*/new Array(D_CODES$1 * 2);
	zero$1(static_dtree);
	/* The static distance tree. (Actually a trivial tree since all codes use
	 * 5 bits.)
	 */

	var _dist_code = /*#__PURE__*/new Array(DIST_CODE_LEN);
	zero$1(_dist_code);
	/* Distance codes. The first 256 values correspond to the distances
	 * 3 .. 258, the last 256 values correspond to the top 8 bits of
	 * the 15 bit distances.
	 */

	var _length_code = /*#__PURE__*/new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
	zero$1(_length_code);
	/* length code for each normalized match length (0 == MIN_MATCH) */

	var base_length = /*#__PURE__*/new Array(LENGTH_CODES$1);
	zero$1(base_length);
	/* First normalized length for each code (0 = MIN_MATCH) */

	var base_dist = /*#__PURE__*/new Array(D_CODES$1);
	zero$1(base_dist);
	/* First normalized distance for each code (0 = distance of 1) */

	function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
	  this.static_tree = static_tree; /* static tree or NULL */
	  this.extra_bits = extra_bits; /* extra bits for each code or NULL */
	  this.extra_base = extra_base; /* base index for extra_bits */
	  this.elems = elems; /* max number of elements in the tree */
	  this.max_length = max_length; /* max bit length for the codes */

	  // show if `static_tree` has data or dummy - needed for monomorphic objects
	  this.has_stree = static_tree && static_tree.length;
	}
	var static_l_desc;
	var static_d_desc;
	var static_bl_desc;
	function TreeDesc(dyn_tree, stat_desc) {
	  this.dyn_tree = dyn_tree; /* the dynamic tree */
	  this.max_code = 0; /* largest code with non zero frequency */
	  this.stat_desc = stat_desc; /* the corresponding static tree */
	}

	function d_code(dist) {
	  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
	}

	/* ===========================================================================
	 * Output a short LSB first on the stream.
	 * IN assertion: there is enough room in pendingBuf.
	 */
	function put_short(s, w) {
	  //    put_byte(s, (uch)((w) & 0xff));
	  //    put_byte(s, (uch)((ush)(w) >> 8));
	  s.pending_buf[s.pending++] = w & 0xff;
	  s.pending_buf[s.pending++] = w >>> 8 & 0xff;
	}

	/* ===========================================================================
	 * Send a value on a given number of bits.
	 * IN assertion: length <= 16 and value fits in length bits.
	 */
	function send_bits(s, value, length) {
	  if (s.bi_valid > Buf_size - length) {
	    s.bi_buf |= value << s.bi_valid & 0xffff;
	    put_short(s, s.bi_buf);
	    s.bi_buf = value >> Buf_size - s.bi_valid;
	    s.bi_valid += length - Buf_size;
	  } else {
	    s.bi_buf |= value << s.bi_valid & 0xffff;
	    s.bi_valid += length;
	  }
	}
	function send_code(s, c, tree) {
	  send_bits(s, tree[c * 2] /*.Code*/, tree[c * 2 + 1] /*.Len*/);
	}

	/* ===========================================================================
	 * Reverse the first len bits of a code, using straightforward code (a faster
	 * method would use a table)
	 * IN assertion: 1 <= len <= 15
	 */
	function bi_reverse(code, len) {
	  var res = 0;
	  do {
	    res |= code & 1;
	    code >>>= 1;
	    res <<= 1;
	  } while (--len > 0);
	  return res >>> 1;
	}

	/* ===========================================================================
	 * Flush the bit buffer, keeping at most 7 bits in it.
	 */
	function bi_flush(s) {
	  if (s.bi_valid === 16) {
	    put_short(s, s.bi_buf);
	    s.bi_buf = 0;
	    s.bi_valid = 0;
	  } else if (s.bi_valid >= 8) {
	    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
	    s.bi_buf >>= 8;
	    s.bi_valid -= 8;
	  }
	}

	/* ===========================================================================
	 * Compute the optimal bit lengths for a tree and update the total bit length
	 * for the current block.
	 * IN assertion: the fields freq and dad are set, heap[heap_max] and
	 *    above are the tree nodes sorted by increasing frequency.
	 * OUT assertions: the field len is set to the optimal bit length, the
	 *     array bl_count contains the frequencies for each bit length.
	 *     The length opt_len is updated; static_len is also updated if stree is
	 *     not null.
	 */
	function gen_bitlen(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc;    /* the tree descriptor */
	{
	  var tree = desc.dyn_tree;
	  var max_code = desc.max_code;
	  var stree = desc.stat_desc.static_tree;
	  var has_stree = desc.stat_desc.has_stree;
	  var extra = desc.stat_desc.extra_bits;
	  var base = desc.stat_desc.extra_base;
	  var max_length = desc.stat_desc.max_length;
	  var h; /* heap index */
	  var n, m; /* iterate over the tree elements */
	  var bits; /* bit length */
	  var xbits; /* extra bits */
	  var f; /* frequency */
	  var overflow = 0; /* number of elements with bit length too large */

	  for (bits = 0; bits <= MAX_BITS$1; bits++) {
	    s.bl_count[bits] = 0;
	  }

	  /* In a first pass, compute the optimal bit lengths (which may
	   * overflow in the case of the bit length tree).
	   */
	  tree[s.heap[s.heap_max] * 2 + 1] /*.Len*/ = 0; /* root of the heap */

	  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
	    n = s.heap[h];
	    bits = tree[tree[n * 2 + 1] /*.Dad*/ * 2 + 1] /*.Len*/ + 1;
	    if (bits > max_length) {
	      bits = max_length;
	      overflow++;
	    }
	    tree[n * 2 + 1] /*.Len*/ = bits;
	    /* We overwrite tree[n].Dad which is no longer needed */

	    if (n > max_code) {
	      continue;
	    } /* not a leaf node */

	    s.bl_count[bits]++;
	    xbits = 0;
	    if (n >= base) {
	      xbits = extra[n - base];
	    }
	    f = tree[n * 2] /*.Freq*/;
	    s.opt_len += f * (bits + xbits);
	    if (has_stree) {
	      s.static_len += f * (stree[n * 2 + 1] /*.Len*/ + xbits);
	    }
	  }
	  if (overflow === 0) {
	    return;
	  }

	  // Trace((stderr,"\nbit length overflow\n"));
	  /* This happens for example on obj2 and pic of the Calgary corpus */

	  /* Find the first bit length which could increase: */
	  do {
	    bits = max_length - 1;
	    while (s.bl_count[bits] === 0) {
	      bits--;
	    }
	    s.bl_count[bits]--; /* move one leaf down the tree */
	    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
	    s.bl_count[max_length]--;
	    /* The brother of the overflow item also moves one step up,
	     * but this does not affect bl_count[max_length]
	     */
	    overflow -= 2;
	  } while (overflow > 0);

	  /* Now recompute all bit lengths, scanning in increasing frequency.
	   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
	   * lengths instead of fixing only the wrong ones. This idea is taken
	   * from 'ar' written by Haruhiko Okumura.)
	   */
	  for (bits = max_length; bits !== 0; bits--) {
	    n = s.bl_count[bits];
	    while (n !== 0) {
	      m = s.heap[--h];
	      if (m > max_code) {
	        continue;
	      }
	      if (tree[m * 2 + 1] /*.Len*/ !== bits) {
	        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
	        s.opt_len += (bits - tree[m * 2 + 1] /*.Len*/) * tree[m * 2] /*.Freq*/;
	        tree[m * 2 + 1] /*.Len*/ = bits;
	      }
	      n--;
	    }
	  }
	}

	/* ===========================================================================
	 * Generate the codes for a given tree and bit counts (which need not be
	 * optimal).
	 * IN assertion: the array bl_count contains the bit length statistics for
	 * the given tree and the field len is set for all tree elements.
	 * OUT assertion: the field code is set for all tree elements of non
	 *     zero code length.
	 */
	function gen_codes(tree, max_code, bl_count)
	//    ct_data *tree;             /* the tree to decorate */
	//    int max_code;              /* largest code with non zero frequency */
	//    ushf *bl_count;            /* number of codes at each bit length */
	{
	  var next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */
	  var code = 0; /* running code value */
	  var bits; /* bit index */
	  var n; /* code index */

	  /* The distribution counts are first used to generate the code values
	   * without bit reversal.
	   */
	  for (bits = 1; bits <= MAX_BITS$1; bits++) {
	    next_code[bits] = code = code + bl_count[bits - 1] << 1;
	  }
	  /* Check that the bit counts in bl_count are consistent. The last code
	   * must be all ones.
	   */
	  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
	  //        "inconsistent bit counts");
	  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

	  for (n = 0; n <= max_code; n++) {
	    var len = tree[n * 2 + 1] /*.Len*/;
	    if (len === 0) {
	      continue;
	    }
	    /* Now reverse the bits */
	    tree[n * 2] /*.Code*/ = bi_reverse(next_code[len]++, len);

	    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
	    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
	  }
	}

	/* ===========================================================================
	 * Initialize the various 'constant' tables.
	 */
	function tr_static_init() {
	  var n; /* iterates over tree elements */
	  var bits; /* bit counter */
	  var length; /* length value */
	  var code; /* code value */
	  var dist; /* distance index */
	  var bl_count = new Array(MAX_BITS$1 + 1);
	  /* number of codes at each bit length for an optimal tree */

	  // do check in _tr_init()
	  //if (static_init_done) return;

	  /* For some embedded targets, global variables are not initialized: */
	  /*#ifdef NO_INIT_GLOBAL_POINTERS
	    static_l_desc.static_tree = static_ltree;
	    static_l_desc.extra_bits = extra_lbits;
	    static_d_desc.static_tree = static_dtree;
	    static_d_desc.extra_bits = extra_dbits;
	    static_bl_desc.extra_bits = extra_blbits;
	  #endif*/

	  /* Initialize the mapping length (0..255) -> length code (0..28) */
	  length = 0;
	  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
	    base_length[code] = length;
	    for (n = 0; n < 1 << extra_lbits[code]; n++) {
	      _length_code[length++] = code;
	    }
	  }
	  //Assert (length == 256, "tr_static_init: length != 256");
	  /* Note that the length 255 (match length 258) can be represented
	   * in two different ways: code 284 + 5 bits or code 285, so we
	   * overwrite length_code[255] to use the best encoding:
	   */
	  _length_code[length - 1] = code;

	  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
	  dist = 0;
	  for (code = 0; code < 16; code++) {
	    base_dist[code] = dist;
	    for (n = 0; n < 1 << extra_dbits[code]; n++) {
	      _dist_code[dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: dist != 256");
	  dist >>= 7; /* from now on, all distances are divided by 128 */
	  for (; code < D_CODES$1; code++) {
	    base_dist[code] = dist << 7;
	    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
	      _dist_code[256 + dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

	  /* Construct the codes of the static literal tree */
	  for (bits = 0; bits <= MAX_BITS$1; bits++) {
	    bl_count[bits] = 0;
	  }
	  n = 0;
	  while (n <= 143) {
	    static_ltree[n * 2 + 1] /*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  while (n <= 255) {
	    static_ltree[n * 2 + 1] /*.Len*/ = 9;
	    n++;
	    bl_count[9]++;
	  }
	  while (n <= 279) {
	    static_ltree[n * 2 + 1] /*.Len*/ = 7;
	    n++;
	    bl_count[7]++;
	  }
	  while (n <= 287) {
	    static_ltree[n * 2 + 1] /*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  /* Codes 286 and 287 do not exist, but we must include them in the
	   * tree construction to get a canonical Huffman tree (longest code
	   * all ones)
	   */
	  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);

	  /* The static distance tree is trivial: */
	  for (n = 0; n < D_CODES$1; n++) {
	    static_dtree[n * 2 + 1] /*.Len*/ = 5;
	    static_dtree[n * 2] /*.Code*/ = bi_reverse(n, 5);
	  }

	  // Now data ready and we can init static trees
	  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
	  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
	  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);

	  //static_init_done = true;
	}

	/* ===========================================================================
	 * Initialize a new block.
	 */
	function init_block(s) {
	  var n; /* iterates over tree elements */

	  /* Initialize the trees. */
	  for (n = 0; n < L_CODES$1; n++) {
	    s.dyn_ltree[n * 2] /*.Freq*/ = 0;
	  }
	  for (n = 0; n < D_CODES$1; n++) {
	    s.dyn_dtree[n * 2] /*.Freq*/ = 0;
	  }
	  for (n = 0; n < BL_CODES$1; n++) {
	    s.bl_tree[n * 2] /*.Freq*/ = 0;
	  }
	  s.dyn_ltree[END_BLOCK * 2] /*.Freq*/ = 1;
	  s.opt_len = s.static_len = 0;
	  s.last_lit = s.matches = 0;
	}

	/* ===========================================================================
	 * Flush the bit buffer and align the output on a byte boundary
	 */
	function bi_windup(s) {
	  if (s.bi_valid > 8) {
	    put_short(s, s.bi_buf);
	  } else if (s.bi_valid > 0) {
	    //put_byte(s, (Byte)s->bi_buf);
	    s.pending_buf[s.pending++] = s.bi_buf;
	  }
	  s.bi_buf = 0;
	  s.bi_valid = 0;
	}

	/* ===========================================================================
	 * Copy a stored block, storing first the length and its
	 * one's complement if requested.
	 */
	function copy_block(s, buf, len, header)
	//DeflateState *s;
	//charf    *buf;    /* the input data */
	//unsigned len;     /* its length */
	//int      header;  /* true if block header must be written */
	{
	  bi_windup(s); /* align on byte boundary */

	  if (header) {
	    put_short(s, len);
	    put_short(s, ~len);
	  }
	  //  while (len--) {
	  //    put_byte(s, *buf++);
	  //  }
	  utils$6.arraySet(s.pending_buf, s.window, buf, len, s.pending);
	  s.pending += len;
	}

	/* ===========================================================================
	 * Compares to subtrees, using the tree depth as tie breaker when
	 * the subtrees have equal frequency. This minimizes the worst case length.
	 */
	function smaller(tree, n, m, depth) {
	  var _n2 = n * 2;
	  var _m2 = m * 2;
	  return tree[_n2] /*.Freq*/ < tree[_m2] /*.Freq*/ || tree[_n2] /*.Freq*/ === tree[_m2] /*.Freq*/ && depth[n] <= depth[m];
	}

	/* ===========================================================================
	 * Restore the heap property by moving down the tree starting at node k,
	 * exchanging a node with the smallest of its two sons if necessary, stopping
	 * when the heap property is re-established (each father smaller than its
	 * two sons).
	 */
	function pqdownheap(s, tree, k)
	//    deflate_state *s;
	//    ct_data *tree;  /* the tree to restore */
	//    int k;               /* node to move down */
	{
	  var v = s.heap[k];
	  var j = k << 1; /* left son of k */
	  while (j <= s.heap_len) {
	    /* Set j to the smallest of the two sons: */
	    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
	      j++;
	    }
	    /* Exit if v is smaller than both sons */
	    if (smaller(tree, v, s.heap[j], s.depth)) {
	      break;
	    }

	    /* Exchange v with the smallest son */
	    s.heap[k] = s.heap[j];
	    k = j;

	    /* And continue down the tree, setting j to the left son of k */
	    j <<= 1;
	  }
	  s.heap[k] = v;
	}

	// inlined manually
	// var SMALLEST = 1;

	/* ===========================================================================
	 * Send the block data compressed using the given Huffman trees
	 */
	function compress_block(s, ltree, dtree)
	//    deflate_state *s;
	//    const ct_data *ltree; /* literal tree */
	//    const ct_data *dtree; /* distance tree */
	{
	  var dist; /* distance of matched string */
	  var lc; /* match length or unmatched char (if dist == 0) */
	  var lx = 0; /* running index in l_buf */
	  var code; /* the code to send */
	  var extra; /* number of extra bits to send */

	  if (s.last_lit !== 0) {
	    do {
	      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
	      lc = s.pending_buf[s.l_buf + lx];
	      lx++;
	      if (dist === 0) {
	        send_code(s, lc, ltree); /* send a literal byte */
	        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
	      } else {
	        /* Here, lc is the match length - MIN_MATCH */
	        code = _length_code[lc];
	        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */
	        extra = extra_lbits[code];
	        if (extra !== 0) {
	          lc -= base_length[code];
	          send_bits(s, lc, extra); /* send the extra length bits */
	        }

	        dist--; /* dist is now the match distance - 1 */
	        code = d_code(dist);
	        //Assert (code < D_CODES, "bad d_code");

	        send_code(s, code, dtree); /* send the distance code */
	        extra = extra_dbits[code];
	        if (extra !== 0) {
	          dist -= base_dist[code];
	          send_bits(s, dist, extra); /* send the extra distance bits */
	        }
	      } /* literal or match pair ? */

	      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
	      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
	      //       "pendingBuf overflow");
	    } while (lx < s.last_lit);
	  }
	  send_code(s, END_BLOCK, ltree);
	}

	/* ===========================================================================
	 * Construct one Huffman tree and assigns the code bit strings and lengths.
	 * Update the total bit length for the current block.
	 * IN assertion: the field freq is set for all tree elements.
	 * OUT assertions: the fields len and code are set to the optimal bit length
	 *     and corresponding code. The length opt_len is updated; static_len is
	 *     also updated if stree is not null. The field max_code is set.
	 */
	function build_tree(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc; /* the tree descriptor */
	{
	  var tree = desc.dyn_tree;
	  var stree = desc.stat_desc.static_tree;
	  var has_stree = desc.stat_desc.has_stree;
	  var elems = desc.stat_desc.elems;
	  var n, m; /* iterate over heap elements */
	  var max_code = -1; /* largest code with non zero frequency */
	  var node; /* new node being created */

	  /* Construct the initial heap, with least frequent element in
	   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
	   * heap[0] is not used.
	   */
	  s.heap_len = 0;
	  s.heap_max = HEAP_SIZE$1;
	  for (n = 0; n < elems; n++) {
	    if (tree[n * 2] /*.Freq*/ !== 0) {
	      s.heap[++s.heap_len] = max_code = n;
	      s.depth[n] = 0;
	    } else {
	      tree[n * 2 + 1] /*.Len*/ = 0;
	    }
	  }

	  /* The pkzip format requires that at least one distance code exists,
	   * and that at least one bit should be sent even if there is only one
	   * possible code. So to avoid special checks later on we force at least
	   * two codes of non zero frequency.
	   */
	  while (s.heap_len < 2) {
	    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
	    tree[node * 2] /*.Freq*/ = 1;
	    s.depth[node] = 0;
	    s.opt_len--;
	    if (has_stree) {
	      s.static_len -= stree[node * 2 + 1] /*.Len*/;
	    }
	    /* node is 0 or 1 so it does not have extra bits */
	  }

	  desc.max_code = max_code;

	  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
	   * establish sub-heaps of increasing lengths:
	   */
	  for (n = s.heap_len >> 1 /*int /2*/; n >= 1; n--) {
	    pqdownheap(s, tree, n);
	  }

	  /* Construct the Huffman tree by repeatedly combining the least two
	   * frequent nodes.
	   */
	  node = elems; /* next internal node of the tree */
	  do {
	    //pqremove(s, tree, n);  /* n = node of least frequency */
	    /*** pqremove ***/
	    n = s.heap[1 /*SMALLEST*/];
	    s.heap[1 /*SMALLEST*/] = s.heap[s.heap_len--];
	    pqdownheap(s, tree, 1 /*SMALLEST*/);
	    /***/

	    m = s.heap[1 /*SMALLEST*/]; /* m = node of next least frequency */

	    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
	    s.heap[--s.heap_max] = m;

	    /* Create a new node father of n and m */
	    tree[node * 2] /*.Freq*/ = tree[n * 2] /*.Freq*/ + tree[m * 2] /*.Freq*/;
	    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
	    tree[n * 2 + 1] /*.Dad*/ = tree[m * 2 + 1] /*.Dad*/ = node;

	    /* and insert the new node in the heap */
	    s.heap[1 /*SMALLEST*/] = node++;
	    pqdownheap(s, tree, 1 /*SMALLEST*/);
	  } while (s.heap_len >= 2);
	  s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/];

	  /* At this point, the fields freq and dad are set. We can now
	   * generate the bit lengths.
	   */
	  gen_bitlen(s, desc);

	  /* The field len is now set, we can generate the bit codes */
	  gen_codes(tree, max_code, s.bl_count);
	}

	/* ===========================================================================
	 * Scan a literal or distance tree to determine the frequencies of the codes
	 * in the bit length tree.
	 */
	function scan_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree;   /* the tree to be scanned */
	//    int max_code;    /* and its largest code of non zero frequency */
	{
	  var n; /* iterates over all tree elements */
	  var prevlen = -1; /* last emitted length */
	  var curlen; /* length of current code */

	  var nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

	  var count = 0; /* repeat count of the current code */
	  var max_count = 7; /* max repeat count */
	  var min_count = 4; /* min repeat count */

	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }
	  tree[(max_code + 1) * 2 + 1] /*.Len*/ = 0xffff; /* guard */

	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;

	    if (++count < max_count && curlen === nextlen) {
	      continue;
	    } else if (count < min_count) {
	      s.bl_tree[curlen * 2] /*.Freq*/ += count;
	    } else if (curlen !== 0) {
	      if (curlen !== prevlen) {
	        s.bl_tree[curlen * 2] /*.Freq*/++;
	      }
	      s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
	    } else if (count <= 10) {
	      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
	    } else {
	      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
	    }

	    count = 0;
	    prevlen = curlen;
	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;
	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;
	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}

	/* ===========================================================================
	 * Send a literal or distance tree in compressed form, using the codes in
	 * bl_tree.
	 */
	function send_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree; /* the tree to be scanned */
	//    int max_code;       /* and its largest code of non zero frequency */
	{
	  var n; /* iterates over all tree elements */
	  var prevlen = -1; /* last emitted length */
	  var curlen; /* length of current code */

	  var nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

	  var count = 0; /* repeat count of the current code */
	  var max_count = 7; /* max repeat count */
	  var min_count = 4; /* min repeat count */

	  /* tree[max_code+1].Len = -1; */ /* guard already set */
	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }
	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;

	    if (++count < max_count && curlen === nextlen) {
	      continue;
	    } else if (count < min_count) {
	      do {
	        send_code(s, curlen, s.bl_tree);
	      } while (--count !== 0);
	    } else if (curlen !== 0) {
	      if (curlen !== prevlen) {
	        send_code(s, curlen, s.bl_tree);
	        count--;
	      }
	      //Assert(count >= 3 && count <= 6, " 3_6?");
	      send_code(s, REP_3_6, s.bl_tree);
	      send_bits(s, count - 3, 2);
	    } else if (count <= 10) {
	      send_code(s, REPZ_3_10, s.bl_tree);
	      send_bits(s, count - 3, 3);
	    } else {
	      send_code(s, REPZ_11_138, s.bl_tree);
	      send_bits(s, count - 11, 7);
	    }
	    count = 0;
	    prevlen = curlen;
	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;
	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;
	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}

	/* ===========================================================================
	 * Construct the Huffman tree for the bit lengths and return the index in
	 * bl_order of the last bit length code to send.
	 */
	function build_bl_tree(s) {
	  var max_blindex; /* index of last bit length code of non zero freq */

	  /* Determine the bit length frequencies for literal and distance trees */
	  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
	  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

	  /* Build the bit length tree: */
	  build_tree(s, s.bl_desc);
	  /* opt_len now includes the length of the tree representations, except
	   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
	   */

	  /* Determine the number of bit length codes to send. The pkzip format
	   * requires that at least 4 bit length codes be sent. (appnote.txt says
	   * 3 but the actual value used is 4.)
	   */
	  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
	    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] /*.Len*/ !== 0) {
	      break;
	    }
	  }
	  /* Update opt_len to include the bit length tree and counts */
	  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
	  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
	  //        s->opt_len, s->static_len));

	  return max_blindex;
	}

	/* ===========================================================================
	 * Send the header for a block using dynamic Huffman trees: the counts, the
	 * lengths of the bit length codes, the literal tree and the distance tree.
	 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
	 */
	function send_all_trees(s, lcodes, dcodes, blcodes)
	//    deflate_state *s;
	//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
	{
	  var rank; /* index in bl_order */

	  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
	  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
	  //        "too many codes");
	  //Tracev((stderr, "\nbl counts: "));
	  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
	  send_bits(s, dcodes - 1, 5);
	  send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */
	  for (rank = 0; rank < blcodes; rank++) {
	    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
	    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1] /*.Len*/, 3);
	  }
	  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

	  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
	  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

	  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
	  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
	}

	/* ===========================================================================
	 * Check if the data type is TEXT or BINARY, using the following algorithm:
	 * - TEXT if the two conditions below are satisfied:
	 *    a) There are no non-portable control characters belonging to the
	 *       "black list" (0..6, 14..25, 28..31).
	 *    b) There is at least one printable character belonging to the
	 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
	 * - BINARY otherwise.
	 * - The following partially-portable control characters form a
	 *   "gray list" that is ignored in this detection algorithm:
	 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
	 * IN assertion: the fields Freq of dyn_ltree are set.
	 */
	function detect_data_type(s) {
	  /* black_mask is the bit mask of black-listed bytes
	   * set bits 0..6, 14..25, and 28..31
	   * 0xf3ffc07f = binary 11110011111111111100000001111111
	   */
	  var black_mask = 0xf3ffc07f;
	  var n;

	  /* Check for non-textual ("black-listed") bytes. */
	  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
	    if (black_mask & 1 && s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
	      return Z_BINARY;
	    }
	  }

	  /* Check for textual ("white-listed") bytes. */
	  if (s.dyn_ltree[9 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[10 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[13 * 2] /*.Freq*/ !== 0) {
	    return Z_TEXT;
	  }
	  for (n = 32; n < LITERALS$1; n++) {
	    if (s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
	      return Z_TEXT;
	    }
	  }

	  /* There are no "black-listed" or "white-listed" bytes:
	   * this stream either is empty or has tolerated ("gray-listed") bytes only.
	   */
	  return Z_BINARY;
	}
	var static_init_done = false;

	/* ===========================================================================
	 * Initialize the tree data structures for a new zlib stream.
	 */
	function _tr_init(s) {
	  if (!static_init_done) {
	    tr_static_init();
	    static_init_done = true;
	  }
	  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
	  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
	  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
	  s.bi_buf = 0;
	  s.bi_valid = 0;

	  /* Initialize the first block of the first file: */
	  init_block(s);
	}

	/* ===========================================================================
	 * Send a stored block
	 */
	function _tr_stored_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */
	  copy_block(s, buf, stored_len, true); /* with header */
	}

	/* ===========================================================================
	 * Send one empty static block to give enough lookahead for inflate.
	 * This takes 10 bits, of which 7 may remain in the bit buffer.
	 */
	function _tr_align(s) {
	  send_bits(s, STATIC_TREES << 1, 3);
	  send_code(s, END_BLOCK, static_ltree);
	  bi_flush(s);
	}

	/* ===========================================================================
	 * Determine the best encoding for the current block: dynamic trees, static
	 * trees or store, and output the encoded block to the zip file.
	 */
	function _tr_flush_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block, or NULL if too old */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  var opt_lenb, static_lenb; /* opt_len and static_len in bytes */
	  var max_blindex = 0; /* index of last bit length code of non zero freq */

	  /* Build the Huffman trees unless a stored block is forced */
	  if (s.level > 0) {
	    /* Check if the file is binary or text */
	    if (s.strm.data_type === Z_UNKNOWN$1) {
	      s.strm.data_type = detect_data_type(s);
	    }

	    /* Construct the literal and distance trees */
	    build_tree(s, s.l_desc);
	    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));

	    build_tree(s, s.d_desc);
	    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));
	    /* At this point, opt_len and static_len are the total bit lengths of
	     * the compressed block data, excluding the tree representations.
	     */

	    /* Build the bit length tree for the above two trees, and get the index
	     * in bl_order of the last bit length code to send.
	     */
	    max_blindex = build_bl_tree(s);

	    /* Determine the best encoding. Compute the block lengths in bytes. */
	    opt_lenb = s.opt_len + 3 + 7 >>> 3;
	    static_lenb = s.static_len + 3 + 7 >>> 3;

	    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
	    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
	    //        s->last_lit));

	    if (static_lenb <= opt_lenb) {
	      opt_lenb = static_lenb;
	    }
	  } else {
	    // Assert(buf != (char*)0, "lost buf");
	    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
	  }

	  if (stored_len + 4 <= opt_lenb && buf !== -1) {
	    /* 4: two words for the lengths */

	    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
	     * Otherwise we can't have processed more than WSIZE input bytes since
	     * the last block flush, because compression would have been
	     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
	     * transform a block into a stored block.
	     */
	    _tr_stored_block(s, buf, stored_len, last);
	  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
	    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
	    compress_block(s, static_ltree, static_dtree);
	  } else {
	    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
	    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
	    compress_block(s, s.dyn_ltree, s.dyn_dtree);
	  }
	  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
	  /* The above check is made mod 2^32, for files larger than 512 MB
	   * and uLong implemented on 32 bits.
	   */
	  init_block(s);
	  if (last) {
	    bi_windup(s);
	  }
	  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
	  //       s->compressed_len-7*last));
	}

	/* ===========================================================================
	 * Save the match info and tally the frequency counts. Return true if
	 * the current block must be flushed.
	 */
	function _tr_tally(s, dist, lc)
	//    deflate_state *s;
	//    unsigned dist;  /* distance of matched string */
	//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
	{
	  //var out_length, in_length, dcode;

	  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
	  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
	  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
	  s.last_lit++;
	  if (dist === 0) {
	    /* lc is the unmatched char */
	    s.dyn_ltree[lc * 2] /*.Freq*/++;
	  } else {
	    s.matches++;
	    /* Here, lc is the match length - MIN_MATCH */
	    dist--; /* dist = match distance - 1 */
	    //Assert((ush)dist < (ush)MAX_DIST(s) &&
	    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
	    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

	    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2] /*.Freq*/++;
	    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
	  }

	  // (!) This block is disabled in zlib defaults,
	  // don't enable it for binary compatibility

	  //#ifdef TRUNCATE_BLOCK
	  //  /* Try to guess if it is profitable to stop the current block here */
	  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
	  //    /* Compute an upper bound for the compressed length */
	  //    out_length = s.last_lit*8;
	  //    in_length = s.strstart - s.block_start;
	  //
	  //    for (dcode = 0; dcode < D_CODES; dcode++) {
	  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
	  //    }
	  //    out_length >>>= 3;
	  //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
	  //    //       s->last_lit, in_length, out_length,
	  //    //       100L - out_length*100L/in_length));
	  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
	  //      return true;
	  //    }
	  //  }
	  //#endif

	  return s.last_lit === s.lit_bufsize - 1;
	  /* We avoid equality with lit_bufsize because of wraparound at 64K
	   * on 16 bit machines and because stored blocks are restricted to
	   * 64K-1 bytes.
	   */
	}

	trees$1._tr_init = _tr_init;
	trees$1._tr_stored_block = _tr_stored_block;
	trees$1._tr_flush_block = _tr_flush_block;
	trees$1._tr_tally = _tr_tally;
	trees$1._tr_align = _tr_align;

	// Note: adler32 takes 12% for level 0 and 2% for level 6.
	// It isn't worth it to make additional optimizations as in original.
	// Small size is preferable.

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	function adler32$2(adler, buf, len, pos) {
	  var s1 = adler & 0xffff | 0,
	    s2 = adler >>> 16 & 0xffff | 0,
	    n = 0;
	  while (len !== 0) {
	    // Set limit ~ twice less than 5552, to keep
	    // s2 in 31-bits, because we force signed ints.
	    // in other case %= will fail.
	    n = len > 2000 ? 2000 : len;
	    len -= n;
	    do {
	      s1 = s1 + buf[pos++] | 0;
	      s2 = s2 + s1 | 0;
	    } while (--n);
	    s1 %= 65521;
	    s2 %= 65521;
	  }
	  return s1 | s2 << 16 | 0;
	}
	var adler32_1 = adler32$2;

	// Note: we can't get significant speed boost here.
	// So write code to minimize size - no pregenerated tables
	// and array tools dependencies.

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	// Use ordinary array, since untyped makes no boost here
	function makeTable() {
	  var c,
	    table = [];
	  for (var n = 0; n < 256; n++) {
	    c = n;
	    for (var k = 0; k < 8; k++) {
	      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
	    }
	    table[n] = c;
	  }
	  return table;
	}

	// Create table on load. Just 255 signed longs. Not a problem.
	var crcTable = /*#__PURE__*/makeTable();
	function crc32$2(crc, buf, len, pos) {
	  var t = crcTable,
	    end = pos + len;
	  crc ^= -1;
	  for (var i = pos; i < end; i++) {
	    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
	  }
	  return crc ^ -1; // >>> 0;
	}

	var crc32_1 = crc32$2;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	var messages = {
	  2: 'need dictionary',
	  /* Z_NEED_DICT       2  */
	  1: 'stream end',
	  /* Z_STREAM_END      1  */
	  0: '',
	  /* Z_OK              0  */
	  '-1': 'file error',
	  /* Z_ERRNO         (-1) */
	  '-2': 'stream error',
	  /* Z_STREAM_ERROR  (-2) */
	  '-3': 'data error',
	  /* Z_DATA_ERROR    (-3) */
	  '-4': 'insufficient memory',
	  /* Z_MEM_ERROR     (-4) */
	  '-5': 'buffer error',
	  /* Z_BUF_ERROR     (-5) */
	  '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */
	};

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	var utils$5 = common;
	var trees = trees$1;
	var adler32$1 = adler32_1;
	var crc32$1 = crc32_1;
	var msg$2 = messages;

	/* Public constants ==========================================================*/
	/* ===========================================================================*/

	/* Allowed flush values; see deflate() and inflate() below for details */
	var Z_NO_FLUSH$1 = 0;
	var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	var Z_FULL_FLUSH = 3;
	var Z_FINISH$2 = 4;
	var Z_BLOCK$1 = 5;
	//var Z_TREES         = 6;

	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK$2 = 0;
	var Z_STREAM_END$2 = 1;
	//var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR$1 = -2;
	var Z_DATA_ERROR$1 = -3;
	//var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR$1 = -5;
	//var Z_VERSION_ERROR = -6;

	/* compression levels */
	//var Z_NO_COMPRESSION      = 0;
	//var Z_BEST_SPEED          = 1;
	//var Z_BEST_COMPRESSION    = 9;
	var Z_DEFAULT_COMPRESSION$1 = -1;
	var Z_FILTERED = 1;
	var Z_HUFFMAN_ONLY = 2;
	var Z_RLE = 3;
	var Z_FIXED = 4;
	var Z_DEFAULT_STRATEGY$1 = 0;

	/* Possible values of the data_type field (though see inflate()) */
	//var Z_BINARY              = 0;
	//var Z_TEXT                = 1;
	//var Z_ASCII               = 1; // = Z_TEXT
	var Z_UNKNOWN = 2;

	/* The deflate compression method */
	var Z_DEFLATED$2 = 8;

	/*============================================================================*/

	var MAX_MEM_LEVEL = 9;
	/* Maximum value for memLevel in deflateInit2 */
	var MAX_WBITS$1 = 15;
	/* 32K LZ77 window */
	var DEF_MEM_LEVEL = 8;
	var LENGTH_CODES = 29;
	/* number of length codes, not counting the special END_BLOCK code */
	var LITERALS = 256;
	/* number of literal bytes 0..255 */
	var L_CODES = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */
	var D_CODES = 30;
	/* number of distance codes */
	var BL_CODES = 19;
	/* number of codes used to transfer the bit lengths */
	var HEAP_SIZE = 2 * L_CODES + 1;
	/* maximum heap size */
	var MAX_BITS = 15;
	/* All codes must not exceed MAX_BITS bits */

	var MIN_MATCH = 3;
	var MAX_MATCH = 258;
	var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
	var PRESET_DICT = 0x20;
	var INIT_STATE = 42;
	var EXTRA_STATE = 69;
	var NAME_STATE = 73;
	var COMMENT_STATE = 91;
	var HCRC_STATE = 103;
	var BUSY_STATE = 113;
	var FINISH_STATE = 666;
	var BS_NEED_MORE = 1; /* block not completed, need more input or more output */
	var BS_BLOCK_DONE = 2; /* block flush performed */
	var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
	var BS_FINISH_DONE = 4; /* finish done, accept no more input or output */

	var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

	function err(strm, errorCode) {
	  strm.msg = msg$2[errorCode];
	  return errorCode;
	}
	function rank(f) {
	  return (f << 1) - (f > 4 ? 9 : 0);
	}
	function zero(buf) {
	  var len = buf.length;
	  while (--len >= 0) {
	    buf[len] = 0;
	  }
	}

	/* =========================================================================
	 * Flush as much pending output as possible. All deflate() output goes
	 * through this function so some applications may wish to modify it
	 * to avoid allocating a large strm->output buffer and copying into it.
	 * (See also read_buf()).
	 */
	function flush_pending(strm) {
	  var s = strm.state;

	  //_tr_flush_bits(s);
	  var len = s.pending;
	  if (len > strm.avail_out) {
	    len = strm.avail_out;
	  }
	  if (len === 0) {
	    return;
	  }
	  utils$5.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
	  strm.next_out += len;
	  s.pending_out += len;
	  strm.total_out += len;
	  strm.avail_out -= len;
	  s.pending -= len;
	  if (s.pending === 0) {
	    s.pending_out = 0;
	  }
	}
	function flush_block_only(s, last) {
	  trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
	  s.block_start = s.strstart;
	  flush_pending(s.strm);
	}
	function put_byte(s, b) {
	  s.pending_buf[s.pending++] = b;
	}

	/* =========================================================================
	 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
	 * IN assertion: the stream state is correct and there is enough room in
	 * pending_buf.
	 */
	function putShortMSB(s, b) {
	  //  put_byte(s, (Byte)(b >> 8));
	  //  put_byte(s, (Byte)(b & 0xff));
	  s.pending_buf[s.pending++] = b >>> 8 & 0xff;
	  s.pending_buf[s.pending++] = b & 0xff;
	}

	/* ===========================================================================
	 * Read a new buffer from the current input stream, update the adler32
	 * and total number of bytes read.  All deflate() input goes through
	 * this function so some applications may wish to modify it to avoid
	 * allocating a large strm->input buffer and copying from it.
	 * (See also flush_pending()).
	 */
	function read_buf(strm, buf, start, size) {
	  var len = strm.avail_in;
	  if (len > size) {
	    len = size;
	  }
	  if (len === 0) {
	    return 0;
	  }
	  strm.avail_in -= len;

	  // zmemcpy(buf, strm->next_in, len);
	  utils$5.arraySet(buf, strm.input, strm.next_in, len, start);
	  if (strm.state.wrap === 1) {
	    strm.adler = adler32$1(strm.adler, buf, len, start);
	  } else if (strm.state.wrap === 2) {
	    strm.adler = crc32$1(strm.adler, buf, len, start);
	  }
	  strm.next_in += len;
	  strm.total_in += len;
	  return len;
	}

	/* ===========================================================================
	 * Set match_start to the longest match starting at the given string and
	 * return its length. Matches shorter or equal to prev_length are discarded,
	 * in which case the result is equal to prev_length and match_start is
	 * garbage.
	 * IN assertions: cur_match is the head of the hash chain for the current
	 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
	 * OUT assertion: the match length is not greater than s->lookahead.
	 */
	function longest_match(s, cur_match) {
	  var chain_length = s.max_chain_length; /* max hash chain length */
	  var scan = s.strstart; /* current string */
	  var match; /* matched string */
	  var len; /* length of current match */
	  var best_len = s.prev_length; /* best match length so far */
	  var nice_match = s.nice_match; /* stop if match long enough */
	  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/;

	  var _win = s.window; // shortcut

	  var wmask = s.w_mask;
	  var prev = s.prev;

	  /* Stop when cur_match becomes <= limit. To simplify the code,
	   * we prevent matches with the string of window index 0.
	   */

	  var strend = s.strstart + MAX_MATCH;
	  var scan_end1 = _win[scan + best_len - 1];
	  var scan_end = _win[scan + best_len];

	  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
	   * It is easy to get rid of this optimization if necessary.
	   */
	  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

	  /* Do not waste too much time if we already have a good match: */
	  if (s.prev_length >= s.good_match) {
	    chain_length >>= 2;
	  }
	  /* Do not look for matches beyond the end of the input. This is necessary
	   * to make deflate deterministic.
	   */
	  if (nice_match > s.lookahead) {
	    nice_match = s.lookahead;
	  }

	  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

	  do {
	    // Assert(cur_match < s->strstart, "no future");
	    match = cur_match;

	    /* Skip to next match if the match length cannot increase
	     * or if the match length is less than 2.  Note that the checks below
	     * for insufficient lookahead only occur occasionally for performance
	     * reasons.  Therefore uninitialized memory will be accessed, and
	     * conditional jumps will be made that depend on those values.
	     * However the length of the match is limited to the lookahead, so
	     * the output of deflate is not affected by the uninitialized values.
	     */

	    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
	      continue;
	    }

	    /* The check at best_len-1 can be removed because it will be made
	     * again later. (This heuristic is not always a win.)
	     * It is not necessary to compare scan[2] and match[2] since they
	     * are always equal when the other bytes match, given that
	     * the hash keys are equal and that HASH_BITS >= 8.
	     */
	    scan += 2;
	    match++;
	    // Assert(*scan == *match, "match[2]?");

	    /* We check for insufficient lookahead only every 8th comparison;
	     * the 256th check will be made at strstart+258.
	     */
	    do {
	      /*jshint noempty:false*/
	    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);

	    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

	    len = MAX_MATCH - (strend - scan);
	    scan = strend - MAX_MATCH;
	    if (len > best_len) {
	      s.match_start = cur_match;
	      best_len = len;
	      if (len >= nice_match) {
	        break;
	      }
	      scan_end1 = _win[scan + best_len - 1];
	      scan_end = _win[scan + best_len];
	    }
	  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
	  if (best_len <= s.lookahead) {
	    return best_len;
	  }
	  return s.lookahead;
	}

	/* ===========================================================================
	 * Fill the window when the lookahead becomes insufficient.
	 * Updates strstart and lookahead.
	 *
	 * IN assertion: lookahead < MIN_LOOKAHEAD
	 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
	 *    At least one byte has been read, or avail_in == 0; reads are
	 *    performed for at least two bytes (required for the zip translate_eol
	 *    option -- not supported here).
	 */
	function fill_window(s) {
	  var _w_size = s.w_size;
	  var p, n, m, more, str;

	  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

	  do {
	    more = s.window_size - s.lookahead - s.strstart;

	    // JS ints have 32 bit, block below not needed
	    /* Deal with !@#$% 64K limit: */
	    //if (sizeof(int) <= 2) {
	    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
	    //        more = wsize;
	    //
	    //  } else if (more == (unsigned)(-1)) {
	    //        /* Very unlikely, but possible on 16 bit machine if
	    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
	    //         */
	    //        more--;
	    //    }
	    //}

	    /* If the window is almost full and there is insufficient lookahead,
	     * move the upper half to the lower one to make room in the upper half.
	     */
	    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
	      utils$5.arraySet(s.window, s.window, _w_size, _w_size, 0);
	      s.match_start -= _w_size;
	      s.strstart -= _w_size;
	      /* we now have strstart >= MAX_DIST */
	      s.block_start -= _w_size;

	      /* Slide the hash table (could be avoided with 32 bit values
	       at the expense of memory usage). We slide even when level == 0
	       to keep the hash table consistent if we switch back to level > 0
	       later. (Using level 0 permanently is not an optimal usage of
	       zlib, so we don't care about this pathological case.)
	       */

	      n = s.hash_size;
	      p = n;
	      do {
	        m = s.head[--p];
	        s.head[p] = m >= _w_size ? m - _w_size : 0;
	      } while (--n);
	      n = _w_size;
	      p = n;
	      do {
	        m = s.prev[--p];
	        s.prev[p] = m >= _w_size ? m - _w_size : 0;
	        /* If n is not on any hash chain, prev[n] is garbage but
	         * its value will never be used.
	         */
	      } while (--n);
	      more += _w_size;
	    }
	    if (s.strm.avail_in === 0) {
	      break;
	    }

	    /* If there was no sliding:
	     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
	     *    more == window_size - lookahead - strstart
	     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
	     * => more >= window_size - 2*WSIZE + 2
	     * In the BIG_MEM or MMAP case (not yet supported),
	     *   window_size == input_size + MIN_LOOKAHEAD  &&
	     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
	     * Otherwise, window_size == 2*WSIZE so more >= 2.
	     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
	     */
	    //Assert(more >= 2, "more < 2");
	    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
	    s.lookahead += n;

	    /* Initialize the hash value now that we have some input: */
	    if (s.lookahead + s.insert >= MIN_MATCH) {
	      str = s.strstart - s.insert;
	      s.ins_h = s.window[str];

	      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
	      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
	      //#if MIN_MATCH != 3
	      //        Call update_hash() MIN_MATCH-3 more times
	      //#endif
	      while (s.insert) {
	        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
	        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
	        s.prev[str & s.w_mask] = s.head[s.ins_h];
	        s.head[s.ins_h] = str;
	        str++;
	        s.insert--;
	        if (s.lookahead + s.insert < MIN_MATCH) {
	          break;
	        }
	      }
	    }
	    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
	     * but this is not important since only literal bytes will be emitted.
	     */
	  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

	  /* If the WIN_INIT bytes after the end of the current data have never been
	   * written, then zero those bytes in order to avoid memory check reports of
	   * the use of uninitialized (or uninitialised as Julian writes) bytes by
	   * the longest match routines.  Update the high water mark for the next
	   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
	   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
	   */
	  //  if (s.high_water < s.window_size) {
	  //    var curr = s.strstart + s.lookahead;
	  //    var init = 0;
	  //
	  //    if (s.high_water < curr) {
	  //      /* Previous high water mark below current data -- zero WIN_INIT
	  //       * bytes or up to end of window, whichever is less.
	  //       */
	  //      init = s.window_size - curr;
	  //      if (init > WIN_INIT)
	  //        init = WIN_INIT;
	  //      zmemzero(s->window + curr, (unsigned)init);
	  //      s->high_water = curr + init;
	  //    }
	  //    else if (s->high_water < (ulg)curr + WIN_INIT) {
	  //      /* High water mark at or above current data, but below current data
	  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
	  //       * to end of window, whichever is less.
	  //       */
	  //      init = (ulg)curr + WIN_INIT - s->high_water;
	  //      if (init > s->window_size - s->high_water)
	  //        init = s->window_size - s->high_water;
	  //      zmemzero(s->window + s->high_water, (unsigned)init);
	  //      s->high_water += init;
	  //    }
	  //  }
	  //
	  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
	  //    "not enough room for search");
	}

	/* ===========================================================================
	 * Copy without compression as much as possible from the input stream, return
	 * the current block state.
	 * This function does not insert new strings in the dictionary since
	 * uncompressible data is probably not useful. This function is used
	 * only for the level=0 compression option.
	 * NOTE: this function should be optimized to avoid extra copying from
	 * window to pending_buf.
	 */
	function deflate_stored(s, flush) {
	  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
	   * to pending_buf_size, and each stored block has a 5 byte header:
	   */
	  var max_block_size = 0xffff;
	  if (max_block_size > s.pending_buf_size - 5) {
	    max_block_size = s.pending_buf_size - 5;
	  }

	  /* Copy as much as possible from input to output: */
	  for (;;) {
	    /* Fill the window as much as possible: */
	    if (s.lookahead <= 1) {
	      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
	      //  s->block_start >= (long)s->w_size, "slide too late");
	      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
	      //        s.block_start >= s.w_size)) {
	      //        throw  new Error("slide too late");
	      //      }

	      fill_window(s);
	      if (s.lookahead === 0 && flush === Z_NO_FLUSH$1) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) {
	        break;
	      }
	      /* flush the current block */
	    }
	    //Assert(s->block_start >= 0L, "block gone");
	    //    if (s.block_start < 0) throw new Error("block gone");

	    s.strstart += s.lookahead;
	    s.lookahead = 0;

	    /* Emit a stored block if pending_buf will be full: */
	    var max_start = s.block_start + max_block_size;
	    if (s.strstart === 0 || s.strstart >= max_start) {
	      /* strstart == 0 is possible when wraparound on 16-bit machine */
	      s.lookahead = s.strstart - max_start;
	      s.strstart = max_start;
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	    /* Flush if we may have to slide, otherwise block_start may become
	     * negative and the data will be gone:
	     */
	    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }

	  s.insert = 0;
	  if (flush === Z_FINISH$2) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.strstart > s.block_start) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }

	  return BS_NEED_MORE;
	}

	/* ===========================================================================
	 * Compress as much as possible from the input stream, return the current
	 * block state.
	 * This function does not perform lazy evaluation of matches and inserts
	 * new strings in the dictionary only for unmatched strings or for short
	 * matches. It is used only for the fast compression options.
	 */
	function deflate_fast(s, flush) {
	  var hash_head; /* head of the hash chain */
	  var bflush; /* set if current block must be flushed */

	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) {
	        break; /* flush the current block */
	      }
	    }

	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0 /*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }

	    /* Find the longest match, discarding those <= prev_length.
	     * At this point we have always match_length < MIN_MATCH
	     */
	    if (hash_head !== 0 /*NIL*/ && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */
	    }

	    if (s.match_length >= MIN_MATCH) {
	      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

	      /*** _tr_tally_dist(s, s.strstart - s.match_start,
	                     s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
	      s.lookahead -= s.match_length;

	      /* Insert new strings in the hash table only if the match length
	       * is not too large. This saves time but degrades compression.
	       */
	      if (s.match_length <= s.max_lazy_match /*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
	        s.match_length--; /* string at strstart already in table */
	        do {
	          s.strstart++;
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
	           * always MIN_MATCH bytes ahead.
	           */
	        } while (--s.match_length !== 0);
	        s.strstart++;
	      } else {
	        s.strstart += s.match_length;
	        s.match_length = 0;
	        s.ins_h = s.window[s.strstart];
	        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
	        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;

	        //#if MIN_MATCH != 3
	        //                Call UPDATE_HASH() MIN_MATCH-3 more times
	        //#endif
	        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
	         * matter since it will be recomputed at next deflate call.
	         */
	      }
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s.window[s.strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }

	  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
	  if (flush === Z_FINISH$2) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }

	  return BS_BLOCK_DONE;
	}

	/* ===========================================================================
	 * Same as above, but achieves better compression. We use a lazy
	 * evaluation for matches: a match is finally adopted only if there is
	 * no better match at the next window position.
	 */
	function deflate_slow(s, flush) {
	  var hash_head; /* head of hash chain */
	  var bflush; /* set if current block must be flushed */

	  var max_insert;

	  /* Process the input block. */
	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) {
	        break;
	      } /* flush the current block */
	    }

	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0 /*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }

	    /* Find the longest match, discarding those <= prev_length.
	     */
	    s.prev_length = s.match_length;
	    s.prev_match = s.match_start;
	    s.match_length = MIN_MATCH - 1;
	    if (hash_head !== 0 /*NIL*/ && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD /*MAX_DIST(s)*/) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */

	      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/)) {
	        /* If prev_match is also MIN_MATCH, match_start is garbage
	         * but we will ignore the current match anyway.
	         */
	        s.match_length = MIN_MATCH - 1;
	      }
	    }
	    /* If there was a match at the previous step and the current
	     * match is not better, output the previous match:
	     */
	    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
	      max_insert = s.strstart + s.lookahead - MIN_MATCH;
	      /* Do not insert strings in hash table beyond this. */

	      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

	      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
	                     s.prev_length - MIN_MATCH, bflush);***/
	      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
	      /* Insert in hash table all strings up to the end of the match.
	       * strstart-1 and strstart are already inserted. If there is not
	       * enough lookahead, the last two strings are not inserted in
	       * the hash table.
	       */
	      s.lookahead -= s.prev_length - 1;
	      s.prev_length -= 2;
	      do {
	        if (++s.strstart <= max_insert) {
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	        }
	      } while (--s.prev_length !== 0);
	      s.match_available = 0;
	      s.match_length = MIN_MATCH - 1;
	      s.strstart++;
	      if (bflush) {
	        /*** FLUSH_BLOCK(s, 0); ***/
	        flush_block_only(s, false);
	        if (s.strm.avail_out === 0) {
	          return BS_NEED_MORE;
	        }
	        /***/
	      }
	    } else if (s.match_available) {
	      /* If there was no match at the previous position, output a
	       * single literal. If there was a match but the current match
	       * is longer, truncate the previous match to a single literal.
	       */
	      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
	      if (bflush) {
	        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
	        flush_block_only(s, false);
	        /***/
	      }

	      s.strstart++;
	      s.lookahead--;
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	    } else {
	      /* There is no previous match to compare with, wait for
	       * the next step to decide.
	       */
	      s.match_available = 1;
	      s.strstart++;
	      s.lookahead--;
	    }
	  }
	  //Assert (flush != Z_NO_FLUSH, "no flush?");
	  if (s.match_available) {
	    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
	    s.match_available = 0;
	  }
	  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
	  if (flush === Z_FINISH$2) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }

	  return BS_BLOCK_DONE;
	}

	/* ===========================================================================
	 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
	 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
	 * deflate switches away from Z_RLE.)
	 */
	function deflate_rle(s, flush) {
	  var bflush; /* set if current block must be flushed */
	  var prev; /* byte at distance one to match */
	  var scan, strend; /* scan goes up to strend for length of run */

	  var _win = s.window;
	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the longest run, plus one for the unrolled loop.
	     */
	    if (s.lookahead <= MAX_MATCH) {
	      fill_window(s);
	      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$1) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) {
	        break;
	      } /* flush the current block */
	    }

	    /* See how many times the previous byte repeats */
	    s.match_length = 0;
	    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
	      scan = s.strstart - 1;
	      prev = _win[scan];
	      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
	        strend = s.strstart + MAX_MATCH;
	        do {
	          /*jshint noempty:false*/
	        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
	        s.match_length = MAX_MATCH - (strend - scan);
	        if (s.match_length > s.lookahead) {
	          s.match_length = s.lookahead;
	        }
	      }
	      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
	    }

	    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
	    if (s.match_length >= MIN_MATCH) {
	      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

	      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
	      s.lookahead -= s.match_length;
	      s.strstart += s.match_length;
	      s.match_length = 0;
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s->window[s->strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }

	  s.insert = 0;
	  if (flush === Z_FINISH$2) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }

	  return BS_BLOCK_DONE;
	}

	/* ===========================================================================
	 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
	 * (It will be regenerated if this run of deflate switches away from Huffman.)
	 */
	function deflate_huff(s, flush) {
	  var bflush; /* set if current block must be flushed */

	  for (;;) {
	    /* Make sure that we have a literal to write. */
	    if (s.lookahead === 0) {
	      fill_window(s);
	      if (s.lookahead === 0) {
	        if (flush === Z_NO_FLUSH$1) {
	          return BS_NEED_MORE;
	        }
	        break; /* flush the current block */
	      }
	    }

	    /* Output a literal byte */
	    s.match_length = 0;
	    //Tracevv((stderr,"%c", s->window[s->strstart]));
	    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	    s.lookahead--;
	    s.strstart++;
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }

	  s.insert = 0;
	  if (flush === Z_FINISH$2) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }

	  return BS_BLOCK_DONE;
	}

	/* Values for max_lazy_match, good_match and max_chain_length, depending on
	 * the desired pack level (0..9). The values given below have been tuned to
	 * exclude worst case performance for pathological files. Better values may be
	 * found for specific files.
	 */
	function Config(good_length, max_lazy, nice_length, max_chain, func) {
	  this.good_length = good_length;
	  this.max_lazy = max_lazy;
	  this.nice_length = nice_length;
	  this.max_chain = max_chain;
	  this.func = func;
	}
	var configuration_table;
	configuration_table = [
	/*#__PURE__*/
	/*      good lazy nice chain */
	new Config(0, 0, 0, 0, deflate_stored),
	/*#__PURE__*/
	/* 0 store only */
	new Config(4, 4, 8, 4, deflate_fast),
	/*#__PURE__*/
	/* 1 max speed, no lazy matches */
	new Config(4, 5, 16, 8, deflate_fast),
	/*#__PURE__*/
	/* 2 */
	new Config(4, 6, 32, 32, deflate_fast),
	/*#__PURE__*/
	/* 3 */
	new Config(4, 4, 16, 16, deflate_slow),
	/*#__PURE__*/
	/* 4 lazy matches */
	new Config(8, 16, 32, 32, deflate_slow),
	/*#__PURE__*/
	/* 5 */
	new Config(8, 16, 128, 128, deflate_slow),
	/*#__PURE__*/
	/* 6 */
	new Config(8, 32, 128, 256, deflate_slow),
	/*#__PURE__*/
	/* 7 */
	new Config(32, 128, 258, 1024, deflate_slow),
	/*#__PURE__*/
	/* 8 */
	new Config(32, 258, 258, 4096, deflate_slow) /* 9 max compression */];

	/* ===========================================================================
	 * Initialize the "longest match" routines for a new zlib stream
	 */
	function lm_init(s) {
	  s.window_size = 2 * s.w_size;

	  /*** CLEAR_HASH(s); ***/
	  zero(s.head); // Fill with NIL (= 0);

	  /* Set the default configuration parameters:
	   */
	  s.max_lazy_match = configuration_table[s.level].max_lazy;
	  s.good_match = configuration_table[s.level].good_length;
	  s.nice_match = configuration_table[s.level].nice_length;
	  s.max_chain_length = configuration_table[s.level].max_chain;
	  s.strstart = 0;
	  s.block_start = 0;
	  s.lookahead = 0;
	  s.insert = 0;
	  s.match_length = s.prev_length = MIN_MATCH - 1;
	  s.match_available = 0;
	  s.ins_h = 0;
	}
	function DeflateState() {
	  this.strm = null; /* pointer back to this zlib stream */
	  this.status = 0; /* as the name implies */
	  this.pending_buf = null; /* output still pending */
	  this.pending_buf_size = 0; /* size of pending_buf */
	  this.pending_out = 0; /* next pending byte to output to the stream */
	  this.pending = 0; /* nb of bytes in the pending buffer */
	  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
	  this.gzhead = null; /* gzip header information to write */
	  this.gzindex = 0; /* where in extra, name, or comment */
	  this.method = Z_DEFLATED$2; /* can only be DEFLATED */
	  this.last_flush = -1; /* value of flush param for previous deflate call */

	  this.w_size = 0; /* LZ77 window size (32K by default) */
	  this.w_bits = 0; /* log2(w_size)  (8..16) */
	  this.w_mask = 0; /* w_size - 1 */

	  this.window = null;
	  /* Sliding window. Input bytes are read into the second half of the window,
	   * and move to the first half later to keep a dictionary of at least wSize
	   * bytes. With this organization, matches are limited to a distance of
	   * wSize-MAX_MATCH bytes, but this ensures that IO is always
	   * performed with a length multiple of the block size.
	   */

	  this.window_size = 0;
	  /* Actual size of window: 2*wSize, except when the user input buffer
	   * is directly used as sliding window.
	   */

	  this.prev = null;
	  /* Link to older string with same hash index. To limit the size of this
	   * array to 64K, this link is maintained only for the last 32K strings.
	   * An index in this array is thus a window index modulo 32K.
	   */

	  this.head = null; /* Heads of the hash chains or NIL. */

	  this.ins_h = 0; /* hash index of string to be inserted */
	  this.hash_size = 0; /* number of elements in hash table */
	  this.hash_bits = 0; /* log2(hash_size) */
	  this.hash_mask = 0; /* hash_size-1 */

	  this.hash_shift = 0;
	  /* Number of bits by which ins_h must be shifted at each input
	   * step. It must be such that after MIN_MATCH steps, the oldest
	   * byte no longer takes part in the hash key, that is:
	   *   hash_shift * MIN_MATCH >= hash_bits
	   */

	  this.block_start = 0;
	  /* Window position at the beginning of the current output block. Gets
	   * negative when the window is moved backwards.
	   */

	  this.match_length = 0; /* length of best match */
	  this.prev_match = 0; /* previous match */
	  this.match_available = 0; /* set if previous match exists */
	  this.strstart = 0; /* start of string to insert */
	  this.match_start = 0; /* start of matching string */
	  this.lookahead = 0; /* number of valid bytes ahead in window */

	  this.prev_length = 0;
	  /* Length of the best match at previous step. Matches not greater than this
	   * are discarded. This is used in the lazy match evaluation.
	   */

	  this.max_chain_length = 0;
	  /* To speed up deflation, hash chains are never searched beyond this
	   * length.  A higher limit improves compression ratio but degrades the
	   * speed.
	   */

	  this.max_lazy_match = 0;
	  /* Attempt to find a better match only when the current match is strictly
	   * smaller than this value. This mechanism is used only for compression
	   * levels >= 4.
	   */
	  // That's alias to max_lazy_match, don't use directly
	  //this.max_insert_length = 0;
	  /* Insert new strings in the hash table only if the match length is not
	   * greater than this length. This saves time but degrades compression.
	   * max_insert_length is used only for compression levels <= 3.
	   */

	  this.level = 0; /* compression level (1..9) */
	  this.strategy = 0; /* favor or force Huffman coding*/

	  this.good_match = 0;
	  /* Use a faster search when the previous match is longer than this */

	  this.nice_match = 0; /* Stop searching when current match exceeds this */

	  /* used by trees.c: */

	  /* Didn't use ct_data typedef below to suppress compiler warning */

	  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
	  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
	  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

	  // Use flat array of DOUBLE size, with interleaved fata,
	  // because JS does not support effective
	  this.dyn_ltree = new utils$5.Buf16(HEAP_SIZE * 2);
	  this.dyn_dtree = new utils$5.Buf16((2 * D_CODES + 1) * 2);
	  this.bl_tree = new utils$5.Buf16((2 * BL_CODES + 1) * 2);
	  zero(this.dyn_ltree);
	  zero(this.dyn_dtree);
	  zero(this.bl_tree);
	  this.l_desc = null; /* desc. for literal tree */
	  this.d_desc = null; /* desc. for distance tree */
	  this.bl_desc = null; /* desc. for bit length tree */

	  //ush bl_count[MAX_BITS+1];
	  this.bl_count = new utils$5.Buf16(MAX_BITS + 1);
	  /* number of codes at each bit length for an optimal tree */

	  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
	  this.heap = new utils$5.Buf16(2 * L_CODES + 1); /* heap used to build the Huffman trees */
	  zero(this.heap);
	  this.heap_len = 0; /* number of elements in the heap */
	  this.heap_max = 0; /* element of largest frequency */
	  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
	   * The same heap array is used to build all trees.
	   */

	  this.depth = new utils$5.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
	  zero(this.depth);
	  /* Depth of each subtree used as tie breaker for trees of equal frequency
	   */

	  this.l_buf = 0; /* buffer index for literals or lengths */

	  this.lit_bufsize = 0;
	  /* Size of match buffer for literals/lengths.  There are 4 reasons for
	   * limiting lit_bufsize to 64K:
	   *   - frequencies can be kept in 16 bit counters
	   *   - if compression is not successful for the first block, all input
	   *     data is still in the window so we can still emit a stored block even
	   *     when input comes from standard input.  (This can also be done for
	   *     all blocks if lit_bufsize is not greater than 32K.)
	   *   - if compression is not successful for a file smaller than 64K, we can
	   *     even emit a stored file instead of a stored block (saving 5 bytes).
	   *     This is applicable only for zip (not gzip or zlib).
	   *   - creating new Huffman trees less frequently may not provide fast
	   *     adaptation to changes in the input data statistics. (Take for
	   *     example a binary file with poorly compressible code followed by
	   *     a highly compressible string table.) Smaller buffer sizes give
	   *     fast adaptation but have of course the overhead of transmitting
	   *     trees more frequently.
	   *   - I can't count above 4
	   */

	  this.last_lit = 0; /* running index in l_buf */

	  this.d_buf = 0;
	  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
	   * the same number of elements. To use different lengths, an extra flag
	   * array would be necessary.
	   */

	  this.opt_len = 0; /* bit length of current block with optimal trees */
	  this.static_len = 0; /* bit length of current block with static trees */
	  this.matches = 0; /* number of string matches in current block */
	  this.insert = 0; /* bytes at end of window left to insert */

	  this.bi_buf = 0;
	  /* Output buffer. bits are inserted starting at the bottom (least
	   * significant bits).
	   */
	  this.bi_valid = 0;
	  /* Number of valid bits in bi_buf.  All bits above the last valid bit
	   * are always zero.
	   */

	  // Used for window memory init. We safely ignore it for JS. That makes
	  // sense only for pointers and memory check tools.
	  //this.high_water = 0;
	  /* High water mark offset in window for initialized bytes -- bytes above
	   * this are set to zero in order to avoid memory check warnings when
	   * longest match routines access bytes past the input.  This is then
	   * updated to the new high water mark.
	   */
	}

	function deflateResetKeep(strm) {
	  var s;
	  if (!strm || !strm.state) {
	    return err(strm, Z_STREAM_ERROR$1);
	  }
	  strm.total_in = strm.total_out = 0;
	  strm.data_type = Z_UNKNOWN;
	  s = strm.state;
	  s.pending = 0;
	  s.pending_out = 0;
	  if (s.wrap < 0) {
	    s.wrap = -s.wrap;
	    /* was made negative by deflate(..., Z_FINISH); */
	  }

	  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
	  strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
	  : 1; // adler32(0, Z_NULL, 0)
	  s.last_flush = Z_NO_FLUSH$1;
	  trees._tr_init(s);
	  return Z_OK$2;
	}
	function deflateReset(strm) {
	  var ret = deflateResetKeep(strm);
	  if (ret === Z_OK$2) {
	    lm_init(strm.state);
	  }
	  return ret;
	}
	function deflateSetHeader(strm, head) {
	  if (!strm || !strm.state) {
	    return Z_STREAM_ERROR$1;
	  }
	  if (strm.state.wrap !== 2) {
	    return Z_STREAM_ERROR$1;
	  }
	  strm.state.gzhead = head;
	  return Z_OK$2;
	}
	function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
	  if (!strm) {
	    // === Z_NULL
	    return Z_STREAM_ERROR$1;
	  }
	  var wrap = 1;
	  if (level === Z_DEFAULT_COMPRESSION$1) {
	    level = 6;
	  }
	  if (windowBits < 0) {
	    /* suppress zlib wrapper */
	    wrap = 0;
	    windowBits = -windowBits;
	  } else if (windowBits > 15) {
	    wrap = 2; /* write gzip wrapper instead */
	    windowBits -= 16;
	  }
	  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
	    return err(strm, Z_STREAM_ERROR$1);
	  }
	  if (windowBits === 8) {
	    windowBits = 9;
	  }
	  /* until 256-byte window bug fixed */

	  var s = new DeflateState();
	  strm.state = s;
	  s.strm = strm;
	  s.wrap = wrap;
	  s.gzhead = null;
	  s.w_bits = windowBits;
	  s.w_size = 1 << s.w_bits;
	  s.w_mask = s.w_size - 1;
	  s.hash_bits = memLevel + 7;
	  s.hash_size = 1 << s.hash_bits;
	  s.hash_mask = s.hash_size - 1;
	  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
	  s.window = new utils$5.Buf8(s.w_size * 2);
	  s.head = new utils$5.Buf16(s.hash_size);
	  s.prev = new utils$5.Buf16(s.w_size);

	  // Don't need mem init magic for JS.
	  //s.high_water = 0;  /* nothing written to s->window yet */

	  s.lit_bufsize = 1 << memLevel + 6; /* 16K elements by default */

	  s.pending_buf_size = s.lit_bufsize * 4;

	  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
	  //s->pending_buf = (uchf *) overlay;
	  s.pending_buf = new utils$5.Buf8(s.pending_buf_size);

	  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
	  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
	  s.d_buf = 1 * s.lit_bufsize;

	  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
	  s.l_buf = (1 + 2) * s.lit_bufsize;
	  s.level = level;
	  s.strategy = strategy;
	  s.method = method;
	  return deflateReset(strm);
	}
	function deflateInit(strm, level) {
	  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
	}
	function deflate$2(strm, flush) {
	  var old_flush, s;
	  var beg, val; // for gzip header write only

	  if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {
	    return strm ? err(strm, Z_STREAM_ERROR$1) : Z_STREAM_ERROR$1;
	  }
	  s = strm.state;
	  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH$2) {
	    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$1);
	  }
	  s.strm = strm; /* just in case */
	  old_flush = s.last_flush;
	  s.last_flush = flush;

	  /* Write the header */
	  if (s.status === INIT_STATE) {
	    if (s.wrap === 2) {
	      // GZIP header
	      strm.adler = 0; //crc32(0L, Z_NULL, 0);
	      put_byte(s, 31);
	      put_byte(s, 139);
	      put_byte(s, 8);
	      if (!s.gzhead) {
	        // s->gzhead == Z_NULL
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
	        put_byte(s, OS_CODE);
	        s.status = BUSY_STATE;
	      } else {
	        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
	        put_byte(s, s.gzhead.time & 0xff);
	        put_byte(s, s.gzhead.time >> 8 & 0xff);
	        put_byte(s, s.gzhead.time >> 16 & 0xff);
	        put_byte(s, s.gzhead.time >> 24 & 0xff);
	        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
	        put_byte(s, s.gzhead.os & 0xff);
	        if (s.gzhead.extra && s.gzhead.extra.length) {
	          put_byte(s, s.gzhead.extra.length & 0xff);
	          put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
	        }
	        if (s.gzhead.hcrc) {
	          strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending, 0);
	        }
	        s.gzindex = 0;
	        s.status = EXTRA_STATE;
	      }
	    } else
	      // DEFLATE header
	      {
	        var header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
	        var level_flags = -1;
	        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
	          level_flags = 0;
	        } else if (s.level < 6) {
	          level_flags = 1;
	        } else if (s.level === 6) {
	          level_flags = 2;
	        } else {
	          level_flags = 3;
	        }
	        header |= level_flags << 6;
	        if (s.strstart !== 0) {
	          header |= PRESET_DICT;
	        }
	        header += 31 - header % 31;
	        s.status = BUSY_STATE;
	        putShortMSB(s, header);

	        /* Save the adler32 of the preset dictionary: */
	        if (s.strstart !== 0) {
	          putShortMSB(s, strm.adler >>> 16);
	          putShortMSB(s, strm.adler & 0xffff);
	        }
	        strm.adler = 1; // adler32(0L, Z_NULL, 0);
	      }
	  }

	  //#ifdef GZIP
	  if (s.status === EXTRA_STATE) {
	    if (s.gzhead.extra /* != Z_NULL*/) {
	      beg = s.pending; /* start of bytes to update crc */

	      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            break;
	          }
	        }
	        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
	        s.gzindex++;
	      }
	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (s.gzindex === s.gzhead.extra.length) {
	        s.gzindex = 0;
	        s.status = NAME_STATE;
	      }
	    } else {
	      s.status = NAME_STATE;
	    }
	  }
	  if (s.status === NAME_STATE) {
	    if (s.gzhead.name /* != Z_NULL*/) {
	      beg = s.pending; /* start of bytes to update crc */
	      //int val;

	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.name.length) {
	          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);
	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.gzindex = 0;
	        s.status = COMMENT_STATE;
	      }
	    } else {
	      s.status = COMMENT_STATE;
	    }
	  }
	  if (s.status === COMMENT_STATE) {
	    if (s.gzhead.comment /* != Z_NULL*/) {
	      beg = s.pending; /* start of bytes to update crc */
	      //int val;

	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.comment.length) {
	          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);
	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.status = HCRC_STATE;
	      }
	    } else {
	      s.status = HCRC_STATE;
	    }
	  }
	  if (s.status === HCRC_STATE) {
	    if (s.gzhead.hcrc) {
	      if (s.pending + 2 > s.pending_buf_size) {
	        flush_pending(strm);
	      }
	      if (s.pending + 2 <= s.pending_buf_size) {
	        put_byte(s, strm.adler & 0xff);
	        put_byte(s, strm.adler >> 8 & 0xff);
	        strm.adler = 0; //crc32(0L, Z_NULL, 0);
	        s.status = BUSY_STATE;
	      }
	    } else {
	      s.status = BUSY_STATE;
	    }
	  }
	  //#endif

	  /* Flush as much pending output as possible */
	  if (s.pending !== 0) {
	    flush_pending(strm);
	    if (strm.avail_out === 0) {
	      /* Since avail_out is 0, deflate will be called again with
	       * more output space, but possibly with both pending and
	       * avail_in equal to zero. There won't be anything to do,
	       * but this is not an error situation so make sure we
	       * return OK instead of BUF_ERROR at next call of deflate:
	       */
	      s.last_flush = -1;
	      return Z_OK$2;
	    }

	    /* Make sure there is something to do and avoid duplicate consecutive
	     * flushes. For repeated and useless calls with Z_FINISH, we keep
	     * returning Z_STREAM_END instead of Z_BUF_ERROR.
	     */
	  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$2) {
	    return err(strm, Z_BUF_ERROR$1);
	  }

	  /* User must not provide more input after the first FINISH: */
	  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
	    return err(strm, Z_BUF_ERROR$1);
	  }

	  /* Start a new block or continue the current one.
	   */
	  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$1 && s.status !== FINISH_STATE) {
	    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
	    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
	      s.status = FINISH_STATE;
	    }
	    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
	      if (strm.avail_out === 0) {
	        s.last_flush = -1;
	        /* avoid BUF_ERROR next call, see above */
	      }

	      return Z_OK$2;
	      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
	       * of deflate should use the same flush parameter to make sure
	       * that the flush is complete. So we don't have to output an
	       * empty block here, this will be done at next call. This also
	       * ensures that for a very small output buffer, we emit at most
	       * one empty block.
	       */
	    }

	    if (bstate === BS_BLOCK_DONE) {
	      if (flush === Z_PARTIAL_FLUSH) {
	        trees._tr_align(s);
	      } else if (flush !== Z_BLOCK$1) {
	        /* FULL_FLUSH or SYNC_FLUSH */

	        trees._tr_stored_block(s, 0, 0, false);
	        /* For a full flush, this empty block will be recognized
	         * as a special marker by inflate_sync().
	         */
	        if (flush === Z_FULL_FLUSH) {
	          /*** CLEAR_HASH(s); ***/ /* forget history */
	          zero(s.head); // Fill with NIL (= 0);

	          if (s.lookahead === 0) {
	            s.strstart = 0;
	            s.block_start = 0;
	            s.insert = 0;
	          }
	        }
	      }
	      flush_pending(strm);
	      if (strm.avail_out === 0) {
	        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
	        return Z_OK$2;
	      }
	    }
	  }
	  //Assert(strm->avail_out > 0, "bug2");
	  //if (strm.avail_out <= 0) { throw new Error("bug2");}

	  if (flush !== Z_FINISH$2) {
	    return Z_OK$2;
	  }
	  if (s.wrap <= 0) {
	    return Z_STREAM_END$2;
	  }

	  /* Write the trailer */
	  if (s.wrap === 2) {
	    put_byte(s, strm.adler & 0xff);
	    put_byte(s, strm.adler >> 8 & 0xff);
	    put_byte(s, strm.adler >> 16 & 0xff);
	    put_byte(s, strm.adler >> 24 & 0xff);
	    put_byte(s, strm.total_in & 0xff);
	    put_byte(s, strm.total_in >> 8 & 0xff);
	    put_byte(s, strm.total_in >> 16 & 0xff);
	    put_byte(s, strm.total_in >> 24 & 0xff);
	  } else {
	    putShortMSB(s, strm.adler >>> 16);
	    putShortMSB(s, strm.adler & 0xffff);
	  }
	  flush_pending(strm);
	  /* If avail_out is zero, the application will call deflate again
	   * to flush the rest.
	   */
	  if (s.wrap > 0) {
	    s.wrap = -s.wrap;
	  }
	  /* write the trailer only once! */
	  return s.pending !== 0 ? Z_OK$2 : Z_STREAM_END$2;
	}
	function deflateEnd(strm) {
	  var status;
	  if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {
	    return Z_STREAM_ERROR$1;
	  }
	  status = strm.state.status;
	  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
	    return err(strm, Z_STREAM_ERROR$1);
	  }
	  strm.state = null;
	  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$1) : Z_OK$2;
	}

	/* =========================================================================
	 * Initializes the compression dictionary from the given byte
	 * sequence without producing any compressed output.
	 */
	function deflateSetDictionary(strm, dictionary) {
	  var dictLength = dictionary.length;
	  var s;
	  var str, n;
	  var wrap;
	  var avail;
	  var next;
	  var input;
	  var tmpDict;
	  if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {
	    return Z_STREAM_ERROR$1;
	  }
	  s = strm.state;
	  wrap = s.wrap;
	  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
	    return Z_STREAM_ERROR$1;
	  }

	  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
	  if (wrap === 1) {
	    /* adler32(strm->adler, dictionary, dictLength); */
	    strm.adler = adler32$1(strm.adler, dictionary, dictLength, 0);
	  }
	  s.wrap = 0; /* avoid computing Adler-32 in read_buf */

	  /* if dictionary would fill window, just replace the history */
	  if (dictLength >= s.w_size) {
	    if (wrap === 0) {
	      /* already empty otherwise */
	      /*** CLEAR_HASH(s); ***/
	      zero(s.head); // Fill with NIL (= 0);
	      s.strstart = 0;
	      s.block_start = 0;
	      s.insert = 0;
	    }
	    /* use the tail */
	    // dictionary = dictionary.slice(dictLength - s.w_size);
	    tmpDict = new utils$5.Buf8(s.w_size);
	    utils$5.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
	    dictionary = tmpDict;
	    dictLength = s.w_size;
	  }
	  /* insert dictionary into window and hash */
	  avail = strm.avail_in;
	  next = strm.next_in;
	  input = strm.input;
	  strm.avail_in = dictLength;
	  strm.next_in = 0;
	  strm.input = dictionary;
	  fill_window(s);
	  while (s.lookahead >= MIN_MATCH) {
	    str = s.strstart;
	    n = s.lookahead - (MIN_MATCH - 1);
	    do {
	      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
	      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
	      s.prev[str & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = str;
	      str++;
	    } while (--n);
	    s.strstart = str;
	    s.lookahead = MIN_MATCH - 1;
	    fill_window(s);
	  }
	  s.strstart += s.lookahead;
	  s.block_start = s.strstart;
	  s.insert = s.lookahead;
	  s.lookahead = 0;
	  s.match_length = s.prev_length = MIN_MATCH - 1;
	  s.match_available = 0;
	  strm.next_in = next;
	  strm.input = input;
	  strm.avail_in = avail;
	  s.wrap = wrap;
	  return Z_OK$2;
	}
	deflate$3.deflateInit = deflateInit;
	deflate$3.deflateInit2 = deflateInit2;
	deflate$3.deflateReset = deflateReset;
	deflate$3.deflateResetKeep = deflateResetKeep;
	deflate$3.deflateSetHeader = deflateSetHeader;
	deflate$3.deflate = deflate$2;
	deflate$3.deflateEnd = deflateEnd;
	deflate$3.deflateSetDictionary = deflateSetDictionary;
	deflate$3.deflateInfo = 'pako deflate (from Nodeca project)';

	var strings$2 = {};

	var utils$4 = common;

	// Quick check if we can use fast array to bin string conversion
	//
	// - apply(Array) can fail on Android 2.2
	// - apply(Uint8Array) can fail on iOS 5.1 Safari
	//
	var STR_APPLY_OK = true;
	var STR_APPLY_UIA_OK = true;
	try {
	  String.fromCharCode.apply(null, [0]);
	} catch (__) {
	  STR_APPLY_OK = false;
	}
	try {
	  String.fromCharCode.apply(null, new Uint8Array(1));
	} catch (__) {
	  STR_APPLY_UIA_OK = false;
	}

	// Table with utf8 lengths (calculated by first byte of sequence)
	// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
	// because max possible codepoint is 0x10ffff
	var _utf8len = /*#__PURE__*/new utils$4.Buf8(256);
	for (var q = 0; q < 256; q++) {
	  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
	}
	_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start

	// convert string to array (typed, when possible)
	strings$2.string2buf = function (str) {
	  var buf,
	    c,
	    c2,
	    m_pos,
	    i,
	    str_len = str.length,
	    buf_len = 0;

	  // count binary size
	  for (m_pos = 0; m_pos < str_len; m_pos++) {
	    c = str.charCodeAt(m_pos);
	    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
	      c2 = str.charCodeAt(m_pos + 1);
	      if ((c2 & 0xfc00) === 0xdc00) {
	        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
	        m_pos++;
	      }
	    }
	    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
	  }

	  // allocate buffer
	  buf = new utils$4.Buf8(buf_len);

	  // convert
	  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
	    c = str.charCodeAt(m_pos);
	    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
	      c2 = str.charCodeAt(m_pos + 1);
	      if ((c2 & 0xfc00) === 0xdc00) {
	        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
	        m_pos++;
	      }
	    }
	    if (c < 0x80) {
	      /* one byte */
	      buf[i++] = c;
	    } else if (c < 0x800) {
	      /* two bytes */
	      buf[i++] = 0xC0 | c >>> 6;
	      buf[i++] = 0x80 | c & 0x3f;
	    } else if (c < 0x10000) {
	      /* three bytes */
	      buf[i++] = 0xE0 | c >>> 12;
	      buf[i++] = 0x80 | c >>> 6 & 0x3f;
	      buf[i++] = 0x80 | c & 0x3f;
	    } else {
	      /* four bytes */
	      buf[i++] = 0xf0 | c >>> 18;
	      buf[i++] = 0x80 | c >>> 12 & 0x3f;
	      buf[i++] = 0x80 | c >>> 6 & 0x3f;
	      buf[i++] = 0x80 | c & 0x3f;
	    }
	  }
	  return buf;
	};

	// Helper (used in 2 places)
	function buf2binstring(buf, len) {
	  // On Chrome, the arguments in a function call that are allowed is `65534`.
	  // If the length of the buffer is smaller than that, we can use this optimization,
	  // otherwise we will take a slower path.
	  if (len < 65534) {
	    if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
	      return String.fromCharCode.apply(null, utils$4.shrinkBuf(buf, len));
	    }
	  }
	  var result = '';
	  for (var i = 0; i < len; i++) {
	    result += String.fromCharCode(buf[i]);
	  }
	  return result;
	}

	// Convert byte array to binary string
	strings$2.buf2binstring = function (buf) {
	  return buf2binstring(buf, buf.length);
	};

	// Convert binary string (typed, when possible)
	strings$2.binstring2buf = function (str) {
	  var buf = new utils$4.Buf8(str.length);
	  for (var i = 0, len = buf.length; i < len; i++) {
	    buf[i] = str.charCodeAt(i);
	  }
	  return buf;
	};

	// convert array to string
	strings$2.buf2string = function (buf, max) {
	  var i, out, c, c_len;
	  var len = max || buf.length;

	  // Reserve max possible length (2 words per char)
	  // NB: by unknown reasons, Array is significantly faster for
	  //     String.fromCharCode.apply than Uint16Array.
	  var utf16buf = new Array(len * 2);
	  for (out = 0, i = 0; i < len;) {
	    c = buf[i++];
	    // quick process ascii
	    if (c < 0x80) {
	      utf16buf[out++] = c;
	      continue;
	    }
	    c_len = _utf8len[c];
	    // skip 5 & 6 byte codes
	    if (c_len > 4) {
	      utf16buf[out++] = 0xfffd;
	      i += c_len - 1;
	      continue;
	    }

	    // apply mask on first byte
	    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
	    // join the rest
	    while (c_len > 1 && i < len) {
	      c = c << 6 | buf[i++] & 0x3f;
	      c_len--;
	    }

	    // terminated by end of string?
	    if (c_len > 1) {
	      utf16buf[out++] = 0xfffd;
	      continue;
	    }
	    if (c < 0x10000) {
	      utf16buf[out++] = c;
	    } else {
	      c -= 0x10000;
	      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
	      utf16buf[out++] = 0xdc00 | c & 0x3ff;
	    }
	  }
	  return buf2binstring(utf16buf, out);
	};

	// Calculate max possible position in utf8 buffer,
	// that will not break sequence. If that's not possible
	// - (very small limits) return max size as is.
	//
	// buf[] - utf8 bytes array
	// max   - length limit (mandatory);
	strings$2.utf8border = function (buf, max) {
	  var pos;
	  max = max || buf.length;
	  if (max > buf.length) {
	    max = buf.length;
	  }

	  // go back from last position, until start of sequence found
	  pos = max - 1;
	  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
	    pos--;
	  }

	  // Very small and broken sequence,
	  // return max, because we should return something anyway.
	  if (pos < 0) {
	    return max;
	  }

	  // If we came to start of buffer - that means buffer is too small,
	  // return max too.
	  if (pos === 0) {
	    return max;
	  }
	  return pos + _utf8len[buf[pos]] > max ? pos : max;
	};

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	function ZStream$2() {
	  /* next input byte */
	  this.input = null; // JS specific, because we have no pointers
	  this.next_in = 0;
	  /* number of bytes available at input */
	  this.avail_in = 0;
	  /* total number of input bytes read so far */
	  this.total_in = 0;
	  /* next output byte should be put there */
	  this.output = null; // JS specific, because we have no pointers
	  this.next_out = 0;
	  /* remaining free space at output */
	  this.avail_out = 0;
	  /* total number of bytes output so far */
	  this.total_out = 0;
	  /* last error message, NULL if no error */
	  this.msg = '' /*Z_NULL*/;
	  /* not visible by applications */
	  this.state = null;
	  /* best guess about the data type: binary or text */
	  this.data_type = 2 /*Z_UNKNOWN*/;
	  /* adler32 value of the uncompressed data */
	  this.adler = 0;
	}
	var zstream = ZStream$2;

	var zlib_deflate = deflate$3;
	var utils$3 = common;
	var strings$1 = strings$2;
	var msg$1 = messages;
	var ZStream$1 = zstream;
	var toString$2 = Object.prototype.toString;

	/* Public constants ==========================================================*/
	/* ===========================================================================*/

	var Z_NO_FLUSH = 0;
	var Z_FINISH$1 = 4;
	var Z_OK$1 = 0;
	var Z_STREAM_END$1 = 1;
	var Z_SYNC_FLUSH = 2;
	var Z_DEFAULT_COMPRESSION = -1;
	var Z_DEFAULT_STRATEGY = 0;
	var Z_DEFLATED$1 = 8;

	/* ===========================================================================*/

	/**
	 * class Deflate
	 *
	 * Generic JS-style wrapper for zlib calls. If you don't need
	 * streaming behaviour - use more simple functions: [[deflate]],
	 * [[deflateRaw]] and [[gzip]].
	 **/

	/* internal
	 * Deflate.chunks -> Array
	 *
	 * Chunks of output data, if [[Deflate#onData]] not overridden.
	 **/

	/**
	 * Deflate.result -> Uint8Array|Array
	 *
	 * Compressed result, generated by default [[Deflate#onData]]
	 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
	 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
	 * push a chunk with explicit flush (call [[Deflate#push]] with
	 * `Z_SYNC_FLUSH` param).
	 **/

	/**
	 * Deflate.err -> Number
	 *
	 * Error code after deflate finished. 0 (Z_OK) on success.
	 * You will not need it in real life, because deflate errors
	 * are possible only on wrong options or bad `onData` / `onEnd`
	 * custom handlers.
	 **/

	/**
	 * Deflate.msg -> String
	 *
	 * Error message, if [[Deflate.err]] != 0
	 **/

	/**
	 * new Deflate(options)
	 * - options (Object): zlib deflate options.
	 *
	 * Creates new deflator instance with specified params. Throws exception
	 * on bad params. Supported options:
	 *
	 * - `level`
	 * - `windowBits`
	 * - `memLevel`
	 * - `strategy`
	 * - `dictionary`
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information on these.
	 *
	 * Additional options, for internal needs:
	 *
	 * - `chunkSize` - size of generated data chunks (16K by default)
	 * - `raw` (Boolean) - do raw deflate
	 * - `gzip` (Boolean) - create gzip wrapper
	 * - `to` (String) - if equal to 'string', then result will be "binary string"
	 *    (each char code [0..255])
	 * - `header` (Object) - custom header for gzip
	 *   - `text` (Boolean) - true if compressed data believed to be text
	 *   - `time` (Number) - modification time, unix timestamp
	 *   - `os` (Number) - operation system code
	 *   - `extra` (Array) - array of bytes with extra data (max 65536)
	 *   - `name` (String) - file name (binary string)
	 *   - `comment` (String) - comment (binary string)
	 *   - `hcrc` (Boolean) - true if header crc should be added
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
	 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
	 *
	 * var deflate = new pako.Deflate({ level: 3});
	 *
	 * deflate.push(chunk1, false);
	 * deflate.push(chunk2, true);  // true -> last chunk
	 *
	 * if (deflate.err) { throw new Error(deflate.err); }
	 *
	 * console.log(deflate.result);
	 * ```
	 **/
	function Deflate(options) {
	  if (!(this instanceof Deflate)) return new Deflate(options);
	  this.options = utils$3.assign({
	    level: Z_DEFAULT_COMPRESSION,
	    method: Z_DEFLATED$1,
	    chunkSize: 16384,
	    windowBits: 15,
	    memLevel: 8,
	    strategy: Z_DEFAULT_STRATEGY,
	    to: ''
	  }, options || {});
	  var opt = this.options;
	  if (opt.raw && opt.windowBits > 0) {
	    opt.windowBits = -opt.windowBits;
	  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
	    opt.windowBits += 16;
	  }
	  this.err = 0; // error code, if happens (0 = Z_OK)
	  this.msg = ''; // error message
	  this.ended = false; // used to avoid multiple onEnd() calls
	  this.chunks = []; // chunks of compressed data

	  this.strm = new ZStream$1();
	  this.strm.avail_out = 0;
	  var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
	  if (status !== Z_OK$1) {
	    throw new Error(msg$1[status]);
	  }
	  if (opt.header) {
	    zlib_deflate.deflateSetHeader(this.strm, opt.header);
	  }
	  if (opt.dictionary) {
	    var dict;
	    // Convert data if needed
	    if (typeof opt.dictionary === 'string') {
	      // If we need to compress text, change encoding to utf8.
	      dict = strings$1.string2buf(opt.dictionary);
	    } else if (toString$2.call(opt.dictionary) === '[object ArrayBuffer]') {
	      dict = new Uint8Array(opt.dictionary);
	    } else {
	      dict = opt.dictionary;
	    }
	    status = zlib_deflate.deflateSetDictionary(this.strm, dict);
	    if (status !== Z_OK$1) {
	      throw new Error(msg$1[status]);
	    }
	    this._dict_set = true;
	  }
	}

	/**
	 * Deflate#push(data[, mode]) -> Boolean
	 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
	 *   converted to utf8 byte sequence.
	 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
	 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
	 *
	 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
	 * new compressed chunks. Returns `true` on success. The last data block must have
	 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
	 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
	 * can use mode Z_SYNC_FLUSH, keeping the compression context.
	 *
	 * On fail call [[Deflate#onEnd]] with error code and return false.
	 *
	 * We strongly recommend to use `Uint8Array` on input for best speed (output
	 * array format is detected automatically). Also, don't skip last param and always
	 * use the same type in your code (boolean or number). That will improve JS speed.
	 *
	 * For regular `Array`-s make sure all elements are [0..255].
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * push(chunk, false); // push one of data chunks
	 * ...
	 * push(chunk, true);  // push last chunk
	 * ```
	 **/
	Deflate.prototype.push = function (data, mode) {
	  var strm = this.strm;
	  var chunkSize = this.options.chunkSize;
	  var status, _mode;
	  if (this.ended) {
	    return false;
	  }
	  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH$1 : Z_NO_FLUSH;

	  // Convert data if needed
	  if (typeof data === 'string') {
	    // If we need to compress text, change encoding to utf8.
	    strm.input = strings$1.string2buf(data);
	  } else if (toString$2.call(data) === '[object ArrayBuffer]') {
	    strm.input = new Uint8Array(data);
	  } else {
	    strm.input = data;
	  }
	  strm.next_in = 0;
	  strm.avail_in = strm.input.length;
	  do {
	    if (strm.avail_out === 0) {
	      strm.output = new utils$3.Buf8(chunkSize);
	      strm.next_out = 0;
	      strm.avail_out = chunkSize;
	    }
	    status = zlib_deflate.deflate(strm, _mode); /* no bad return value */

	    if (status !== Z_STREAM_END$1 && status !== Z_OK$1) {
	      this.onEnd(status);
	      this.ended = true;
	      return false;
	    }
	    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH$1 || _mode === Z_SYNC_FLUSH)) {
	      if (this.options.to === 'string') {
	        this.onData(strings$1.buf2binstring(utils$3.shrinkBuf(strm.output, strm.next_out)));
	      } else {
	        this.onData(utils$3.shrinkBuf(strm.output, strm.next_out));
	      }
	    }
	  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END$1);

	  // Finalize on the last chunk.
	  if (_mode === Z_FINISH$1) {
	    status = zlib_deflate.deflateEnd(this.strm);
	    this.onEnd(status);
	    this.ended = true;
	    return status === Z_OK$1;
	  }

	  // callback interim results if Z_SYNC_FLUSH.
	  if (_mode === Z_SYNC_FLUSH) {
	    this.onEnd(Z_OK$1);
	    strm.avail_out = 0;
	    return true;
	  }
	  return true;
	};

	/**
	 * Deflate#onData(chunk) -> Void
	 * - chunk (Uint8Array|Array|String): output data. Type of array depends
	 *   on js engine support. When string output requested, each chunk
	 *   will be string.
	 *
	 * By default, stores data blocks in `chunks[]` property and glue
	 * those in `onEnd`. Override this handler, if you need another behaviour.
	 **/
	Deflate.prototype.onData = function (chunk) {
	  this.chunks.push(chunk);
	};

	/**
	 * Deflate#onEnd(status) -> Void
	 * - status (Number): deflate status. 0 (Z_OK) on success,
	 *   other if not.
	 *
	 * Called once after you tell deflate that the input stream is
	 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
	 * or if an error happened. By default - join collected chunks,
	 * free memory and fill `results` / `err` properties.
	 **/
	Deflate.prototype.onEnd = function (status) {
	  // On success - join
	  if (status === Z_OK$1) {
	    if (this.options.to === 'string') {
	      this.result = this.chunks.join('');
	    } else {
	      this.result = utils$3.flattenChunks(this.chunks);
	    }
	  }
	  this.chunks = [];
	  this.err = status;
	  this.msg = this.strm.msg;
	};

	/**
	 * deflate(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to compress.
	 * - options (Object): zlib deflate options.
	 *
	 * Compress `data` with deflate algorithm and `options`.
	 *
	 * Supported options are:
	 *
	 * - level
	 * - windowBits
	 * - memLevel
	 * - strategy
	 * - dictionary
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information on these.
	 *
	 * Sugar (options):
	 *
	 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
	 *   negative windowBits implicitly.
	 * - `to` (String) - if equal to 'string', then result will be "binary string"
	 *    (each char code [0..255])
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
	 *
	 * console.log(pako.deflate(data));
	 * ```
	 **/
	function deflate$1(input, options) {
	  var deflator = new Deflate(options);
	  deflator.push(input, true);

	  // That will never happens, if you don't cheat with options :)
	  if (deflator.err) {
	    throw deflator.msg || msg$1[deflator.err];
	  }
	  return deflator.result;
	}

	/**
	 * deflateRaw(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to compress.
	 * - options (Object): zlib deflate options.
	 *
	 * The same as [[deflate]], but creates raw data, without wrapper
	 * (header and adler32 crc).
	 **/
	function deflateRaw(input, options) {
	  options = options || {};
	  options.raw = true;
	  return deflate$1(input, options);
	}

	/**
	 * gzip(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to compress.
	 * - options (Object): zlib deflate options.
	 *
	 * The same as [[deflate]], but create gzip wrapper instead of
	 * deflate one.
	 **/
	function gzip(input, options) {
	  options = options || {};
	  options.gzip = true;
	  return deflate$1(input, options);
	}
	deflate$4.Deflate = Deflate;
	deflate$4.deflate = deflate$1;
	deflate$4.deflateRaw = deflateRaw;
	deflate$4.gzip = gzip;

	var inflate$4 = {};

	var inflate$3 = {};

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	// See state defs from inflate.js
	var BAD$1 = 30; /* got a data error -- remain here until reset */
	var TYPE$1 = 12; /* i: waiting for type bits, including last-flag bit */

	/*
	   Decode literal, length, and distance codes and write out the resulting
	   literal and match bytes until either not enough input or output is
	   available, an end-of-block is encountered, or a data error is encountered.
	   When large enough input and output buffers are supplied to inflate(), for
	   example, a 16K input buffer and a 64K output buffer, more than 95% of the
	   inflate execution time is spent in this routine.

	   Entry assumptions:

	        state.mode === LEN
	        strm.avail_in >= 6
	        strm.avail_out >= 258
	        start >= strm.avail_out
	        state.bits < 8

	   On return, state.mode is one of:

	        LEN -- ran out of enough output space or enough available input
	        TYPE -- reached end of block code, inflate() to interpret next block
	        BAD -- error in block data

	   Notes:

	    - The maximum input bits used by a length/distance pair is 15 bits for the
	      length code, 5 bits for the length extra, 15 bits for the distance code,
	      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
	      Therefore if strm.avail_in >= 6, then there is enough input to avoid
	      checking for available input while decoding.

	    - The maximum bytes that a single length/distance pair can output is 258
	      bytes, which is the maximum length that can be coded.  inflate_fast()
	      requires strm.avail_out >= 258 for each loop to avoid checking for
	      output space.
	 */
	var inffast = function inflate_fast(strm, start) {
	  var state;
	  var _in; /* local strm.input */
	  var last; /* have enough input while in < last */
	  var _out; /* local strm.output */
	  var beg; /* inflate()'s initial strm.output */
	  var end; /* while out < end, enough space available */
	  //#ifdef INFLATE_STRICT
	  var dmax; /* maximum distance from zlib header */
	  //#endif
	  var wsize; /* window size or zero if not using window */
	  var whave; /* valid bytes in the window */
	  var wnext; /* window write index */
	  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
	  var s_window; /* allocated sliding window, if wsize != 0 */
	  var hold; /* local strm.hold */
	  var bits; /* local strm.bits */
	  var lcode; /* local strm.lencode */
	  var dcode; /* local strm.distcode */
	  var lmask; /* mask for first level of length codes */
	  var dmask; /* mask for first level of distance codes */
	  var here; /* retrieved table entry */
	  var op; /* code bits, operation, extra bits, or */
	  /*  window position, window bytes to copy */
	  var len; /* match length, unused bytes */
	  var dist; /* match distance */
	  var from; /* where to copy match from */
	  var from_source;
	  var input, output; // JS specific, because we have no pointers

	  /* copy state to local variables */
	  state = strm.state;
	  //here = state.here;
	  _in = strm.next_in;
	  input = strm.input;
	  last = _in + (strm.avail_in - 5);
	  _out = strm.next_out;
	  output = strm.output;
	  beg = _out - (start - strm.avail_out);
	  end = _out + (strm.avail_out - 257);
	  //#ifdef INFLATE_STRICT
	  dmax = state.dmax;
	  //#endif
	  wsize = state.wsize;
	  whave = state.whave;
	  wnext = state.wnext;
	  s_window = state.window;
	  hold = state.hold;
	  bits = state.bits;
	  lcode = state.lencode;
	  dcode = state.distcode;
	  lmask = (1 << state.lenbits) - 1;
	  dmask = (1 << state.distbits) - 1;

	  /* decode literals and length/distances until end-of-block or not enough
	     input data or output space */

	  top: do {
	    if (bits < 15) {
	      hold += input[_in++] << bits;
	      bits += 8;
	      hold += input[_in++] << bits;
	      bits += 8;
	    }
	    here = lcode[hold & lmask];
	    dolen: for (;;) {
	      // Goto emulation
	      op = here >>> 24 /*here.bits*/;
	      hold >>>= op;
	      bits -= op;
	      op = here >>> 16 & 0xff /*here.op*/;
	      if (op === 0) {
	        /* literal */
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        output[_out++] = here & 0xffff /*here.val*/;
	      } else if (op & 16) {
	        /* length base */
	        len = here & 0xffff /*here.val*/;
	        op &= 15; /* number of extra bits */
	        if (op) {
	          if (bits < op) {
	            hold += input[_in++] << bits;
	            bits += 8;
	          }
	          len += hold & (1 << op) - 1;
	          hold >>>= op;
	          bits -= op;
	        }
	        //Tracevv((stderr, "inflate:         length %u\n", len));
	        if (bits < 15) {
	          hold += input[_in++] << bits;
	          bits += 8;
	          hold += input[_in++] << bits;
	          bits += 8;
	        }
	        here = dcode[hold & dmask];
	        dodist: for (;;) {
	          // goto emulation
	          op = here >>> 24 /*here.bits*/;
	          hold >>>= op;
	          bits -= op;
	          op = here >>> 16 & 0xff /*here.op*/;

	          if (op & 16) {
	            /* distance base */
	            dist = here & 0xffff /*here.val*/;
	            op &= 15; /* number of extra bits */
	            if (bits < op) {
	              hold += input[_in++] << bits;
	              bits += 8;
	              if (bits < op) {
	                hold += input[_in++] << bits;
	                bits += 8;
	              }
	            }
	            dist += hold & (1 << op) - 1;
	            //#ifdef INFLATE_STRICT
	            if (dist > dmax) {
	              strm.msg = 'invalid distance too far back';
	              state.mode = BAD$1;
	              break top;
	            }
	            //#endif
	            hold >>>= op;
	            bits -= op;
	            //Tracevv((stderr, "inflate:         distance %u\n", dist));
	            op = _out - beg; /* max distance in output */
	            if (dist > op) {
	              /* see if copy from window */
	              op = dist - op; /* distance back in window */
	              if (op > whave) {
	                if (state.sane) {
	                  strm.msg = 'invalid distance too far back';
	                  state.mode = BAD$1;
	                  break top;
	                }

	                // (!) This block is disabled in zlib defaults,
	                // don't enable it for binary compatibility
	                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	                //                if (len <= op - whave) {
	                //                  do {
	                //                    output[_out++] = 0;
	                //                  } while (--len);
	                //                  continue top;
	                //                }
	                //                len -= op - whave;
	                //                do {
	                //                  output[_out++] = 0;
	                //                } while (--op > whave);
	                //                if (op === 0) {
	                //                  from = _out - dist;
	                //                  do {
	                //                    output[_out++] = output[from++];
	                //                  } while (--len);
	                //                  continue top;
	                //                }
	                //#endif
	              }

	              from = 0; // window index
	              from_source = s_window;
	              if (wnext === 0) {
	                /* very common case */
	                from += wsize - op;
	                if (op < len) {
	                  /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist; /* rest from output */
	                  from_source = output;
	                }
	              } else if (wnext < op) {
	                /* wrap around window */
	                from += wsize + wnext - op;
	                op -= wnext;
	                if (op < len) {
	                  /* some from end of window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = 0;
	                  if (wnext < len) {
	                    /* some from start of window */
	                    op = wnext;
	                    len -= op;
	                    do {
	                      output[_out++] = s_window[from++];
	                    } while (--op);
	                    from = _out - dist; /* rest from output */
	                    from_source = output;
	                  }
	                }
	              } else {
	                /* contiguous in window */
	                from += wnext - op;
	                if (op < len) {
	                  /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist; /* rest from output */
	                  from_source = output;
	                }
	              }
	              while (len > 2) {
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                len -= 3;
	              }
	              if (len) {
	                output[_out++] = from_source[from++];
	                if (len > 1) {
	                  output[_out++] = from_source[from++];
	                }
	              }
	            } else {
	              from = _out - dist; /* copy direct from output */
	              do {
	                /* minimum length is three */
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                len -= 3;
	              } while (len > 2);
	              if (len) {
	                output[_out++] = output[from++];
	                if (len > 1) {
	                  output[_out++] = output[from++];
	                }
	              }
	            }
	          } else if ((op & 64) === 0) {
	            /* 2nd level distance code */
	            here = dcode[(here & 0xffff /*here.val*/) + (hold & (1 << op) - 1)];
	            continue dodist;
	          } else {
	            strm.msg = 'invalid distance code';
	            state.mode = BAD$1;
	            break top;
	          }
	          break; // need to emulate goto via "continue"
	        }
	      } else if ((op & 64) === 0) {
	        /* 2nd level length code */
	        here = lcode[(here & 0xffff /*here.val*/) + (hold & (1 << op) - 1)];
	        continue dolen;
	      } else if (op & 32) {
	        /* end-of-block */
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.mode = TYPE$1;
	        break top;
	      } else {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD$1;
	        break top;
	      }
	      break; // need to emulate goto via "continue"
	    }
	  } while (_in < last && _out < end);

	  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
	  len = bits >> 3;
	  _in -= len;
	  bits -= len << 3;
	  hold &= (1 << bits) - 1;

	  /* update state and return */
	  strm.next_in = _in;
	  strm.next_out = _out;
	  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
	  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
	  state.hold = hold;
	  state.bits = bits;
	  return;
	};

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	var utils$2 = common;
	var MAXBITS = 15;
	var ENOUGH_LENS$1 = 852;
	var ENOUGH_DISTS$1 = 592;
	//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

	var CODES$1 = 0;
	var LENS$1 = 1;
	var DISTS$1 = 2;
	var lbase = [/* Length codes 257..285 base */
	3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
	var lext = [/* Length codes 257..285 extra */
	16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
	var dbase = [/* Distance codes 0..29 base */
	1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
	var dext = [/* Distance codes 0..29 extra */
	16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
	var inftrees = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
	  var bits = opts.bits;
	  //here = opts.here; /* table entry for duplication */

	  var len = 0; /* a code's length in bits */
	  var sym = 0; /* index of code symbols */
	  var min = 0,
	    max = 0; /* minimum and maximum code lengths */
	  var root = 0; /* number of index bits for root table */
	  var curr = 0; /* number of index bits for current table */
	  var drop = 0; /* code bits to drop for sub-table */
	  var left = 0; /* number of prefix codes available */
	  var used = 0; /* code entries in table used */
	  var huff = 0; /* Huffman code */
	  var incr; /* for incrementing code, index */
	  var fill; /* index for replicating entries */
	  var low; /* low bits for current root entry */
	  var mask; /* mask for low root bits */
	  var next; /* next available space in table */
	  var base = null; /* base value table to use */
	  var base_index = 0;
	  //  var shoextra;    /* extra bits table to use */
	  var end; /* use base and extra for symbol > end */
	  var count = new utils$2.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
	  var offs = new utils$2.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
	  var extra = null;
	  var extra_index = 0;
	  var here_bits, here_op, here_val;

	  /*
	   Process a set of code lengths to create a canonical Huffman code.  The
	   code lengths are lens[0..codes-1].  Each length corresponds to the
	   symbols 0..codes-1.  The Huffman code is generated by first sorting the
	   symbols by length from short to long, and retaining the symbol order
	   for codes with equal lengths.  Then the code starts with all zero bits
	   for the first code of the shortest length, and the codes are integer
	   increments for the same length, and zeros are appended as the length
	   increases.  For the deflate format, these bits are stored backwards
	   from their more natural integer increment ordering, and so when the
	   decoding tables are built in the large loop below, the integer codes
	   are incremented backwards.
	    This routine assumes, but does not check, that all of the entries in
	   lens[] are in the range 0..MAXBITS.  The caller must assure this.
	   1..MAXBITS is interpreted as that code length.  zero means that that
	   symbol does not occur in this code.
	    The codes are sorted by computing a count of codes for each length,
	   creating from that a table of starting indices for each length in the
	   sorted table, and then entering the symbols in order in the sorted
	   table.  The sorted table is work[], with that space being provided by
	   the caller.
	    The length counts are used for other purposes as well, i.e. finding
	   the minimum and maximum length codes, determining if there are any
	   codes at all, checking for a valid set of lengths, and looking ahead
	   at length counts to determine sub-table sizes when building the
	   decoding tables.
	   */

	  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
	  for (len = 0; len <= MAXBITS; len++) {
	    count[len] = 0;
	  }
	  for (sym = 0; sym < codes; sym++) {
	    count[lens[lens_index + sym]]++;
	  }

	  /* bound code lengths, force root to be within code lengths */
	  root = bits;
	  for (max = MAXBITS; max >= 1; max--) {
	    if (count[max] !== 0) {
	      break;
	    }
	  }
	  if (root > max) {
	    root = max;
	  }
	  if (max === 0) {
	    /* no symbols to code at all */
	    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
	    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
	    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
	    table[table_index++] = 1 << 24 | 64 << 16 | 0;

	    //table.op[opts.table_index] = 64;
	    //table.bits[opts.table_index] = 1;
	    //table.val[opts.table_index++] = 0;
	    table[table_index++] = 1 << 24 | 64 << 16 | 0;
	    opts.bits = 1;
	    return 0; /* no symbols, but wait for decoding to report error */
	  }

	  for (min = 1; min < max; min++) {
	    if (count[min] !== 0) {
	      break;
	    }
	  }
	  if (root < min) {
	    root = min;
	  }

	  /* check for an over-subscribed or incomplete set of lengths */
	  left = 1;
	  for (len = 1; len <= MAXBITS; len++) {
	    left <<= 1;
	    left -= count[len];
	    if (left < 0) {
	      return -1;
	    } /* over-subscribed */
	  }

	  if (left > 0 && (type === CODES$1 || max !== 1)) {
	    return -1; /* incomplete set */
	  }

	  /* generate offsets into symbol table for each length for sorting */
	  offs[1] = 0;
	  for (len = 1; len < MAXBITS; len++) {
	    offs[len + 1] = offs[len] + count[len];
	  }

	  /* sort symbols by length, by symbol order within each length */
	  for (sym = 0; sym < codes; sym++) {
	    if (lens[lens_index + sym] !== 0) {
	      work[offs[lens[lens_index + sym]]++] = sym;
	    }
	  }

	  /*
	   Create and fill in decoding tables.  In this loop, the table being
	   filled is at next and has curr index bits.  The code being used is huff
	   with length len.  That code is converted to an index by dropping drop
	   bits off of the bottom.  For codes where len is less than drop + curr,
	   those top drop + curr - len bits are incremented through all values to
	   fill the table with replicated entries.
	    root is the number of index bits for the root table.  When len exceeds
	   root, sub-tables are created pointed to by the root entry with an index
	   of the low root bits of huff.  This is saved in low to check for when a
	   new sub-table should be started.  drop is zero when the root table is
	   being filled, and drop is root when sub-tables are being filled.
	    When a new sub-table is needed, it is necessary to look ahead in the
	   code lengths to determine what size sub-table is needed.  The length
	   counts are used for this, and so count[] is decremented as codes are
	   entered in the tables.
	    used keeps track of how many table entries have been allocated from the
	   provided *table space.  It is checked for LENS and DIST tables against
	   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
	   the initial root table size constants.  See the comments in inftrees.h
	   for more information.
	    sym increments through all symbols, and the loop terminates when
	   all codes of length max, i.e. all codes, have been processed.  This
	   routine permits incomplete codes, so another loop after this one fills
	   in the rest of the decoding tables with invalid code markers.
	   */

	  /* set up for code type */
	  // poor man optimization - use if-else instead of switch,
	  // to avoid deopts in old v8
	  if (type === CODES$1) {
	    base = extra = work; /* dummy value--not used */
	    end = 19;
	  } else if (type === LENS$1) {
	    base = lbase;
	    base_index -= 257;
	    extra = lext;
	    extra_index -= 257;
	    end = 256;
	  } else {
	    /* DISTS */
	    base = dbase;
	    extra = dext;
	    end = -1;
	  }

	  /* initialize opts for loop */
	  huff = 0; /* starting code */
	  sym = 0; /* starting code symbol */
	  len = min; /* starting code length */
	  next = table_index; /* current table to fill in */
	  curr = root; /* current table index bits */
	  drop = 0; /* current bits to drop from code for index */
	  low = -1; /* trigger new sub-table when len > root */
	  used = 1 << root; /* use root table entries */
	  mask = used - 1; /* mask for comparing low */

	  /* check available table space */
	  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
	    return 1;
	  }

	  /* process all codes and make table entries */
	  for (;;) {
	    /* create table entry */
	    here_bits = len - drop;
	    if (work[sym] < end) {
	      here_op = 0;
	      here_val = work[sym];
	    } else if (work[sym] > end) {
	      here_op = extra[extra_index + work[sym]];
	      here_val = base[base_index + work[sym]];
	    } else {
	      here_op = 32 + 64; /* end of block */
	      here_val = 0;
	    }

	    /* replicate for those indices with low len bits equal to huff */
	    incr = 1 << len - drop;
	    fill = 1 << curr;
	    min = fill; /* save offset to next table */
	    do {
	      fill -= incr;
	      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
	    } while (fill !== 0);

	    /* backwards increment the len-bit code huff */
	    incr = 1 << len - 1;
	    while (huff & incr) {
	      incr >>= 1;
	    }
	    if (incr !== 0) {
	      huff &= incr - 1;
	      huff += incr;
	    } else {
	      huff = 0;
	    }

	    /* go to next symbol, update count, len */
	    sym++;
	    if (--count[len] === 0) {
	      if (len === max) {
	        break;
	      }
	      len = lens[lens_index + work[sym]];
	    }

	    /* create new sub-table if needed */
	    if (len > root && (huff & mask) !== low) {
	      /* if first time, transition to sub-tables */
	      if (drop === 0) {
	        drop = root;
	      }

	      /* increment past last table */
	      next += min; /* here min is 1 << curr */

	      /* determine length of next table */
	      curr = len - drop;
	      left = 1 << curr;
	      while (curr + drop < max) {
	        left -= count[curr + drop];
	        if (left <= 0) {
	          break;
	        }
	        curr++;
	        left <<= 1;
	      }

	      /* check for enough space */
	      used += 1 << curr;
	      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
	        return 1;
	      }

	      /* point entry in root table to sub-table */
	      low = huff & mask;
	      /*table.op[low] = curr;
	      table.bits[low] = root;
	      table.val[low] = next - opts.table_index;*/
	      table[low] = root << 24 | curr << 16 | next - table_index | 0;
	    }
	  }

	  /* fill in remaining table entry if code is incomplete (guaranteed to have
	   at most one remaining entry, since if the code is incomplete, the
	   maximum code length that was allowed to get this far is one bit) */
	  if (huff !== 0) {
	    //table.op[next + huff] = 64;            /* invalid code marker */
	    //table.bits[next + huff] = len - drop;
	    //table.val[next + huff] = 0;
	    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
	  }

	  /* set return parameters */
	  //opts.table_index += used;
	  opts.bits = root;
	  return 0;
	};

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	var utils$1 = common;
	var adler32 = adler32_1;
	var crc32 = crc32_1;
	var inflate_fast = inffast;
	var inflate_table = inftrees;
	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;

	/* Public constants ==========================================================*/
	/* ===========================================================================*/

	/* Allowed flush values; see deflate() and inflate() below for details */
	//var Z_NO_FLUSH      = 0;
	//var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	//var Z_FULL_FLUSH    = 3;
	var Z_FINISH = 4;
	var Z_BLOCK = 5;
	var Z_TREES = 6;

	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK = 0;
	var Z_STREAM_END = 1;
	var Z_NEED_DICT = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR = -2;
	var Z_DATA_ERROR = -3;
	var Z_MEM_ERROR = -4;
	var Z_BUF_ERROR = -5;
	//var Z_VERSION_ERROR = -6;

	/* The deflate compression method */
	var Z_DEFLATED = 8;

	/* STATES ====================================================================*/
	/* ===========================================================================*/

	var HEAD = 1; /* i: waiting for magic header */
	var FLAGS = 2; /* i: waiting for method and flags (gzip) */
	var TIME = 3; /* i: waiting for modification time (gzip) */
	var OS = 4; /* i: waiting for extra flags and operating system (gzip) */
	var EXLEN = 5; /* i: waiting for extra length (gzip) */
	var EXTRA = 6; /* i: waiting for extra bytes (gzip) */
	var NAME = 7; /* i: waiting for end of file name (gzip) */
	var COMMENT$1 = 8; /* i: waiting for end of comment (gzip) */
	var HCRC = 9; /* i: waiting for header crc (gzip) */
	var DICTID = 10; /* i: waiting for dictionary check value */
	var DICT = 11; /* waiting for inflateSetDictionary() call */
	var TYPE = 12; /* i: waiting for type bits, including last-flag bit */
	var TYPEDO = 13; /* i: same, but skip check to exit inflate on new block */
	var STORED = 14; /* i: waiting for stored size (length and complement) */
	var COPY_ = 15; /* i/o: same as COPY below, but only first time in */
	var COPY = 16; /* i/o: waiting for input or output to copy stored block */
	var TABLE = 17; /* i: waiting for dynamic block table lengths */
	var LENLENS = 18; /* i: waiting for code length code lengths */
	var CODELENS = 19; /* i: waiting for length/lit and distance code lengths */
	var LEN_ = 20; /* i: same as LEN below, but only first time in */
	var LEN = 21; /* i: waiting for length/lit/eob code */
	var LENEXT = 22; /* i: waiting for length extra bits */
	var DIST = 23; /* i: waiting for distance code */
	var DISTEXT = 24; /* i: waiting for distance extra bits */
	var MATCH = 25; /* o: waiting for output space to copy string */
	var LIT = 26; /* o: waiting for output space to write literal */
	var CHECK = 27; /* i: waiting for 32-bit check value */
	var LENGTH = 28; /* i: waiting for 32-bit length (gzip) */
	var DONE = 29; /* finished check, done -- remain here until reset */
	var BAD = 30; /* got a data error -- remain here until reset */
	var MEM = 31; /* got an inflate() memory error -- remain here until reset */
	var SYNC = 32; /* looking for synchronization bytes to restart inflate() */

	/* ===========================================================================*/

	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_WBITS = MAX_WBITS;
	function zswap32(q) {
	  return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
	}
	function InflateState() {
	  this.mode = 0; /* current inflate mode */
	  this.last = false; /* true if processing last block */
	  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
	  this.havedict = false; /* true if dictionary provided */
	  this.flags = 0; /* gzip header method and flags (0 if zlib) */
	  this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */
	  this.check = 0; /* protected copy of check value */
	  this.total = 0; /* protected copy of output count */
	  // TODO: may be {}
	  this.head = null; /* where to save gzip header information */

	  /* sliding window */
	  this.wbits = 0; /* log base 2 of requested window size */
	  this.wsize = 0; /* window size or zero if not using window */
	  this.whave = 0; /* valid bytes in the window */
	  this.wnext = 0; /* window write index */
	  this.window = null; /* allocated sliding window, if needed */

	  /* bit accumulator */
	  this.hold = 0; /* input bit accumulator */
	  this.bits = 0; /* number of bits in "in" */

	  /* for string and stored block copying */
	  this.length = 0; /* literal or length of data to copy */
	  this.offset = 0; /* distance back to copy string from */

	  /* for table and code decoding */
	  this.extra = 0; /* extra bits needed */

	  /* fixed and dynamic code tables */
	  this.lencode = null; /* starting table for length/literal codes */
	  this.distcode = null; /* starting table for distance codes */
	  this.lenbits = 0; /* index bits for lencode */
	  this.distbits = 0; /* index bits for distcode */

	  /* dynamic table building */
	  this.ncode = 0; /* number of code length code lengths */
	  this.nlen = 0; /* number of length code lengths */
	  this.ndist = 0; /* number of distance code lengths */
	  this.have = 0; /* number of code lengths in lens[] */
	  this.next = null; /* next available space in codes[] */

	  this.lens = new utils$1.Buf16(320); /* temporary storage for code lengths */
	  this.work = new utils$1.Buf16(288); /* work area for code table building */

	  /*
	   because we don't have pointers in js, we use lencode and distcode directly
	   as buffers so we don't need codes
	  */
	  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
	  this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */
	  this.distdyn = null; /* dynamic table for distance codes (JS specific) */
	  this.sane = 0; /* if false, allow invalid distance too far */
	  this.back = 0; /* bits back of last unprocessed length/lit */
	  this.was = 0; /* initial length of match */
	}

	function inflateResetKeep(strm) {
	  var state;
	  if (!strm || !strm.state) {
	    return Z_STREAM_ERROR;
	  }
	  state = strm.state;
	  strm.total_in = strm.total_out = state.total = 0;
	  strm.msg = ''; /*Z_NULL*/
	  if (state.wrap) {
	    /* to support ill-conceived Java test suite */
	    strm.adler = state.wrap & 1;
	  }
	  state.mode = HEAD;
	  state.last = 0;
	  state.havedict = 0;
	  state.dmax = 32768;
	  state.head = null /*Z_NULL*/;
	  state.hold = 0;
	  state.bits = 0;
	  //state.lencode = state.distcode = state.next = state.codes;
	  state.lencode = state.lendyn = new utils$1.Buf32(ENOUGH_LENS);
	  state.distcode = state.distdyn = new utils$1.Buf32(ENOUGH_DISTS);
	  state.sane = 1;
	  state.back = -1;
	  //Tracev((stderr, "inflate: reset\n"));
	  return Z_OK;
	}
	function inflateReset(strm) {
	  var state;
	  if (!strm || !strm.state) {
	    return Z_STREAM_ERROR;
	  }
	  state = strm.state;
	  state.wsize = 0;
	  state.whave = 0;
	  state.wnext = 0;
	  return inflateResetKeep(strm);
	}
	function inflateReset2(strm, windowBits) {
	  var wrap;
	  var state;

	  /* get the state */
	  if (!strm || !strm.state) {
	    return Z_STREAM_ERROR;
	  }
	  state = strm.state;

	  /* extract wrap request from windowBits parameter */
	  if (windowBits < 0) {
	    wrap = 0;
	    windowBits = -windowBits;
	  } else {
	    wrap = (windowBits >> 4) + 1;
	    if (windowBits < 48) {
	      windowBits &= 15;
	    }
	  }

	  /* set number of window bits, free window if different */
	  if (windowBits && (windowBits < 8 || windowBits > 15)) {
	    return Z_STREAM_ERROR;
	  }
	  if (state.window !== null && state.wbits !== windowBits) {
	    state.window = null;
	  }

	  /* update state and reset the rest of it */
	  state.wrap = wrap;
	  state.wbits = windowBits;
	  return inflateReset(strm);
	}
	function inflateInit2(strm, windowBits) {
	  var ret;
	  var state;
	  if (!strm) {
	    return Z_STREAM_ERROR;
	  }
	  //strm.msg = Z_NULL;                 /* in case we return an error */

	  state = new InflateState();

	  //if (state === Z_NULL) return Z_MEM_ERROR;
	  //Tracev((stderr, "inflate: allocated\n"));
	  strm.state = state;
	  state.window = null /*Z_NULL*/;
	  ret = inflateReset2(strm, windowBits);
	  if (ret !== Z_OK) {
	    strm.state = null /*Z_NULL*/;
	  }

	  return ret;
	}
	function inflateInit(strm) {
	  return inflateInit2(strm, DEF_WBITS);
	}

	/*
	 Return state with length and distance decoding tables and index sizes set to
	 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
	 If BUILDFIXED is defined, then instead this routine builds the tables the
	 first time it's called, and returns those tables the first time and
	 thereafter.  This reduces the size of the code by about 2K bytes, in
	 exchange for a little execution time.  However, BUILDFIXED should not be
	 used for threaded applications, since the rewriting of the tables and virgin
	 may not be thread-safe.
	 */
	var virgin = true;
	var lenfix, distfix; // We have no pointers in JS, so keep tables separate

	function fixedtables(state) {
	  /* build fixed huffman tables if first call (may not be thread safe) */
	  if (virgin) {
	    var sym;
	    lenfix = new utils$1.Buf32(512);
	    distfix = new utils$1.Buf32(32);

	    /* literal/length table */
	    sym = 0;
	    while (sym < 144) {
	      state.lens[sym++] = 8;
	    }
	    while (sym < 256) {
	      state.lens[sym++] = 9;
	    }
	    while (sym < 280) {
	      state.lens[sym++] = 7;
	    }
	    while (sym < 288) {
	      state.lens[sym++] = 8;
	    }
	    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
	      bits: 9
	    });

	    /* distance table */
	    sym = 0;
	    while (sym < 32) {
	      state.lens[sym++] = 5;
	    }
	    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
	      bits: 5
	    });

	    /* do this just once */
	    virgin = false;
	  }
	  state.lencode = lenfix;
	  state.lenbits = 9;
	  state.distcode = distfix;
	  state.distbits = 5;
	}

	/*
	 Update the window with the last wsize (normally 32K) bytes written before
	 returning.  If window does not exist yet, create it.  This is only called
	 when a window is already in use, or when output has been written during this
	 inflate call, but the end of the deflate stream has not been reached yet.
	 It is also called to create a window for dictionary data when a dictionary
	 is loaded.

	 Providing output buffers larger than 32K to inflate() should provide a speed
	 advantage, since only the last 32K of output is copied to the sliding window
	 upon return from inflate(), and since all distances after the first 32K of
	 output will fall in the output data, making match copies simpler and faster.
	 The advantage may be dependent on the size of the processor's data caches.
	 */
	function updatewindow(strm, src, end, copy) {
	  var dist;
	  var state = strm.state;

	  /* if it hasn't been done already, allocate space for the window */
	  if (state.window === null) {
	    state.wsize = 1 << state.wbits;
	    state.wnext = 0;
	    state.whave = 0;
	    state.window = new utils$1.Buf8(state.wsize);
	  }

	  /* copy state->wsize or less output bytes into the circular window */
	  if (copy >= state.wsize) {
	    utils$1.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
	    state.wnext = 0;
	    state.whave = state.wsize;
	  } else {
	    dist = state.wsize - state.wnext;
	    if (dist > copy) {
	      dist = copy;
	    }
	    //zmemcpy(state->window + state->wnext, end - copy, dist);
	    utils$1.arraySet(state.window, src, end - copy, dist, state.wnext);
	    copy -= dist;
	    if (copy) {
	      //zmemcpy(state->window, end - copy, copy);
	      utils$1.arraySet(state.window, src, end - copy, copy, 0);
	      state.wnext = copy;
	      state.whave = state.wsize;
	    } else {
	      state.wnext += dist;
	      if (state.wnext === state.wsize) {
	        state.wnext = 0;
	      }
	      if (state.whave < state.wsize) {
	        state.whave += dist;
	      }
	    }
	  }
	  return 0;
	}
	function inflate$2(strm, flush) {
	  var state;
	  var input, output; // input/output buffers
	  var next; /* next input INDEX */
	  var put; /* next output INDEX */
	  var have, left; /* available input and output */
	  var hold; /* bit buffer */
	  var bits; /* bits in bit buffer */
	  var _in, _out; /* save starting available input and output */
	  var copy; /* number of stored or match bytes to copy */
	  var from; /* where to copy match bytes from */
	  var from_source;
	  var here = 0; /* current decoding table entry */
	  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
	  //var last;                   /* parent table entry */
	  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
	  var len; /* length to copy for repeats, bits to drop */
	  var ret; /* return code */
	  var hbuf = new utils$1.Buf8(4); /* buffer for gzip header crc calculation */
	  var opts;
	  var n; // temporary var for NEED_BITS

	  var order = /* permutation of code lengths */
	  [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
	  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
	    return Z_STREAM_ERROR;
	  }
	  state = strm.state;
	  if (state.mode === TYPE) {
	    state.mode = TYPEDO;
	  } /* skip check */

	  //--- LOAD() ---
	  put = strm.next_out;
	  output = strm.output;
	  left = strm.avail_out;
	  next = strm.next_in;
	  input = strm.input;
	  have = strm.avail_in;
	  hold = state.hold;
	  bits = state.bits;
	  //---

	  _in = have;
	  _out = left;
	  ret = Z_OK;
	  inf_leave:
	  // goto emulation
	  for (;;) {
	    switch (state.mode) {
	      case HEAD:
	        if (state.wrap === 0) {
	          state.mode = TYPEDO;
	          break;
	        }
	        //=== NEEDBITS(16);
	        while (bits < 16) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (state.wrap & 2 && hold === 0x8b1f) {
	          /* gzip header */
	          state.check = 0 /*crc32(0L, Z_NULL, 0)*/;
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = hold >>> 8 & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//

	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	          state.mode = FLAGS;
	          break;
	        }
	        state.flags = 0; /* expect zlib header */
	        if (state.head) {
	          state.head.done = false;
	        }
	        if (!(state.wrap & 1) || /* check if zlib header allowed */
	        (((hold & 0xff /*BITS(8)*/) << 8) + (hold >> 8)) % 31) {
	          strm.msg = 'incorrect header check';
	          state.mode = BAD;
	          break;
	        }
	        if ((hold & 0x0f /*BITS(4)*/) !== Z_DEFLATED) {
	          strm.msg = 'unknown compression method';
	          state.mode = BAD;
	          break;
	        }
	        //--- DROPBITS(4) ---//
	        hold >>>= 4;
	        bits -= 4;
	        //---//
	        len = (hold & 0x0f /*BITS(4)*/) + 8;
	        if (state.wbits === 0) {
	          state.wbits = len;
	        } else if (len > state.wbits) {
	          strm.msg = 'invalid window size';
	          state.mode = BAD;
	          break;
	        }
	        state.dmax = 1 << len;
	        //Tracev((stderr, "inflate:   zlib header ok\n"));
	        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
	        state.mode = hold & 0x200 ? DICTID : TYPE;
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        break;
	      case FLAGS:
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.flags = hold;
	        if ((state.flags & 0xff) !== Z_DEFLATED) {
	          strm.msg = 'unknown compression method';
	          state.mode = BAD;
	          break;
	        }
	        if (state.flags & 0xe000) {
	          strm.msg = 'unknown header flags set';
	          state.mode = BAD;
	          break;
	        }
	        if (state.head) {
	          state.head.text = hold >> 8 & 1;
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = hold >>> 8 & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = TIME;
	      /* falls through */
	      case TIME:
	        //=== NEEDBITS(32); */
	        while (bits < 32) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (state.head) {
	          state.head.time = hold;
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC4(state.check, hold)
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = hold >>> 8 & 0xff;
	          hbuf[2] = hold >>> 16 & 0xff;
	          hbuf[3] = hold >>> 24 & 0xff;
	          state.check = crc32(state.check, hbuf, 4, 0);
	          //===
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = OS;
	      /* falls through */
	      case OS:
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (state.head) {
	          state.head.xflags = hold & 0xff;
	          state.head.os = hold >> 8;
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = hold >>> 8 & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = EXLEN;
	      /* falls through */
	      case EXLEN:
	        if (state.flags & 0x0400) {
	          //=== NEEDBITS(16); */
	          while (bits < 16) {
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.length = hold;
	          if (state.head) {
	            state.head.extra_len = hold;
	          }
	          if (state.flags & 0x0200) {
	            //=== CRC2(state.check, hold);
	            hbuf[0] = hold & 0xff;
	            hbuf[1] = hold >>> 8 & 0xff;
	            state.check = crc32(state.check, hbuf, 2, 0);
	            //===//
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	        } else if (state.head) {
	          state.head.extra = null /*Z_NULL*/;
	        }

	        state.mode = EXTRA;
	      /* falls through */
	      case EXTRA:
	        if (state.flags & 0x0400) {
	          copy = state.length;
	          if (copy > have) {
	            copy = have;
	          }
	          if (copy) {
	            if (state.head) {
	              len = state.head.extra_len - state.length;
	              if (!state.head.extra) {
	                // Use untyped array for more convenient processing later
	                state.head.extra = new Array(state.head.extra_len);
	              }
	              utils$1.arraySet(state.head.extra, input, next,
	              // extra field is limited to 65536 bytes
	              // - no need for additional size check
	              copy, /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
	              len);
	              //zmemcpy(state.head.extra + len, next,
	              //        len + copy > state.head.extra_max ?
	              //        state.head.extra_max - len : copy);
	            }

	            if (state.flags & 0x0200) {
	              state.check = crc32(state.check, input, copy, next);
	            }
	            have -= copy;
	            next += copy;
	            state.length -= copy;
	          }
	          if (state.length) {
	            break inf_leave;
	          }
	        }
	        state.length = 0;
	        state.mode = NAME;
	      /* falls through */
	      case NAME:
	        if (state.flags & 0x0800) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          copy = 0;
	          do {
	            // TODO: 2 or 1 bytes?
	            len = input[next + copy++];
	            /* use constant limit because in js we should not preallocate memory */
	            if (state.head && len && state.length < 65536 /*state.head.name_max*/) {
	              state.head.name += String.fromCharCode(len);
	            }
	          } while (len && copy < have);
	          if (state.flags & 0x0200) {
	            state.check = crc32(state.check, input, copy, next);
	          }
	          have -= copy;
	          next += copy;
	          if (len) {
	            break inf_leave;
	          }
	        } else if (state.head) {
	          state.head.name = null;
	        }
	        state.length = 0;
	        state.mode = COMMENT$1;
	      /* falls through */
	      case COMMENT$1:
	        if (state.flags & 0x1000) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          copy = 0;
	          do {
	            len = input[next + copy++];
	            /* use constant limit because in js we should not preallocate memory */
	            if (state.head && len && state.length < 65536 /*state.head.comm_max*/) {
	              state.head.comment += String.fromCharCode(len);
	            }
	          } while (len && copy < have);
	          if (state.flags & 0x0200) {
	            state.check = crc32(state.check, input, copy, next);
	          }
	          have -= copy;
	          next += copy;
	          if (len) {
	            break inf_leave;
	          }
	        } else if (state.head) {
	          state.head.comment = null;
	        }
	        state.mode = HCRC;
	      /* falls through */
	      case HCRC:
	        if (state.flags & 0x0200) {
	          //=== NEEDBITS(16); */
	          while (bits < 16) {
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          if (hold !== (state.check & 0xffff)) {
	            strm.msg = 'header crc mismatch';
	            state.mode = BAD;
	            break;
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	        }

	        if (state.head) {
	          state.head.hcrc = state.flags >> 9 & 1;
	          state.head.done = true;
	        }
	        strm.adler = state.check = 0;
	        state.mode = TYPE;
	        break;
	      case DICTID:
	        //=== NEEDBITS(32); */
	        while (bits < 32) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        strm.adler = state.check = zswap32(hold);
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = DICT;
	      /* falls through */
	      case DICT:
	        if (state.havedict === 0) {
	          //--- RESTORE() ---
	          strm.next_out = put;
	          strm.avail_out = left;
	          strm.next_in = next;
	          strm.avail_in = have;
	          state.hold = hold;
	          state.bits = bits;
	          //---
	          return Z_NEED_DICT;
	        }
	        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
	        state.mode = TYPE;
	      /* falls through */
	      case TYPE:
	        if (flush === Z_BLOCK || flush === Z_TREES) {
	          break inf_leave;
	        }
	      /* falls through */
	      case TYPEDO:
	        if (state.last) {
	          //--- BYTEBITS() ---//
	          hold >>>= bits & 7;
	          bits -= bits & 7;
	          //---//
	          state.mode = CHECK;
	          break;
	        }
	        //=== NEEDBITS(3); */
	        while (bits < 3) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.last = hold & 0x01 /*BITS(1)*/;
	        //--- DROPBITS(1) ---//
	        hold >>>= 1;
	        bits -= 1;
	        //---//

	        switch (hold & 0x03 /*BITS(2)*/) {
	          case 0:
	            /* stored block */
	            //Tracev((stderr, "inflate:     stored block%s\n",
	            //        state.last ? " (last)" : ""));
	            state.mode = STORED;
	            break;
	          case 1:
	            /* fixed block */
	            fixedtables(state);
	            //Tracev((stderr, "inflate:     fixed codes block%s\n",
	            //        state.last ? " (last)" : ""));
	            state.mode = LEN_; /* decode codes */
	            if (flush === Z_TREES) {
	              //--- DROPBITS(2) ---//
	              hold >>>= 2;
	              bits -= 2;
	              //---//
	              break inf_leave;
	            }
	            break;
	          case 2:
	            /* dynamic block */
	            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
	            //        state.last ? " (last)" : ""));
	            state.mode = TABLE;
	            break;
	          case 3:
	            strm.msg = 'invalid block type';
	            state.mode = BAD;
	        }
	        //--- DROPBITS(2) ---//
	        hold >>>= 2;
	        bits -= 2;
	        //---//
	        break;
	      case STORED:
	        //--- BYTEBITS() ---// /* go to byte boundary */
	        hold >>>= bits & 7;
	        bits -= bits & 7;
	        //---//
	        //=== NEEDBITS(32); */
	        while (bits < 32) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
	          strm.msg = 'invalid stored block lengths';
	          state.mode = BAD;
	          break;
	        }
	        state.length = hold & 0xffff;
	        //Tracev((stderr, "inflate:       stored length %u\n",
	        //        state.length));
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = COPY_;
	        if (flush === Z_TREES) {
	          break inf_leave;
	        }
	      /* falls through */
	      case COPY_:
	        state.mode = COPY;
	      /* falls through */
	      case COPY:
	        copy = state.length;
	        if (copy) {
	          if (copy > have) {
	            copy = have;
	          }
	          if (copy > left) {
	            copy = left;
	          }
	          if (copy === 0) {
	            break inf_leave;
	          }
	          //--- zmemcpy(put, next, copy); ---
	          utils$1.arraySet(output, input, next, copy, put);
	          //---//
	          have -= copy;
	          next += copy;
	          left -= copy;
	          put += copy;
	          state.length -= copy;
	          break;
	        }
	        //Tracev((stderr, "inflate:       stored end\n"));
	        state.mode = TYPE;
	        break;
	      case TABLE:
	        //=== NEEDBITS(14); */
	        while (bits < 14) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.nlen = (hold & 0x1f /*BITS(5)*/) + 257;
	        //--- DROPBITS(5) ---//
	        hold >>>= 5;
	        bits -= 5;
	        //---//
	        state.ndist = (hold & 0x1f /*BITS(5)*/) + 1;
	        //--- DROPBITS(5) ---//
	        hold >>>= 5;
	        bits -= 5;
	        //---//
	        state.ncode = (hold & 0x0f /*BITS(4)*/) + 4;
	        //--- DROPBITS(4) ---//
	        hold >>>= 4;
	        bits -= 4;
	        //---//
	        //#ifndef PKZIP_BUG_WORKAROUND
	        if (state.nlen > 286 || state.ndist > 30) {
	          strm.msg = 'too many length or distance symbols';
	          state.mode = BAD;
	          break;
	        }
	        //#endif
	        //Tracev((stderr, "inflate:       table sizes ok\n"));
	        state.have = 0;
	        state.mode = LENLENS;
	      /* falls through */
	      case LENLENS:
	        while (state.have < state.ncode) {
	          //=== NEEDBITS(3);
	          while (bits < 3) {
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
	          //--- DROPBITS(3) ---//
	          hold >>>= 3;
	          bits -= 3;
	          //---//
	        }

	        while (state.have < 19) {
	          state.lens[order[state.have++]] = 0;
	        }
	        // We have separate tables & no pointers. 2 commented lines below not needed.
	        //state.next = state.codes;
	        //state.lencode = state.next;
	        // Switch to use dynamic table
	        state.lencode = state.lendyn;
	        state.lenbits = 7;
	        opts = {
	          bits: state.lenbits
	        };
	        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
	        state.lenbits = opts.bits;
	        if (ret) {
	          strm.msg = 'invalid code lengths set';
	          state.mode = BAD;
	          break;
	        }
	        //Tracev((stderr, "inflate:       code lengths ok\n"));
	        state.have = 0;
	        state.mode = CODELENS;
	      /* falls through */
	      case CODELENS:
	        while (state.have < state.nlen + state.ndist) {
	          for (;;) {
	            here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
	            here_bits = here >>> 24;
	            here_op = here >>> 16 & 0xff;
	            here_val = here & 0xffff;
	            if (here_bits <= bits) {
	              break;
	            }
	            //--- PULLBYTE() ---//
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	            //---//
	          }

	          if (here_val < 16) {
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            state.lens[state.have++] = here_val;
	          } else {
	            if (here_val === 16) {
	              //=== NEEDBITS(here.bits + 2);
	              n = here_bits + 2;
	              while (bits < n) {
	                if (have === 0) {
	                  break inf_leave;
	                }
	                have--;
	                hold += input[next++] << bits;
	                bits += 8;
	              }
	              //===//
	              //--- DROPBITS(here.bits) ---//
	              hold >>>= here_bits;
	              bits -= here_bits;
	              //---//
	              if (state.have === 0) {
	                strm.msg = 'invalid bit length repeat';
	                state.mode = BAD;
	                break;
	              }
	              len = state.lens[state.have - 1];
	              copy = 3 + (hold & 0x03); //BITS(2);
	              //--- DROPBITS(2) ---//
	              hold >>>= 2;
	              bits -= 2;
	              //---//
	            } else if (here_val === 17) {
	              //=== NEEDBITS(here.bits + 3);
	              n = here_bits + 3;
	              while (bits < n) {
	                if (have === 0) {
	                  break inf_leave;
	                }
	                have--;
	                hold += input[next++] << bits;
	                bits += 8;
	              }
	              //===//
	              //--- DROPBITS(here.bits) ---//
	              hold >>>= here_bits;
	              bits -= here_bits;
	              //---//
	              len = 0;
	              copy = 3 + (hold & 0x07); //BITS(3);
	              //--- DROPBITS(3) ---//
	              hold >>>= 3;
	              bits -= 3;
	              //---//
	            } else {
	              //=== NEEDBITS(here.bits + 7);
	              n = here_bits + 7;
	              while (bits < n) {
	                if (have === 0) {
	                  break inf_leave;
	                }
	                have--;
	                hold += input[next++] << bits;
	                bits += 8;
	              }
	              //===//
	              //--- DROPBITS(here.bits) ---//
	              hold >>>= here_bits;
	              bits -= here_bits;
	              //---//
	              len = 0;
	              copy = 11 + (hold & 0x7f); //BITS(7);
	              //--- DROPBITS(7) ---//
	              hold >>>= 7;
	              bits -= 7;
	              //---//
	            }

	            if (state.have + copy > state.nlen + state.ndist) {
	              strm.msg = 'invalid bit length repeat';
	              state.mode = BAD;
	              break;
	            }
	            while (copy--) {
	              state.lens[state.have++] = len;
	            }
	          }
	        }

	        /* handle error breaks in while */
	        if (state.mode === BAD) {
	          break;
	        }

	        /* check for end-of-block code (better have one) */
	        if (state.lens[256] === 0) {
	          strm.msg = 'invalid code -- missing end-of-block';
	          state.mode = BAD;
	          break;
	        }

	        /* build code tables -- note: do not change the lenbits or distbits
	           values here (9 and 6) without reading the comments in inftrees.h
	           concerning the ENOUGH constants, which depend on those values */
	        state.lenbits = 9;
	        opts = {
	          bits: state.lenbits
	        };
	        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
	        // We have separate tables & no pointers. 2 commented lines below not needed.
	        // state.next_index = opts.table_index;
	        state.lenbits = opts.bits;
	        // state.lencode = state.next;

	        if (ret) {
	          strm.msg = 'invalid literal/lengths set';
	          state.mode = BAD;
	          break;
	        }
	        state.distbits = 6;
	        //state.distcode.copy(state.codes);
	        // Switch to use dynamic table
	        state.distcode = state.distdyn;
	        opts = {
	          bits: state.distbits
	        };
	        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
	        // We have separate tables & no pointers. 2 commented lines below not needed.
	        // state.next_index = opts.table_index;
	        state.distbits = opts.bits;
	        // state.distcode = state.next;

	        if (ret) {
	          strm.msg = 'invalid distances set';
	          state.mode = BAD;
	          break;
	        }
	        //Tracev((stderr, 'inflate:       codes ok\n'));
	        state.mode = LEN_;
	        if (flush === Z_TREES) {
	          break inf_leave;
	        }
	      /* falls through */
	      case LEN_:
	        state.mode = LEN;
	      /* falls through */
	      case LEN:
	        if (have >= 6 && left >= 258) {
	          //--- RESTORE() ---
	          strm.next_out = put;
	          strm.avail_out = left;
	          strm.next_in = next;
	          strm.avail_in = have;
	          state.hold = hold;
	          state.bits = bits;
	          //---
	          inflate_fast(strm, _out);
	          //--- LOAD() ---
	          put = strm.next_out;
	          output = strm.output;
	          left = strm.avail_out;
	          next = strm.next_in;
	          input = strm.input;
	          have = strm.avail_in;
	          hold = state.hold;
	          bits = state.bits;
	          //---

	          if (state.mode === TYPE) {
	            state.back = -1;
	          }
	          break;
	        }
	        state.back = 0;
	        for (;;) {
	          here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
	          here_bits = here >>> 24;
	          here_op = here >>> 16 & 0xff;
	          here_val = here & 0xffff;
	          if (here_bits <= bits) {
	            break;
	          }
	          //--- PULLBYTE() ---//
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }

	        if (here_op && (here_op & 0xf0) === 0) {
	          last_bits = here_bits;
	          last_op = here_op;
	          last_val = here_val;
	          for (;;) {
	            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1 /*BITS(last.bits + last.op)*/) >> last_bits)];
	            here_bits = here >>> 24;
	            here_op = here >>> 16 & 0xff;
	            here_val = here & 0xffff;
	            if (last_bits + here_bits <= bits) {
	              break;
	            }
	            //--- PULLBYTE() ---//
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	            //---//
	          }
	          //--- DROPBITS(last.bits) ---//
	          hold >>>= last_bits;
	          bits -= last_bits;
	          //---//
	          state.back += last_bits;
	        }
	        //--- DROPBITS(here.bits) ---//
	        hold >>>= here_bits;
	        bits -= here_bits;
	        //---//
	        state.back += here_bits;
	        state.length = here_val;
	        if (here_op === 0) {
	          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	          //        "inflate:         literal '%c'\n" :
	          //        "inflate:         literal 0x%02x\n", here.val));
	          state.mode = LIT;
	          break;
	        }
	        if (here_op & 32) {
	          //Tracevv((stderr, "inflate:         end of block\n"));
	          state.back = -1;
	          state.mode = TYPE;
	          break;
	        }
	        if (here_op & 64) {
	          strm.msg = 'invalid literal/length code';
	          state.mode = BAD;
	          break;
	        }
	        state.extra = here_op & 15;
	        state.mode = LENEXT;
	      /* falls through */
	      case LENEXT:
	        if (state.extra) {
	          //=== NEEDBITS(state.extra);
	          n = state.extra;
	          while (bits < n) {
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.length += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
	          //--- DROPBITS(state.extra) ---//
	          hold >>>= state.extra;
	          bits -= state.extra;
	          //---//
	          state.back += state.extra;
	        }
	        //Tracevv((stderr, "inflate:         length %u\n", state.length));
	        state.was = state.length;
	        state.mode = DIST;
	      /* falls through */
	      case DIST:
	        for (;;) {
	          here = state.distcode[hold & (1 << state.distbits) - 1]; /*BITS(state.distbits)*/
	          here_bits = here >>> 24;
	          here_op = here >>> 16 & 0xff;
	          here_val = here & 0xffff;
	          if (here_bits <= bits) {
	            break;
	          }
	          //--- PULLBYTE() ---//
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }

	        if ((here_op & 0xf0) === 0) {
	          last_bits = here_bits;
	          last_op = here_op;
	          last_val = here_val;
	          for (;;) {
	            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1 /*BITS(last.bits + last.op)*/) >> last_bits)];
	            here_bits = here >>> 24;
	            here_op = here >>> 16 & 0xff;
	            here_val = here & 0xffff;
	            if (last_bits + here_bits <= bits) {
	              break;
	            }
	            //--- PULLBYTE() ---//
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	            //---//
	          }
	          //--- DROPBITS(last.bits) ---//
	          hold >>>= last_bits;
	          bits -= last_bits;
	          //---//
	          state.back += last_bits;
	        }
	        //--- DROPBITS(here.bits) ---//
	        hold >>>= here_bits;
	        bits -= here_bits;
	        //---//
	        state.back += here_bits;
	        if (here_op & 64) {
	          strm.msg = 'invalid distance code';
	          state.mode = BAD;
	          break;
	        }
	        state.offset = here_val;
	        state.extra = here_op & 15;
	        state.mode = DISTEXT;
	      /* falls through */
	      case DISTEXT:
	        if (state.extra) {
	          //=== NEEDBITS(state.extra);
	          n = state.extra;
	          while (bits < n) {
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.offset += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
	          //--- DROPBITS(state.extra) ---//
	          hold >>>= state.extra;
	          bits -= state.extra;
	          //---//
	          state.back += state.extra;
	        }
	        //#ifdef INFLATE_STRICT
	        if (state.offset > state.dmax) {
	          strm.msg = 'invalid distance too far back';
	          state.mode = BAD;
	          break;
	        }
	        //#endif
	        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
	        state.mode = MATCH;
	      /* falls through */
	      case MATCH:
	        if (left === 0) {
	          break inf_leave;
	        }
	        copy = _out - left;
	        if (state.offset > copy) {
	          /* copy from window */
	          copy = state.offset - copy;
	          if (copy > state.whave) {
	            if (state.sane) {
	              strm.msg = 'invalid distance too far back';
	              state.mode = BAD;
	              break;
	            }
	            // (!) This block is disabled in zlib defaults,
	            // don't enable it for binary compatibility
	            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	            //          Trace((stderr, "inflate.c too far\n"));
	            //          copy -= state.whave;
	            //          if (copy > state.length) { copy = state.length; }
	            //          if (copy > left) { copy = left; }
	            //          left -= copy;
	            //          state.length -= copy;
	            //          do {
	            //            output[put++] = 0;
	            //          } while (--copy);
	            //          if (state.length === 0) { state.mode = LEN; }
	            //          break;
	            //#endif
	          }

	          if (copy > state.wnext) {
	            copy -= state.wnext;
	            from = state.wsize - copy;
	          } else {
	            from = state.wnext - copy;
	          }
	          if (copy > state.length) {
	            copy = state.length;
	          }
	          from_source = state.window;
	        } else {
	          /* copy from output */
	          from_source = output;
	          from = put - state.offset;
	          copy = state.length;
	        }
	        if (copy > left) {
	          copy = left;
	        }
	        left -= copy;
	        state.length -= copy;
	        do {
	          output[put++] = from_source[from++];
	        } while (--copy);
	        if (state.length === 0) {
	          state.mode = LEN;
	        }
	        break;
	      case LIT:
	        if (left === 0) {
	          break inf_leave;
	        }
	        output[put++] = state.length;
	        left--;
	        state.mode = LEN;
	        break;
	      case CHECK:
	        if (state.wrap) {
	          //=== NEEDBITS(32);
	          while (bits < 32) {
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            // Use '|' instead of '+' to make sure that result is signed
	            hold |= input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          _out -= left;
	          strm.total_out += _out;
	          state.total += _out;
	          if (_out) {
	            strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
	            state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
	          }
	          _out = left;
	          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
	          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
	            strm.msg = 'incorrect data check';
	            state.mode = BAD;
	            break;
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	          //Tracev((stderr, "inflate:   check matches trailer\n"));
	        }

	        state.mode = LENGTH;
	      /* falls through */
	      case LENGTH:
	        if (state.wrap && state.flags) {
	          //=== NEEDBITS(32);
	          while (bits < 32) {
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          if (hold !== (state.total & 0xffffffff)) {
	            strm.msg = 'incorrect length check';
	            state.mode = BAD;
	            break;
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	          //Tracev((stderr, "inflate:   length matches trailer\n"));
	        }

	        state.mode = DONE;
	      /* falls through */
	      case DONE:
	        ret = Z_STREAM_END;
	        break inf_leave;
	      case BAD:
	        ret = Z_DATA_ERROR;
	        break inf_leave;
	      case MEM:
	        return Z_MEM_ERROR;
	      case SYNC:
	      /* falls through */
	      default:
	        return Z_STREAM_ERROR;
	    }
	  }

	  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

	  /*
	     Return from inflate(), updating the total counts and the check value.
	     If there was no progress during the inflate() call, return a buffer
	     error.  Call updatewindow() to create and/or update the window state.
	     Note: a memory error from inflate() is non-recoverable.
	   */

	  //--- RESTORE() ---
	  strm.next_out = put;
	  strm.avail_out = left;
	  strm.next_in = next;
	  strm.avail_in = have;
	  state.hold = hold;
	  state.bits = bits;
	  //---

	  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
	    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
	  }
	  _in -= strm.avail_in;
	  _out -= strm.avail_out;
	  strm.total_in += _in;
	  strm.total_out += _out;
	  state.total += _out;
	  if (state.wrap && _out) {
	    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
	    state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
	  }
	  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
	  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
	    ret = Z_BUF_ERROR;
	  }
	  return ret;
	}
	function inflateEnd(strm) {
	  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
	    return Z_STREAM_ERROR;
	  }
	  var state = strm.state;
	  if (state.window) {
	    state.window = null;
	  }
	  strm.state = null;
	  return Z_OK;
	}
	function inflateGetHeader(strm, head) {
	  var state;

	  /* check state */
	  if (!strm || !strm.state) {
	    return Z_STREAM_ERROR;
	  }
	  state = strm.state;
	  if ((state.wrap & 2) === 0) {
	    return Z_STREAM_ERROR;
	  }

	  /* save header structure */
	  state.head = head;
	  head.done = false;
	  return Z_OK;
	}
	function inflateSetDictionary(strm, dictionary) {
	  var dictLength = dictionary.length;
	  var state;
	  var dictid;
	  var ret;

	  /* check state */
	  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) {
	    return Z_STREAM_ERROR;
	  }
	  state = strm.state;
	  if (state.wrap !== 0 && state.mode !== DICT) {
	    return Z_STREAM_ERROR;
	  }

	  /* check for correct dictionary identifier */
	  if (state.mode === DICT) {
	    dictid = 1; /* adler32(0, null, 0)*/
	    /* dictid = adler32(dictid, dictionary, dictLength); */
	    dictid = adler32(dictid, dictionary, dictLength, 0);
	    if (dictid !== state.check) {
	      return Z_DATA_ERROR;
	    }
	  }
	  /* copy dictionary to window using updatewindow(), which will amend the
	   existing dictionary if appropriate */
	  ret = updatewindow(strm, dictionary, dictLength, dictLength);
	  if (ret) {
	    state.mode = MEM;
	    return Z_MEM_ERROR;
	  }
	  state.havedict = 1;
	  // Tracev((stderr, "inflate:   dictionary set\n"));
	  return Z_OK;
	}
	inflate$3.inflateReset = inflateReset;
	inflate$3.inflateReset2 = inflateReset2;
	inflate$3.inflateResetKeep = inflateResetKeep;
	inflate$3.inflateInit = inflateInit;
	inflate$3.inflateInit2 = inflateInit2;
	inflate$3.inflate = inflate$2;
	inflate$3.inflateEnd = inflateEnd;
	inflate$3.inflateGetHeader = inflateGetHeader;
	inflate$3.inflateSetDictionary = inflateSetDictionary;
	inflate$3.inflateInfo = 'pako inflate (from Nodeca project)';

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	var constants$1 = {
	  /* Allowed flush values; see deflate() and inflate() below for details */
	  Z_NO_FLUSH: 0,
	  Z_PARTIAL_FLUSH: 1,
	  Z_SYNC_FLUSH: 2,
	  Z_FULL_FLUSH: 3,
	  Z_FINISH: 4,
	  Z_BLOCK: 5,
	  Z_TREES: 6,
	  /* Return codes for the compression/decompression functions. Negative values
	  * are errors, positive values are used for special but normal events.
	  */
	  Z_OK: 0,
	  Z_STREAM_END: 1,
	  Z_NEED_DICT: 2,
	  Z_ERRNO: -1,
	  Z_STREAM_ERROR: -2,
	  Z_DATA_ERROR: -3,
	  //Z_MEM_ERROR:     -4,
	  Z_BUF_ERROR: -5,
	  //Z_VERSION_ERROR: -6,

	  /* compression levels */
	  Z_NO_COMPRESSION: 0,
	  Z_BEST_SPEED: 1,
	  Z_BEST_COMPRESSION: 9,
	  Z_DEFAULT_COMPRESSION: -1,
	  Z_FILTERED: 1,
	  Z_HUFFMAN_ONLY: 2,
	  Z_RLE: 3,
	  Z_FIXED: 4,
	  Z_DEFAULT_STRATEGY: 0,
	  /* Possible values of the data_type field (though see inflate()) */
	  Z_BINARY: 0,
	  Z_TEXT: 1,
	  //Z_ASCII:                1, // = Z_TEXT (deprecated)
	  Z_UNKNOWN: 2,
	  /* The deflate compression method */
	  Z_DEFLATED: 8
	  //Z_NULL:                 null // Use -1 or null inline, depending on var type
	};

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	function GZheader$1() {
	  /* true if compressed data believed to be text */
	  this.text = 0;
	  /* modification time */
	  this.time = 0;
	  /* extra flags (not used when writing a gzip file) */
	  this.xflags = 0;
	  /* operating system */
	  this.os = 0;
	  /* pointer to extra field or Z_NULL if none */
	  this.extra = null;
	  /* extra field length (valid if extra != Z_NULL) */
	  this.extra_len = 0; // Actually, we don't need it in JS,
	  // but leave for few code modifications

	  //
	  // Setup limits is not necessary because in js we should not preallocate memory
	  // for inflate use constant limit in 65536 bytes
	  //

	  /* space at extra (only when reading header) */
	  // this.extra_max  = 0;
	  /* pointer to zero-terminated file name or Z_NULL */
	  this.name = '';
	  /* space at name (only when reading header) */
	  // this.name_max   = 0;
	  /* pointer to zero-terminated comment or Z_NULL */
	  this.comment = '';
	  /* space at comment (only when reading header) */
	  // this.comm_max   = 0;
	  /* true if there was or will be a header crc */
	  this.hcrc = 0;
	  /* true when done reading gzip header (not used when writing a gzip file) */
	  this.done = false;
	}
	var gzheader = GZheader$1;

	var zlib_inflate = inflate$3;
	var utils = common;
	var strings = strings$2;
	var c = constants$1;
	var msg = messages;
	var ZStream = zstream;
	var GZheader = gzheader;
	var toString$1 = Object.prototype.toString;

	/**
	 * class Inflate
	 *
	 * Generic JS-style wrapper for zlib calls. If you don't need
	 * streaming behaviour - use more simple functions: [[inflate]]
	 * and [[inflateRaw]].
	 **/

	/* internal
	 * inflate.chunks -> Array
	 *
	 * Chunks of output data, if [[Inflate#onData]] not overridden.
	 **/

	/**
	 * Inflate.result -> Uint8Array|Array|String
	 *
	 * Uncompressed result, generated by default [[Inflate#onData]]
	 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
	 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
	 * push a chunk with explicit flush (call [[Inflate#push]] with
	 * `Z_SYNC_FLUSH` param).
	 **/

	/**
	 * Inflate.err -> Number
	 *
	 * Error code after inflate finished. 0 (Z_OK) on success.
	 * Should be checked if broken data possible.
	 **/

	/**
	 * Inflate.msg -> String
	 *
	 * Error message, if [[Inflate.err]] != 0
	 **/

	/**
	 * new Inflate(options)
	 * - options (Object): zlib inflate options.
	 *
	 * Creates new inflator instance with specified params. Throws exception
	 * on bad params. Supported options:
	 *
	 * - `windowBits`
	 * - `dictionary`
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information on these.
	 *
	 * Additional options, for internal needs:
	 *
	 * - `chunkSize` - size of generated data chunks (16K by default)
	 * - `raw` (Boolean) - do raw inflate
	 * - `to` (String) - if equal to 'string', then result will be converted
	 *   from utf8 to utf16 (javascript) string. When string output requested,
	 *   chunk length can differ from `chunkSize`, depending on content.
	 *
	 * By default, when no options set, autodetect deflate/gzip data format via
	 * wrapper header.
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
	 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
	 *
	 * var inflate = new pako.Inflate({ level: 3});
	 *
	 * inflate.push(chunk1, false);
	 * inflate.push(chunk2, true);  // true -> last chunk
	 *
	 * if (inflate.err) { throw new Error(inflate.err); }
	 *
	 * console.log(inflate.result);
	 * ```
	 **/
	function Inflate(options) {
	  if (!(this instanceof Inflate)) return new Inflate(options);
	  this.options = utils.assign({
	    chunkSize: 16384,
	    windowBits: 0,
	    to: ''
	  }, options || {});
	  var opt = this.options;

	  // Force window size for `raw` data, if not set directly,
	  // because we have no header for autodetect.
	  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
	    opt.windowBits = -opt.windowBits;
	    if (opt.windowBits === 0) {
	      opt.windowBits = -15;
	    }
	  }

	  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
	  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
	    opt.windowBits += 32;
	  }

	  // Gzip header has no info about windows size, we can do autodetect only
	  // for deflate. So, if window size not set, force it to max when gzip possible
	  if (opt.windowBits > 15 && opt.windowBits < 48) {
	    // bit 3 (16) -> gzipped data
	    // bit 4 (32) -> autodetect gzip/deflate
	    if ((opt.windowBits & 15) === 0) {
	      opt.windowBits |= 15;
	    }
	  }
	  this.err = 0; // error code, if happens (0 = Z_OK)
	  this.msg = ''; // error message
	  this.ended = false; // used to avoid multiple onEnd() calls
	  this.chunks = []; // chunks of compressed data

	  this.strm = new ZStream();
	  this.strm.avail_out = 0;
	  var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
	  if (status !== c.Z_OK) {
	    throw new Error(msg[status]);
	  }
	  this.header = new GZheader();
	  zlib_inflate.inflateGetHeader(this.strm, this.header);

	  // Setup dictionary
	  if (opt.dictionary) {
	    // Convert data if needed
	    if (typeof opt.dictionary === 'string') {
	      opt.dictionary = strings.string2buf(opt.dictionary);
	    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
	      opt.dictionary = new Uint8Array(opt.dictionary);
	    }
	    if (opt.raw) {
	      //In raw mode we need to set the dictionary early
	      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
	      if (status !== c.Z_OK) {
	        throw new Error(msg[status]);
	      }
	    }
	  }
	}

	/**
	 * Inflate#push(data[, mode]) -> Boolean
	 * - data (Uint8Array|Array|ArrayBuffer|String): input data
	 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
	 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
	 *
	 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
	 * new output chunks. Returns `true` on success. The last data block must have
	 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
	 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
	 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
	 *
	 * On fail call [[Inflate#onEnd]] with error code and return false.
	 *
	 * We strongly recommend to use `Uint8Array` on input for best speed (output
	 * format is detected automatically). Also, don't skip last param and always
	 * use the same type in your code (boolean or number). That will improve JS speed.
	 *
	 * For regular `Array`-s make sure all elements are [0..255].
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * push(chunk, false); // push one of data chunks
	 * ...
	 * push(chunk, true);  // push last chunk
	 * ```
	 **/
	Inflate.prototype.push = function (data, mode) {
	  var strm = this.strm;
	  var chunkSize = this.options.chunkSize;
	  var dictionary = this.options.dictionary;
	  var status, _mode;
	  var next_out_utf8, tail, utf8str;

	  // Flag to properly process Z_BUF_ERROR on testing inflate call
	  // when we check that all output data was flushed.
	  var allowBufError = false;
	  if (this.ended) {
	    return false;
	  }
	  _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;

	  // Convert data if needed
	  if (typeof data === 'string') {
	    // Only binary strings can be decompressed on practice
	    strm.input = strings.binstring2buf(data);
	  } else if (toString$1.call(data) === '[object ArrayBuffer]') {
	    strm.input = new Uint8Array(data);
	  } else {
	    strm.input = data;
	  }
	  strm.next_in = 0;
	  strm.avail_in = strm.input.length;
	  do {
	    if (strm.avail_out === 0) {
	      strm.output = new utils.Buf8(chunkSize);
	      strm.next_out = 0;
	      strm.avail_out = chunkSize;
	    }
	    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH); /* no bad return value */

	    if (status === c.Z_NEED_DICT && dictionary) {
	      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
	    }
	    if (status === c.Z_BUF_ERROR && allowBufError === true) {
	      status = c.Z_OK;
	      allowBufError = false;
	    }
	    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
	      this.onEnd(status);
	      this.ended = true;
	      return false;
	    }
	    if (strm.next_out) {
	      if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
	        if (this.options.to === 'string') {
	          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
	          tail = strm.next_out - next_out_utf8;
	          utf8str = strings.buf2string(strm.output, next_out_utf8);

	          // move tail
	          strm.next_out = tail;
	          strm.avail_out = chunkSize - tail;
	          if (tail) {
	            utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
	          }
	          this.onData(utf8str);
	        } else {
	          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
	        }
	      }
	    }

	    // When no more input data, we should check that internal inflate buffers
	    // are flushed. The only way to do it when avail_out = 0 - run one more
	    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
	    // Here we set flag to process this error properly.
	    //
	    // NOTE. Deflate does not return error in this case and does not needs such
	    // logic.
	    if (strm.avail_in === 0 && strm.avail_out === 0) {
	      allowBufError = true;
	    }
	  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
	  if (status === c.Z_STREAM_END) {
	    _mode = c.Z_FINISH;
	  }

	  // Finalize on the last chunk.
	  if (_mode === c.Z_FINISH) {
	    status = zlib_inflate.inflateEnd(this.strm);
	    this.onEnd(status);
	    this.ended = true;
	    return status === c.Z_OK;
	  }

	  // callback interim results if Z_SYNC_FLUSH.
	  if (_mode === c.Z_SYNC_FLUSH) {
	    this.onEnd(c.Z_OK);
	    strm.avail_out = 0;
	    return true;
	  }
	  return true;
	};

	/**
	 * Inflate#onData(chunk) -> Void
	 * - chunk (Uint8Array|Array|String): output data. Type of array depends
	 *   on js engine support. When string output requested, each chunk
	 *   will be string.
	 *
	 * By default, stores data blocks in `chunks[]` property and glue
	 * those in `onEnd`. Override this handler, if you need another behaviour.
	 **/
	Inflate.prototype.onData = function (chunk) {
	  this.chunks.push(chunk);
	};

	/**
	 * Inflate#onEnd(status) -> Void
	 * - status (Number): inflate status. 0 (Z_OK) on success,
	 *   other if not.
	 *
	 * Called either after you tell inflate that the input stream is
	 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
	 * or if an error happened. By default - join collected chunks,
	 * free memory and fill `results` / `err` properties.
	 **/
	Inflate.prototype.onEnd = function (status) {
	  // On success - join
	  if (status === c.Z_OK) {
	    if (this.options.to === 'string') {
	      // Glue & convert here, until we teach pako to send
	      // utf8 aligned strings to onData
	      this.result = this.chunks.join('');
	    } else {
	      this.result = utils.flattenChunks(this.chunks);
	    }
	  }
	  this.chunks = [];
	  this.err = status;
	  this.msg = this.strm.msg;
	};

	/**
	 * inflate(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * Decompress `data` with inflate/ungzip and `options`. Autodetect
	 * format via wrapper header by default. That's why we don't provide
	 * separate `ungzip` method.
	 *
	 * Supported options are:
	 *
	 * - windowBits
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information.
	 *
	 * Sugar (options):
	 *
	 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
	 *   negative windowBits implicitly.
	 * - `to` (String) - if equal to 'string', then result will be converted
	 *   from utf8 to utf16 (javascript) string. When string output requested,
	 *   chunk length can differ from `chunkSize`, depending on content.
	 *
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
	 *   , output;
	 *
	 * try {
	 *   output = pako.inflate(input);
	 * } catch (err)
	 *   console.log(err);
	 * }
	 * ```
	 **/
	function inflate$1(input, options) {
	  var inflator = new Inflate(options);
	  inflator.push(input, true);

	  // That will never happens, if you don't cheat with options :)
	  if (inflator.err) {
	    throw inflator.msg || msg[inflator.err];
	  }
	  return inflator.result;
	}

	/**
	 * inflateRaw(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * The same as [[inflate]], but creates raw data, without wrapper
	 * (header and adler32 crc).
	 **/
	function inflateRaw(input, options) {
	  options = options || {};
	  options.raw = true;
	  return inflate$1(input, options);
	}

	/**
	 * ungzip(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * Just shortcut to [[inflate]], because it autodetects format
	 * by header.content. Done for convenience.
	 **/

	inflate$4.Inflate = Inflate;
	inflate$4.inflate = inflate$1;
	inflate$4.inflateRaw = inflateRaw;
	inflate$4.ungzip = inflate$1;

	var assign$1 = common.assign;
	var deflate = deflate$4;
	var inflate = inflate$4;
	var constants = constants$1;
	var pako = {};
	assign$1(pako, deflate, inflate, constants);
	var pako_1 = pako;

	// browserify-zlib, which is the zlib shim used by default in webpacked code,
	// does not properly uncompress bgzf chunks that contain more than
	// one bgzf block, so export an unzip function that uses pako directly
	// if we are running in a browser.
	function unzip(_x) {
	  return _unzip.apply(this, arguments);
	} // similar to pakounzip, except it does extra counting
	// to return the positions of compressed and decompressed
	// data offsets
	function _unzip() {
	  _unzip = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(inputData) {
	    var strm, pos, i, chunks, totalSize, inflator, remainingInput, _inflator, result, _i, offset;
	    return _regeneratorRuntime().wrap(function _callee$(_context) {
	      while (1) switch (_context.prev = _context.next) {
	        case 0:
	          _context.prev = 0;
	          pos = 0;
	          i = 0;
	          chunks = [];
	          totalSize = 0;
	        case 5:
	          remainingInput = inputData.subarray(pos);
	          inflator = new pako_1.Inflate();
	          _inflator = inflator;
	          strm = _inflator.strm;
	          inflator.push(remainingInput, pako_1.Z_SYNC_FLUSH);
	          if (!inflator.err) {
	            _context.next = 12;
	            break;
	          }
	          throw new Error(inflator.msg);
	        case 12:
	          pos += strm.next_in;
	          chunks[i] = inflator.result;
	          totalSize += chunks[i].length;
	          i += 1;
	        case 16:
	          if (strm.avail_in) {
	            _context.next = 5;
	            break;
	          }
	        case 17:
	          result = new Uint8Array(totalSize);
	          for (_i = 0, offset = 0; _i < chunks.length; _i++) {
	            result.set(chunks[_i], offset);
	            offset += chunks[_i].length;
	          }
	          return _context.abrupt("return", Buffer.from(result));
	        case 22:
	          _context.prev = 22;
	          _context.t0 = _context["catch"](0);
	          if (!"".concat(_context.t0).match(/incorrect header check/)) {
	            _context.next = 26;
	            break;
	          }
	          throw new Error('problem decompressing block: incorrect gzip header check');
	        case 26:
	          throw _context.t0;
	        case 27:
	        case "end":
	          return _context.stop();
	      }
	    }, _callee, null, [[0, 22]]);
	  }));
	  return _unzip.apply(this, arguments);
	}

	/**
	 * @license
	 * Copyright 2009 The Closure Library Authors
	 * Copyright 2020 Daniel Wirtz / The long.js Authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * SPDX-License-Identifier: Apache-2.0
	 */

	// WebAssembly optimizations to do native i64 multiplication and divide
	var wasm = null;
	try {
	  wasm = new WebAssembly.Instance( /*#__PURE__*/new WebAssembly.Module( /*#__PURE__*/new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
	} catch (e) {
	  // no wasm support :(
	}

	/**
	 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
	 *  See the from* functions below for more convenient ways of constructing Longs.
	 * @exports Long
	 * @class A Long class for representing a 64 bit two's-complement integer value.
	 * @param {number} low The low (signed) 32 bits of the long
	 * @param {number} high The high (signed) 32 bits of the long
	 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
	 * @constructor
	 */
	function Long(low, high, unsigned) {
	  /**
	   * The low 32 bits as a signed value.
	   * @type {number}
	   */
	  this.low = low | 0;

	  /**
	   * The high 32 bits as a signed value.
	   * @type {number}
	   */
	  this.high = high | 0;

	  /**
	   * Whether unsigned or not.
	   * @type {boolean}
	   */
	  this.unsigned = !!unsigned;
	}
	Object.defineProperty(Long.prototype, "__isLong__", {
	  value: true
	});

	/**
	 * @function
	 * @param {*} obj Object
	 * @returns {boolean}
	 * @inner
	 */
	function isLong(obj) {
	  return (obj && obj["__isLong__"]) === true;
	}

	/**
	 * @function
	 * @param {*} value number
	 * @returns {number}
	 * @inner
	 */
	function ctz32(value) {
	  var c = Math.clz32(value & -value);
	  return value ? 31 - c : c;
	}

	/**
	 * Tests if the specified object is a Long.
	 * @function
	 * @param {*} obj Object
	 * @returns {boolean}
	 */
	Long.isLong = isLong;

	/**
	 * A cache of the Long representations of small integer values.
	 * @type {!Object}
	 * @inner
	 */
	var INT_CACHE = {};

	/**
	 * A cache of the Long representations of small unsigned integer values.
	 * @type {!Object}
	 * @inner
	 */
	var UINT_CACHE = {};

	/**
	 * @param {number} value
	 * @param {boolean=} unsigned
	 * @returns {!Long}
	 * @inner
	 */
	function fromInt(value, unsigned) {
	  var obj, cachedObj, cache;
	  if (unsigned) {
	    value >>>= 0;
	    if (cache = 0 <= value && value < 256) {
	      cachedObj = UINT_CACHE[value];
	      if (cachedObj) return cachedObj;
	    }
	    obj = fromBits(value, 0, true);
	    if (cache) UINT_CACHE[value] = obj;
	    return obj;
	  } else {
	    value |= 0;
	    if (cache = -128 <= value && value < 128) {
	      cachedObj = INT_CACHE[value];
	      if (cachedObj) return cachedObj;
	    }
	    obj = fromBits(value, value < 0 ? -1 : 0, false);
	    if (cache) INT_CACHE[value] = obj;
	    return obj;
	  }
	}

	/**
	 * Returns a Long representing the given 32 bit integer value.
	 * @function
	 * @param {number} value The 32 bit integer in question
	 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
	 * @returns {!Long} The corresponding Long value
	 */
	Long.fromInt = fromInt;

	/**
	 * @param {number} value
	 * @param {boolean=} unsigned
	 * @returns {!Long}
	 * @inner
	 */
	function fromNumber(value, unsigned) {
	  if (isNaN(value)) return unsigned ? UZERO : ZERO;
	  if (unsigned) {
	    if (value < 0) return UZERO;
	    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
	  } else {
	    if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
	    if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
	  }
	  if (value < 0) return fromNumber(-value, unsigned).neg();
	  return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
	}

	/**
	 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
	 * @function
	 * @param {number} value The number in question
	 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
	 * @returns {!Long} The corresponding Long value
	 */
	Long.fromNumber = fromNumber;

	/**
	 * @param {number} lowBits
	 * @param {number} highBits
	 * @param {boolean=} unsigned
	 * @returns {!Long}
	 * @inner
	 */
	function fromBits(lowBits, highBits, unsigned) {
	  return new Long(lowBits, highBits, unsigned);
	}

	/**
	 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
	 *  assumed to use 32 bits.
	 * @function
	 * @param {number} lowBits The low 32 bits
	 * @param {number} highBits The high 32 bits
	 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
	 * @returns {!Long} The corresponding Long value
	 */
	Long.fromBits = fromBits;

	/**
	 * @function
	 * @param {number} base
	 * @param {number} exponent
	 * @returns {number}
	 * @inner
	 */
	var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

	/**
	 * @param {string} str
	 * @param {(boolean|number)=} unsigned
	 * @param {number=} radix
	 * @returns {!Long}
	 * @inner
	 */
	function fromString(str, unsigned, radix) {
	  if (str.length === 0) throw Error('empty string');
	  if (typeof unsigned === 'number') {
	    // For goog.math.long compatibility
	    radix = unsigned;
	    unsigned = false;
	  } else {
	    unsigned = !!unsigned;
	  }
	  if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
	  radix = radix || 10;
	  if (radix < 2 || 36 < radix) throw RangeError('radix');
	  var p;
	  if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {
	    return fromString(str.substring(1), unsigned, radix).neg();
	  }

	  // Do several (8) digits each time through the loop, so as to
	  // minimize the calls to the very expensive emulated div.
	  var radixToPower = fromNumber(pow_dbl(radix, 8));
	  var result = ZERO;
	  for (var i = 0; i < str.length; i += 8) {
	    var size = Math.min(8, str.length - i),
	      value = parseInt(str.substring(i, i + size), radix);
	    if (size < 8) {
	      var power = fromNumber(pow_dbl(radix, size));
	      result = result.mul(power).add(fromNumber(value));
	    } else {
	      result = result.mul(radixToPower);
	      result = result.add(fromNumber(value));
	    }
	  }
	  result.unsigned = unsigned;
	  return result;
	}

	/**
	 * Returns a Long representation of the given string, written using the specified radix.
	 * @function
	 * @param {string} str The textual representation of the Long
	 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
	 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
	 * @returns {!Long} The corresponding Long value
	 */
	Long.fromString = fromString;

	/**
	 * @function
	 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
	 * @param {boolean=} unsigned
	 * @returns {!Long}
	 * @inner
	 */
	function fromValue(val, unsigned) {
	  if (typeof val === 'number') return fromNumber(val, unsigned);
	  if (typeof val === 'string') return fromString(val, unsigned);
	  // Throws for non-objects, converts non-instanceof Long:
	  return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
	}

	/**
	 * Converts the specified value to a Long using the appropriate from* function for its type.
	 * @function
	 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
	 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
	 * @returns {!Long}
	 */
	Long.fromValue = fromValue;

	// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
	// no runtime penalty for these.

	/**
	 * @type {number}
	 * @const
	 * @inner
	 */
	var TWO_PWR_16_DBL = 1 << 16;

	/**
	 * @type {number}
	 * @const
	 * @inner
	 */
	var TWO_PWR_24_DBL = 1 << 24;

	/**
	 * @type {number}
	 * @const
	 * @inner
	 */
	var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

	/**
	 * @type {number}
	 * @const
	 * @inner
	 */
	var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

	/**
	 * @type {number}
	 * @const
	 * @inner
	 */
	var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

	/**
	 * @type {!Long}
	 * @const
	 * @inner
	 */
	var TWO_PWR_24 = /*#__PURE__*/fromInt(TWO_PWR_24_DBL);

	/**
	 * @type {!Long}
	 * @inner
	 */
	var ZERO = /*#__PURE__*/fromInt(0);

	/**
	 * Signed zero.
	 * @type {!Long}
	 */
	Long.ZERO = ZERO;

	/**
	 * @type {!Long}
	 * @inner
	 */
	var UZERO = /*#__PURE__*/fromInt(0, true);

	/**
	 * Unsigned zero.
	 * @type {!Long}
	 */
	Long.UZERO = UZERO;

	/**
	 * @type {!Long}
	 * @inner
	 */
	var ONE = /*#__PURE__*/fromInt(1);

	/**
	 * Signed one.
	 * @type {!Long}
	 */
	Long.ONE = ONE;

	/**
	 * @type {!Long}
	 * @inner
	 */
	var UONE = /*#__PURE__*/fromInt(1, true);

	/**
	 * Unsigned one.
	 * @type {!Long}
	 */
	Long.UONE = UONE;

	/**
	 * @type {!Long}
	 * @inner
	 */
	var NEG_ONE = /*#__PURE__*/fromInt(-1);

	/**
	 * Signed negative one.
	 * @type {!Long}
	 */
	Long.NEG_ONE = NEG_ONE;

	/**
	 * @type {!Long}
	 * @inner
	 */
	var MAX_VALUE = /*#__PURE__*/fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);

	/**
	 * Maximum signed value.
	 * @type {!Long}
	 */
	Long.MAX_VALUE = MAX_VALUE;

	/**
	 * @type {!Long}
	 * @inner
	 */
	var MAX_UNSIGNED_VALUE = /*#__PURE__*/fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);

	/**
	 * Maximum unsigned value.
	 * @type {!Long}
	 */
	Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

	/**
	 * @type {!Long}
	 * @inner
	 */
	var MIN_VALUE = /*#__PURE__*/fromBits(0, 0x80000000 | 0, false);

	/**
	 * Minimum signed value.
	 * @type {!Long}
	 */
	Long.MIN_VALUE = MIN_VALUE;

	/**
	 * @alias Long.prototype
	 * @inner
	 */
	var LongPrototype = Long.prototype;

	/**
	 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
	 * @this {!Long}
	 * @returns {number}
	 */
	LongPrototype.toInt = function toInt() {
	  return this.unsigned ? this.low >>> 0 : this.low;
	};

	/**
	 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
	 * @this {!Long}
	 * @returns {number}
	 */
	LongPrototype.toNumber = function toNumber() {
	  if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
	  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
	};

	/**
	 * Converts the Long to a string written in the specified radix.
	 * @this {!Long}
	 * @param {number=} radix Radix (2-36), defaults to 10
	 * @returns {string}
	 * @override
	 * @throws {RangeError} If `radix` is out of range
	 */
	LongPrototype.toString = function toString(radix) {
	  radix = radix || 10;
	  if (radix < 2 || 36 < radix) throw RangeError('radix');
	  if (this.isZero()) return '0';
	  if (this.isNegative()) {
	    // Unsigned Longs are never negative
	    if (this.eq(MIN_VALUE)) {
	      // We need to change the Long value before it can be negated, so we remove
	      // the bottom-most digit in this base and then recurse to do the rest.
	      var radixLong = fromNumber(radix),
	        div = this.div(radixLong),
	        rem1 = div.mul(radixLong).sub(this);
	      return div.toString(radix) + rem1.toInt().toString(radix);
	    } else return '-' + this.neg().toString(radix);
	  }

	  // Do several (6) digits each time through the loop, so as to
	  // minimize the calls to the very expensive emulated div.
	  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
	    rem = this;
	  var result = '';
	  while (true) {
	    var remDiv = rem.div(radixToPower),
	      intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
	      digits = intval.toString(radix);
	    rem = remDiv;
	    if (rem.isZero()) return digits + result;else {
	      while (digits.length < 6) digits = '0' + digits;
	      result = '' + digits + result;
	    }
	  }
	};

	/**
	 * Gets the high 32 bits as a signed integer.
	 * @this {!Long}
	 * @returns {number} Signed high bits
	 */
	LongPrototype.getHighBits = function getHighBits() {
	  return this.high;
	};

	/**
	 * Gets the high 32 bits as an unsigned integer.
	 * @this {!Long}
	 * @returns {number} Unsigned high bits
	 */
	LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
	  return this.high >>> 0;
	};

	/**
	 * Gets the low 32 bits as a signed integer.
	 * @this {!Long}
	 * @returns {number} Signed low bits
	 */
	LongPrototype.getLowBits = function getLowBits() {
	  return this.low;
	};

	/**
	 * Gets the low 32 bits as an unsigned integer.
	 * @this {!Long}
	 * @returns {number} Unsigned low bits
	 */
	LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
	  return this.low >>> 0;
	};

	/**
	 * Gets the number of bits needed to represent the absolute value of this Long.
	 * @this {!Long}
	 * @returns {number}
	 */
	LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
	  if (this.isNegative())
	    // Unsigned Longs are never negative
	    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
	  var val = this.high != 0 ? this.high : this.low;
	  for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
	  return this.high != 0 ? bit + 33 : bit + 1;
	};

	/**
	 * Tests if this Long's value equals zero.
	 * @this {!Long}
	 * @returns {boolean}
	 */
	LongPrototype.isZero = function isZero() {
	  return this.high === 0 && this.low === 0;
	};

	/**
	 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
	 * @returns {boolean}
	 */
	LongPrototype.eqz = LongPrototype.isZero;

	/**
	 * Tests if this Long's value is negative.
	 * @this {!Long}
	 * @returns {boolean}
	 */
	LongPrototype.isNegative = function isNegative() {
	  return !this.unsigned && this.high < 0;
	};

	/**
	 * Tests if this Long's value is positive or zero.
	 * @this {!Long}
	 * @returns {boolean}
	 */
	LongPrototype.isPositive = function isPositive() {
	  return this.unsigned || this.high >= 0;
	};

	/**
	 * Tests if this Long's value is odd.
	 * @this {!Long}
	 * @returns {boolean}
	 */
	LongPrototype.isOdd = function isOdd() {
	  return (this.low & 1) === 1;
	};

	/**
	 * Tests if this Long's value is even.
	 * @this {!Long}
	 * @returns {boolean}
	 */
	LongPrototype.isEven = function isEven() {
	  return (this.low & 1) === 0;
	};

	/**
	 * Tests if this Long's value equals the specified's.
	 * @this {!Long}
	 * @param {!Long|number|string} other Other value
	 * @returns {boolean}
	 */
	LongPrototype.equals = function equals(other) {
	  if (!isLong(other)) other = fromValue(other);
	  if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
	  return this.high === other.high && this.low === other.low;
	};

	/**
	 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
	 * @function
	 * @param {!Long|number|string} other Other value
	 * @returns {boolean}
	 */
	LongPrototype.eq = LongPrototype.equals;

	/**
	 * Tests if this Long's value differs from the specified's.
	 * @this {!Long}
	 * @param {!Long|number|string} other Other value
	 * @returns {boolean}
	 */
	LongPrototype.notEquals = function notEquals(other) {
	  return !this.eq( /* validates */other);
	};

	/**
	 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
	 * @function
	 * @param {!Long|number|string} other Other value
	 * @returns {boolean}
	 */
	LongPrototype.neq = LongPrototype.notEquals;

	/**
	 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
	 * @function
	 * @param {!Long|number|string} other Other value
	 * @returns {boolean}
	 */
	LongPrototype.ne = LongPrototype.notEquals;

	/**
	 * Tests if this Long's value is less than the specified's.
	 * @this {!Long}
	 * @param {!Long|number|string} other Other value
	 * @returns {boolean}
	 */
	LongPrototype.lessThan = function lessThan(other) {
	  return this.comp( /* validates */other) < 0;
	};

	/**
	 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
	 * @function
	 * @param {!Long|number|string} other Other value
	 * @returns {boolean}
	 */
	LongPrototype.lt = LongPrototype.lessThan;

	/**
	 * Tests if this Long's value is less than or equal the specified's.
	 * @this {!Long}
	 * @param {!Long|number|string} other Other value
	 * @returns {boolean}
	 */
	LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
	  return this.comp( /* validates */other) <= 0;
	};

	/**
	 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
	 * @function
	 * @param {!Long|number|string} other Other value
	 * @returns {boolean}
	 */
	LongPrototype.lte = LongPrototype.lessThanOrEqual;

	/**
	 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
	 * @function
	 * @param {!Long|number|string} other Other value
	 * @returns {boolean}
	 */
	LongPrototype.le = LongPrototype.lessThanOrEqual;

	/**
	 * Tests if this Long's value is greater than the specified's.
	 * @this {!Long}
	 * @param {!Long|number|string} other Other value
	 * @returns {boolean}
	 */
	LongPrototype.greaterThan = function greaterThan(other) {
	  return this.comp( /* validates */other) > 0;
	};

	/**
	 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
	 * @function
	 * @param {!Long|number|string} other Other value
	 * @returns {boolean}
	 */
	LongPrototype.gt = LongPrototype.greaterThan;

	/**
	 * Tests if this Long's value is greater than or equal the specified's.
	 * @this {!Long}
	 * @param {!Long|number|string} other Other value
	 * @returns {boolean}
	 */
	LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
	  return this.comp( /* validates */other) >= 0;
	};

	/**
	 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
	 * @function
	 * @param {!Long|number|string} other Other value
	 * @returns {boolean}
	 */
	LongPrototype.gte = LongPrototype.greaterThanOrEqual;

	/**
	 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
	 * @function
	 * @param {!Long|number|string} other Other value
	 * @returns {boolean}
	 */
	LongPrototype.ge = LongPrototype.greaterThanOrEqual;

	/**
	 * Compares this Long's value with the specified's.
	 * @this {!Long}
	 * @param {!Long|number|string} other Other value
	 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
	 *  if the given one is greater
	 */
	LongPrototype.compare = function compare(other) {
	  if (!isLong(other)) other = fromValue(other);
	  if (this.eq(other)) return 0;
	  var thisNeg = this.isNegative(),
	    otherNeg = other.isNegative();
	  if (thisNeg && !otherNeg) return -1;
	  if (!thisNeg && otherNeg) return 1;
	  // At this point the sign bits are the same
	  if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
	  // Both are positive if at least one is unsigned
	  return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
	};

	/**
	 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
	 * @function
	 * @param {!Long|number|string} other Other value
	 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
	 *  if the given one is greater
	 */
	LongPrototype.comp = LongPrototype.compare;

	/**
	 * Negates this Long's value.
	 * @this {!Long}
	 * @returns {!Long} Negated Long
	 */
	LongPrototype.negate = function negate() {
	  if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
	  return this.not().add(ONE);
	};

	/**
	 * Negates this Long's value. This is an alias of {@link Long#negate}.
	 * @function
	 * @returns {!Long} Negated Long
	 */
	LongPrototype.neg = LongPrototype.negate;

	/**
	 * Returns the sum of this and the specified Long.
	 * @this {!Long}
	 * @param {!Long|number|string} addend Addend
	 * @returns {!Long} Sum
	 */
	LongPrototype.add = function add(addend) {
	  if (!isLong(addend)) addend = fromValue(addend);

	  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

	  var a48 = this.high >>> 16;
	  var a32 = this.high & 0xFFFF;
	  var a16 = this.low >>> 16;
	  var a00 = this.low & 0xFFFF;
	  var b48 = addend.high >>> 16;
	  var b32 = addend.high & 0xFFFF;
	  var b16 = addend.low >>> 16;
	  var b00 = addend.low & 0xFFFF;
	  var c48 = 0,
	    c32 = 0,
	    c16 = 0,
	    c00 = 0;
	  c00 += a00 + b00;
	  c16 += c00 >>> 16;
	  c00 &= 0xFFFF;
	  c16 += a16 + b16;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c32 += a32 + b32;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c48 += a48 + b48;
	  c48 &= 0xFFFF;
	  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
	};

	/**
	 * Returns the difference of this and the specified Long.
	 * @this {!Long}
	 * @param {!Long|number|string} subtrahend Subtrahend
	 * @returns {!Long} Difference
	 */
	LongPrototype.subtract = function subtract(subtrahend) {
	  if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
	  return this.add(subtrahend.neg());
	};

	/**
	 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
	 * @function
	 * @param {!Long|number|string} subtrahend Subtrahend
	 * @returns {!Long} Difference
	 */
	LongPrototype.sub = LongPrototype.subtract;

	/**
	 * Returns the product of this and the specified Long.
	 * @this {!Long}
	 * @param {!Long|number|string} multiplier Multiplier
	 * @returns {!Long} Product
	 */
	LongPrototype.multiply = function multiply(multiplier) {
	  if (this.isZero()) return this;
	  if (!isLong(multiplier)) multiplier = fromValue(multiplier);

	  // use wasm support if present
	  if (wasm) {
	    var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
	    return fromBits(low, wasm["get_high"](), this.unsigned);
	  }
	  if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
	  if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
	  if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
	  if (this.isNegative()) {
	    if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();
	  } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();

	  // If both longs are small, use float multiplication
	  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

	  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
	  // We can skip products that would overflow.

	  var a48 = this.high >>> 16;
	  var a32 = this.high & 0xFFFF;
	  var a16 = this.low >>> 16;
	  var a00 = this.low & 0xFFFF;
	  var b48 = multiplier.high >>> 16;
	  var b32 = multiplier.high & 0xFFFF;
	  var b16 = multiplier.low >>> 16;
	  var b00 = multiplier.low & 0xFFFF;
	  var c48 = 0,
	    c32 = 0,
	    c16 = 0,
	    c00 = 0;
	  c00 += a00 * b00;
	  c16 += c00 >>> 16;
	  c00 &= 0xFFFF;
	  c16 += a16 * b00;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c16 += a00 * b16;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c32 += a32 * b00;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c32 += a16 * b16;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c32 += a00 * b32;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
	  c48 &= 0xFFFF;
	  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
	};

	/**
	 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
	 * @function
	 * @param {!Long|number|string} multiplier Multiplier
	 * @returns {!Long} Product
	 */
	LongPrototype.mul = LongPrototype.multiply;

	/**
	 * Returns this Long divided by the specified. The result is signed if this Long is signed or
	 *  unsigned if this Long is unsigned.
	 * @this {!Long}
	 * @param {!Long|number|string} divisor Divisor
	 * @returns {!Long} Quotient
	 */
	LongPrototype.divide = function divide(divisor) {
	  if (!isLong(divisor)) divisor = fromValue(divisor);
	  if (divisor.isZero()) throw Error('division by zero');

	  // use wasm support if present
	  if (wasm) {
	    // guard against signed division overflow: the largest
	    // negative number / -1 would be 1 larger than the largest
	    // positive number, due to two's complement.
	    if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {
	      // be consistent with non-wasm code path
	      return this;
	    }
	    var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
	    return fromBits(low, wasm["get_high"](), this.unsigned);
	  }
	  if (this.isZero()) return this.unsigned ? UZERO : ZERO;
	  var approx, rem, res;
	  if (!this.unsigned) {
	    // This section is only relevant for signed longs and is derived from the
	    // closure library as a whole.
	    if (this.eq(MIN_VALUE)) {
	      if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
	      else if (divisor.eq(MIN_VALUE)) return ONE;else {
	        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
	        var halfThis = this.shr(1);
	        approx = halfThis.div(divisor).shl(1);
	        if (approx.eq(ZERO)) {
	          return divisor.isNegative() ? ONE : NEG_ONE;
	        } else {
	          rem = this.sub(divisor.mul(approx));
	          res = approx.add(rem.div(divisor));
	          return res;
	        }
	      }
	    } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
	    if (this.isNegative()) {
	      if (divisor.isNegative()) return this.neg().div(divisor.neg());
	      return this.neg().div(divisor).neg();
	    } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
	    res = ZERO;
	  } else {
	    // The algorithm below has not been made for unsigned longs. It's therefore
	    // required to take special care of the MSB prior to running it.
	    if (!divisor.unsigned) divisor = divisor.toUnsigned();
	    if (divisor.gt(this)) return UZERO;
	    if (divisor.gt(this.shru(1)))
	      // 15 >>> 1 = 7 ; with divisor = 8 ; true
	      return UONE;
	    res = UZERO;
	  }

	  // Repeat the following until the remainder is less than other:  find a
	  // floating-point that approximates remainder / other *from below*, add this
	  // into the result, and subtract it from the remainder.  It is critical that
	  // the approximate value is less than or equal to the real value so that the
	  // remainder never becomes negative.
	  rem = this;
	  while (rem.gte(divisor)) {
	    // Approximate the result of division. This may be a little greater or
	    // smaller than the actual value.
	    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

	    // We will tweak the approximate result by changing it in the 48-th digit or
	    // the smallest non-fractional digit, whichever is larger.
	    var log2 = Math.ceil(Math.log(approx) / Math.LN2),
	      delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
	      // Decrease the approximation until it is smaller than the remainder.  Note
	      // that if it is too large, the product overflows and is negative.
	      approxRes = fromNumber(approx),
	      approxRem = approxRes.mul(divisor);
	    while (approxRem.isNegative() || approxRem.gt(rem)) {
	      approx -= delta;
	      approxRes = fromNumber(approx, this.unsigned);
	      approxRem = approxRes.mul(divisor);
	    }

	    // We know the answer can't be zero... and actually, zero would cause
	    // infinite recursion since we would make no progress.
	    if (approxRes.isZero()) approxRes = ONE;
	    res = res.add(approxRes);
	    rem = rem.sub(approxRem);
	  }
	  return res;
	};

	/**
	 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
	 * @function
	 * @param {!Long|number|string} divisor Divisor
	 * @returns {!Long} Quotient
	 */
	LongPrototype.div = LongPrototype.divide;

	/**
	 * Returns this Long modulo the specified.
	 * @this {!Long}
	 * @param {!Long|number|string} divisor Divisor
	 * @returns {!Long} Remainder
	 */
	LongPrototype.modulo = function modulo(divisor) {
	  if (!isLong(divisor)) divisor = fromValue(divisor);

	  // use wasm support if present
	  if (wasm) {
	    var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
	    return fromBits(low, wasm["get_high"](), this.unsigned);
	  }
	  return this.sub(this.div(divisor).mul(divisor));
	};

	/**
	 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
	 * @function
	 * @param {!Long|number|string} divisor Divisor
	 * @returns {!Long} Remainder
	 */
	LongPrototype.mod = LongPrototype.modulo;

	/**
	 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
	 * @function
	 * @param {!Long|number|string} divisor Divisor
	 * @returns {!Long} Remainder
	 */
	LongPrototype.rem = LongPrototype.modulo;

	/**
	 * Returns the bitwise NOT of this Long.
	 * @this {!Long}
	 * @returns {!Long}
	 */
	LongPrototype.not = function not() {
	  return fromBits(~this.low, ~this.high, this.unsigned);
	};

	/**
	 * Returns count leading zeros of this Long.
	 * @this {!Long}
	 * @returns {!number}
	 */
	LongPrototype.countLeadingZeros = function countLeadingZeros() {
	  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
	};

	/**
	 * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
	 * @function
	 * @param {!Long}
	 * @returns {!number}
	 */
	LongPrototype.clz = LongPrototype.countLeadingZeros;

	/**
	 * Returns count trailing zeros of this Long.
	 * @this {!Long}
	 * @returns {!number}
	 */
	LongPrototype.countTrailingZeros = function countTrailingZeros() {
	  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
	};

	/**
	 * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
	 * @function
	 * @param {!Long}
	 * @returns {!number}
	 */
	LongPrototype.ctz = LongPrototype.countTrailingZeros;

	/**
	 * Returns the bitwise AND of this Long and the specified.
	 * @this {!Long}
	 * @param {!Long|number|string} other Other Long
	 * @returns {!Long}
	 */
	LongPrototype.and = function and(other) {
	  if (!isLong(other)) other = fromValue(other);
	  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
	};

	/**
	 * Returns the bitwise OR of this Long and the specified.
	 * @this {!Long}
	 * @param {!Long|number|string} other Other Long
	 * @returns {!Long}
	 */
	LongPrototype.or = function or(other) {
	  if (!isLong(other)) other = fromValue(other);
	  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
	};

	/**
	 * Returns the bitwise XOR of this Long and the given one.
	 * @this {!Long}
	 * @param {!Long|number|string} other Other Long
	 * @returns {!Long}
	 */
	LongPrototype.xor = function xor(other) {
	  if (!isLong(other)) other = fromValue(other);
	  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
	};

	/**
	 * Returns this Long with bits shifted to the left by the given amount.
	 * @this {!Long}
	 * @param {number|!Long} numBits Number of bits
	 * @returns {!Long} Shifted Long
	 */
	LongPrototype.shiftLeft = function shiftLeft(numBits) {
	  if (isLong(numBits)) numBits = numBits.toInt();
	  if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);
	};

	/**
	 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
	 * @function
	 * @param {number|!Long} numBits Number of bits
	 * @returns {!Long} Shifted Long
	 */
	LongPrototype.shl = LongPrototype.shiftLeft;

	/**
	 * Returns this Long with bits arithmetically shifted to the right by the given amount.
	 * @this {!Long}
	 * @param {number|!Long} numBits Number of bits
	 * @returns {!Long} Shifted Long
	 */
	LongPrototype.shiftRight = function shiftRight(numBits) {
	  if (isLong(numBits)) numBits = numBits.toInt();
	  if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
	};

	/**
	 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
	 * @function
	 * @param {number|!Long} numBits Number of bits
	 * @returns {!Long} Shifted Long
	 */
	LongPrototype.shr = LongPrototype.shiftRight;

	/**
	 * Returns this Long with bits logically shifted to the right by the given amount.
	 * @this {!Long}
	 * @param {number|!Long} numBits Number of bits
	 * @returns {!Long} Shifted Long
	 */
	LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
	  if (isLong(numBits)) numBits = numBits.toInt();
	  if ((numBits &= 63) === 0) return this;
	  if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
	  if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
	  return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
	};

	/**
	 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
	 * @function
	 * @param {number|!Long} numBits Number of bits
	 * @returns {!Long} Shifted Long
	 */
	LongPrototype.shru = LongPrototype.shiftRightUnsigned;

	/**
	 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
	 * @function
	 * @param {number|!Long} numBits Number of bits
	 * @returns {!Long} Shifted Long
	 */
	LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

	/**
	 * Returns this Long with bits rotated to the left by the given amount.
	 * @this {!Long}
	 * @param {number|!Long} numBits Number of bits
	 * @returns {!Long} Rotated Long
	 */
	LongPrototype.rotateLeft = function rotateLeft(numBits) {
	  var b;
	  if (isLong(numBits)) numBits = numBits.toInt();
	  if ((numBits &= 63) === 0) return this;
	  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
	  if (numBits < 32) {
	    b = 32 - numBits;
	    return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
	  }
	  numBits -= 32;
	  b = 32 - numBits;
	  return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
	};
	/**
	 * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
	 * @function
	 * @param {number|!Long} numBits Number of bits
	 * @returns {!Long} Rotated Long
	 */
	LongPrototype.rotl = LongPrototype.rotateLeft;

	/**
	 * Returns this Long with bits rotated to the right by the given amount.
	 * @this {!Long}
	 * @param {number|!Long} numBits Number of bits
	 * @returns {!Long} Rotated Long
	 */
	LongPrototype.rotateRight = function rotateRight(numBits) {
	  var b;
	  if (isLong(numBits)) numBits = numBits.toInt();
	  if ((numBits &= 63) === 0) return this;
	  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
	  if (numBits < 32) {
	    b = 32 - numBits;
	    return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
	  }
	  numBits -= 32;
	  b = 32 - numBits;
	  return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
	};
	/**
	 * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
	 * @function
	 * @param {number|!Long} numBits Number of bits
	 * @returns {!Long} Rotated Long
	 */
	LongPrototype.rotr = LongPrototype.rotateRight;

	/**
	 * Converts this Long to signed.
	 * @this {!Long}
	 * @returns {!Long} Signed long
	 */
	LongPrototype.toSigned = function toSigned() {
	  if (!this.unsigned) return this;
	  return fromBits(this.low, this.high, false);
	};

	/**
	 * Converts this Long to unsigned.
	 * @this {!Long}
	 * @returns {!Long} Unsigned long
	 */
	LongPrototype.toUnsigned = function toUnsigned() {
	  if (this.unsigned) return this;
	  return fromBits(this.low, this.high, true);
	};

	/**
	 * Converts this Long to its byte representation.
	 * @param {boolean=} le Whether little or big endian, defaults to big endian
	 * @this {!Long}
	 * @returns {!Array.<number>} Byte representation
	 */
	LongPrototype.toBytes = function toBytes(le) {
	  return le ? this.toBytesLE() : this.toBytesBE();
	};

	/**
	 * Converts this Long to its little endian byte representation.
	 * @this {!Long}
	 * @returns {!Array.<number>} Little endian byte representation
	 */
	LongPrototype.toBytesLE = function toBytesLE() {
	  var hi = this.high,
	    lo = this.low;
	  return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];
	};

	/**
	 * Converts this Long to its big endian byte representation.
	 * @this {!Long}
	 * @returns {!Array.<number>} Big endian byte representation
	 */
	LongPrototype.toBytesBE = function toBytesBE() {
	  var hi = this.high,
	    lo = this.low;
	  return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];
	};

	/**
	 * Creates a Long from its byte representation.
	 * @param {!Array.<number>} bytes Byte representation
	 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
	 * @param {boolean=} le Whether little or big endian, defaults to big endian
	 * @returns {Long} The corresponding Long value
	 */
	Long.fromBytes = function fromBytes(bytes, unsigned, le) {
	  return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
	};

	/**
	 * Creates a Long from its little endian byte representation.
	 * @param {!Array.<number>} bytes Little endian byte representation
	 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
	 * @returns {Long} The corresponding Long value
	 */
	Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
	  return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
	};

	/**
	 * Creates a Long from its big endian byte representation.
	 * @param {!Array.<number>} bytes Big endian byte representation
	 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
	 * @returns {Long} The corresponding Long value
	 */
	Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
	  return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
	};

	// const COMPRESSED_POSITION = 0
	var UNCOMPRESSED_POSITION = 1;
	var GziIndex = /*#__PURE__*/function () {
	  function GziIndex(_ref) {
	    var filehandle = _ref.filehandle,
	      path = _ref.path;
	    _classCallCheck(this, GziIndex);
	    if (filehandle) {
	      this.filehandle = filehandle;
	    } else if (path) {
	      this.filehandle = new LocalFile(path);
	    } else {
	      throw new TypeError('either filehandle or path must be defined');
	    }
	  }
	  _createClass(GziIndex, [{
	    key: "_readLongWithOverflow",
	    value: function _readLongWithOverflow(buf) {
	      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var unsigned = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	      //@ts-ignore
	      var _long = Long.fromBytesLE(buf.slice(offset, offset + 8), unsigned);
	      if (_long.greaterThan(Number.MAX_SAFE_INTEGER) || _long.lessThan(Number.MIN_SAFE_INTEGER)) {
	        throw new TypeError('integer overflow');
	      }
	      return _long.toNumber();
	    }
	  }, {
	    key: "_getIndex",
	    value: function _getIndex() {
	      if (!this.index) {
	        this.index = this._readIndex();
	      }
	      return this.index;
	    }
	  }, {
	    key: "_readIndex",
	    value: function () {
	      var _readIndex2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
	        var buf, numEntries, entries, bufSize, entryNumber, compressedPosition, uncompressedPosition;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              buf = Buffer.allocUnsafe(8);
	              _context.next = 3;
	              return this.filehandle.read(buf, 0, 8, 0);
	            case 3:
	              numEntries = this._readLongWithOverflow(buf, 0, true);
	              if (numEntries) {
	                _context.next = 6;
	                break;
	              }
	              return _context.abrupt("return", [[0, 0]]);
	            case 6:
	              entries = new Array(numEntries + 1);
	              entries[0] = [0, 0];
	              // TODO rewrite this to make an index-index that stays in memory
	              bufSize = 8 * 2 * numEntries;
	              if (!(bufSize > Number.MAX_SAFE_INTEGER)) {
	                _context.next = 11;
	                break;
	              }
	              throw new TypeError('integer overflow');
	            case 11:
	              buf = Buffer.allocUnsafe(bufSize);
	              _context.next = 14;
	              return this.filehandle.read(buf, 0, bufSize, 8);
	            case 14:
	              for (entryNumber = 0; entryNumber < numEntries; entryNumber += 1) {
	                compressedPosition = this._readLongWithOverflow(buf, entryNumber * 16);
	                uncompressedPosition = this._readLongWithOverflow(buf, entryNumber * 16 + 8);
	                entries[entryNumber + 1] = [compressedPosition, uncompressedPosition];
	              }
	              return _context.abrupt("return", entries);
	            case 16:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this);
	      }));
	      function _readIndex() {
	        return _readIndex2.apply(this, arguments);
	      }
	      return _readIndex;
	    }()
	  }, {
	    key: "getLastBlock",
	    value: function () {
	      var _getLastBlock = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
	        var entries;
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              _context2.next = 2;
	              return this._getIndex();
	            case 2:
	              entries = _context2.sent;
	              if (entries.length) {
	                _context2.next = 5;
	                break;
	              }
	              return _context2.abrupt("return", undefined);
	            case 5:
	              return _context2.abrupt("return", entries[entries.length - 1]);
	            case 6:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2, this);
	      }));
	      function getLastBlock() {
	        return _getLastBlock.apply(this, arguments);
	      }
	      return getLastBlock;
	    }()
	  }, {
	    key: "getRelevantBlocksForRead",
	    value: function () {
	      var _getRelevantBlocksForRead = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(length, position) {
	        var endPosition, entries, relevant, compare, lowerBound, upperBound, searchPosition, comparison, i;
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              endPosition = position + length;
	              if (!(length === 0)) {
	                _context3.next = 3;
	                break;
	              }
	              return _context3.abrupt("return", []);
	            case 3:
	              _context3.next = 5;
	              return this._getIndex();
	            case 5:
	              entries = _context3.sent;
	              relevant = []; // binary search to find the block that the
	              // read starts in and extend forward from that
	              compare = function compare(entry, nextEntry) {
	                var uncompressedPosition = entry[UNCOMPRESSED_POSITION];
	                var nextUncompressedPosition = nextEntry ? nextEntry[UNCOMPRESSED_POSITION] : Infinity;
	                // block overlaps read start
	                if (uncompressedPosition <= position && nextUncompressedPosition > position) {
	                  return 0;
	                  // block is before read start
	                }

	                if (uncompressedPosition < position) {
	                  return -1;
	                }
	                // block is after read start
	                return 1;
	              };
	              lowerBound = 0;
	              upperBound = entries.length - 1;
	              searchPosition = Math.floor(entries.length / 2);
	              comparison = compare(entries[searchPosition], entries[searchPosition + 1]);
	              while (comparison !== 0) {
	                if (comparison > 0) {
	                  upperBound = searchPosition - 1;
	                } else if (comparison < 0) {
	                  lowerBound = searchPosition + 1;
	                }
	                searchPosition = Math.ceil((upperBound - lowerBound) / 2) + lowerBound;
	                comparison = compare(entries[searchPosition], entries[searchPosition + 1]);
	              }
	              // here's where we read forward
	              relevant.push(entries[searchPosition]);
	              i = searchPosition + 1;
	            case 15:
	              if (!(i < entries.length)) {
	                _context3.next = 22;
	                break;
	              }
	              relevant.push(entries[i]);
	              if (!(entries[i][UNCOMPRESSED_POSITION] >= endPosition)) {
	                _context3.next = 19;
	                break;
	              }
	              return _context3.abrupt("break", 22);
	            case 19:
	              i += 1;
	              _context3.next = 15;
	              break;
	            case 22:
	              if (relevant[relevant.length - 1][UNCOMPRESSED_POSITION] < endPosition) {
	                relevant.push([]);
	              }
	              return _context3.abrupt("return", relevant);
	            case 24:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this);
	      }));
	      function getRelevantBlocksForRead(_x, _x2) {
	        return _getRelevantBlocksForRead.apply(this, arguments);
	      }
	      return getRelevantBlocksForRead;
	    }()
	  }]);
	  return GziIndex;
	}();

	var BgzFilehandle = /*#__PURE__*/function () {
	  function BgzFilehandle(_ref) {
	    var filehandle = _ref.filehandle,
	      path = _ref.path,
	      gziFilehandle = _ref.gziFilehandle,
	      gziPath = _ref.gziPath;
	    _classCallCheck(this, BgzFilehandle);
	    if (filehandle) {
	      this.filehandle = filehandle;
	    } else if (path) {
	      this.filehandle = new LocalFile(path);
	    } else {
	      throw new TypeError('either filehandle or path must be defined');
	    }
	    if (!gziFilehandle && !gziPath && !path) {
	      throw new TypeError('either gziFilehandle or gziPath must be defined');
	    }
	    this.gzi = new GziIndex({
	      filehandle: gziFilehandle,
	      path: !gziFilehandle && !gziPath && path ? gziPath : "".concat(path, ".gzi")
	    });
	  }
	  _createClass(BgzFilehandle, [{
	    key: "stat",
	    value: function () {
	      var _stat = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
	        var compressedStat;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return this.filehandle.stat();
	            case 2:
	              compressedStat = _context.sent;
	              _context.t0 = Object;
	              _context.t1 = compressedStat;
	              _context.next = 7;
	              return this.getUncompressedFileSize();
	            case 7:
	              _context.t2 = _context.sent;
	              _context.t3 = undefined;
	              _context.t4 = undefined;
	              _context.t5 = {
	                size: _context.t2,
	                blocks: _context.t3,
	                blksize: _context.t4
	              };
	              return _context.abrupt("return", _context.t0.assign.call(_context.t0, _context.t1, _context.t5));
	            case 12:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this);
	      }));
	      function stat() {
	        return _stat.apply(this, arguments);
	      }
	      return stat;
	    }()
	  }, {
	    key: "getUncompressedFileSize",
	    value: function () {
	      var _getUncompressedFileSize = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
	        var _yield$this$gzi$getLa, _yield$this$gzi$getLa2, uncompressedPosition, _yield$this$filehandl, size, buf, _yield$this$filehandl2, bytesRead, lastBlockUncompressedSize;
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              _context2.next = 2;
	              return this.gzi.getLastBlock();
	            case 2:
	              _yield$this$gzi$getLa = _context2.sent;
	              _yield$this$gzi$getLa2 = _slicedToArray(_yield$this$gzi$getLa, 2);
	              uncompressedPosition = _yield$this$gzi$getLa2[1];
	              _context2.next = 7;
	              return this.filehandle.stat();
	            case 7:
	              _yield$this$filehandl = _context2.sent;
	              size = _yield$this$filehandl.size;
	              buf = Buffer.allocUnsafe(4); // note: there should be a 28-byte EOF marker (an empty block) at
	              // the end of the file, so we skip backward past that
	              _context2.next = 12;
	              return this.filehandle.read(buf, 0, 4, size - 28 - 4);
	            case 12:
	              _yield$this$filehandl2 = _context2.sent;
	              bytesRead = _yield$this$filehandl2.bytesRead;
	              if (!(bytesRead !== 4)) {
	                _context2.next = 16;
	                break;
	              }
	              throw new Error('read error');
	            case 16:
	              lastBlockUncompressedSize = buf.readUInt32LE(0);
	              return _context2.abrupt("return", uncompressedPosition + lastBlockUncompressedSize);
	            case 18:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2, this);
	      }));
	      function getUncompressedFileSize() {
	        return _getUncompressedFileSize.apply(this, arguments);
	      }
	      return getUncompressedFileSize;
	    }()
	  }, {
	    key: "_readAndUncompressBlock",
	    value: function () {
	      var _readAndUncompressBlock2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(blockBuffer, _ref2, _ref3) {
	        var _ref4, compressedPosition, _ref5, nextCompressedPosition, next, blockCompressedLength, unzippedBuffer;
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              _ref4 = /*#__PURE__*/_slicedToArray(_ref2, 1), compressedPosition = _ref4[0];
	              _ref5 = /*#__PURE__*/_slicedToArray(_ref3, 1), nextCompressedPosition = _ref5[0];
	              next = nextCompressedPosition;
	              if (next) {
	                _context3.next = 7;
	                break;
	              }
	              _context3.next = 6;
	              return this.filehandle.stat();
	            case 6:
	              next = _context3.sent.size;
	            case 7:
	              // read the compressed data into the block buffer
	              blockCompressedLength = next - compressedPosition;
	              _context3.next = 10;
	              return this.filehandle.read(blockBuffer, 0, blockCompressedLength, compressedPosition);
	            case 10:
	              _context3.next = 12;
	              return unzip(blockBuffer.slice(0, blockCompressedLength));
	            case 12:
	              unzippedBuffer = _context3.sent;
	              return _context3.abrupt("return", unzippedBuffer);
	            case 14:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this);
	      }));
	      function _readAndUncompressBlock(_x, _x2, _x3) {
	        return _readAndUncompressBlock2.apply(this, arguments);
	      }
	      return _readAndUncompressBlock;
	    }()
	  }, {
	    key: "read",
	    value: function () {
	      var _read = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(buf, offset, length, position) {
	        var blockPositions, blockBuffer, destinationOffset, bytesRead, blockNum, uncompressedBuffer, _blockPositions$block, uncompressedPosition, sourceOffset, sourceEnd;
	        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
	          while (1) switch (_context4.prev = _context4.next) {
	            case 0:
	              _context4.next = 2;
	              return this.gzi.getRelevantBlocksForRead(length, position);
	            case 2:
	              blockPositions = _context4.sent;
	              blockBuffer = Buffer.allocUnsafe(32768 * 2); // uncompress the blocks and read from them one at a time to keep memory usage down
	              destinationOffset = offset;
	              bytesRead = 0;
	              blockNum = 0;
	            case 7:
	              if (!(blockNum < blockPositions.length - 1)) {
	                _context4.next = 18;
	                break;
	              }
	              _context4.next = 10;
	              return this._readAndUncompressBlock(blockBuffer, blockPositions[blockNum], blockPositions[blockNum + 1]);
	            case 10:
	              uncompressedBuffer = _context4.sent;
	              _blockPositions$block = _slicedToArray(blockPositions[blockNum], 2), uncompressedPosition = _blockPositions$block[1];
	              sourceOffset = uncompressedPosition >= position ? 0 : position - uncompressedPosition;
	              sourceEnd = Math.min(position + length, uncompressedPosition + uncompressedBuffer.length) - uncompressedPosition;
	              if (sourceOffset >= 0 && sourceOffset < uncompressedBuffer.length) {
	                uncompressedBuffer.copy(buf, destinationOffset, sourceOffset, sourceEnd);
	                destinationOffset += sourceEnd - sourceOffset;
	                bytesRead += sourceEnd - sourceOffset;
	              }
	            case 15:
	              blockNum += 1;
	              _context4.next = 7;
	              break;
	            case 18:
	              return _context4.abrupt("return", {
	                bytesRead: bytesRead,
	                buffer: buf
	              });
	            case 19:
	            case "end":
	              return _context4.stop();
	          }
	        }, _callee4, this);
	      }));
	      function read(_x4, _x5, _x6, _x7) {
	        return _read.apply(this, arguments);
	      }
	      return read;
	    }()
	  }]);
	  return BgzFilehandle;
	}();

	function _faiOffset(idx, pos) {
	  return idx.offset + idx.lineBytes * Math.floor(pos / idx.lineLength) + pos % idx.lineLength;
	}
	function readFAI(_x, _x2) {
	  return _readFAI.apply(this, arguments);
	}
	function _readFAI() {
	  _readFAI = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(fai, opts) {
	    var text, idCounter, currSeq, data;
	    return _regeneratorRuntime().wrap(function _callee10$(_context10) {
	      while (1) switch (_context10.prev = _context10.next) {
	        case 0:
	          _context10.next = 2;
	          return fai.readFile(opts);
	        case 2:
	          text = _context10.sent;
	          if (text && text.length) {
	            _context10.next = 5;
	            break;
	          }
	          throw new Error('No data read from FASTA index (FAI) file');
	        case 5:
	          idCounter = 0;
	          data = text.toString('utf8').split(/\r?\n/).filter(function (line) {
	            return /\S/.test(line);
	          }).map(function (line) {
	            return line.split('\t');
	          }).filter(function (row) {
	            return row[0] !== '';
	          }).map(function (row) {
	            if (!currSeq || currSeq.name !== row[0]) {
	              currSeq = {
	                name: row[0],
	                id: idCounter
	              };
	              idCounter += 1;
	            }
	            return {
	              id: currSeq.id,
	              name: row[0],
	              length: +row[1],
	              start: 0,
	              end: +row[1],
	              offset: +row[2],
	              lineLength: +row[3],
	              lineBytes: +row[4]
	            };
	          });
	          return _context10.abrupt("return", {
	            name: Object.fromEntries(data.map(function (entry) {
	              return [entry.name, entry];
	            })),
	            id: Object.fromEntries(data.map(function (entry) {
	              return [entry.id, entry];
	            }))
	          });
	        case 8:
	        case "end":
	          return _context10.stop();
	      }
	    }, _callee10);
	  }));
	  return _readFAI.apply(this, arguments);
	}
	var IndexedFasta = /*#__PURE__*/function () {
	  function IndexedFasta(_ref) {
	    var fasta = _ref.fasta,
	      fai = _ref.fai,
	      path = _ref.path,
	      faiPath = _ref.faiPath;
	    _classCallCheck(this, IndexedFasta);
	    if (fasta) {
	      this.fasta = fasta;
	    } else if (path) {
	      this.fasta = new LocalFile(path);
	    } else {
	      throw new Error('Need to pass filehandle for fasta or path to localfile');
	    }
	    if (fai) {
	      this.fai = fai;
	    } else if (faiPath) {
	      this.fai = new LocalFile(faiPath);
	    } else if (path) {
	      this.fai = new LocalFile("".concat(path, ".fai"));
	    } else {
	      throw new Error('Need to pass filehandle for  or path to localfile');
	    }
	  }
	  _createClass(IndexedFasta, [{
	    key: "_getIndexes",
	    value: function () {
	      var _getIndexes2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(opts) {
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              if (!this.indexes) {
	                this.indexes = readFAI(this.fai, opts);
	              }
	              return _context.abrupt("return", this.indexes);
	            case 2:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this);
	      }));
	      function _getIndexes(_x3) {
	        return _getIndexes2.apply(this, arguments);
	      }
	      return _getIndexes;
	    }()
	    /**
	     * @returns {array[string]} array of string sequence
	     * names that are present in the index, in which the
	     * array index indicates the sequence ID, and the value
	     * is the sequence name
	     */
	  }, {
	    key: "getSequenceNames",
	    value: function () {
	      var _getSequenceNames = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(opts) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              _context2.t0 = Object;
	              _context2.next = 3;
	              return this._getIndexes(opts);
	            case 3:
	              _context2.t1 = _context2.sent.name;
	              return _context2.abrupt("return", _context2.t0.keys.call(_context2.t0, _context2.t1));
	            case 5:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2, this);
	      }));
	      function getSequenceNames(_x4) {
	        return _getSequenceNames.apply(this, arguments);
	      }
	      return getSequenceNames;
	    }()
	    /**
	     * @returns {array[string]} array of string sequence
	     * names that are present in the index, in which the
	     * array index indicates the sequence ID, and the value
	     * is the sequence name
	     */
	  }, {
	    key: "getSequenceSizes",
	    value: function () {
	      var _getSequenceSizes = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(opts) {
	        var returnObject, idx, vals, i;
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              returnObject = {};
	              _context3.next = 3;
	              return this._getIndexes(opts);
	            case 3:
	              idx = _context3.sent;
	              vals = Object.values(idx.id);
	              for (i = 0; i < vals.length; i += 1) {
	                returnObject[vals[i].name] = vals[i].length;
	              }
	              return _context3.abrupt("return", returnObject);
	            case 7:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this);
	      }));
	      function getSequenceSizes(_x5) {
	        return _getSequenceSizes.apply(this, arguments);
	      }
	      return getSequenceSizes;
	    }()
	    /**
	     * @returns {array[string]} array of string sequence
	     * names that are present in the index, in which the
	     * array index indicates the sequence ID, and the value
	     * is the sequence name
	     */
	  }, {
	    key: "getSequenceSize",
	    value: function () {
	      var _getSequenceSize = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(seqName, opts) {
	        var _a, idx;
	        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
	          while (1) switch (_context4.prev = _context4.next) {
	            case 0:
	              _context4.next = 2;
	              return this._getIndexes(opts);
	            case 2:
	              idx = _context4.sent;
	              return _context4.abrupt("return", (_a = idx.name[seqName]) === null || _a === void 0 ? void 0 : _a.length);
	            case 4:
	            case "end":
	              return _context4.stop();
	          }
	        }, _callee4, this);
	      }));
	      function getSequenceSize(_x6, _x7) {
	        return _getSequenceSize.apply(this, arguments);
	      }
	      return getSequenceSize;
	    }()
	    /**
	     *
	     * @param {string} name
	     * @returns {Promise[boolean]} true if the file contains the given reference sequence name
	     */
	  }, {
	    key: "hasReferenceSequence",
	    value: function () {
	      var _hasReferenceSequence = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(name, opts) {
	        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
	          while (1) switch (_context5.prev = _context5.next) {
	            case 0:
	              _context5.next = 2;
	              return this._getIndexes(opts);
	            case 2:
	              _context5.t0 = name;
	              return _context5.abrupt("return", !!_context5.sent.name[_context5.t0]);
	            case 4:
	            case "end":
	              return _context5.stop();
	          }
	        }, _callee5, this);
	      }));
	      function hasReferenceSequence(_x8, _x9) {
	        return _hasReferenceSequence.apply(this, arguments);
	      }
	      return hasReferenceSequence;
	    }()
	    /**
	     *
	     * @param {number} seqId
	     * @param {number} min
	     * @param {number} max
	     */
	  }, {
	    key: "getResiduesById",
	    value: function () {
	      var _getResiduesById = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(seqId, min, max, opts) {
	        var indexEntry;
	        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
	          while (1) switch (_context6.prev = _context6.next) {
	            case 0:
	              _context6.next = 2;
	              return this._getIndexes(opts);
	            case 2:
	              _context6.t0 = seqId;
	              indexEntry = _context6.sent.id[_context6.t0];
	              if (indexEntry) {
	                _context6.next = 6;
	                break;
	              }
	              return _context6.abrupt("return", undefined);
	            case 6:
	              return _context6.abrupt("return", this._fetchFromIndexEntry(indexEntry, min, max, opts));
	            case 7:
	            case "end":
	              return _context6.stop();
	          }
	        }, _callee6, this);
	      }));
	      function getResiduesById(_x10, _x11, _x12, _x13) {
	        return _getResiduesById.apply(this, arguments);
	      }
	      return getResiduesById;
	    }()
	    /**
	     * @param {string} seqName
	     * @param {number} min
	     * @param {number} max
	     */
	  }, {
	    key: "getResiduesByName",
	    value: function () {
	      var _getResiduesByName = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(seqName, min, max, opts) {
	        var indexEntry;
	        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
	          while (1) switch (_context7.prev = _context7.next) {
	            case 0:
	              _context7.next = 2;
	              return this._getIndexes(opts);
	            case 2:
	              _context7.t0 = seqName;
	              indexEntry = _context7.sent.name[_context7.t0];
	              if (indexEntry) {
	                _context7.next = 6;
	                break;
	              }
	              return _context7.abrupt("return", undefined);
	            case 6:
	              return _context7.abrupt("return", this._fetchFromIndexEntry(indexEntry, min, max, opts));
	            case 7:
	            case "end":
	              return _context7.stop();
	          }
	        }, _callee7, this);
	      }));
	      function getResiduesByName(_x14, _x15, _x16, _x17) {
	        return _getResiduesByName.apply(this, arguments);
	      }
	      return getResiduesByName;
	    }() //alias for getResiduesByName
	  }, {
	    key: "getSequence",
	    value: function () {
	      var _getSequence = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(seqName, min, max, opts) {
	        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
	          while (1) switch (_context8.prev = _context8.next) {
	            case 0:
	              return _context8.abrupt("return", this.getResiduesByName(seqName, min, max, opts));
	            case 1:
	            case "end":
	              return _context8.stop();
	          }
	        }, _callee8, this);
	      }));
	      function getSequence(_x18, _x19, _x20, _x21) {
	        return _getSequence.apply(this, arguments);
	      }
	      return getSequence;
	    }()
	  }, {
	    key: "_fetchFromIndexEntry",
	    value: function () {
	      var _fetchFromIndexEntry2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(indexEntry) {
	        var min,
	          max,
	          opts,
	          end,
	          position,
	          readlen,
	          residues,
	          _args9 = arguments;
	        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
	          while (1) switch (_context9.prev = _context9.next) {
	            case 0:
	              min = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : 0;
	              max = _args9.length > 2 ? _args9[2] : undefined;
	              opts = _args9.length > 3 ? _args9[3] : undefined;
	              end = max;
	              if (!(min < 0)) {
	                _context9.next = 6;
	                break;
	              }
	              throw new TypeError('regionStart cannot be less than 0');
	            case 6:
	              if (end === undefined || end > indexEntry.length) {
	                end = indexEntry.length;
	              }
	              if (!(min >= end)) {
	                _context9.next = 9;
	                break;
	              }
	              return _context9.abrupt("return", '');
	            case 9:
	              position = _faiOffset(indexEntry, min);
	              readlen = _faiOffset(indexEntry, end) - position;
	              residues = Buffer.allocUnsafe(readlen);
	              _context9.next = 14;
	              return this.fasta.read(residues, 0, readlen, position, opts);
	            case 14:
	              return _context9.abrupt("return", residues.toString('utf8').replace(/\s+/g, ''));
	            case 15:
	            case "end":
	              return _context9.stop();
	          }
	        }, _callee9, this);
	      }));
	      function _fetchFromIndexEntry(_x22) {
	        return _fetchFromIndexEntry2.apply(this, arguments);
	      }
	      return _fetchFromIndexEntry;
	    }()
	  }]);
	  return IndexedFasta;
	}();

	var BgzipIndexedFasta = /*#__PURE__*/function (_IndexedFasta) {
	  _inherits(BgzipIndexedFasta, _IndexedFasta);
	  var _super = /*#__PURE__*/_createSuper(BgzipIndexedFasta);
	  function BgzipIndexedFasta(_ref) {
	    var _this;
	    var fasta = _ref.fasta,
	      path = _ref.path,
	      fai = _ref.fai,
	      faiPath = _ref.faiPath,
	      gzi = _ref.gzi,
	      gziPath = _ref.gziPath;
	    _classCallCheck(this, BgzipIndexedFasta);
	    _this = _super.call(this, {
	      fasta: fasta,
	      path: path,
	      fai: fai,
	      faiPath: faiPath
	    });
	    if (fasta && gzi) {
	      _this.fasta = new BgzFilehandle({
	        filehandle: fasta,
	        gziFilehandle: gzi
	      });
	    } else if (path && gziPath) {
	      _this.fasta = new BgzFilehandle({
	        path: path,
	        gziPath: gziPath
	      });
	    }
	    return _this;
	  }
	  return _createClass(BgzipIndexedFasta);
	}(IndexedFasta);

	function parseSmallFasta(text) {
	  return text.split('>').filter(function (t) {
	    return /\S/.test(t);
	  }).map(function (entryText) {
	    var _entryText$split = entryText.split('\n'),
	      _entryText$split2 = _toArray(_entryText$split),
	      defLine = _entryText$split2[0],
	      seqLines = _entryText$split2.slice(1);
	    var _defLine$split = defLine.split(' '),
	      _defLine$split2 = _toArray(_defLine$split),
	      id = _defLine$split2[0],
	      description = _defLine$split2.slice(1);
	    var sequence = seqLines.join('').replace(/\s/g, '');
	    return {
	      id: id,
	      description: description.join(' '),
	      sequence: sequence
	    };
	  });
	}
	// memoized
	var FetchableSmallFasta = /*#__PURE__*/function () {
	  function FetchableSmallFasta(_ref) {
	    var fasta = _ref.fasta,
	      path = _ref.path;
	    _classCallCheck(this, FetchableSmallFasta);
	    if (fasta) {
	      this.fasta = fasta;
	    } else if (path) {
	      this.fasta = new LocalFile(path);
	    } else {
	      throw new Error('Need to pass fasta or path');
	    }
	    this.data = this.fasta.readFile().then(function (buffer) {
	      var text = buffer.toString('utf8');
	      return parseSmallFasta(text);
	    });
	  }
	  _createClass(FetchableSmallFasta, [{
	    key: "fetch",
	    value: function () {
	      var _fetch = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(id, start, end) {
	        var data, entry, length;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return this.data;
	            case 2:
	              data = _context.sent;
	              entry = data.find(function (iter) {
	                return iter.id === id;
	              });
	              length = end - start;
	              if (entry) {
	                _context.next = 7;
	                break;
	              }
	              throw new Error("no sequence with id ".concat(id, " exists"));
	            case 7:
	              return _context.abrupt("return", entry.sequence.substr(start, length));
	            case 8:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this);
	      }));
	      function fetch(_x, _x2, _x3) {
	        return _fetch.apply(this, arguments);
	      }
	      return fetch;
	    }()
	  }, {
	    key: "getSequenceNames",
	    value: function () {
	      var _getSequenceNames = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
	        var data;
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              _context2.next = 2;
	              return this.data;
	            case 2:
	              data = _context2.sent;
	              return _context2.abrupt("return", data.map(function (entry) {
	                return entry.id;
	              }));
	            case 4:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2, this);
	      }));
	      function getSequenceNames() {
	        return _getSequenceNames.apply(this, arguments);
	      }
	      return getSequenceNames;
	    }()
	  }]);
	  return FetchableSmallFasta;
	}();

	var esm = {
		__proto__: null,
		parseSmallFasta: parseSmallFasta,
		FetchableSmallFasta: FetchableSmallFasta,
		IndexedFasta: IndexedFasta,
		BgzipIndexedFasta: BgzipIndexedFasta
	};

	var require$$0 = /*@__PURE__*/getAugmentedNamespace(esm);

	var require$$2 = /*@__PURE__*/getAugmentedNamespace(esm$1);

	/* eslint-disable @typescript-eslint/restrict-template-expressions */
	/* eslint-disable @typescript-eslint/no-unnecessary-condition */
	Object.defineProperty(AddAssemblyFromExternalChange$1, "__esModule", {
	  value: true
	});
	AddAssemblyFromExternalChange$1.AddAssemblyFromExternalChange = void 0;
	/* eslint-disable @typescript-eslint/require-await */
	var common_1$l = dist$1;
	var indexedfasta_1$1 = require$$0;
	var generic_filehandle_1 = require$$2;
	var AddAssemblyFromExternalChange = /*#__PURE__*/function (_common_1$AssemblySpe) {
	  _inherits(AddAssemblyFromExternalChange, _common_1$AssemblySpe);
	  var _super = /*#__PURE__*/_createSuper(AddAssemblyFromExternalChange);
	  function AddAssemblyFromExternalChange(json, options) {
	    var _this;
	    _classCallCheck(this, AddAssemblyFromExternalChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'AddAssemblyFromExternalChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    return _this;
	  }
	  _createClass(AddAssemblyFromExternalChange, [{
	    key: "notification",
	    get: function get() {
	      return "Assembly \"".concat(this.changes[0].assemblyName, "\" added successfully. To use it, please refresh the page.");
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        changes = this.changes,
	        typeName = this.typeName;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          _changes$ = _changes[0],
	          assemblyName = _changes$.assemblyName,
	          externalLocation = _changes$.externalLocation;
	        return {
	          typeName: typeName,
	          assembly: assembly,
	          assemblyName: assemblyName,
	          externalLocation: externalLocation
	        };
	      }
	      return {
	        typeName: typeName,
	        assembly: assembly,
	        changes: changes
	      };
	    }
	    /**
	     * Applies the required change to database
	     * @param backend - parameters from backend
	     * @returns
	     */
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var assemblyModel, checkModel, refSeqModel, user, assembly, changes, logger, CHUNK_SIZE, customChunkSize, _iterator, _step, _logger$debug, change, assemblyName, externalLocation, fa, fai, gzi, sequenceAdapter, allSequenceSizes, assemblyDoc, checkDocs, checks, _yield$assemblyModel$, _yield$assemblyModel$2, newAssemblyDoc, sequenceName, _logger$debug2, _yield$refSeqModel$cr, _yield$refSeqModel$cr2, newRefSeqDoc;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              assemblyModel = backend.assemblyModel, checkModel = backend.checkModel, refSeqModel = backend.refSeqModel, user = backend.user;
	              assembly = this.assembly, changes = this.changes, logger = this.logger;
	              CHUNK_SIZE = process$1.env.CHUNK_SIZE;
	              customChunkSize = CHUNK_SIZE && Number(CHUNK_SIZE);
	              _iterator = _createForOfIteratorHelper(changes);
	              _context.prev = 5;
	              _iterator.s();
	            case 7:
	              if ((_step = _iterator.n()).done) {
	                _context.next = 45;
	                break;
	              }
	              change = _step.value;
	              assemblyName = change.assemblyName, externalLocation = change.externalLocation;
	              fa = externalLocation.fa, fai = externalLocation.fai, gzi = externalLocation.gzi;
	              sequenceAdapter = gzi ? new indexedfasta_1$1.BgzipIndexedFasta({
	                fasta: new generic_filehandle_1.RemoteFile(fa, {
	                  fetch: fetch
	                }),
	                fai: new generic_filehandle_1.RemoteFile(fai, {
	                  fetch: fetch
	                }),
	                gzi: new generic_filehandle_1.RemoteFile(gzi, {
	                  fetch: fetch
	                })
	              }) : new indexedfasta_1$1.IndexedFasta({
	                fasta: new generic_filehandle_1.RemoteFile(fa, {
	                  fetch: fetch
	                }),
	                fai: new generic_filehandle_1.RemoteFile(fai, {
	                  fetch: fetch
	                })
	              });
	              _context.next = 14;
	              return sequenceAdapter.getSequenceSizes();
	            case 14:
	              allSequenceSizes = _context.sent;
	              if (allSequenceSizes) {
	                _context.next = 17;
	                break;
	              }
	              throw new Error('No data read from indexed fasta getSequenceSizes');
	            case 17:
	              _context.next = 19;
	              return assemblyModel.findOne({
	                name: assemblyName
	              }).exec();
	            case 19:
	              assemblyDoc = _context.sent;
	              if (!assemblyDoc) {
	                _context.next = 22;
	                break;
	              }
	              throw new Error("Assembly \"".concat(assemblyName, "\" already exists"));
	            case 22:
	              _context.next = 24;
	              return checkModel.find({
	                "default": true
	              }).exec();
	            case 24:
	              checkDocs = _context.sent;
	              checks = checkDocs.map(function (checkDoc) {
	                return checkDoc._id.toHexString();
	              });
	              _context.next = 28;
	              return assemblyModel.create([{
	                _id: assembly,
	                name: assemblyName,
	                user: user,
	                status: -1,
	                externalLocation: externalLocation,
	                checks: checks
	              }]);
	            case 28:
	              _yield$assemblyModel$ = _context.sent;
	              _yield$assemblyModel$2 = _slicedToArray(_yield$assemblyModel$, 1);
	              newAssemblyDoc = _yield$assemblyModel$2[0];
	              (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, "Added new assembly \"".concat(assemblyName, "\", docId \"").concat(newAssemblyDoc._id, "\""));
	              _context.t0 = _regeneratorRuntime().keys(allSequenceSizes);
	            case 33:
	              if ((_context.t1 = _context.t0()).done) {
	                _context.next = 43;
	                break;
	              }
	              sequenceName = _context.t1.value;
	              _context.next = 37;
	              return refSeqModel.create([_objectSpread2(_objectSpread2({
	                name: sequenceName,
	                assembly: newAssemblyDoc._id,
	                length: allSequenceSizes[sequenceName]
	              }, customChunkSize ? {
	                chunkSize: customChunkSize
	              } : null), {}, {
	                user: user,
	                status: -1
	              })]);
	            case 37:
	              _yield$refSeqModel$cr = _context.sent;
	              _yield$refSeqModel$cr2 = _slicedToArray(_yield$refSeqModel$cr, 1);
	              newRefSeqDoc = _yield$refSeqModel$cr2[0];
	              (_logger$debug2 = logger.debug) === null || _logger$debug2 === void 0 || _logger$debug2.call(logger, "Added new refSeq \"".concat(sequenceName, "\", docId \"").concat(newRefSeqDoc._id, "\""));
	              _context.next = 33;
	              break;
	            case 43:
	              _context.next = 7;
	              break;
	            case 45:
	              _context.next = 50;
	              break;
	            case 47:
	              _context.prev = 47;
	              _context.t2 = _context["catch"](5);
	              _iterator.e(_context.t2);
	            case 50:
	              _context.prev = 50;
	              _iterator.f();
	              return _context.finish(50);
	            case 53:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this, [[5, 47, 50, 53]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }() // eslint-disable-next-line @typescript-eslint/no-empty-function
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_dataStore) {
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var assembly = this.assembly,
	        changes = this.changes,
	        logger = this.logger,
	        typeName = this.typeName;
	      return new AddAssemblyFromExternalChange({
	        typeName: typeName,
	        changes: changes,
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return AddAssemblyFromExternalChange;
	}(common_1$l.AssemblySpecificChange);
	AddAssemblyFromExternalChange$1.AddAssemblyFromExternalChange = AddAssemblyFromExternalChange;

	var AddAssemblyFromFileChange$1 = {};

	Object.defineProperty(AddAssemblyFromFileChange$1, "__esModule", {
	  value: true
	});
	AddAssemblyFromFileChange$1.AddAssemblyFromFileChange = void 0;
	var indexedfasta_1 = require$$0;
	var FromFileBaseChange_1$1 = FromFileBaseChange$1;
	var AddAssemblyFromFileChange = /*#__PURE__*/function (_FromFileBaseChange_) {
	  _inherits(AddAssemblyFromFileChange, _FromFileBaseChange_);
	  var _super = /*#__PURE__*/_createSuper(AddAssemblyFromFileChange);
	  function AddAssemblyFromFileChange(json, options) {
	    var _this;
	    _classCallCheck(this, AddAssemblyFromFileChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'AddAssemblyFromFileChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    return _this;
	  }
	  _createClass(AddAssemblyFromFileChange, [{
	    key: "notification",
	    get: function get() {
	      return "Assembly \"".concat(this.changes[0].assemblyName, "\" added successfully. To use it, please refresh the page.");
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        changes = this.changes,
	        typeName = this.typeName;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          _changes$ = _changes[0],
	          assemblyName = _changes$.assemblyName,
	          fileIds = _changes$.fileIds;
	        return {
	          typeName: typeName,
	          assembly: assembly,
	          assemblyName: assemblyName,
	          fileIds: fileIds
	        };
	      }
	      return {
	        typeName: typeName,
	        assembly: assembly,
	        changes: changes
	      };
	    }
	    /**
	     * Applies the required change to database
	     * @param backend - parameters from backend
	     * @returns
	     */
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var changes, _iterator, _step, change, assemblyName, fileIds;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              changes = this.changes;
	              _iterator = _createForOfIteratorHelper(changes);
	              _context.prev = 2;
	              _iterator.s();
	            case 4:
	              if ((_step = _iterator.n()).done) {
	                _context.next = 11;
	                break;
	              }
	              change = _step.value;
	              assemblyName = change.assemblyName, fileIds = change.fileIds;
	              _context.next = 9;
	              return 'gzi' in fileIds ? this.executeOnServerIndexed(backend, assemblyName, fileIds) : this.executeOnServerFasta(backend, assemblyName, fileIds.fa);
	            case 9:
	              _context.next = 4;
	              break;
	            case 11:
	              _context.next = 16;
	              break;
	            case 13:
	              _context.prev = 13;
	              _context.t0 = _context["catch"](2);
	              _iterator.e(_context.t0);
	            case 16:
	              _context.prev = 16;
	              _iterator.f();
	              return _context.finish(16);
	            case 19:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this, [[2, 13, 16, 19]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnServerIndexed",
	    value: function () {
	      var _executeOnServerIndexed = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(backend, assemblyName, fileIds) {
	        var _this$logger$debug, _this$logger;
	        var CHUNK_SIZE, customChunkSize, FILE_UPLOAD_FOLDER, faId, faiId, gziId, assemblyModel, checkModel, fileModel, filesService, refSeqModel, user, faDoc, faChecksum, faiDoc, faiChecksum, gziDoc, gziChecksum, fasta, fai, gzi, sequenceAdapter, allSequenceSizes, assemblyDoc, checkDocs, checks, _yield$assemblyModel$, _yield$assemblyModel$2, newAssemblyDoc, sequenceName, _this$logger$debug2, _this$logger2, _yield$refSeqModel$cr, _yield$refSeqModel$cr2, newRefSeqDoc;
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              CHUNK_SIZE = process$1.env.CHUNK_SIZE;
	              customChunkSize = CHUNK_SIZE && Number(CHUNK_SIZE);
	              FILE_UPLOAD_FOLDER = process$1.env.FILE_UPLOAD_FOLDER;
	              if (FILE_UPLOAD_FOLDER) {
	                _context2.next = 5;
	                break;
	              }
	              throw new Error('No FILE_UPLOAD_FOLDER found in .env file');
	            case 5:
	              faId = fileIds.fa, faiId = fileIds.fai, gziId = fileIds.gzi;
	              assemblyModel = backend.assemblyModel, checkModel = backend.checkModel, fileModel = backend.fileModel, filesService = backend.filesService, refSeqModel = backend.refSeqModel, user = backend.user;
	              _context2.next = 9;
	              return fileModel.findById(faId);
	            case 9:
	              faDoc = _context2.sent;
	              faChecksum = faDoc === null || faDoc === void 0 ? void 0 : faDoc.checksum;
	              if (faChecksum) {
	                _context2.next = 13;
	                break;
	              }
	              throw new Error("No checksum for file document ".concat(faDoc === null || faDoc === void 0 ? void 0 : faDoc.id));
	            case 13:
	              _context2.next = 15;
	              return fileModel.findById(faiId);
	            case 15:
	              faiDoc = _context2.sent;
	              faiChecksum = faiDoc === null || faiDoc === void 0 ? void 0 : faiDoc.checksum;
	              if (faiChecksum) {
	                _context2.next = 19;
	                break;
	              }
	              throw new Error("No checksum for file document ".concat(faiDoc === null || faiDoc === void 0 ? void 0 : faiDoc.id));
	            case 19:
	              _context2.next = 21;
	              return fileModel.findById(gziId);
	            case 21:
	              gziDoc = _context2.sent;
	              gziChecksum = gziDoc === null || gziDoc === void 0 ? void 0 : gziDoc.checksum;
	              if (gziChecksum) {
	                _context2.next = 25;
	                break;
	              }
	              throw new Error("No checksum for file document ".concat(gziDoc === null || gziDoc === void 0 ? void 0 : gziDoc.id));
	            case 25:
	              fasta = filesService.getFileHandle(faDoc);
	              fai = filesService.getFileHandle(faiDoc);
	              gzi = filesService.getFileHandle(gziDoc);
	              sequenceAdapter = new indexedfasta_1.BgzipIndexedFasta({
	                fasta: fasta,
	                fai: fai,
	                gzi: gzi
	              });
	              _context2.next = 31;
	              return sequenceAdapter.getSequenceSizes();
	            case 31:
	              allSequenceSizes = _context2.sent;
	              _context2.next = 34;
	              return Promise.all([fasta.close(), fai.close(), gzi.close()]);
	            case 34:
	              _context2.next = 36;
	              return assemblyModel.findOne({
	                name: assemblyName
	              }).exec();
	            case 36:
	              assemblyDoc = _context2.sent;
	              if (!assemblyDoc) {
	                _context2.next = 39;
	                break;
	              }
	              throw new Error("Assembly \"".concat(assemblyName, "\" already exists"));
	            case 39:
	              _context2.next = 41;
	              return checkModel.find({
	                "default": true
	              }).exec();
	            case 41:
	              checkDocs = _context2.sent;
	              checks = checkDocs.map(function (checkDoc) {
	                return checkDoc._id.toHexString();
	              });
	              _context2.next = 45;
	              return assemblyModel.create([{
	                _id: this.assembly,
	                name: assemblyName,
	                user: user,
	                status: -1,
	                fileIds: fileIds,
	                checks: checks
	              }]);
	            case 45:
	              _yield$assemblyModel$ = _context2.sent;
	              _yield$assemblyModel$2 = _slicedToArray(_yield$assemblyModel$, 1);
	              newAssemblyDoc = _yield$assemblyModel$2[0];
	              (_this$logger$debug = (_this$logger = this.logger).debug) === null || _this$logger$debug === void 0 || _this$logger$debug.call(_this$logger, "Added new assembly \"".concat(assemblyName, "\", docId \"").concat(newAssemblyDoc._id, "\""));
	              _context2.t0 = _regeneratorRuntime().keys(allSequenceSizes);
	            case 50:
	              if ((_context2.t1 = _context2.t0()).done) {
	                _context2.next = 60;
	                break;
	              }
	              sequenceName = _context2.t1.value;
	              _context2.next = 54;
	              return refSeqModel.create([_objectSpread2(_objectSpread2({
	                name: sequenceName,
	                assembly: newAssemblyDoc._id,
	                length: allSequenceSizes[sequenceName]
	              }, customChunkSize ? {
	                chunkSize: customChunkSize
	              } : null), {}, {
	                user: user,
	                status: -1
	              })]);
	            case 54:
	              _yield$refSeqModel$cr = _context2.sent;
	              _yield$refSeqModel$cr2 = _slicedToArray(_yield$refSeqModel$cr, 1);
	              newRefSeqDoc = _yield$refSeqModel$cr2[0];
	              (_this$logger$debug2 = (_this$logger2 = this.logger).debug) === null || _this$logger$debug2 === void 0 || _this$logger$debug2.call(_this$logger2, "Added new refSeq \"".concat(sequenceName, "\", docId \"").concat(newRefSeqDoc._id, "\""));
	              _context2.next = 50;
	              break;
	            case 60:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2, this);
	      }));
	      function executeOnServerIndexed(_x2, _x3, _x4) {
	        return _executeOnServerIndexed.apply(this, arguments);
	      }
	      return executeOnServerIndexed;
	    }()
	  }, {
	    key: "executeOnServerFasta",
	    value: function () {
	      var _executeOnServerFasta = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(backend, assemblyName, fileId) {
	        var _this$logger$debug3, _this$logger3, _this$logger$debug4, _this$logger4, _this$logger$debug5, _this$logger5;
	        var assemblyModel, checkModel, fileModel, user, fileDoc, assemblyDoc, checkDocs, checks, _yield$assemblyModel$3, _yield$assemblyModel$4, newAssemblyDoc;
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              assemblyModel = backend.assemblyModel, checkModel = backend.checkModel, fileModel = backend.fileModel, user = backend.user; // Get file checksum
	              _context3.next = 3;
	              return fileModel.findById(fileId).exec();
	            case 3:
	              fileDoc = _context3.sent;
	              if (fileDoc) {
	                _context3.next = 6;
	                break;
	              }
	              throw new Error("File \"".concat(fileId, "\" not found in Mongo"));
	            case 6:
	              (_this$logger$debug3 = (_this$logger3 = this.logger).debug) === null || _this$logger$debug3 === void 0 || _this$logger$debug3.call(_this$logger3, "FileId \"".concat(fileId, "\", checksum \"").concat(fileDoc.checksum, "\""));
	              // Check and add new assembly
	              _context3.next = 9;
	              return assemblyModel.findOne({
	                name: assemblyName
	              }).exec();
	            case 9:
	              assemblyDoc = _context3.sent;
	              if (!assemblyDoc) {
	                _context3.next = 12;
	                break;
	              }
	              throw new Error("Assembly \"".concat(assemblyName, "\" already exists"));
	            case 12:
	              _context3.next = 14;
	              return checkModel.find({
	                "default": true
	              }).exec();
	            case 14:
	              checkDocs = _context3.sent;
	              checks = checkDocs.map(function (checkDoc) {
	                return checkDoc._id.toHexString();
	              }); // Add assembly
	              _context3.next = 18;
	              return assemblyModel.create([{
	                _id: this.assembly,
	                name: assemblyName,
	                user: user,
	                status: -1,
	                fileIds: {
	                  fa: fileId
	                },
	                checks: checks
	              }]);
	            case 18:
	              _yield$assemblyModel$3 = _context3.sent;
	              _yield$assemblyModel$4 = _slicedToArray(_yield$assemblyModel$3, 1);
	              newAssemblyDoc = _yield$assemblyModel$4[0];
	              (_this$logger$debug4 = (_this$logger4 = this.logger).debug) === null || _this$logger$debug4 === void 0 || _this$logger$debug4.call(_this$logger4, "Added new assembly \"".concat(assemblyName, "\", docId \"").concat(newAssemblyDoc._id, "\""));
	              (_this$logger$debug5 = (_this$logger5 = this.logger).debug) === null || _this$logger$debug5 === void 0 || _this$logger$debug5.call(_this$logger5, "File type: \"".concat(fileDoc.type, "\", assemblyId: \"").concat(newAssemblyDoc._id, "\""));
	              // Add refSeqs
	              // We cannot use Mongo 'session' / transaction here because Mongo has 16 MB limit for transaction
	              _context3.next = 25;
	              return this.addRefSeqIntoDb(fileDoc, newAssemblyDoc._id.toString(), backend);
	            case 25:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this);
	      }));
	      function executeOnServerFasta(_x5, _x6, _x7) {
	        return _executeOnServerFasta.apply(this, arguments);
	      }
	      return executeOnServerFasta;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_backend) {
	        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
	          while (1) switch (_context4.prev = _context4.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context4.stop();
	          }
	        }, _callee4);
	      }));
	      function executeOnLocalGFF3(_x8) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }() // eslint-disable-next-line @typescript-eslint/no-empty-function
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_dataStore) {
	        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
	          while (1) switch (_context5.prev = _context5.next) {
	            case 0:
	            case "end":
	              return _context5.stop();
	          }
	        }, _callee5);
	      }));
	      function executeOnClient(_x9) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var assembly = this.assembly,
	        changes = this.changes,
	        logger = this.logger,
	        typeName = this.typeName;
	      return new AddAssemblyFromFileChange({
	        typeName: typeName,
	        changes: changes,
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return AddAssemblyFromFileChange;
	}(FromFileBaseChange_1$1.FromFileBaseChange);
	AddAssemblyFromFileChange$1.AddAssemblyFromFileChange = AddAssemblyFromFileChange;

	var AddFeatureChange$1 = {};

	var DeleteFeatureChange$1 = {};

	Object.defineProperty(DeleteFeatureChange$1, "__esModule", {
	  value: true
	});
	DeleteFeatureChange$1.DeleteFeatureChange = void 0;
	DeleteFeatureChange$1.findAndDeleteChildFeature = findAndDeleteChildFeature;
	DeleteFeatureChange$1.isDeleteFeatureChange = isDeleteFeatureChange;
	/* eslint-disable @typescript-eslint/restrict-template-expressions */
	/* eslint-disable @typescript-eslint/require-await */
	/* eslint-disable @typescript-eslint/no-unnecessary-condition */
	var common_1$k = dist$1;
	var AddFeatureChange_1 = AddFeatureChange$1;
	var DeleteFeatureChange = /*#__PURE__*/function (_common_1$FeatureChan) {
	  _inherits(DeleteFeatureChange, _common_1$FeatureChan);
	  var _super = /*#__PURE__*/_createSuper(DeleteFeatureChange);
	  function DeleteFeatureChange(json, options) {
	    var _this;
	    _classCallCheck(this, DeleteFeatureChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'DeleteFeatureChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    return _this;
	  }
	  // eslint-disable-next-line @typescript-eslint/class-literal-property-style
	  _createClass(DeleteFeatureChange, [{
	    key: "notification",
	    get: function get() {
	      return 'Feature deleted successfully';
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        typeName = this.typeName;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          _changes$ = _changes[0],
	          deletedFeature = _changes$.deletedFeature,
	          parentFeatureId = _changes$.parentFeatureId;
	        return {
	          typeName: typeName,
	          changedIds: changedIds,
	          assembly: assembly,
	          deletedFeature: deletedFeature,
	          parentFeatureId: parentFeatureId
	        };
	      }
	      return {
	        typeName: typeName,
	        changedIds: changedIds,
	        assembly: assembly,
	        changes: changes
	      };
	    }
	    /**
	     * Applies the required change to database
	     * @param backend - parameters from backend
	     * @returns
	     */
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var _this2 = this;
	        var featureModel, session, changes, logger, _iterator, _step, _loop;
	        return _regeneratorRuntime().wrap(function _callee$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              featureModel = backend.featureModel, session = backend.session;
	              changes = this.changes, logger = this.logger; // Loop the changes
	              _iterator = _createForOfIteratorHelper(changes);
	              _context2.prev = 3;
	              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
	                var _logger$debug3;
	                var change, deletedFeature, parentFeatureId, featureDoc, errMsg, _logger$debug, deletedIds, _logger$debug2;
	                return _regeneratorRuntime().wrap(function _loop$(_context) {
	                  while (1) switch (_context.prev = _context.next) {
	                    case 0:
	                      change = _step.value;
	                      deletedFeature = change.deletedFeature, parentFeatureId = change.parentFeatureId; // Search feature
	                      _context.next = 4;
	                      return featureModel.findOne({
	                        allIds: deletedFeature._id
	                      }).session(session).exec();
	                    case 4:
	                      featureDoc = _context.sent;
	                      if (featureDoc) {
	                        _context.next = 9;
	                        break;
	                      }
	                      errMsg = "*** ERROR: The following featureId was not found in database ='".concat(deletedFeature._id, "'");
	                      logger.error(errMsg);
	                      throw new Error(errMsg);
	                    case 9:
	                      if (!featureDoc._id.equals(deletedFeature._id)) {
	                        _context.next = 16;
	                        break;
	                      }
	                      if (!parentFeatureId) {
	                        _context.next = 12;
	                        break;
	                      }
	                      throw new Error("Feature \"".concat(deletedFeature._id, "\" is top-level, but received a parent feature ID"));
	                    case 12:
	                      _context.next = 14;
	                      return featureModel.findByIdAndDelete(featureDoc._id);
	                    case 14:
	                      (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, "Feature \"".concat(deletedFeature._id, "\" deleted from document \"").concat(featureDoc._id, "\". Whole document deleted."));
	                      return _context.abrupt("return", 1);
	                    case 16:
	                      deletedIds = findAndDeleteChildFeature(featureDoc, deletedFeature._id, _this2);
	                      deletedIds.push(deletedFeature._id);
	                      featureDoc.allIds = featureDoc.allIds.filter(function (id) {
	                        return !deletedIds.includes(id);
	                      });
	                      // Save updated document in Mongo
	                      featureDoc.markModified('children'); // Mark as modified. Without this save() -method is not updating data in database
	                      _context.prev = 20;
	                      _context.next = 23;
	                      return featureDoc.save();
	                    case 23:
	                      _context.next = 29;
	                      break;
	                    case 25:
	                      _context.prev = 25;
	                      _context.t0 = _context["catch"](20);
	                      (_logger$debug2 = logger.debug) === null || _logger$debug2 === void 0 || _logger$debug2.call(logger, "*** FAILED: ".concat(_context.t0));
	                      throw _context.t0;
	                    case 29:
	                      (_logger$debug3 = logger.debug) === null || _logger$debug3 === void 0 || _logger$debug3.call(logger, "Feature \"".concat(deletedFeature._id, "\" deleted from document \"").concat(featureDoc._id, "\""));
	                    case 30:
	                    case "end":
	                      return _context.stop();
	                  }
	                }, _loop, null, [[20, 25]]);
	              });
	              _iterator.s();
	            case 6:
	              if ((_step = _iterator.n()).done) {
	                _context2.next = 12;
	                break;
	              }
	              return _context2.delegateYield(_loop(), "t0", 8);
	            case 8:
	              if (!_context2.t0) {
	                _context2.next = 10;
	                break;
	              }
	              return _context2.abrupt("continue", 10);
	            case 10:
	              _context2.next = 6;
	              break;
	            case 12:
	              _context2.next = 17;
	              break;
	            case 14:
	              _context2.prev = 14;
	              _context2.t1 = _context2["catch"](3);
	              _iterator.e(_context2.t1);
	            case 17:
	              _context2.prev = 17;
	              _iterator.f();
	              return _context2.finish(17);
	            case 20:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee, this, [[3, 14, 17, 20]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }()
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(dataStore) {
	        var _iterator2, _step2, change, deletedFeature, parentFeatureId, parentFeature;
	        return _regeneratorRuntime().wrap(function _callee3$(_context4) {
	          while (1) switch (_context4.prev = _context4.next) {
	            case 0:
	              if (dataStore) {
	                _context4.next = 2;
	                break;
	              }
	              throw new Error('No data store');
	            case 2:
	              _iterator2 = _createForOfIteratorHelper(this.changes);
	              _context4.prev = 3;
	              _iterator2.s();
	            case 5:
	              if ((_step2 = _iterator2.n()).done) {
	                _context4.next = 18;
	                break;
	              }
	              change = _step2.value;
	              deletedFeature = change.deletedFeature, parentFeatureId = change.parentFeatureId;
	              if (!parentFeatureId) {
	                _context4.next = 15;
	                break;
	              }
	              parentFeature = dataStore.getFeature(parentFeatureId);
	              if (parentFeature) {
	                _context4.next = 12;
	                break;
	              }
	              throw new Error("Could not find parent feature \"".concat(parentFeatureId, "\""));
	            case 12:
	              parentFeature.deleteChild(deletedFeature._id);
	              _context4.next = 16;
	              break;
	            case 15:
	              if (dataStore.getFeature(deletedFeature._id)) {
	                dataStore.deleteFeature(deletedFeature._id);
	              }
	            case 16:
	              _context4.next = 5;
	              break;
	            case 18:
	              _context4.next = 23;
	              break;
	            case 20:
	              _context4.prev = 20;
	              _context4.t0 = _context4["catch"](3);
	              _iterator2.e(_context4.t0);
	            case 23:
	              _context4.prev = 23;
	              _iterator2.f();
	              return _context4.finish(23);
	            case 26:
	            case "end":
	              return _context4.stop();
	          }
	        }, _callee3, this, [[3, 20, 23, 26]]);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var _logger$debug4;
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        logger = this.logger;
	      var inverseChangedIds = _toConsumableArray(changedIds).reverse();
	      var inverseChanges = _toConsumableArray(changes).reverse().map(function (deleteFeatureChange) {
	        return {
	          addedFeature: deleteFeatureChange.deletedFeature,
	          parentFeatureId: deleteFeatureChange.parentFeatureId
	        };
	      });
	      (_logger$debug4 = logger.debug) === null || _logger$debug4 === void 0 || _logger$debug4.call(logger, "INVERSE CHANGE '".concat(JSON.stringify(inverseChanges), "'"));
	      return new AddFeatureChange_1.AddFeatureChange({
	        changedIds: inverseChangedIds,
	        typeName: 'AddFeatureChange',
	        changes: inverseChanges,
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return DeleteFeatureChange;
	}(common_1$k.FeatureChange);
	DeleteFeatureChange$1.DeleteFeatureChange = DeleteFeatureChange;
	/**
	 * Delete feature's subfeatures that match an ID and return the IDs of any
	 * sub-subfeatures that were deleted
	 * @param feature -
	 * @param featureIdToDelete -
	 * @returns - list of deleted feature IDs
	 */
	function findAndDeleteChildFeature(feature, featureIdToDelete, change) {
	  if (!feature.children) {
	    throw new Error("Feature ".concat(feature._id, " has no children"));
	  }
	  var _id = feature._id,
	    children = feature.children;
	  var child = children.get(featureIdToDelete);
	  if (child) {
	    var deletedIds = change.getChildFeatureIds(child);
	    children["delete"](featureIdToDelete);
	    return deletedIds;
	  }
	  var _iterator3 = _createForOfIteratorHelper(children),
	    _step3;
	  try {
	    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	      var _step3$value = _slicedToArray(_step3.value, 2),
	        childFeature = _step3$value[1];
	      try {
	        return findAndDeleteChildFeature(childFeature, featureIdToDelete, change);
	      } catch (_unused) {
	        // pass
	      }
	    }
	  } catch (err) {
	    _iterator3.e(err);
	  } finally {
	    _iterator3.f();
	  }
	  throw new Error("Feature \"".concat(featureIdToDelete, "\" not found in ").concat(_id));
	}
	function isDeleteFeatureChange(change) {
	  return change.typeName === 'DeleteFeatureChange';
	}

	Object.defineProperty(AddFeatureChange$1, "__esModule", {
	  value: true
	});
	AddFeatureChange$1.AddFeatureChange = void 0;
	AddFeatureChange$1.isAddFeatureChange = isAddFeatureChange;
	/* eslint-disable @typescript-eslint/restrict-template-expressions */
	/* eslint-disable @typescript-eslint/require-await */
	/* eslint-disable @typescript-eslint/no-unnecessary-condition */
	var common_1$j = dist$1;
	var DeleteFeatureChange_1$4 = DeleteFeatureChange$1;
	var AddFeatureChange = /*#__PURE__*/function (_common_1$FeatureChan) {
	  _inherits(AddFeatureChange, _common_1$FeatureChan);
	  var _super = /*#__PURE__*/_createSuper(AddFeatureChange);
	  function AddFeatureChange(json, options) {
	    var _this;
	    _classCallCheck(this, AddFeatureChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'AddFeatureChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    return _this;
	  }
	  // eslint-disable-next-line @typescript-eslint/class-literal-property-style
	  _createClass(AddFeatureChange, [{
	    key: "notification",
	    get: function get() {
	      return 'Feature added successfully';
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        typeName = this.typeName;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          _changes$ = _changes[0],
	          addedFeature = _changes$.addedFeature,
	          allIds = _changes$.allIds,
	          copyFeature = _changes$.copyFeature,
	          parentFeatureId = _changes$.parentFeatureId;
	        return {
	          typeName: typeName,
	          changedIds: changedIds,
	          assembly: assembly,
	          addedFeature: addedFeature,
	          parentFeatureId: parentFeatureId,
	          copyFeature: copyFeature,
	          allIds: allIds
	        };
	      }
	      return {
	        typeName: typeName,
	        changedIds: changedIds,
	        assembly: assembly,
	        changes: changes
	      };
	    }
	    /**
	     * Applies the required change to database
	     * @param backend - parameters from backend
	     * @returns
	     */
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var _logger$debug, _logger$debug2;
	        var assemblyModel, featureModel, refSeqModel, session, user, assembly, changes, logger, assemblyDoc, errMsg, featureCnt, _iterator, _step, _logger$debug3, change, addedFeature, allIds, copyFeature, parentFeatureId, _id, refSeq, refSeqDoc, _logger$debug4, _yield$featureModel$c, _yield$featureModel$c2, newFeatureDoc, _topLevelFeature$allI, topLevelFeature, parentFeature, childIds, _logger$verbose, _childIds, allIdsV2, _yield$featureModel$c3, _yield$featureModel$c4, _newFeatureDoc;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              assemblyModel = backend.assemblyModel, featureModel = backend.featureModel, refSeqModel = backend.refSeqModel, session = backend.session, user = backend.user;
	              assembly = this.assembly, changes = this.changes, logger = this.logger;
	              _context.next = 4;
	              return assemblyModel.findById(assembly).session(session).exec();
	            case 4:
	              assemblyDoc = _context.sent;
	              if (assemblyDoc) {
	                _context.next = 9;
	                break;
	              }
	              errMsg = "*** ERROR: Assembly with id \"".concat(assembly, "\" not found");
	              logger.error(errMsg);
	              throw new Error(errMsg);
	            case 9:
	              featureCnt = 0;
	              (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, "changes: ".concat(JSON.stringify(changes)));
	              // Loop the changes
	              _iterator = _createForOfIteratorHelper(changes);
	              _context.prev = 12;
	              _iterator.s();
	            case 14:
	              if ((_step = _iterator.n()).done) {
	                _context.next = 61;
	                break;
	              }
	              change = _step.value;
	              (_logger$debug3 = logger.debug) === null || _logger$debug3 === void 0 || _logger$debug3.call(logger, "change: ".concat(JSON.stringify(change)));
	              addedFeature = change.addedFeature, allIds = change.allIds, copyFeature = change.copyFeature, parentFeatureId = change.parentFeatureId;
	              _id = addedFeature._id, refSeq = addedFeature.refSeq;
	              _context.next = 21;
	              return refSeqModel.findById(refSeq).session(session).exec();
	            case 21:
	              refSeqDoc = _context.sent;
	              if (refSeqDoc) {
	                _context.next = 24;
	                break;
	              }
	              throw new Error("RefSeq was not found by assembly \"".concat(assembly, "\" and seq_id \"").concat(refSeq, "\" not found"));
	            case 24:
	              if (!copyFeature) {
	                _context.next = 34;
	                break;
	              }
	              _context.next = 27;
	              return featureModel.create([_objectSpread2(_objectSpread2({}, addedFeature), {}, {
	                allIds: allIds,
	                status: -1,
	                user: user
	              })], {
	                session: session
	              });
	            case 27:
	              _yield$featureModel$c = _context.sent;
	              _yield$featureModel$c2 = _slicedToArray(_yield$featureModel$c, 1);
	              newFeatureDoc = _yield$featureModel$c2[0];
	              (_logger$debug4 = logger.debug) === null || _logger$debug4 === void 0 || _logger$debug4.call(logger, "Copied feature, docId \"".concat(newFeatureDoc._id, "\" to assembly \"").concat(assembly, "\""));
	              featureCnt++;
	              _context.next = 58;
	              break;
	            case 34:
	              if (!parentFeatureId) {
	                _context.next = 50;
	                break;
	              }
	              _context.next = 37;
	              return featureModel.findOne({
	                allIds: parentFeatureId
	              }).session(session).exec();
	            case 37:
	              topLevelFeature = _context.sent;
	              if (topLevelFeature) {
	                _context.next = 40;
	                break;
	              }
	              throw new Error("Could not find feature with ID \"".concat(parentFeatureId, "\""));
	            case 40:
	              parentFeature = this.getFeatureFromId(topLevelFeature, parentFeatureId);
	              if (parentFeature) {
	                _context.next = 43;
	                break;
	              }
	              throw new Error("Could not find feature with ID \"".concat(parentFeatureId, "\" in feature \"").concat(topLevelFeature._id, "\""));
	            case 43:
	              this.addChild(parentFeature, addedFeature);
	              childIds = this.getChildFeatureIds(addedFeature);
	              (_topLevelFeature$allI = topLevelFeature.allIds).push.apply(_topLevelFeature$allI, [_id].concat(_toConsumableArray(childIds)));
	              _context.next = 48;
	              return topLevelFeature.save();
	            case 48:
	              _context.next = 58;
	              break;
	            case 50:
	              _childIds = this.getChildFeatureIds(addedFeature);
	              allIdsV2 = [_id].concat(_toConsumableArray(_childIds));
	              _context.next = 54;
	              return featureModel.create([_objectSpread2({
	                allIds: allIdsV2,
	                status: 0
	              }, addedFeature)], {
	                session: session
	              });
	            case 54:
	              _yield$featureModel$c3 = _context.sent;
	              _yield$featureModel$c4 = _slicedToArray(_yield$featureModel$c3, 1);
	              _newFeatureDoc = _yield$featureModel$c4[0];
	              (_logger$verbose = logger.verbose) === null || _logger$verbose === void 0 || _logger$verbose.call(logger, "Added docId \"".concat(_newFeatureDoc._id, "\""));
	            case 58:
	              featureCnt++;
	            case 59:
	              _context.next = 14;
	              break;
	            case 61:
	              _context.next = 66;
	              break;
	            case 63:
	              _context.prev = 63;
	              _context.t0 = _context["catch"](12);
	              _iterator.e(_context.t0);
	            case 66:
	              _context.prev = 66;
	              _iterator.f();
	              return _context.finish(66);
	            case 69:
	              (_logger$debug2 = logger.debug) === null || _logger$debug2 === void 0 || _logger$debug2.call(logger, "Added ".concat(featureCnt, " new feature(s) into database."));
	            case 70:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this, [[12, 63, 66, 69]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }()
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(dataStore) {
	        var assembly, changes, _iterator2, _step2, change, addedFeature, parentFeatureId, parentFeature;
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              if (dataStore) {
	                _context3.next = 2;
	                break;
	              }
	              throw new Error('No data store');
	            case 2:
	              assembly = this.assembly, changes = this.changes;
	              _iterator2 = _createForOfIteratorHelper(changes);
	              _context3.prev = 4;
	              _iterator2.s();
	            case 6:
	              if ((_step2 = _iterator2.n()).done) {
	                _context3.next = 20;
	                break;
	              }
	              change = _step2.value;
	              addedFeature = change.addedFeature, parentFeatureId = change.parentFeatureId;
	              if (!parentFeatureId) {
	                _context3.next = 17;
	                break;
	              }
	              parentFeature = dataStore.getFeature(parentFeatureId);
	              if (parentFeature) {
	                _context3.next = 13;
	                break;
	              }
	              throw new Error("Could not find parent feature \"".concat(parentFeatureId, "\""));
	            case 13:
	              // create an ID for the parent feature if it does not have one
	              if (!parentFeature.attributes.get('_id')) {
	                parentFeature.setAttribute('_id', [parentFeature._id]);
	              }
	              parentFeature.addChild(addedFeature);
	              _context3.next = 18;
	              break;
	            case 17:
	              dataStore.addFeature(assembly, addedFeature);
	            case 18:
	              _context3.next = 6;
	              break;
	            case 20:
	              _context3.next = 25;
	              break;
	            case 22:
	              _context3.prev = 22;
	              _context3.t0 = _context3["catch"](4);
	              _iterator2.e(_context3.t0);
	            case 25:
	              _context3.prev = 25;
	              _iterator2.f();
	              return _context3.finish(25);
	            case 28:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this, [[4, 22, 25, 28]]);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        logger = this.logger;
	      var inverseChangedIds = _toConsumableArray(changedIds).reverse();
	      var inverseChanges = _toConsumableArray(changes).reverse().map(function (addFeatureChange) {
	        return {
	          deletedFeature: addFeatureChange.addedFeature,
	          parentFeatureId: addFeatureChange.parentFeatureId
	        };
	      });
	      return new DeleteFeatureChange_1$4.DeleteFeatureChange({
	        changedIds: inverseChangedIds,
	        typeName: 'DeleteFeatureChange',
	        changes: inverseChanges,
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return AddFeatureChange;
	}(common_1$j.FeatureChange);
	AddFeatureChange$1.AddFeatureChange = AddFeatureChange;
	function isAddFeatureChange(change) {
	  return change.typeName === 'AddFeatureChange';
	}

	var AddFeaturesFromFileChange$1 = {};

	Object.defineProperty(AddFeaturesFromFileChange$1, "__esModule", {
	  value: true
	});
	AddFeaturesFromFileChange$1.AddFeaturesFromFileChange = void 0;
	var FromFileBaseChange_1 = FromFileBaseChange$1;
	var AddFeaturesFromFileChange = /*#__PURE__*/function (_FromFileBaseChange_) {
	  _inherits(AddFeaturesFromFileChange, _FromFileBaseChange_);
	  var _super = /*#__PURE__*/_createSuper(AddFeaturesFromFileChange);
	  function AddFeaturesFromFileChange(json, options) {
	    var _json$deleteExistingF;
	    var _this;
	    _classCallCheck(this, AddFeaturesFromFileChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'AddFeaturesFromFileChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _defineProperty(_assertThisInitialized(_this), "deleteExistingFeatures", false);
	    _this.deleteExistingFeatures = (_json$deleteExistingF = json.deleteExistingFeatures) !== null && _json$deleteExistingF !== void 0 ? _json$deleteExistingF : false;
	    _this.changes = 'changes' in json ? json.changes : [json];
	    return _this;
	  }
	  // eslint-disable-next-line @typescript-eslint/class-literal-property-style
	  _createClass(AddFeaturesFromFileChange, [{
	    key: "notification",
	    get: function get() {
	      return 'Features have been added. To see them, please refresh the page.';
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        changes = this.changes,
	        deleteExistingFeatures = this.deleteExistingFeatures,
	        typeName = this.typeName;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          fileId = _changes[0].fileId;
	        return {
	          typeName: typeName,
	          assembly: assembly,
	          fileId: fileId,
	          deleteExistingFeatures: deleteExistingFeatures
	        };
	      }
	      return {
	        typeName: typeName,
	        assembly: assembly,
	        changes: changes,
	        deleteExistingFeatures: deleteExistingFeatures
	      };
	    }
	    /**
	     * Applies the required change to database
	     * @param backend - parameters from backend
	     * @returns
	     */
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var _logger$debug;
	        var fileModel, filesService, changes, deleteExistingFeatures, logger, _iterator2, _step2, _logger$debug2, change, fileId, FILE_UPLOAD_FOLDER, fileDoc, featureStream, featureCount, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, f, gff3Feature, _logger$debug3;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              fileModel = backend.fileModel, filesService = backend.filesService;
	              changes = this.changes, deleteExistingFeatures = this.deleteExistingFeatures, logger = this.logger;
	              if (!deleteExistingFeatures) {
	                _context.next = 5;
	                break;
	              }
	              _context.next = 5;
	              return this.removeExistingFeatures(backend);
	            case 5:
	              _iterator2 = _createForOfIteratorHelper(changes);
	              _context.prev = 6;
	              _iterator2.s();
	            case 8:
	              if ((_step2 = _iterator2.n()).done) {
	                _context.next = 56;
	                break;
	              }
	              change = _step2.value;
	              fileId = change.fileId;
	              FILE_UPLOAD_FOLDER = process$1.env.FILE_UPLOAD_FOLDER;
	              if (FILE_UPLOAD_FOLDER) {
	                _context.next = 14;
	                break;
	              }
	              throw new Error('No FILE_UPLOAD_FOLDER found in .env file');
	            case 14:
	              _context.next = 16;
	              return fileModel.findById(fileId).exec();
	            case 16:
	              fileDoc = _context.sent;
	              if (fileDoc) {
	                _context.next = 19;
	                break;
	              }
	              throw new Error("File \"".concat(fileId, "\" not found in Mongo"));
	            case 19:
	              (_logger$debug2 = logger.debug) === null || _logger$debug2 === void 0 || _logger$debug2.call(logger, "FileId \"".concat(fileId, "\", checksum \"").concat(fileDoc.checksum, "\""));
	              // Read data from compressed file and parse the content
	              featureStream = filesService.parseGFF3(filesService.getFileStream(fileDoc));
	              featureCount = 0;
	              _iteratorAbruptCompletion = false;
	              _didIteratorError = false;
	              _context.prev = 24;
	              _iterator = _asyncIterator(featureStream);
	            case 26:
	              _context.next = 28;
	              return _iterator.next();
	            case 28:
	              if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {
	                _context.next = 38;
	                break;
	              }
	              f = _step.value;
	              gff3Feature = f; // Add new feature into database
	              // We cannot use Mongo 'session' / transaction here because Mongo has 16 MB limit for transaction
	              _context.next = 33;
	              return this.addFeatureIntoDb(gff3Feature, backend);
	            case 33:
	              featureCount++;
	              if (featureCount % 1000 === 0) {
	                (_logger$debug3 = logger.debug) === null || _logger$debug3 === void 0 || _logger$debug3.call(logger, "Processed ".concat(featureCount, " features"));
	              }
	            case 35:
	              _iteratorAbruptCompletion = false;
	              _context.next = 26;
	              break;
	            case 38:
	              _context.next = 44;
	              break;
	            case 40:
	              _context.prev = 40;
	              _context.t0 = _context["catch"](24);
	              _didIteratorError = true;
	              _iteratorError = _context.t0;
	            case 44:
	              _context.prev = 44;
	              _context.prev = 45;
	              if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
	                _context.next = 49;
	                break;
	              }
	              _context.next = 49;
	              return _iterator["return"]();
	            case 49:
	              _context.prev = 49;
	              if (!_didIteratorError) {
	                _context.next = 52;
	                break;
	              }
	              throw _iteratorError;
	            case 52:
	              return _context.finish(49);
	            case 53:
	              return _context.finish(44);
	            case 54:
	              _context.next = 8;
	              break;
	            case 56:
	              _context.next = 61;
	              break;
	            case 58:
	              _context.prev = 58;
	              _context.t1 = _context["catch"](6);
	              _iterator2.e(_context.t1);
	            case 61:
	              _context.prev = 61;
	              _iterator2.f();
	              return _context.finish(61);
	            case 64:
	              (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, 'New features added into database!');
	            case 65:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this, [[6, 58, 61, 64], [24, 40, 44, 54], [45,, 49, 53]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }() // eslint-disable-next-line @typescript-eslint/no-empty-function
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_dataStore) {
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var assembly = this.assembly,
	        changes = this.changes,
	        logger = this.logger,
	        typeName = this.typeName;
	      return new AddFeaturesFromFileChange({
	        typeName: typeName,
	        changes: changes,
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return AddFeaturesFromFileChange;
	}(FromFileBaseChange_1.FromFileBaseChange);
	AddFeaturesFromFileChange$1.AddFeaturesFromFileChange = AddFeaturesFromFileChange;

	var AddRefSeqAliasesChange$1 = {};

	Object.defineProperty(AddRefSeqAliasesChange$1, "__esModule", {
	  value: true
	});
	AddRefSeqAliasesChange$1.AddRefSeqAliasesChange = void 0;
	var common_1$i = dist$1;
	var util_1$4 = require$$1__default$1["default"];
	var AddRefSeqAliasesChange = /*#__PURE__*/function (_common_1$AssemblySpe) {
	  _inherits(AddRefSeqAliasesChange, _common_1$AssemblySpe);
	  var _super = /*#__PURE__*/_createSuper(AddRefSeqAliasesChange);
	  function AddRefSeqAliasesChange(json, options) {
	    var _this;
	    _classCallCheck(this, AddRefSeqAliasesChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'AddRefSeqAliasesChange');
	    _defineProperty(_assertThisInitialized(_this), "refSeqAliases", void 0);
	    _this.refSeqAliases = json.refSeqAliases;
	    return _this;
	  }
	  _createClass(AddRefSeqAliasesChange, [{
	    key: "executeOnClient",
	    value: function executeOnClient(clientDataStore) {
	      var _ref = (0, util_1$4.getSession)(clientDataStore),
	        assemblyManager = _ref.assemblyManager;
	      var assembly = assemblyManager.get(this.assembly);
	      if (!assembly) {
	        throw new Error("assembly ".concat(this.assembly, " not found"));
	      }
	      var sessionAliases = assembly.refNameAliases;
	      var sessionLCAliases = assembly.lowerCaseRefNameAliases;
	      if (!sessionAliases || !sessionLCAliases) {
	        throw new Error('Session refNameAliases not found in assembly');
	      }
	      var _iterator = _createForOfIteratorHelper(this.refSeqAliases),
	        _step;
	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var refSeqAlias = _step.value;
	          var aliases = refSeqAlias.aliases,
	            refName = refSeqAlias.refName;
	          var _iterator2 = _createForOfIteratorHelper(aliases),
	            _step2;
	          try {
	            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	              var alias = _step2.value;
	              sessionAliases[alias] = refName;
	              sessionLCAliases[alias.toLowerCase()] = refName;
	            }
	          } catch (err) {
	            _iterator2.e(err);
	          } finally {
	            _iterator2.f();
	          }
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }
	      assembly.setRefNameAliases(sessionAliases, sessionLCAliases);
	      return Promise.resolve();
	    }
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      throw new Error('Method not implemented.');
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        refSeqAliases = this.refSeqAliases,
	        typeName = this.typeName;
	      return {
	        assembly: assembly,
	        typeName: typeName,
	        refSeqAliases: refSeqAliases
	      };
	    }
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var refSeqModel, session, assembly, logger, refSeqAliases, _iterator3, _step3, _logger$debug, refSeqAlias, aliases, refName;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              refSeqModel = backend.refSeqModel, session = backend.session;
	              assembly = this.assembly, logger = this.logger, refSeqAliases = this.refSeqAliases;
	              _iterator3 = _createForOfIteratorHelper(refSeqAliases);
	              _context.prev = 3;
	              _iterator3.s();
	            case 5:
	              if ((_step3 = _iterator3.n()).done) {
	                _context.next = 13;
	                break;
	              }
	              refSeqAlias = _step3.value;
	              (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, "Updating Refname alias for assembly: ".concat(assembly, ", refSeqAlias: ").concat(JSON.stringify(refSeqAlias)));
	              aliases = refSeqAlias.aliases, refName = refSeqAlias.refName;
	              _context.next = 11;
	              return refSeqModel.updateOne({
	                assembly: assembly,
	                name: refName
	              }, {
	                $set: {
	                  aliases: aliases
	                }
	              }).session(session);
	            case 11:
	              _context.next = 5;
	              break;
	            case 13:
	              _context.next = 18;
	              break;
	            case 15:
	              _context.prev = 15;
	              _context.t0 = _context["catch"](3);
	              _iterator3.e(_context.t0);
	            case 18:
	              _context.prev = 18;
	              _iterator3.f();
	              return _context.finish(18);
	            case 21:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this, [[3, 15, 18, 21]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function executeOnLocalGFF3(_backend) {
	      throw new Error('Method not implemented.');
	    }
	    // eslint-disable-next-line @typescript-eslint/class-literal-property-style
	  }, {
	    key: "notification",
	    get: function get() {
	      return 'RefSeq aliases have been added.';
	    }
	  }]);
	  return AddRefSeqAliasesChange;
	}(common_1$i.AssemblySpecificChange);
	AddRefSeqAliasesChange$1.AddRefSeqAliasesChange = AddRefSeqAliasesChange;

	var DeleteAssemblyChange$1 = {};

	Object.defineProperty(DeleteAssemblyChange$1, "__esModule", {
	  value: true
	});
	DeleteAssemblyChange$1.DeleteAssemblyChange = void 0;
	/* eslint-disable @typescript-eslint/no-unsafe-return */
	/* eslint-disable @typescript-eslint/require-await */
	/* eslint-disable @typescript-eslint/no-unnecessary-condition */
	/* eslint-disable @typescript-eslint/no-unsafe-call */
	var common_1$h = dist$1;
	var util_1$3 = require$$1__default$1["default"];
	var DeleteAssemblyChange = /*#__PURE__*/function (_common_1$AssemblySpe) {
	  _inherits(DeleteAssemblyChange, _common_1$AssemblySpe);
	  var _super = /*#__PURE__*/_createSuper(DeleteAssemblyChange);
	  function DeleteAssemblyChange() {
	    var _this;
	    _classCallCheck(this, DeleteAssemblyChange);
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    _this = _super.call.apply(_super, [this].concat(args));
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'DeleteAssemblyChange');
	    return _this;
	  }
	  _createClass(DeleteAssemblyChange, [{
	    key: "notification",
	    get: function get() {
	      return "Assembly \"".concat(this.assembly, "\" deleted successfully.");
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        typeName = this.typeName;
	      return {
	        typeName: typeName,
	        assembly: assembly
	      };
	    }
	    /**
	     * Applies the required change to database
	     * @param backend - parameters from backend
	     * @returns
	     */
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var _logger$debug;
	        var assemblyModel, featureModel, refSeqChunkModel, refSeqModel, session, assembly, logger, assemblyDoc, errMsg, refSeqs, refSeqIds;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              assemblyModel = backend.assemblyModel, featureModel = backend.featureModel, refSeqChunkModel = backend.refSeqChunkModel, refSeqModel = backend.refSeqModel, session = backend.session;
	              assembly = this.assembly, logger = this.logger;
	              _context.next = 4;
	              return assemblyModel.findById(assembly).session(session).exec();
	            case 4:
	              assemblyDoc = _context.sent;
	              if (assemblyDoc) {
	                _context.next = 9;
	                break;
	              }
	              errMsg = "*** ERROR: Assembly with id \"".concat(assembly, "\" not found");
	              logger.error(errMsg);
	              throw new Error(errMsg);
	            case 9:
	              _context.next = 11;
	              return refSeqModel.find({
	                assembly: assembly
	              }).exec();
	            case 11:
	              refSeqs = _context.sent;
	              refSeqIds = refSeqs.map(function (refSeq) {
	                return refSeq._id;
	              }); // Get and delete RefSeqChunks
	              _context.next = 15;
	              return refSeqChunkModel.deleteMany({
	                refSeq: refSeqIds
	              }).exec();
	            case 15:
	              _context.next = 17;
	              return featureModel.deleteMany({
	                refSeq: refSeqIds
	              }).exec();
	            case 17:
	              _context.next = 19;
	              return refSeqModel.deleteMany({
	                assembly: assembly
	              }).exec();
	            case 19:
	              _context.next = 21;
	              return assemblyModel.findByIdAndDelete(assembly).exec();
	            case 21:
	              (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, "Assembly \"".concat(assembly, "\" deleted from database."));
	            case 22:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }()
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(dataStore) {
	        var _session$removeAssemb, _session$removeSessio;
	        var assembly, session;
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              assembly = this.assembly;
	              if (dataStore) {
	                _context3.next = 3;
	                break;
	              }
	              throw new Error('No data store');
	            case 3:
	              session = (0, util_1$3.getSession)(dataStore); // If assemblyId is not present in client data store
	              if (dataStore.assemblies.has(assembly)) {
	                dataStore.deleteAssembly(assembly);
	              }
	              _context3.next = 7;
	              return (_session$removeAssemb = session.removeAssembly) === null || _session$removeAssemb === void 0 ? void 0 : _session$removeAssemb.call(session, assembly);
	            case 7:
	              _context3.next = 9;
	              return (_session$removeSessio = session.removeSessionAssembly) === null || _session$removeSessio === void 0 ? void 0 : _session$removeSessio.call(session, assembly);
	            case 9:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var assembly = this.assembly,
	        logger = this.logger;
	      return new DeleteAssemblyChange({
	        typeName: 'DeleteAssemblyChange',
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return DeleteAssemblyChange;
	}(common_1$h.AssemblySpecificChange);
	DeleteAssemblyChange$1.DeleteAssemblyChange = DeleteAssemblyChange;

	var DeleteUserChange$1 = {};

	Object.defineProperty(DeleteUserChange$1, "__esModule", {
	  value: true
	});
	DeleteUserChange$1.DeleteUserChange = void 0;
	/* eslint-disable @typescript-eslint/require-await */
	var common_1$g = dist$1;
	var DeleteUserChange = /*#__PURE__*/function (_common_1$Change) {
	  _inherits(DeleteUserChange, _common_1$Change);
	  var _super = /*#__PURE__*/_createSuper(DeleteUserChange);
	  function DeleteUserChange(json, options) {
	    var _this;
	    _classCallCheck(this, DeleteUserChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'DeleteUserChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _defineProperty(_assertThisInitialized(_this), "userId", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    _this.userId = json.userId;
	    return _this;
	  }
	  _createClass(DeleteUserChange, [{
	    key: "toJSON",
	    value: function toJSON() {
	      var typeName = this.typeName,
	        userId = this.userId;
	      return {
	        typeName: typeName,
	        userId: userId
	      };
	    }
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var session, userModel, logger, userId, user, errMsg;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              session = backend.session, userModel = backend.userModel;
	              logger = this.logger, userId = this.userId;
	              _context.next = 4;
	              return userModel.findOneAndDelete({
	                _id: userId
	              }).session(session).exec();
	            case 4:
	              user = _context.sent;
	              if (user) {
	                _context.next = 9;
	                break;
	              }
	              errMsg = "*** ERROR: User with id \"".concat(userId, "\" not found");
	              logger.error(errMsg);
	              throw new Error(errMsg);
	            case 9:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }() // eslint-disable-next-line @typescript-eslint/no-empty-function
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_dataStore) {
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var logger = this.logger,
	        typeName = this.typeName,
	        userId = this.userId;
	      return new DeleteUserChange({
	        typeName: typeName,
	        userId: userId
	      }, {
	        logger: logger
	      });
	      //   const inverseChangedIds = this.changedIds.slice().reverse()
	      //   const inverseChanges = this.changes
	      //     .slice()
	      //     .reverse()
	      //     .map((deleteUserChange) => ({
	      //       addedUser: deleteUserChange.userId,
	      //     }))
	      //   this.logger.debug?.(`INVERSE CHANGE '${JSON.stringify(inverseChanges)}'`)
	      //   // return new AddUserChange()
	      // }
	    }
	  }]);
	  return DeleteUserChange;
	}(common_1$g.Change);
	DeleteUserChange$1.DeleteUserChange = DeleteUserChange;

	var FeatureAttributeChange$1 = {};

	Object.defineProperty(FeatureAttributeChange$1, "__esModule", {
	  value: true
	});
	FeatureAttributeChange$1.FeatureAttributeChange = void 0;
	FeatureAttributeChange$1.isFeatureAttributeChange = isFeatureAttributeChange;
	/* eslint-disable @typescript-eslint/restrict-template-expressions */
	/* eslint-disable @typescript-eslint/require-await */
	/* eslint-disable @typescript-eslint/no-unnecessary-condition */
	var common_1$f = dist$1;
	var FeatureAttributeChange = /*#__PURE__*/function (_common_1$FeatureChan) {
	  _inherits(FeatureAttributeChange, _common_1$FeatureChan);
	  var _super = /*#__PURE__*/_createSuper(FeatureAttributeChange);
	  function FeatureAttributeChange(json, options) {
	    var _this;
	    _classCallCheck(this, FeatureAttributeChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'FeatureAttributeChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    return _this;
	  }
	  _createClass(FeatureAttributeChange, [{
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        typeName = this.typeName;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          _changes$ = _changes[0],
	          oldAttributes = _changes$.oldAttributes,
	          newAttributes = _changes$.newAttributes,
	          featureId = _changes$.featureId;
	        return {
	          typeName: typeName,
	          changedIds: changedIds,
	          assembly: assembly,
	          featureId: featureId,
	          oldAttributes: oldAttributes,
	          newAttributes: newAttributes
	        };
	      }
	      return {
	        typeName: typeName,
	        changedIds: changedIds,
	        assembly: assembly,
	        changes: changes
	      };
	    }
	    /**
	     * Applies the required change to database
	     * @param backend - parameters from backend
	     * @returns
	     */
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var featureModel, session, changes, logger, featuresForChanges, _iterator, _step, _logger$debug, _logger$debug2, change, featureId, topLevelFeature, errMsg, foundFeature, _errMsg, _iterator2, _step2, _logger$debug4, _step2$value, idx, _change, newAttributes, _featuresForChanges$i, feature, _topLevelFeature, _logger$debug3;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              featureModel = backend.featureModel, session = backend.session;
	              changes = this.changes, logger = this.logger;
	              featuresForChanges = []; // Loop the changes and check that all features are found
	              _iterator = _createForOfIteratorHelper(changes);
	              _context.prev = 4;
	              _iterator.s();
	            case 6:
	              if ((_step = _iterator.n()).done) {
	                _context.next = 26;
	                break;
	              }
	              change = _step.value;
	              featureId = change.featureId; // Search correct feature
	              _context.next = 11;
	              return featureModel.findOne({
	                allIds: featureId
	              }).session(session).exec();
	            case 11:
	              topLevelFeature = _context.sent;
	              if (topLevelFeature) {
	                _context.next = 16;
	                break;
	              }
	              errMsg = "*** ERROR: The following featureId was not found in database ='".concat(featureId, "'");
	              logger.error(errMsg);
	              throw new Error(errMsg);
	            case 16:
	              (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, "*** Feature found: ".concat(JSON.stringify(topLevelFeature)));
	              foundFeature = this.getFeatureFromId(topLevelFeature, featureId);
	              if (foundFeature) {
	                _context.next = 22;
	                break;
	              }
	              _errMsg = 'ERROR when searching feature by featureId';
	              logger.error(_errMsg);
	              throw new Error(_errMsg);
	            case 22:
	              (_logger$debug2 = logger.debug) === null || _logger$debug2 === void 0 || _logger$debug2.call(logger, "*** Found feature: ".concat(JSON.stringify(foundFeature)));
	              featuresForChanges.push({
	                feature: foundFeature,
	                topLevelFeature: topLevelFeature
	              });
	            case 24:
	              _context.next = 6;
	              break;
	            case 26:
	              _context.next = 31;
	              break;
	            case 28:
	              _context.prev = 28;
	              _context.t0 = _context["catch"](4);
	              _iterator.e(_context.t0);
	            case 31:
	              _context.prev = 31;
	              _iterator.f();
	              return _context.finish(31);
	            case 34:
	              // Let's update objects
	              _iterator2 = _createForOfIteratorHelper(changes.entries());
	              _context.prev = 35;
	              _iterator2.s();
	            case 37:
	              if ((_step2 = _iterator2.n()).done) {
	                _context.next = 55;
	                break;
	              }
	              _step2$value = _slicedToArray(_step2.value, 2), idx = _step2$value[0], _change = _step2$value[1];
	              newAttributes = _change.newAttributes;
	              _featuresForChanges$i = featuresForChanges[idx], feature = _featuresForChanges$i.feature, _topLevelFeature = _featuresForChanges$i.topLevelFeature;
	              feature.attributes = newAttributes;
	              if (_topLevelFeature._id.equals(feature._id)) {
	                _topLevelFeature.markModified('attributes'); // Mark as modified. Without this save() -method is not updating data in database
	              } else {
	                _topLevelFeature.markModified('children'); // Mark as modified. Without this save() -method is not updating data in database
	              }
	              _context.prev = 43;
	              _context.next = 46;
	              return _topLevelFeature.save();
	            case 46:
	              _context.next = 52;
	              break;
	            case 48:
	              _context.prev = 48;
	              _context.t1 = _context["catch"](43);
	              (_logger$debug3 = logger.debug) === null || _logger$debug3 === void 0 || _logger$debug3.call(logger, "*** FAILED: ".concat(_context.t1));
	              throw _context.t1;
	            case 52:
	              (_logger$debug4 = logger.debug) === null || _logger$debug4 === void 0 || _logger$debug4.call(logger, "*** Feature attributes modified (added, edited or deleted), docId: ".concat(JSON.stringify(_topLevelFeature)));
	            case 53:
	              _context.next = 37;
	              break;
	            case 55:
	              _context.next = 60;
	              break;
	            case 57:
	              _context.prev = 57;
	              _context.t2 = _context["catch"](35);
	              _iterator2.e(_context.t2);
	            case 60:
	              _context.prev = 60;
	              _iterator2.f();
	              return _context.finish(60);
	            case 63:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this, [[4, 28, 31, 34], [35, 57, 60, 63], [43, 48]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              throw new Error('applyToLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }()
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(dataStore) {
	        var _iterator3, _step3, _step3$value, idx, changedId, feature;
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              if (dataStore) {
	                _context3.next = 2;
	                break;
	              }
	              throw new Error('No data store');
	            case 2:
	              _iterator3 = _createForOfIteratorHelper(this.changedIds.entries());
	              _context3.prev = 3;
	              _iterator3.s();
	            case 5:
	              if ((_step3 = _iterator3.n()).done) {
	                _context3.next = 13;
	                break;
	              }
	              _step3$value = _slicedToArray(_step3.value, 2), idx = _step3$value[0], changedId = _step3$value[1];
	              feature = dataStore.getFeature(changedId);
	              if (feature) {
	                _context3.next = 10;
	                break;
	              }
	              throw new Error("Could not find feature with identifier \"".concat(changedId, "\""));
	            case 10:
	              feature.setAttributes(new Map(Object.entries(this.changes[idx].newAttributes)));
	            case 11:
	              _context3.next = 5;
	              break;
	            case 13:
	              _context3.next = 18;
	              break;
	            case 15:
	              _context3.prev = 15;
	              _context3.t0 = _context3["catch"](3);
	              _iterator3.e(_context3.t0);
	            case 18:
	              _context3.prev = 18;
	              _iterator3.f();
	              return _context3.finish(18);
	            case 21:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this, [[3, 15, 18, 21]]);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        logger = this.logger;
	      var inverseChangedIds = _toConsumableArray(changedIds).reverse();
	      var inverseChanges = _toConsumableArray(changes).reverse().map(function (oneChange) {
	        return {
	          featureId: oneChange.featureId,
	          oldAttributes: oneChange.newAttributes,
	          newAttributes: oneChange.oldAttributes
	        };
	      });
	      return new FeatureAttributeChange({
	        changedIds: inverseChangedIds,
	        typeName: 'FeatureAttributeChange',
	        changes: inverseChanges,
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return FeatureAttributeChange;
	}(common_1$f.FeatureChange);
	FeatureAttributeChange$1.FeatureAttributeChange = FeatureAttributeChange;
	function isFeatureAttributeChange(change) {
	  return change.typeName === 'FeatureAttributeChange';
	}

	var ImportJBrowseConfigChange$1 = {};

	var _excluded = ["__v", "_id", "assemblies", "configuration", "internetAccounts", "plugins", "tracks"],
	  _excluded2 = ["hasRole"];
	Object.defineProperty(ImportJBrowseConfigChange$1, "__esModule", {
	  value: true
	});
	ImportJBrowseConfigChange$1.ImportJBrowseConfigChange = void 0;
	ImportJBrowseConfigChange$1.filterJBrowseConfig = filterJBrowseConfig;
	/* eslint-disable @typescript-eslint/require-await */
	var common_1$e = dist$1;
	function filterJBrowseConfig(config) {
	  var _configuration$Apollo;
	  var assemblies = config.assemblies,
	    configuration = config.configuration,
	    internetAccounts = config.internetAccounts,
	    plugins = config.plugins,
	    tracks = config.tracks,
	    rest = _objectWithoutProperties(config, _excluded);
	  // Need to make sure that configuration.ApolloPlugin.hasRole isn't set
	  var filteredConfig = rest;
	  if (assemblies) {
	    filteredConfig.assemblies = assemblies.filter(function (a) {
	      return a.sequence.adapter.type !== 'ApolloSequenceAdapter';
	    });
	  }
	  if (configuration !== null && configuration !== void 0 && (_configuration$Apollo = configuration.ApolloPlugin) !== null && _configuration$Apollo !== void 0 && _configuration$Apollo.hasRole) {
	    var _configuration$Apollo2 = configuration.ApolloPlugin,
	      apolloPluginRest = _objectWithoutProperties(_configuration$Apollo2, _excluded2);
	    filteredConfig.configuration = _objectSpread2(_objectSpread2({}, configuration), {}, {
	      ApolloPlugin: apolloPluginRest
	    });
	  }
	  if (internetAccounts) {
	    filteredConfig.internetAccounts = internetAccounts.filter(function (i) {
	      return i.type !== 'ApolloInternetAccount';
	    });
	  }
	  if (plugins) {
	    filteredConfig.plugins = plugins.filter(function (p) {
	      return p.name !== 'Apollo';
	    });
	  }
	  if (tracks) {
	    filteredConfig.tracks = tracks.filter(function (t) {
	      return t.type !== 'ApolloTrack';
	    });
	  }
	  return filteredConfig;
	}
	var ImportJBrowseConfigChange = /*#__PURE__*/function (_common_1$Change) {
	  _inherits(ImportJBrowseConfigChange, _common_1$Change);
	  var _super = /*#__PURE__*/_createSuper(ImportJBrowseConfigChange);
	  function ImportJBrowseConfigChange(json, options) {
	    var _this;
	    _classCallCheck(this, ImportJBrowseConfigChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'ImportJBrowseConfigChange');
	    _defineProperty(_assertThisInitialized(_this), "oldJBrowseConfig", void 0);
	    _defineProperty(_assertThisInitialized(_this), "newJBrowseConfig", void 0);
	    _this.oldJBrowseConfig = json.oldJBrowseConfig;
	    _this.newJBrowseConfig = json.newJBrowseConfig;
	    return _this;
	  }
	  _createClass(ImportJBrowseConfigChange, [{
	    key: "toJSON",
	    value: function toJSON() {
	      var newJBrowseConfig = this.newJBrowseConfig,
	        oldJBrowseConfig = this.oldJBrowseConfig,
	        typeName = this.typeName;
	      return {
	        typeName: typeName,
	        oldJBrowseConfig: oldJBrowseConfig,
	        newJBrowseConfig: newJBrowseConfig
	      };
	    }
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var _logger$debug;
	        var jbrowseConfigModel, logger, newJBrowseConfig, filteredConfig;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              jbrowseConfigModel = backend.jbrowseConfigModel;
	              logger = this.logger, newJBrowseConfig = this.newJBrowseConfig;
	              _context.next = 4;
	              return jbrowseConfigModel.deleteMany();
	            case 4:
	              if (newJBrowseConfig) {
	                _context.next = 6;
	                break;
	              }
	              return _context.abrupt("return");
	            case 6:
	              filteredConfig = filterJBrowseConfig(newJBrowseConfig);
	              _context.next = 9;
	              return jbrowseConfigModel.create(filteredConfig);
	            case 9:
	              (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, 'Stored new JBrowse Config');
	            case 10:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }() // eslint-disable-next-line @typescript-eslint/no-empty-function
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_dataStore) {
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var logger = this.logger,
	        newJBrowseConfig = this.newJBrowseConfig,
	        oldJBrowseConfig = this.oldJBrowseConfig;
	      return new ImportJBrowseConfigChange({
	        typeName: 'ImportJBrowseConfigChange',
	        oldJBrowseConfig: newJBrowseConfig,
	        newJBrowseConfig: oldJBrowseConfig
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return ImportJBrowseConfigChange;
	}(common_1$e.Change);
	ImportJBrowseConfigChange$1.ImportJBrowseConfigChange = ImportJBrowseConfigChange;

	var LocationEndChange$1 = {};

	Object.defineProperty(LocationEndChange$1, "__esModule", {
	  value: true
	});
	LocationEndChange$1.LocationEndChange = void 0;
	LocationEndChange$1.isLocationEndChange = isLocationEndChange;
	/* eslint-disable @typescript-eslint/restrict-template-expressions */
	/* eslint-disable @typescript-eslint/require-await */
	/* eslint-disable @typescript-eslint/no-unnecessary-condition */
	var common_1$d = dist$1;
	var LocationEndChange = /*#__PURE__*/function (_common_1$FeatureChan) {
	  _inherits(LocationEndChange, _common_1$FeatureChan);
	  var _super = /*#__PURE__*/_createSuper(LocationEndChange);
	  function LocationEndChange(json, options) {
	    var _this;
	    _classCallCheck(this, LocationEndChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'LocationEndChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    return _this;
	  }
	  _createClass(LocationEndChange, [{
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        typeName = this.typeName;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          _changes$ = _changes[0],
	          featureId = _changes$.featureId,
	          newEnd = _changes$.newEnd,
	          oldEnd = _changes$.oldEnd;
	        return {
	          typeName: typeName,
	          changedIds: changedIds,
	          assembly: assembly,
	          featureId: featureId,
	          oldEnd: oldEnd,
	          newEnd: newEnd
	        };
	      }
	      return {
	        typeName: typeName,
	        changedIds: changedIds,
	        assembly: assembly,
	        changes: changes
	      };
	    }
	    /**
	     * Applies the required change to database
	     * @param backend - parameters from backend
	     * @returns
	     */
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var featureModel, session, changes, logger, topLevelFeatures, _iterator, _step, _logger$debug2, _logger$debug3, change, featureId, oldEnd, newEnd, topLevelFeature, feature, _iterator2, _step2, _tlv, childFeature, errMsg, _errMsg, _errMsg2, _i, _topLevelFeatures, tlv, _logger$debug;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              featureModel = backend.featureModel, session = backend.session;
	              changes = this.changes, logger = this.logger; // Let's first check that all features are found and those old values match with expected ones. We do this just to be sure that all changes can be done.
	              topLevelFeatures = [];
	              _iterator = _createForOfIteratorHelper(changes);
	              _context.prev = 4;
	              _iterator.s();
	            case 6:
	              if ((_step = _iterator.n()).done) {
	                _context.next = 55;
	                break;
	              }
	              change = _step.value;
	              featureId = change.featureId, oldEnd = change.oldEnd, newEnd = change.newEnd; // See if we already have top-level feature for this feature
	              topLevelFeature = void 0;
	              feature = void 0;
	              _iterator2 = _createForOfIteratorHelper(topLevelFeatures);
	              _context.prev = 12;
	              _iterator2.s();
	            case 14:
	              if ((_step2 = _iterator2.n()).done) {
	                _context.next = 23;
	                break;
	              }
	              _tlv = _step2.value;
	              childFeature = this.getFeatureFromId(_tlv, featureId);
	              if (!childFeature) {
	                _context.next = 21;
	                break;
	              }
	              topLevelFeature = _tlv;
	              feature = childFeature;
	              return _context.abrupt("break", 23);
	            case 21:
	              _context.next = 14;
	              break;
	            case 23:
	              _context.next = 28;
	              break;
	            case 25:
	              _context.prev = 25;
	              _context.t0 = _context["catch"](12);
	              _iterator2.e(_context.t0);
	            case 28:
	              _context.prev = 28;
	              _iterator2.f();
	              return _context.finish(28);
	            case 31:
	              if (topLevelFeature) {
	                _context.next = 36;
	                break;
	              }
	              _context.next = 34;
	              return featureModel.findOne({
	                allIds: featureId
	              }).session(session).exec();
	            case 34:
	              topLevelFeature = _context.sent;
	              if (topLevelFeature) {
	                topLevelFeatures.push(topLevelFeature);
	              }
	            case 36:
	              if (topLevelFeature) {
	                _context.next = 40;
	                break;
	              }
	              errMsg = "*** ERROR: The following featureId was not found in database ='".concat(featureId, "'");
	              logger.error(errMsg);
	              throw new Error(errMsg);
	            case 40:
	              (_logger$debug2 = logger.debug) === null || _logger$debug2 === void 0 || _logger$debug2.call(logger, "*** TOP level feature found: ".concat(JSON.stringify(topLevelFeature)));
	              if (!feature) {
	                feature = this.getFeatureFromId(topLevelFeature, featureId);
	              }
	              if (feature) {
	                _context.next = 46;
	                break;
	              }
	              _errMsg = 'ERROR when searching feature by featureId';
	              logger.error(_errMsg);
	              throw new Error(_errMsg);
	            case 46:
	              (_logger$debug3 = logger.debug) === null || _logger$debug3 === void 0 || _logger$debug3.call(logger, "*** Found feature: ".concat(JSON.stringify(feature)));
	              if (!(feature.max !== oldEnd)) {
	                _context.next = 51;
	                break;
	              }
	              _errMsg2 = 'Expected previous max does not match';
	              logger.error(_errMsg2);
	              throw new Error(_errMsg2);
	            case 51:
	              feature.max = newEnd;
	              if (topLevelFeature._id.equals(feature._id)) {
	                topLevelFeature.markModified('end'); // Mark as modified. Without this save() -method is not updating data in database
	              } else {
	                topLevelFeature.markModified('children'); // Mark as modified. Without this save() -method is not updating data in database
	              }
	            case 53:
	              _context.next = 6;
	              break;
	            case 55:
	              _context.next = 60;
	              break;
	            case 57:
	              _context.prev = 57;
	              _context.t1 = _context["catch"](4);
	              _iterator.e(_context.t1);
	            case 60:
	              _context.prev = 60;
	              _iterator.f();
	              return _context.finish(60);
	            case 63:
	              _i = 0, _topLevelFeatures = topLevelFeatures;
	            case 64:
	              if (!(_i < _topLevelFeatures.length)) {
	                _context.next = 78;
	                break;
	              }
	              tlv = _topLevelFeatures[_i];
	              _context.prev = 66;
	              _context.next = 69;
	              return tlv.save();
	            case 69:
	              _context.next = 75;
	              break;
	            case 71:
	              _context.prev = 71;
	              _context.t2 = _context["catch"](66);
	              (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, "*** FAILED: ".concat(_context.t2));
	              throw _context.t2;
	            case 75:
	              _i++;
	              _context.next = 64;
	              break;
	            case 78:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this, [[4, 57, 60, 63], [12, 25, 28, 31], [66, 71]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }()
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(dataStore) {
	        var _iterator3, _step3, change, featureId, newEnd, feature;
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              if (dataStore) {
	                _context3.next = 2;
	                break;
	              }
	              throw new Error('No data store');
	            case 2:
	              _iterator3 = _createForOfIteratorHelper(this.changes);
	              _context3.prev = 3;
	              _iterator3.s();
	            case 5:
	              if ((_step3 = _iterator3.n()).done) {
	                _context3.next = 14;
	                break;
	              }
	              change = _step3.value;
	              featureId = change.featureId, newEnd = change.newEnd;
	              feature = dataStore.getFeature(featureId);
	              if (feature) {
	                _context3.next = 11;
	                break;
	              }
	              throw new Error("Could not find feature with identifier \"".concat(featureId, "\""));
	            case 11:
	              feature.setMax(newEnd);
	            case 12:
	              _context3.next = 5;
	              break;
	            case 14:
	              _context3.next = 19;
	              break;
	            case 16:
	              _context3.prev = 16;
	              _context3.t0 = _context3["catch"](3);
	              _iterator3.e(_context3.t0);
	            case 19:
	              _context3.prev = 19;
	              _iterator3.f();
	              return _context3.finish(19);
	            case 22:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this, [[3, 16, 19, 22]]);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        logger = this.logger,
	        typeName = this.typeName;
	      var inverseChangedIds = _toConsumableArray(changedIds).reverse();
	      var inverseChanges = _toConsumableArray(changes).reverse().map(function (endChange) {
	        return {
	          featureId: endChange.featureId,
	          oldEnd: endChange.newEnd,
	          newEnd: endChange.oldEnd
	        };
	      });
	      return new LocationEndChange({
	        changedIds: inverseChangedIds,
	        typeName: typeName,
	        changes: inverseChanges,
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return LocationEndChange;
	}(common_1$d.FeatureChange);
	LocationEndChange$1.LocationEndChange = LocationEndChange;
	function isLocationEndChange(change) {
	  return change.typeName === 'LocationEndChange';
	}

	var LocationStartChange$1 = {};

	Object.defineProperty(LocationStartChange$1, "__esModule", {
	  value: true
	});
	LocationStartChange$1.LocationStartChange = void 0;
	LocationStartChange$1.isLocationStartChange = isLocationStartChange;
	/* eslint-disable @typescript-eslint/restrict-template-expressions */
	/* eslint-disable @typescript-eslint/require-await */
	/* eslint-disable @typescript-eslint/no-unnecessary-condition */
	var common_1$c = dist$1;
	var LocationStartChange = /*#__PURE__*/function (_common_1$FeatureChan) {
	  _inherits(LocationStartChange, _common_1$FeatureChan);
	  var _super = /*#__PURE__*/_createSuper(LocationStartChange);
	  function LocationStartChange(json, options) {
	    var _this;
	    _classCallCheck(this, LocationStartChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'LocationStartChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    return _this;
	  }
	  _createClass(LocationStartChange, [{
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        typeName = this.typeName;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          _changes$ = _changes[0],
	          featureId = _changes$.featureId,
	          newStart = _changes$.newStart,
	          oldStart = _changes$.oldStart;
	        return {
	          typeName: typeName,
	          changedIds: changedIds,
	          assembly: assembly,
	          featureId: featureId,
	          oldStart: oldStart,
	          newStart: newStart
	        };
	      }
	      return {
	        typeName: typeName,
	        changedIds: changedIds,
	        assembly: assembly,
	        changes: changes
	      };
	    }
	    /**
	     * Applies the required change to database
	     * @param backend - parameters from backend
	     * @returns
	     */
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var featureModel, session, changes, logger, topLevelFeatures, _iterator, _step, _logger$debug2, _logger$debug3, change, featureId, oldStart, newStart, topLevelFeature, feature, _iterator2, _step2, _tlv, childFeature, errMsg, _errMsg, _errMsg2, _i, _topLevelFeatures, tlv, _logger$debug;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              featureModel = backend.featureModel, session = backend.session;
	              changes = this.changes, logger = this.logger; // Let's first check that all features are found and those old values match with expected ones. We do this just to be sure that all changes can be done.
	              topLevelFeatures = [];
	              _iterator = _createForOfIteratorHelper(changes);
	              _context.prev = 4;
	              _iterator.s();
	            case 6:
	              if ((_step = _iterator.n()).done) {
	                _context.next = 55;
	                break;
	              }
	              change = _step.value;
	              featureId = change.featureId, oldStart = change.oldStart, newStart = change.newStart; // See if we already have top-level feature for this feature
	              topLevelFeature = void 0;
	              feature = void 0;
	              _iterator2 = _createForOfIteratorHelper(topLevelFeatures);
	              _context.prev = 12;
	              _iterator2.s();
	            case 14:
	              if ((_step2 = _iterator2.n()).done) {
	                _context.next = 23;
	                break;
	              }
	              _tlv = _step2.value;
	              childFeature = this.getFeatureFromId(_tlv, featureId);
	              if (!childFeature) {
	                _context.next = 21;
	                break;
	              }
	              topLevelFeature = _tlv;
	              feature = childFeature;
	              return _context.abrupt("break", 23);
	            case 21:
	              _context.next = 14;
	              break;
	            case 23:
	              _context.next = 28;
	              break;
	            case 25:
	              _context.prev = 25;
	              _context.t0 = _context["catch"](12);
	              _iterator2.e(_context.t0);
	            case 28:
	              _context.prev = 28;
	              _iterator2.f();
	              return _context.finish(28);
	            case 31:
	              if (topLevelFeature) {
	                _context.next = 36;
	                break;
	              }
	              _context.next = 34;
	              return featureModel.findOne({
	                allIds: featureId
	              }).session(session).exec();
	            case 34:
	              topLevelFeature = _context.sent;
	              if (topLevelFeature) {
	                topLevelFeatures.push(topLevelFeature);
	              }
	            case 36:
	              if (topLevelFeature) {
	                _context.next = 40;
	                break;
	              }
	              errMsg = "*** ERROR: The following featureId was not found in database ='".concat(featureId, "'");
	              logger.error(errMsg);
	              throw new Error(errMsg);
	            case 40:
	              (_logger$debug2 = logger.debug) === null || _logger$debug2 === void 0 || _logger$debug2.call(logger, "*** TOP level feature found: ".concat(JSON.stringify(topLevelFeature)));
	              if (!feature) {
	                feature = this.getFeatureFromId(topLevelFeature, featureId);
	              }
	              if (feature) {
	                _context.next = 46;
	                break;
	              }
	              _errMsg = 'ERROR when searching feature by featureId';
	              logger.error(_errMsg);
	              throw new Error(_errMsg);
	            case 46:
	              (_logger$debug3 = logger.debug) === null || _logger$debug3 === void 0 || _logger$debug3.call(logger, "*** Found feature: ".concat(JSON.stringify(feature)));
	              if (!(feature.min !== oldStart)) {
	                _context.next = 51;
	                break;
	              }
	              _errMsg2 = 'Expected previous max does not match';
	              logger.error(_errMsg2);
	              throw new Error(_errMsg2);
	            case 51:
	              feature.min = newStart;
	              if (topLevelFeature._id.equals(feature._id)) {
	                topLevelFeature.markModified('start'); // Mark as modified. Without this save() -method is not updating data in database
	              } else {
	                topLevelFeature.markModified('children'); // Mark as modified. Without this save() -method is not updating data in database
	              }
	            case 53:
	              _context.next = 6;
	              break;
	            case 55:
	              _context.next = 60;
	              break;
	            case 57:
	              _context.prev = 57;
	              _context.t1 = _context["catch"](4);
	              _iterator.e(_context.t1);
	            case 60:
	              _context.prev = 60;
	              _iterator.f();
	              return _context.finish(60);
	            case 63:
	              _i = 0, _topLevelFeatures = topLevelFeatures;
	            case 64:
	              if (!(_i < _topLevelFeatures.length)) {
	                _context.next = 78;
	                break;
	              }
	              tlv = _topLevelFeatures[_i];
	              _context.prev = 66;
	              _context.next = 69;
	              return tlv.save();
	            case 69:
	              _context.next = 75;
	              break;
	            case 71:
	              _context.prev = 71;
	              _context.t2 = _context["catch"](66);
	              (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, "*** FAILED: ".concat(_context.t2));
	              throw _context.t2;
	            case 75:
	              _i++;
	              _context.next = 64;
	              break;
	            case 78:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this, [[4, 57, 60, 63], [12, 25, 28, 31], [66, 71]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }()
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(dataStore) {
	        var _iterator3, _step3, change, featureId, newStart, feature;
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              if (dataStore) {
	                _context3.next = 2;
	                break;
	              }
	              throw new Error('No data store');
	            case 2:
	              _iterator3 = _createForOfIteratorHelper(this.changes);
	              _context3.prev = 3;
	              _iterator3.s();
	            case 5:
	              if ((_step3 = _iterator3.n()).done) {
	                _context3.next = 14;
	                break;
	              }
	              change = _step3.value;
	              featureId = change.featureId, newStart = change.newStart;
	              feature = dataStore.getFeature(featureId);
	              if (feature) {
	                _context3.next = 11;
	                break;
	              }
	              throw new Error("Could not find feature with identifier \"".concat(featureId, "\""));
	            case 11:
	              feature.setMin(newStart);
	            case 12:
	              _context3.next = 5;
	              break;
	            case 14:
	              _context3.next = 19;
	              break;
	            case 16:
	              _context3.prev = 16;
	              _context3.t0 = _context3["catch"](3);
	              _iterator3.e(_context3.t0);
	            case 19:
	              _context3.prev = 19;
	              _iterator3.f();
	              return _context3.finish(19);
	            case 22:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this, [[3, 16, 19, 22]]);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        logger = this.logger,
	        typeName = this.typeName;
	      var inverseChangedIds = _toConsumableArray(changedIds).reverse();
	      var inverseChanges = _toConsumableArray(changes).reverse().map(function (startChange) {
	        return {
	          featureId: startChange.featureId,
	          oldStart: startChange.newStart,
	          newStart: startChange.oldStart
	        };
	      });
	      return new LocationStartChange({
	        changedIds: inverseChangedIds,
	        typeName: typeName,
	        changes: inverseChanges,
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return LocationStartChange;
	}(common_1$c.FeatureChange);
	LocationStartChange$1.LocationStartChange = LocationStartChange;
	function isLocationStartChange(change) {
	  return change.typeName === 'LocationStartChange';
	}

	var MergeExonsChange$1 = {};

	var UndoMergeExonsChange$1 = {};

	/* eslint-disable @typescript-eslint/require-await */
	Object.defineProperty(UndoMergeExonsChange$1, "__esModule", {
	  value: true
	});
	UndoMergeExonsChange$1.UndoMergeExonsChange = void 0;
	var common_1$b = dist$1;
	var MergeExonsChange_1 = MergeExonsChange$1;
	var UndoMergeExonsChange = /*#__PURE__*/function (_common_1$FeatureChan) {
	  _inherits(UndoMergeExonsChange, _common_1$FeatureChan);
	  var _super = /*#__PURE__*/_createSuper(UndoMergeExonsChange);
	  function UndoMergeExonsChange(json, options) {
	    var _this;
	    _classCallCheck(this, UndoMergeExonsChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'UndoMergeExonsChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    return _this;
	  }
	  _createClass(UndoMergeExonsChange, [{
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        typeName = this.typeName;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          _changes$ = _changes[0],
	          exonsToRestore = _changes$.exonsToRestore,
	          parentFeatureId = _changes$.parentFeatureId;
	        return {
	          typeName: typeName,
	          changedIds: changedIds,
	          assembly: assembly,
	          exonsToRestore: exonsToRestore,
	          parentFeatureId: parentFeatureId
	        };
	      }
	      return {
	        typeName: typeName,
	        changedIds: changedIds,
	        assembly: assembly,
	        changes: changes
	      };
	    }
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var featureModel, session, changes, _iterator, _step, change, exonsToRestore, parentFeatureId, topLevelFeature, parentFeature, _iterator2, _step2, _topLevelFeature$allI, exon, childIds;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              featureModel = backend.featureModel, session = backend.session;
	              changes = this.changes;
	              _iterator = _createForOfIteratorHelper(changes);
	              _context.prev = 3;
	              _iterator.s();
	            case 5:
	              if ((_step = _iterator.n()).done) {
	                _context.next = 25;
	                break;
	              }
	              change = _step.value;
	              exonsToRestore = change.exonsToRestore, parentFeatureId = change.parentFeatureId;
	              if (!(exonsToRestore.length !== 2)) {
	                _context.next = 10;
	                break;
	              }
	              throw new Error("Expected exactly two exons to restore. Got :".concat(exonsToRestore.length));
	            case 10:
	              _context.next = 12;
	              return featureModel.findOne({
	                allIds: parentFeatureId
	              }).session(session).exec();
	            case 12:
	              topLevelFeature = _context.sent;
	              if (topLevelFeature) {
	                _context.next = 15;
	                break;
	              }
	              throw new Error("Could not find feature with ID \"".concat(parentFeatureId, "\""));
	            case 15:
	              parentFeature = this.getFeatureFromId(topLevelFeature, parentFeatureId);
	              if (parentFeature) {
	                _context.next = 18;
	                break;
	              }
	              throw new Error("Could not find feature with ID \"".concat(parentFeatureId, "\" in feature \"").concat(topLevelFeature._id.toString(), "\""));
	            case 18:
	              if (!parentFeature.children) {
	                parentFeature.children = new Map();
	              }
	              _iterator2 = _createForOfIteratorHelper(exonsToRestore);
	              try {
	                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	                  exon = _step2.value;
	                  this.addChild(parentFeature, exon);
	                  childIds = this.getChildFeatureIds(exon);
	                  (_topLevelFeature$allI = topLevelFeature.allIds).push.apply(_topLevelFeature$allI, [exon._id].concat(_toConsumableArray(childIds)));
	                }
	              } catch (err) {
	                _iterator2.e(err);
	              } finally {
	                _iterator2.f();
	              }
	              _context.next = 23;
	              return topLevelFeature.save();
	            case 23:
	              _context.next = 5;
	              break;
	            case 25:
	              _context.next = 30;
	              break;
	            case 27:
	              _context.prev = 27;
	              _context.t0 = _context["catch"](3);
	              _iterator.e(_context.t0);
	            case 30:
	              _context.prev = 30;
	              _iterator.f();
	              return _context.finish(30);
	            case 33:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this, [[3, 27, 30, 33]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }()
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(dataStore) {
	        var changes, _iterator3, _step3, change, exonsToRestore, parentFeatureId, parentFeature, _iterator4, _step4, exon;
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              if (dataStore) {
	                _context3.next = 2;
	                break;
	              }
	              throw new Error('No data store');
	            case 2:
	              changes = this.changes;
	              _iterator3 = _createForOfIteratorHelper(changes);
	              _context3.prev = 4;
	              _iterator3.s();
	            case 6:
	              if ((_step3 = _iterator3.n()).done) {
	                _context3.next = 19;
	                break;
	              }
	              change = _step3.value;
	              exonsToRestore = change.exonsToRestore, parentFeatureId = change.parentFeatureId;
	              if (parentFeatureId) {
	                _context3.next = 11;
	                break;
	              }
	              throw new Error('Parent ID is missing');
	            case 11:
	              parentFeature = dataStore.getFeature(parentFeatureId);
	              if (parentFeature) {
	                _context3.next = 14;
	                break;
	              }
	              throw new Error("Could not find parent feature \"".concat(parentFeatureId, "\""));
	            case 14:
	              // create an ID for the parent feature if it does not have one
	              if (!parentFeature.attributes.get('_id')) {
	                parentFeature.setAttribute('_id', [parentFeature._id]);
	              }
	              _iterator4 = _createForOfIteratorHelper(exonsToRestore);
	              try {
	                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
	                  exon = _step4.value;
	                  parentFeature.addChild(exon);
	                }
	              } catch (err) {
	                _iterator4.e(err);
	              } finally {
	                _iterator4.f();
	              }
	            case 17:
	              _context3.next = 6;
	              break;
	            case 19:
	              _context3.next = 24;
	              break;
	            case 21:
	              _context3.prev = 21;
	              _context3.t0 = _context3["catch"](4);
	              _iterator3.e(_context3.t0);
	            case 24:
	              _context3.prev = 24;
	              _iterator3.f();
	              return _context3.finish(24);
	            case 27:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this, [[4, 21, 24, 27]]);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        logger = this.logger;
	      var inverseChangedIds = _toConsumableArray(changedIds).reverse();
	      var inverseChanges = _toConsumableArray(changes).reverse().map(function (undoMergeExonsChange) {
	        return {
	          firstExon: undoMergeExonsChange.exonsToRestore[0],
	          secondExon: undoMergeExonsChange.exonsToRestore[1],
	          parentFeatureId: undoMergeExonsChange.parentFeatureId
	        };
	      });
	      return new MergeExonsChange_1.MergeExonsChange({
	        changedIds: inverseChangedIds,
	        typeName: 'MergeExonsChange',
	        changes: inverseChanges,
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return UndoMergeExonsChange;
	}(common_1$b.FeatureChange);
	UndoMergeExonsChange$1.UndoMergeExonsChange = UndoMergeExonsChange;

	/* eslint-disable @typescript-eslint/require-await */
	/* eslint-disable @typescript-eslint/no-unsafe-assignment */
	Object.defineProperty(MergeExonsChange$1, "__esModule", {
	  value: true
	});
	MergeExonsChange$1.MergeExonsChange = void 0;
	var common_1$a = dist$1;
	var DeleteFeatureChange_1$3 = DeleteFeatureChange$1;
	var UndoMergeExonsChange_1 = UndoMergeExonsChange$1;
	var MergeExonsChange = /*#__PURE__*/function (_common_1$FeatureChan) {
	  _inherits(MergeExonsChange, _common_1$FeatureChan);
	  var _super = /*#__PURE__*/_createSuper(MergeExonsChange);
	  function MergeExonsChange(json, options) {
	    var _this;
	    _classCallCheck(this, MergeExonsChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'MergeExonsChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    return _this;
	  }
	  // eslint-disable-next-line @typescript-eslint/class-literal-property-style
	  _createClass(MergeExonsChange, [{
	    key: "notification",
	    get: function get() {
	      return 'Exons successfully merged';
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        typeName = this.typeName;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          _changes$ = _changes[0],
	          firstExon = _changes$.firstExon,
	          secondExon = _changes$.secondExon,
	          parentFeatureId = _changes$.parentFeatureId;
	        return {
	          typeName: typeName,
	          changedIds: changedIds,
	          assembly: assembly,
	          firstExon: firstExon,
	          secondExon: secondExon,
	          parentFeatureId: parentFeatureId
	        };
	      }
	      return {
	        typeName: typeName,
	        changedIds: changedIds,
	        assembly: assembly,
	        changes: changes
	      };
	    }
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var _this2 = this;
	        var featureModel, session, changes, logger, _iterator, _step, _loop;
	        return _regeneratorRuntime().wrap(function _callee$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              featureModel = backend.featureModel, session = backend.session;
	              changes = this.changes, logger = this.logger;
	              _iterator = _createForOfIteratorHelper(changes);
	              _context2.prev = 3;
	              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
	                var change, firstExon, secondExon, topLevelFeature, errMsg, mergedExon, _errMsg, deletedIds;
	                return _regeneratorRuntime().wrap(function _loop$(_context) {
	                  while (1) switch (_context.prev = _context.next) {
	                    case 0:
	                      change = _step.value;
	                      firstExon = change.firstExon, secondExon = change.secondExon;
	                      _context.next = 4;
	                      return featureModel.findOne({
	                        allIds: firstExon._id
	                      }).session(session).exec();
	                    case 4:
	                      topLevelFeature = _context.sent;
	                      if (topLevelFeature) {
	                        _context.next = 9;
	                        break;
	                      }
	                      errMsg = "*** ERROR: The following featureId was not found in database ='".concat(firstExon._id, "'");
	                      logger.error(errMsg);
	                      throw new Error(errMsg);
	                    case 9:
	                      mergedExon = _this2.getFeatureFromId(topLevelFeature, firstExon._id);
	                      if (mergedExon) {
	                        _context.next = 14;
	                        break;
	                      }
	                      _errMsg = 'ERROR when searching feature by featureId';
	                      logger.error(_errMsg);
	                      throw new Error(_errMsg);
	                    case 14:
	                      mergedExon.min = Math.min(firstExon.min, secondExon.min);
	                      mergedExon.max = Math.max(firstExon.max, secondExon.max);
	                      mergedExon.attributes = _this2.mergeAttributes(firstExon, secondExon);
	                      deletedIds = (0, DeleteFeatureChange_1$3.findAndDeleteChildFeature)(topLevelFeature, secondExon._id, _this2);
	                      deletedIds.push(secondExon._id);
	                      topLevelFeature.allIds = topLevelFeature.allIds.filter(function (id) {
	                        return !deletedIds.includes(id);
	                      });
	                      _context.next = 22;
	                      return topLevelFeature.save();
	                    case 22:
	                    case "end":
	                      return _context.stop();
	                  }
	                }, _loop);
	              });
	              _iterator.s();
	            case 6:
	              if ((_step = _iterator.n()).done) {
	                _context2.next = 10;
	                break;
	              }
	              return _context2.delegateYield(_loop(), "t0", 8);
	            case 8:
	              _context2.next = 6;
	              break;
	            case 10:
	              _context2.next = 15;
	              break;
	            case 12:
	              _context2.prev = 12;
	              _context2.t1 = _context2["catch"](3);
	              _iterator.e(_context2.t1);
	            case 15:
	              _context2.prev = 15;
	              _iterator.f();
	              return _context2.finish(15);
	            case 18:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee, this, [[3, 12, 15, 18]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }()
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(dataStore) {
	        var _iterator2, _step2, _mergedExon$parent, change, firstExon, secondExon, mergedExon, mergedAttrs, _i, _Object$keys, key;
	        return _regeneratorRuntime().wrap(function _callee3$(_context4) {
	          while (1) switch (_context4.prev = _context4.next) {
	            case 0:
	              if (dataStore) {
	                _context4.next = 2;
	                break;
	              }
	              throw new Error('No data store');
	            case 2:
	              _iterator2 = _createForOfIteratorHelper(this.changes);
	              _context4.prev = 3;
	              _iterator2.s();
	            case 5:
	              if ((_step2 = _iterator2.n()).done) {
	                _context4.next = 19;
	                break;
	              }
	              change = _step2.value;
	              firstExon = change.firstExon, secondExon = change.secondExon;
	              mergedExon = dataStore.getFeature(firstExon._id);
	              if (mergedExon) {
	                _context4.next = 11;
	                break;
	              }
	              throw new Error("Could not find feature with identifier \"".concat(firstExon._id, "\""));
	            case 11:
	              mergedExon.setMin(Math.min(firstExon.min, secondExon.min));
	              mergedExon.setMax(Math.max(firstExon.max, secondExon.max));
	              mergedAttrs = this.mergeAttributes(firstExon, secondExon);
	              mergedExon.setAttributes(new Map());
	              for (_i = 0, _Object$keys = Object.keys(mergedAttrs); _i < _Object$keys.length; _i++) {
	                key = _Object$keys[_i];
	                mergedExon.setAttribute(key, mergedAttrs[key]);
	              }
	              (_mergedExon$parent = mergedExon.parent) === null || _mergedExon$parent === void 0 || _mergedExon$parent.deleteChild(secondExon._id);
	            case 17:
	              _context4.next = 5;
	              break;
	            case 19:
	              _context4.next = 24;
	              break;
	            case 21:
	              _context4.prev = 21;
	              _context4.t0 = _context4["catch"](3);
	              _iterator2.e(_context4.t0);
	            case 24:
	              _context4.prev = 24;
	              _iterator2.f();
	              return _context4.finish(24);
	            case 27:
	            case "end":
	              return _context4.stop();
	          }
	        }, _callee3, this, [[3, 21, 24, 27]]);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var _logger$debug;
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        logger = this.logger;
	      var inverseChangedIds = _toConsumableArray(changedIds).reverse();
	      var inverseChanges = _toConsumableArray(changes).reverse().map(function (mergeExonChange) {
	        return {
	          exonsToRestore: [mergeExonChange.firstExon, mergeExonChange.secondExon],
	          parentFeatureId: mergeExonChange.parentFeatureId
	        };
	      });
	      (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, "INVERSE CHANGE '".concat(JSON.stringify(inverseChanges), "'"));
	      return new UndoMergeExonsChange_1.UndoMergeExonsChange({
	        changedIds: inverseChangedIds,
	        typeName: 'UndoMergeExonsChange',
	        changes: inverseChanges,
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }, {
	    key: "mergeAttributes",
	    value: function mergeAttributes(firstExon, secondExon) {
	      var mergedAttrs = {};
	      if (firstExon.attributes) {
	        // eslint-disable-next-line unicorn/prefer-structured-clone
	        mergedAttrs = JSON.parse(JSON.stringify(firstExon.attributes));
	      }
	      if (secondExon.attributes) {
	        // eslint-disable-next-line unicorn/prefer-structured-clone
	        var attrs = JSON.parse(JSON.stringify(secondExon.attributes));
	        var _loop2 = function _loop2() {
	          var key = _Object$keys2[_i2];
	          if (key === '_id' || key === 'gff_id') {
	            return 1; // continue
	          }
	          if (!Object.keys(mergedAttrs).includes(key)) {
	            mergedAttrs[key] = [];
	          }
	          attrs[key].map(function (x) {
	            if (!mergedAttrs[key].includes(x)) {
	              mergedAttrs[key].push(x);
	            }
	          });
	        };
	        for (var _i2 = 0, _Object$keys2 = Object.keys(attrs); _i2 < _Object$keys2.length; _i2++) {
	          if (_loop2()) continue;
	        }
	      }
	      return mergedAttrs;
	    }
	  }]);
	  return MergeExonsChange;
	}(common_1$a.FeatureChange);
	MergeExonsChange$1.MergeExonsChange = MergeExonsChange;

	var MergeTranscriptsChange$1 = {};

	var UndoMergeTranscriptsChange$1 = {};

	/* eslint-disable @typescript-eslint/require-await */
	Object.defineProperty(UndoMergeTranscriptsChange$1, "__esModule", {
	  value: true
	});
	UndoMergeTranscriptsChange$1.UndoMergeTranscriptsChange = void 0;
	var common_1$9 = dist$1;
	var MergeTranscriptsChange_1 = MergeTranscriptsChange$1;
	var UndoMergeTranscriptsChange = /*#__PURE__*/function (_common_1$FeatureChan) {
	  _inherits(UndoMergeTranscriptsChange, _common_1$FeatureChan);
	  var _super = /*#__PURE__*/_createSuper(UndoMergeTranscriptsChange);
	  function UndoMergeTranscriptsChange(json, options) {
	    var _this;
	    _classCallCheck(this, UndoMergeTranscriptsChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'UndoMergeTranscriptsChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    return _this;
	  }
	  _createClass(UndoMergeTranscriptsChange, [{
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        typeName = this.typeName;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          _changes$ = _changes[0],
	          transcriptsToRestore = _changes$.transcriptsToRestore,
	          parentFeatureId = _changes$.parentFeatureId;
	        return {
	          typeName: typeName,
	          changedIds: changedIds,
	          assembly: assembly,
	          transcriptsToRestore: transcriptsToRestore,
	          parentFeatureId: parentFeatureId
	        };
	      }
	      return {
	        typeName: typeName,
	        changedIds: changedIds,
	        assembly: assembly,
	        changes: changes
	      };
	    }
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var featureModel, session, changes, _iterator, _step, change, transcriptsToRestore, parentFeatureId, topLevelFeature, parentFeature, _iterator2, _step2, _topLevelFeature$allI, transcript, childIds;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              featureModel = backend.featureModel, session = backend.session;
	              changes = this.changes;
	              _iterator = _createForOfIteratorHelper(changes);
	              _context.prev = 3;
	              _iterator.s();
	            case 5:
	              if ((_step = _iterator.n()).done) {
	                _context.next = 25;
	                break;
	              }
	              change = _step.value;
	              transcriptsToRestore = change.transcriptsToRestore, parentFeatureId = change.parentFeatureId;
	              if (!(transcriptsToRestore.length !== 2)) {
	                _context.next = 10;
	                break;
	              }
	              throw new Error("Expected exactly two transcripts to restore. Got :".concat(transcriptsToRestore.length));
	            case 10:
	              _context.next = 12;
	              return featureModel.findOne({
	                allIds: parentFeatureId
	              }).session(session).exec();
	            case 12:
	              topLevelFeature = _context.sent;
	              if (topLevelFeature) {
	                _context.next = 15;
	                break;
	              }
	              throw new Error("Could not find feature with ID \"".concat(parentFeatureId, "\""));
	            case 15:
	              parentFeature = this.getFeatureFromId(topLevelFeature, parentFeatureId);
	              if (parentFeature) {
	                _context.next = 18;
	                break;
	              }
	              throw new Error("Could not find feature with ID \"".concat(parentFeatureId, "\" in feature \"").concat(topLevelFeature._id.toString(), "\""));
	            case 18:
	              if (!parentFeature.children) {
	                parentFeature.children = new Map();
	              }
	              _iterator2 = _createForOfIteratorHelper(transcriptsToRestore);
	              try {
	                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	                  transcript = _step2.value;
	                  this.addChild(parentFeature, transcript);
	                  childIds = this.getChildFeatureIds(transcript);
	                  (_topLevelFeature$allI = topLevelFeature.allIds).push.apply(_topLevelFeature$allI, [transcript._id].concat(_toConsumableArray(childIds)));
	                }
	              } catch (err) {
	                _iterator2.e(err);
	              } finally {
	                _iterator2.f();
	              }
	              _context.next = 23;
	              return topLevelFeature.save();
	            case 23:
	              _context.next = 5;
	              break;
	            case 25:
	              _context.next = 30;
	              break;
	            case 27:
	              _context.prev = 27;
	              _context.t0 = _context["catch"](3);
	              _iterator.e(_context.t0);
	            case 30:
	              _context.prev = 30;
	              _iterator.f();
	              return _context.finish(30);
	            case 33:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this, [[3, 27, 30, 33]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }()
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(dataStore) {
	        var changes, _iterator3, _step3, change, transcriptsToRestore, parentFeatureId, parentFeature, _iterator4, _step4, transcript;
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              if (dataStore) {
	                _context3.next = 2;
	                break;
	              }
	              throw new Error('No data store');
	            case 2:
	              changes = this.changes;
	              _iterator3 = _createForOfIteratorHelper(changes);
	              _context3.prev = 4;
	              _iterator3.s();
	            case 6:
	              if ((_step3 = _iterator3.n()).done) {
	                _context3.next = 19;
	                break;
	              }
	              change = _step3.value;
	              transcriptsToRestore = change.transcriptsToRestore, parentFeatureId = change.parentFeatureId;
	              if (parentFeatureId) {
	                _context3.next = 11;
	                break;
	              }
	              throw new Error('Parent ID is missing');
	            case 11:
	              parentFeature = dataStore.getFeature(parentFeatureId);
	              if (parentFeature) {
	                _context3.next = 14;
	                break;
	              }
	              throw new Error("Could not find parent feature \"".concat(parentFeatureId, "\""));
	            case 14:
	              // create an ID for the parent feature if it does not have one
	              if (!parentFeature.attributes.get('_id')) {
	                parentFeature.setAttribute('_id', [parentFeature._id]);
	              }
	              _iterator4 = _createForOfIteratorHelper(transcriptsToRestore);
	              try {
	                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
	                  transcript = _step4.value;
	                  parentFeature.addChild(transcript);
	                }
	              } catch (err) {
	                _iterator4.e(err);
	              } finally {
	                _iterator4.f();
	              }
	            case 17:
	              _context3.next = 6;
	              break;
	            case 19:
	              _context3.next = 24;
	              break;
	            case 21:
	              _context3.prev = 21;
	              _context3.t0 = _context3["catch"](4);
	              _iterator3.e(_context3.t0);
	            case 24:
	              _context3.prev = 24;
	              _iterator3.f();
	              return _context3.finish(24);
	            case 27:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this, [[4, 21, 24, 27]]);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        logger = this.logger;
	      var inverseChangedIds = _toConsumableArray(changedIds).reverse();
	      var inverseChanges = _toConsumableArray(changes).reverse().map(function (undoMergeTranscriptsChange) {
	        return {
	          firstTranscript: undoMergeTranscriptsChange.transcriptsToRestore[0],
	          secondTranscript: undoMergeTranscriptsChange.transcriptsToRestore[1],
	          parentFeatureId: undoMergeTranscriptsChange.parentFeatureId
	        };
	      });
	      return new MergeTranscriptsChange_1.MergeTranscriptsChange({
	        changedIds: inverseChangedIds,
	        typeName: 'MergeTranscriptsChange',
	        changes: inverseChanges,
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return UndoMergeTranscriptsChange;
	}(common_1$9.FeatureChange);
	UndoMergeTranscriptsChange$1.UndoMergeTranscriptsChange = UndoMergeTranscriptsChange;

	/* eslint-disable unicorn/prefer-structured-clone */
	/* eslint-disable @typescript-eslint/require-await */
	/* eslint-disable @typescript-eslint/no-unsafe-assignment */
	Object.defineProperty(MergeTranscriptsChange$1, "__esModule", {
	  value: true
	});
	MergeTranscriptsChange$1.MergeTranscriptsChange = void 0;
	var common_1$8 = dist$1;
	var util_1$2 = require$$1__default$1["default"];
	var DeleteFeatureChange_1$2 = DeleteFeatureChange$1;
	var UndoMergeTranscriptsChange_1 = UndoMergeTranscriptsChange$1;
	var MergeTranscriptsChange = /*#__PURE__*/function (_common_1$FeatureChan) {
	  _inherits(MergeTranscriptsChange, _common_1$FeatureChan);
	  var _super = /*#__PURE__*/_createSuper(MergeTranscriptsChange);
	  function MergeTranscriptsChange(json, options) {
	    var _this;
	    _classCallCheck(this, MergeTranscriptsChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'MergeTranscriptsChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    return _this;
	  }
	  _createClass(MergeTranscriptsChange, [{
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        typeName = this.typeName;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          _changes$ = _changes[0],
	          firstTranscript = _changes$.firstTranscript,
	          secondTranscript = _changes$.secondTranscript,
	          parentFeatureId = _changes$.parentFeatureId;
	        return {
	          typeName: typeName,
	          changedIds: changedIds,
	          assembly: assembly,
	          firstTranscript: firstTranscript,
	          secondTranscript: secondTranscript,
	          parentFeatureId: parentFeatureId
	        };
	      }
	      return {
	        typeName: typeName,
	        changedIds: changedIds,
	        assembly: assembly,
	        changes: changes
	      };
	    }
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var _this2 = this;
	        var featureModel, session, changes, logger, _iterator, _step, _loop;
	        return _regeneratorRuntime().wrap(function _callee$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              featureModel = backend.featureModel, session = backend.session;
	              changes = this.changes, logger = this.logger;
	              _iterator = _createForOfIteratorHelper(changes);
	              _context2.prev = 3;
	              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
	                var change, firstTranscript, secondTranscript, topLevelFeature, errMsg, mergedTranscript, _errMsg, deletedIds;
	                return _regeneratorRuntime().wrap(function _loop$(_context) {
	                  while (1) switch (_context.prev = _context.next) {
	                    case 0:
	                      change = _step.value;
	                      firstTranscript = change.firstTranscript, secondTranscript = change.secondTranscript;
	                      _context.next = 4;
	                      return featureModel.findOne({
	                        allIds: firstTranscript._id
	                      }).session(session).exec();
	                    case 4:
	                      topLevelFeature = _context.sent;
	                      if (topLevelFeature) {
	                        _context.next = 9;
	                        break;
	                      }
	                      errMsg = "*** ERROR: The following featureId was not found in database ='".concat(firstTranscript._id, "'");
	                      logger.error(errMsg);
	                      throw new Error(errMsg);
	                    case 9:
	                      mergedTranscript = _this2.getFeatureFromId(topLevelFeature, firstTranscript._id);
	                      if (mergedTranscript) {
	                        _context.next = 14;
	                        break;
	                      }
	                      _errMsg = 'ERROR when searching feature by featureId';
	                      logger.error(_errMsg);
	                      throw new Error(_errMsg);
	                    case 14:
	                      _this2.mergeTranscriptsOnServer(mergedTranscript, secondTranscript);
	                      deletedIds = (0, DeleteFeatureChange_1$2.findAndDeleteChildFeature)(topLevelFeature, secondTranscript._id, _this2);
	                      deletedIds.push(secondTranscript._id);
	                      topLevelFeature.allIds = topLevelFeature.allIds.filter(function (id) {
	                        return !deletedIds.includes(id);
	                      });
	                      _context.next = 20;
	                      return topLevelFeature.save();
	                    case 20:
	                    case "end":
	                      return _context.stop();
	                  }
	                }, _loop);
	              });
	              _iterator.s();
	            case 6:
	              if ((_step = _iterator.n()).done) {
	                _context2.next = 10;
	                break;
	              }
	              return _context2.delegateYield(_loop(), "t0", 8);
	            case 8:
	              _context2.next = 6;
	              break;
	            case 10:
	              _context2.next = 15;
	              break;
	            case 12:
	              _context2.prev = 12;
	              _context2.t1 = _context2["catch"](3);
	              _iterator.e(_context2.t1);
	            case 15:
	              _context2.prev = 15;
	              _iterator.f();
	              return _context2.finish(15);
	            case 18:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee, this, [[3, 12, 15, 18]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "mergeTranscriptsOnServer",
	    value: function mergeTranscriptsOnServer(firstTranscript, secondTranscript) {
	      firstTranscript.min = Math.min(firstTranscript.min, secondTranscript.min);
	      firstTranscript.max = Math.max(firstTranscript.max, secondTranscript.max);
	      this.mergeTranscriptAttributes(firstTranscript, secondTranscript);
	      if (secondTranscript.children) {
	        for (var _i = 0, _Object$entries = Object.entries(secondTranscript.children); _i < _Object$entries.length; _i++) {
	          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
	            secondFeatureChild = _Object$entries$_i[1];
	          this.mergeFeatureIntoTranscriptOnServer(secondFeatureChild, firstTranscript);
	        }
	      }
	    }
	  }, {
	    key: "mergeFeatureIntoTranscriptOnServer",
	    value: function mergeFeatureIntoTranscriptOnServer(secondFeatureChild, firstTranscript) {
	      var _this3 = this;
	      if (!firstTranscript.children) {
	        firstTranscript.children = new Map();
	      }
	      var merged = false;
	      var mrgChild;
	      var _iterator2 = _createForOfIteratorHelper(firstTranscript.children),
	        _step2;
	      try {
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          var _step2$value = _slicedToArray(_step2.value, 2),
	            fKey = _step2$value[0],
	            firstFeatureChild = _step2$value[1];
	          if (!merged || !mrgChild) {
	            mrgChild = firstFeatureChild;
	          }
	          if (mrgChild.type === secondFeatureChild.type && mrgChild.type === firstFeatureChild.type && (0, util_1$2.doesIntersect2)(secondFeatureChild.min, secondFeatureChild.max, mrgChild.min, mrgChild.max) && (0, util_1$2.doesIntersect2)(firstFeatureChild.min, firstFeatureChild.max, mrgChild.min, mrgChild.max)) {
	            mrgChild.min = Math.min(secondFeatureChild.min, mrgChild.min, firstFeatureChild.min);
	            mrgChild.max = Math.max(secondFeatureChild.max, mrgChild.max, firstFeatureChild.max);
	            var mergedAttrs = this.mergeAttributes(mrgChild, secondFeatureChild);
	            mrgChild.attributes = mergedAttrs;
	            firstTranscript.children["delete"](fKey);
	            merged = true;
	          }
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }
	      if (merged && mrgChild && secondFeatureChild.children) {
	        // Add the children of the source feature
	        // (secondFeatureChild.children) to the merged feature (mrgChild)
	        Object.entries(secondFeatureChild.children).map(function (_ref) {
	          var _ref2 = _slicedToArray(_ref, 2),
	            child = _ref2[1];
	          _this3.addChild(mrgChild, child);
	        });
	      }
	      if (merged && mrgChild) {
	        this.addChild(firstTranscript, mrgChild);
	      } else {
	        // This secondFeatureChild has no overlap with any feature in the
	        // receiving transcript so we add it as it is to the receiving transcript
	        this.addChild(firstTranscript, secondFeatureChild);
	      }
	    }
	    /* --------------------------------- */
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(dataStore) {
	        var _iterator3, _step3, _mergedTranscript$par, _step3$value, idx, changedId, _this$changes$idx, firstTranscript, secondTranscript, mergedTranscript;
	        return _regeneratorRuntime().wrap(function _callee2$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              if (dataStore) {
	                _context3.next = 2;
	                break;
	              }
	              throw new Error('No data store');
	            case 2:
	              _iterator3 = _createForOfIteratorHelper(this.changedIds.entries());
	              _context3.prev = 3;
	              _iterator3.s();
	            case 5:
	              if ((_step3 = _iterator3.n()).done) {
	                _context3.next = 15;
	                break;
	              }
	              _step3$value = _slicedToArray(_step3.value, 2), idx = _step3$value[0], changedId = _step3$value[1];
	              _this$changes$idx = this.changes[idx], firstTranscript = _this$changes$idx.firstTranscript, secondTranscript = _this$changes$idx.secondTranscript;
	              mergedTranscript = dataStore.getFeature(firstTranscript._id);
	              if (mergedTranscript) {
	                _context3.next = 11;
	                break;
	              }
	              throw new Error("Could not find feature with identifier \"".concat(changedId, "\""));
	            case 11:
	              this.mergeTranscriptsOnClient(mergedTranscript, secondTranscript);
	              (_mergedTranscript$par = mergedTranscript.parent) === null || _mergedTranscript$par === void 0 || _mergedTranscript$par.deleteChild(secondTranscript._id);
	            case 13:
	              _context3.next = 5;
	              break;
	            case 15:
	              _context3.next = 20;
	              break;
	            case 17:
	              _context3.prev = 17;
	              _context3.t0 = _context3["catch"](3);
	              _iterator3.e(_context3.t0);
	            case 20:
	              _context3.prev = 20;
	              _iterator3.f();
	              return _context3.finish(20);
	            case 23:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee2, this, [[3, 17, 20, 23]]);
	      }));
	      function executeOnClient(_x2) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "mergeTranscriptsOnClient",
	    value: function mergeTranscriptsOnClient(firstTranscript, secondTranscript) {
	      firstTranscript.setMin(Math.min(firstTranscript.min, secondTranscript.min));
	      firstTranscript.setMax(Math.max(firstTranscript.max, secondTranscript.max));
	      this.mergeTranscriptAttributes(firstTranscript, secondTranscript);
	      if (secondTranscript.children) {
	        for (var _i2 = 0, _Object$entries2 = Object.entries(secondTranscript.children); _i2 < _Object$entries2.length; _i2++) {
	          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
	            secondFeatureChild = _Object$entries2$_i[1];
	          this.mergeFeatureIntoTranscriptOnClient(secondFeatureChild, firstTranscript);
	        }
	      }
	    }
	  }, {
	    key: "mergeFeatureIntoTranscriptOnClient",
	    value: function mergeFeatureIntoTranscriptOnClient(secondFeatureChild, firstTranscript) {
	      if (!firstTranscript.children) {
	        firstTranscript.children = new Map();
	      }
	      var merged = false;
	      var mrgChild;
	      var toDelete;
	      var _iterator4 = _createForOfIteratorHelper(firstTranscript.children),
	        _step4;
	      try {
	        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
	          var _step4$value = _slicedToArray(_step4.value, 2),
	            firstFeatureChild = _step4$value[1];
	          if (!merged || !mrgChild) {
	            toDelete = false;
	            mrgChild = firstFeatureChild;
	          } else {
	            toDelete = true;
	          }
	          if (mrgChild.type === secondFeatureChild.type && mrgChild.type === firstFeatureChild.type && (0, util_1$2.doesIntersect2)(secondFeatureChild.min, secondFeatureChild.max, mrgChild.min, mrgChild.max) && (0, util_1$2.doesIntersect2)(firstFeatureChild.min, firstFeatureChild.max, mrgChild.min, mrgChild.max)) {
	            mrgChild.setMin(Math.min(secondFeatureChild.min, mrgChild.min, firstFeatureChild.min));
	            mrgChild.setMax(Math.max(secondFeatureChild.max, mrgChild.max, firstFeatureChild.max));
	            var mergedAttrs = this.mergeAttributes(mrgChild, secondFeatureChild);
	            Object.entries(mergedAttrs).map(function (_ref5) {
	              var _ref6 = _slicedToArray(_ref5, 2),
	                key = _ref6[0],
	                value = _ref6[1];
	              if (mrgChild) {
	                mrgChild.setAttribute(key, value);
	              }
	            });
	            if (toDelete) {
	              firstTranscript.deleteChild(firstFeatureChild._id);
	            }
	            merged = true;
	          }
	        }
	      } catch (err) {
	        _iterator4.e(err);
	      } finally {
	        _iterator4.f();
	      }
	      if (merged && mrgChild && secondFeatureChild.children) {
	        Object.entries(secondFeatureChild.children).map(function (_ref3) {
	          var _ref4 = _slicedToArray(_ref3, 2),
	            child = _ref4[1];
	          mrgChild.addChild(child);
	        });
	      }
	      if (!(merged && mrgChild)) {
	        // This secondFeatureChild has no overlap with any feature in the
	        // receiving transcript so we add it as it is to the receiving transcript
	        firstTranscript.addChild(secondFeatureChild);
	      }
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	  }, {
	    key: "isAnnotationFeature",
	    value: function isAnnotationFeature(obj) {
	      return (
	        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	        typeof obj.setMin === 'function' &&
	        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	        typeof obj.setMax === 'function' &&
	        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	        typeof obj.addChild === 'function' &&
	        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	        typeof obj.deleteChild === 'function'
	      );
	    }
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_backend) {
	        return _regeneratorRuntime().wrap(function _callee3$(_context4) {
	          while (1) switch (_context4.prev = _context4.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context4.stop();
	          }
	        }, _callee3);
	      }));
	      function executeOnLocalGFF3(_x3) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }() /* Merge attributes from source into destination */
	  }, {
	    key: "mergeAttributes",
	    value: function mergeAttributes(destination, source) {
	      var destAttrs = destination.attributes ? JSON.parse(JSON.stringify(destination.attributes)) : {};
	      if (source.attributes) {
	        var sourceAttrs = JSON.parse(JSON.stringify(source.attributes));
	        Object.entries(sourceAttrs).map(function (_ref7) {
	          var _ref8 = _slicedToArray(_ref7, 2),
	            key = _ref8[0],
	            value = _ref8[1];
	          if (!(key in destAttrs)) {
	            destAttrs[key] = [];
	          }
	          value.map(function (x) {
	            if (!destAttrs[key].includes(x)) {
	              destAttrs[key].push(x);
	            }
	          });
	        });
	      }
	      return destAttrs;
	    }
	  }, {
	    key: "mergeTranscriptAttributes",
	    value: function mergeTranscriptAttributes(firstTranscript, secondTranscript) {
	      var txAttrs = this.mergeAttributes(firstTranscript, secondTranscript);
	      if (this.isAnnotationFeature(firstTranscript)) {
	        Object.entries(txAttrs).map(function (_ref9) {
	          var _ref10 = _slicedToArray(_ref9, 2),
	            key = _ref10[0],
	            value = _ref10[1];
	          firstTranscript.setAttribute(key, value);
	        });
	      } else {
	        firstTranscript.attributes = txAttrs;
	      }
	    }
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var _logger$debug;
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        logger = this.logger;
	      var inverseChangedIds = _toConsumableArray(changedIds).reverse();
	      var inverseChanges = _toConsumableArray(changes).reverse().map(function (mergeTranscriptChange) {
	        return {
	          transcriptsToRestore: [mergeTranscriptChange.firstTranscript, mergeTranscriptChange.secondTranscript],
	          parentFeatureId: mergeTranscriptChange.parentFeatureId
	        };
	      });
	      (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, "INVERSE CHANGE '".concat(JSON.stringify(inverseChanges), "'"));
	      return new UndoMergeTranscriptsChange_1.UndoMergeTranscriptsChange({
	        changedIds: inverseChangedIds,
	        typeName: 'UndoMergeTranscriptsChange',
	        changes: inverseChanges,
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return MergeTranscriptsChange;
	}(common_1$8.FeatureChange);
	MergeTranscriptsChange$1.MergeTranscriptsChange = MergeTranscriptsChange;

	var SplitExonChange$1 = {};

	var UndoSplitExonChange$1 = {};

	/* eslint-disable @typescript-eslint/require-await */
	Object.defineProperty(UndoSplitExonChange$1, "__esModule", {
	  value: true
	});
	UndoSplitExonChange$1.UndoSplitExonChange = void 0;
	var common_1$7 = dist$1;
	var DeleteFeatureChange_1$1 = DeleteFeatureChange$1;
	var SplitExonChange_1 = SplitExonChange$1;
	var UndoSplitExonChange = /*#__PURE__*/function (_common_1$FeatureChan) {
	  _inherits(UndoSplitExonChange, _common_1$FeatureChan);
	  var _super = /*#__PURE__*/_createSuper(UndoSplitExonChange);
	  function UndoSplitExonChange(json, options) {
	    var _this;
	    _classCallCheck(this, UndoSplitExonChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'UndoSplitExonChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    return _this;
	  }
	  _createClass(UndoSplitExonChange, [{
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        typeName = this.typeName;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          _changes$ = _changes[0],
	          exonToRestore = _changes$.exonToRestore,
	          parentFeatureId = _changes$.parentFeatureId,
	          idsToDelete = _changes$.idsToDelete,
	          upstreamCut = _changes$.upstreamCut,
	          downstreamCut = _changes$.downstreamCut,
	          leftExonId = _changes$.leftExonId,
	          rightExonId = _changes$.rightExonId;
	        return {
	          typeName: typeName,
	          changedIds: changedIds,
	          assembly: assembly,
	          exonToRestore: exonToRestore,
	          parentFeatureId: parentFeatureId,
	          idsToDelete: idsToDelete,
	          upstreamCut: upstreamCut,
	          downstreamCut: downstreamCut,
	          leftExonId: leftExonId,
	          rightExonId: rightExonId
	        };
	      }
	      return {
	        typeName: typeName,
	        changedIds: changedIds,
	        assembly: assembly,
	        changes: changes
	      };
	    }
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var _this2 = this;
	        var featureModel, session, changes, _iterator, _step, _loop;
	        return _regeneratorRuntime().wrap(function _callee$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              featureModel = backend.featureModel, session = backend.session;
	              changes = this.changes;
	              _iterator = _createForOfIteratorHelper(changes);
	              _context2.prev = 3;
	              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
	                var _topLevelFeature$allI;
	                var change, exonToRestore, parentFeatureId, idsToDelete, topLevelFeature, parentFeature, childIds;
	                return _regeneratorRuntime().wrap(function _loop$(_context) {
	                  while (1) switch (_context.prev = _context.next) {
	                    case 0:
	                      change = _step.value;
	                      exonToRestore = change.exonToRestore, parentFeatureId = change.parentFeatureId, idsToDelete = change.idsToDelete;
	                      _context.next = 4;
	                      return featureModel.findOne({
	                        allIds: parentFeatureId
	                      }).session(session).exec();
	                    case 4:
	                      topLevelFeature = _context.sent;
	                      if (topLevelFeature) {
	                        _context.next = 7;
	                        break;
	                      }
	                      throw new Error("Could not find feature with ID \"".concat(parentFeatureId, "\""));
	                    case 7:
	                      parentFeature = _this2.getFeatureFromId(topLevelFeature, parentFeatureId);
	                      if (parentFeature) {
	                        _context.next = 10;
	                        break;
	                      }
	                      throw new Error("Could not find feature with ID \"".concat(parentFeatureId, "\" in feature \"").concat(topLevelFeature._id.toString(), "\""));
	                    case 10:
	                      if (!parentFeature.children) {
	                        parentFeature.children = new Map();
	                      }
	                      _this2.addChild(parentFeature, exonToRestore);
	                      childIds = _this2.getChildFeatureIds(exonToRestore);
	                      (_topLevelFeature$allI = topLevelFeature.allIds).push.apply(_topLevelFeature$allI, [exonToRestore._id].concat(_toConsumableArray(childIds)));
	                      topLevelFeature.allIds = topLevelFeature.allIds.filter(function (id) {
	                        return !idsToDelete.includes(id);
	                      });
	                      idsToDelete.map(function (id) {
	                        return (0, DeleteFeatureChange_1$1.findAndDeleteChildFeature)(topLevelFeature, id, _this2);
	                      });
	                      _context.next = 18;
	                      return topLevelFeature.save();
	                    case 18:
	                    case "end":
	                      return _context.stop();
	                  }
	                }, _loop);
	              });
	              _iterator.s();
	            case 6:
	              if ((_step = _iterator.n()).done) {
	                _context2.next = 10;
	                break;
	              }
	              return _context2.delegateYield(_loop(), "t0", 8);
	            case 8:
	              _context2.next = 6;
	              break;
	            case 10:
	              _context2.next = 15;
	              break;
	            case 12:
	              _context2.prev = 12;
	              _context2.t1 = _context2["catch"](3);
	              _iterator.e(_context2.t1);
	            case 15:
	              _context2.prev = 15;
	              _iterator.f();
	              return _context2.finish(15);
	            case 18:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee, this, [[3, 12, 15, 18]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }()
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(dataStore) {
	        var changes, _iterator2, _step2, _loop2;
	        return _regeneratorRuntime().wrap(function _callee3$(_context5) {
	          while (1) switch (_context5.prev = _context5.next) {
	            case 0:
	              if (dataStore) {
	                _context5.next = 2;
	                break;
	              }
	              throw new Error('No data store');
	            case 2:
	              changes = this.changes;
	              _iterator2 = _createForOfIteratorHelper(changes);
	              _context5.prev = 4;
	              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {
	                var change, exonToRestore, parentFeatureId, idsToDelete, parentFeature;
	                return _regeneratorRuntime().wrap(function _loop2$(_context4) {
	                  while (1) switch (_context4.prev = _context4.next) {
	                    case 0:
	                      change = _step2.value;
	                      exonToRestore = change.exonToRestore, parentFeatureId = change.parentFeatureId, idsToDelete = change.idsToDelete;
	                      if (parentFeatureId) {
	                        _context4.next = 4;
	                        break;
	                      }
	                      throw new Error('Parent ID is missing');
	                    case 4:
	                      parentFeature = dataStore.getFeature(parentFeatureId);
	                      if (parentFeature) {
	                        _context4.next = 7;
	                        break;
	                      }
	                      throw new Error("Could not find parent feature \"".concat(parentFeatureId, "\""));
	                    case 7:
	                      // create an ID for the parent feature if it does not have one
	                      if (!parentFeature.attributes.get('_id')) {
	                        parentFeature.setAttribute('_id', [parentFeature._id]);
	                      }
	                      parentFeature.addChild(exonToRestore);
	                      idsToDelete.map(function (id) {
	                        parentFeature.deleteChild(id);
	                      });
	                    case 10:
	                    case "end":
	                      return _context4.stop();
	                  }
	                }, _loop2);
	              });
	              _iterator2.s();
	            case 7:
	              if ((_step2 = _iterator2.n()).done) {
	                _context5.next = 11;
	                break;
	              }
	              return _context5.delegateYield(_loop2(), "t0", 9);
	            case 9:
	              _context5.next = 7;
	              break;
	            case 11:
	              _context5.next = 16;
	              break;
	            case 13:
	              _context5.prev = 13;
	              _context5.t1 = _context5["catch"](4);
	              _iterator2.e(_context5.t1);
	            case 16:
	              _context5.prev = 16;
	              _iterator2.f();
	              return _context5.finish(16);
	            case 19:
	            case "end":
	              return _context5.stop();
	          }
	        }, _callee3, this, [[4, 13, 16, 19]]);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        logger = this.logger;
	      var inverseChangedIds = _toConsumableArray(changedIds).reverse();
	      var inverseChanges = _toConsumableArray(changes).reverse().map(function (undoSplitExonChange) {
	        return {
	          parentFeatureId: undoSplitExonChange.parentFeatureId,
	          exonToBeSplit: undoSplitExonChange.exonToRestore,
	          upstreamCut: undoSplitExonChange.upstreamCut,
	          downstreamCut: undoSplitExonChange.downstreamCut,
	          leftExonId: undoSplitExonChange.leftExonId,
	          rightExonId: undoSplitExonChange.rightExonId
	        };
	      });
	      return new SplitExonChange_1.SplitExonChange({
	        changedIds: inverseChangedIds,
	        typeName: 'SplitExonChange',
	        changes: inverseChanges,
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return UndoSplitExonChange;
	}(common_1$7.FeatureChange);
	UndoSplitExonChange$1.UndoSplitExonChange = UndoSplitExonChange;

	/* eslint-disable @typescript-eslint/require-await */
	/* eslint-disable @typescript-eslint/no-unsafe-assignment */
	Object.defineProperty(SplitExonChange$1, "__esModule", {
	  value: true
	});
	SplitExonChange$1.SplitExonChange = void 0;
	var common_1$6 = dist$1;
	var DeleteFeatureChange_1 = DeleteFeatureChange$1;
	var UndoSplitExonChange_1 = UndoSplitExonChange$1;
	var SplitExonChange = /*#__PURE__*/function (_common_1$FeatureChan) {
	  _inherits(SplitExonChange, _common_1$FeatureChan);
	  var _super = /*#__PURE__*/_createSuper(SplitExonChange);
	  function SplitExonChange(json, options) {
	    var _this;
	    _classCallCheck(this, SplitExonChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'SplitExonChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    return _this;
	  }
	  // eslint-disable-next-line @typescript-eslint/class-literal-property-style
	  _createClass(SplitExonChange, [{
	    key: "notification",
	    get: function get() {
	      return 'Exon successfully split';
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        typeName = this.typeName;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          _changes$ = _changes[0],
	          exonToBeSplit = _changes$.exonToBeSplit,
	          parentFeatureId = _changes$.parentFeatureId,
	          upstreamCut = _changes$.upstreamCut,
	          downstreamCut = _changes$.downstreamCut,
	          leftExonId = _changes$.leftExonId,
	          rightExonId = _changes$.rightExonId;
	        return {
	          typeName: typeName,
	          changedIds: changedIds,
	          assembly: assembly,
	          exonToBeSplit: exonToBeSplit,
	          parentFeatureId: parentFeatureId,
	          upstreamCut: upstreamCut,
	          downstreamCut: downstreamCut,
	          leftExonId: leftExonId,
	          rightExonId: rightExonId
	        };
	      }
	      return {
	        typeName: typeName,
	        changedIds: changedIds,
	        assembly: assembly,
	        changes: changes
	      };
	    }
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var _this2 = this;
	        var featureModel, session, changes, logger, _iterator, _step, _loop;
	        return _regeneratorRuntime().wrap(function _callee$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              featureModel = backend.featureModel, session = backend.session;
	              changes = this.changes, logger = this.logger;
	              _iterator = _createForOfIteratorHelper(changes);
	              _context2.prev = 3;
	              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
	                var change, exonToBeSplit, parentFeatureId, upstreamCut, downstreamCut, leftExonId, rightExonId, topLevelFeature, errMsg, tx, _this2$makeSplitExons, _this2$makeSplitExons2, leftExon, rightExon, deletedIds;
	                return _regeneratorRuntime().wrap(function _loop$(_context) {
	                  while (1) switch (_context.prev = _context.next) {
	                    case 0:
	                      change = _step.value;
	                      exonToBeSplit = change.exonToBeSplit, parentFeatureId = change.parentFeatureId, upstreamCut = change.upstreamCut, downstreamCut = change.downstreamCut, leftExonId = change.leftExonId, rightExonId = change.rightExonId;
	                      _context.next = 4;
	                      return featureModel.findOne({
	                        allIds: exonToBeSplit._id
	                      }).session(session).exec();
	                    case 4:
	                      topLevelFeature = _context.sent;
	                      if (topLevelFeature) {
	                        _context.next = 9;
	                        break;
	                      }
	                      errMsg = "*** ERROR: The following featureId was not found in database ='".concat(exonToBeSplit._id, "'");
	                      logger.error(errMsg);
	                      throw new Error(errMsg);
	                    case 9:
	                      tx = _this2.getFeatureFromId(topLevelFeature, parentFeatureId);
	                      if (tx !== null && tx !== void 0 && tx.children) {
	                        _context.next = 12;
	                        break;
	                      }
	                      throw new Error('ERROR: There should be at least one child (i.e. the exon to be split)');
	                    case 12:
	                      _this2$makeSplitExons = _this2.makeSplitExons(exonToBeSplit, upstreamCut, downstreamCut, leftExonId, rightExonId), _this2$makeSplitExons2 = _slicedToArray(_this2$makeSplitExons, 2), leftExon = _this2$makeSplitExons2[0], rightExon = _this2$makeSplitExons2[1];
	                      tx.children.set(leftExon._id, _objectSpread2(_objectSpread2({
	                        allIds: []
	                      }, leftExon), {}, {
	                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
	                        // @ts-expect-error
	                        _id: leftExon._id
	                      }));
	                      tx.children.set(rightExon._id, _objectSpread2(_objectSpread2({
	                        allIds: []
	                      }, rightExon), {}, {
	                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
	                        // @ts-expect-error
	                        _id: rightExon._id
	                      }));
	                      // Child features should be sorted for click and drag of gene glyphs to work properly
	                      tx.children = new Map(_toConsumableArray(tx.children.entries()).sort(function (a, b) {
	                        return a[1].min - b[1].min;
	                      }));
	                      deletedIds = (0, DeleteFeatureChange_1.findAndDeleteChildFeature)(topLevelFeature, exonToBeSplit._id, _this2);
	                      deletedIds.push(exonToBeSplit._id);
	                      topLevelFeature.allIds = topLevelFeature.allIds.filter(function (id) {
	                        return !deletedIds.includes(id);
	                      });
	                      topLevelFeature.allIds.push(leftExon._id, rightExon._id);
	                      _context.next = 22;
	                      return topLevelFeature.save();
	                    case 22:
	                    case "end":
	                      return _context.stop();
	                  }
	                }, _loop);
	              });
	              _iterator.s();
	            case 6:
	              if ((_step = _iterator.n()).done) {
	                _context2.next = 10;
	                break;
	              }
	              return _context2.delegateYield(_loop(), "t0", 8);
	            case 8:
	              _context2.next = 6;
	              break;
	            case 10:
	              _context2.next = 15;
	              break;
	            case 12:
	              _context2.prev = 12;
	              _context2.t1 = _context2["catch"](3);
	              _iterator.e(_context2.t1);
	            case 15:
	              _context2.prev = 15;
	              _iterator.f();
	              return _context2.finish(15);
	            case 18:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee, this, [[3, 12, 15, 18]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }()
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(dataStore) {
	        var _iterator2, _step2, _step2$value, idx, _this$changes$idx, exonToBeSplit, parentFeatureId, upstreamCut, downstreamCut, leftExonId, rightExonId, _this$makeSplitExons, _this$makeSplitExons2, leftExon, rightExon, parentFeature;
	        return _regeneratorRuntime().wrap(function _callee3$(_context4) {
	          while (1) switch (_context4.prev = _context4.next) {
	            case 0:
	              if (dataStore) {
	                _context4.next = 2;
	                break;
	              }
	              throw new Error('No data store');
	            case 2:
	              _iterator2 = _createForOfIteratorHelper(this.changedIds.entries());
	              _context4.prev = 3;
	              _iterator2.s();
	            case 5:
	              if ((_step2 = _iterator2.n()).done) {
	                _context4.next = 19;
	                break;
	              }
	              _step2$value = _slicedToArray(_step2.value, 1), idx = _step2$value[0];
	              _this$changes$idx = this.changes[idx], exonToBeSplit = _this$changes$idx.exonToBeSplit, parentFeatureId = _this$changes$idx.parentFeatureId, upstreamCut = _this$changes$idx.upstreamCut, downstreamCut = _this$changes$idx.downstreamCut, leftExonId = _this$changes$idx.leftExonId, rightExonId = _this$changes$idx.rightExonId;
	              if (parentFeatureId) {
	                _context4.next = 10;
	                break;
	              }
	              throw new Error('TODO: Split exon without parent');
	            case 10:
	              _this$makeSplitExons = this.makeSplitExons(exonToBeSplit, upstreamCut, downstreamCut, leftExonId, rightExonId), _this$makeSplitExons2 = _slicedToArray(_this$makeSplitExons, 2), leftExon = _this$makeSplitExons2[0], rightExon = _this$makeSplitExons2[1];
	              parentFeature = dataStore.getFeature(parentFeatureId);
	              if (parentFeature) {
	                _context4.next = 14;
	                break;
	              }
	              throw new Error("Could not find parent feature \"".concat(parentFeatureId, "\""));
	            case 14:
	              parentFeature.addChild(leftExon);
	              parentFeature.addChild(rightExon);
	              if (dataStore.getFeature(exonToBeSplit._id)) {
	                dataStore.deleteFeature(exonToBeSplit._id);
	              }
	            case 17:
	              _context4.next = 5;
	              break;
	            case 19:
	              _context4.next = 24;
	              break;
	            case 21:
	              _context4.prev = 21;
	              _context4.t0 = _context4["catch"](3);
	              _iterator2.e(_context4.t0);
	            case 24:
	              _context4.prev = 24;
	              _iterator2.f();
	              return _context4.finish(24);
	            case 27:
	            case "end":
	              return _context4.stop();
	          }
	        }, _callee3, this, [[3, 21, 24, 27]]);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var _logger$debug;
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        logger = this.logger;
	      var inverseChangedIds = _toConsumableArray(changedIds).reverse();
	      var inverseChanges = _toConsumableArray(changes).reverse().map(function (splitExonChange) {
	        return {
	          exonToRestore: splitExonChange.exonToBeSplit,
	          parentFeatureId: splitExonChange.parentFeatureId,
	          idsToDelete: [splitExonChange.leftExonId, splitExonChange.rightExonId],
	          upstreamCut: splitExonChange.upstreamCut,
	          downstreamCut: splitExonChange.downstreamCut,
	          leftExonId: splitExonChange.leftExonId,
	          rightExonId: splitExonChange.rightExonId
	        };
	      });
	      (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, "INVERSE CHANGE '".concat(JSON.stringify(inverseChanges), "'"));
	      return new UndoSplitExonChange_1.UndoSplitExonChange({
	        changedIds: inverseChangedIds,
	        typeName: 'UndoSplitExonChange',
	        changes: inverseChanges,
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }, {
	    key: "makeSplitExons",
	    value: function makeSplitExons(exonToBeSplit, upstreamCut, downstreamCut, leftExonId, rightExonId) {
	      // eslint-disable-next-line unicorn/prefer-structured-clone
	      var exon = JSON.parse(JSON.stringify(exonToBeSplit));
	      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	      delete exon.attributes._id;
	      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	      delete exon.attributes.gff_id;
	      var leftExon = structuredClone(exon);
	      leftExon._id = leftExonId;
	      leftExon.max = upstreamCut;
	      var rightExon = structuredClone(exon);
	      rightExon.min = downstreamCut;
	      rightExon._id = rightExonId;
	      return [leftExon, rightExon];
	    }
	  }]);
	  return SplitExonChange;
	}(common_1$6.FeatureChange);
	SplitExonChange$1.SplitExonChange = SplitExonChange;

	var StrandChange$1 = {};

	Object.defineProperty(StrandChange$1, "__esModule", {
	  value: true
	});
	StrandChange$1.StrandChange = void 0;
	/* eslint-disable @typescript-eslint/restrict-template-expressions */
	/* eslint-disable @typescript-eslint/require-await */
	/* eslint-disable @typescript-eslint/no-unnecessary-condition */
	var common_1$5 = dist$1;
	var StrandChange = /*#__PURE__*/function (_common_1$FeatureChan) {
	  _inherits(StrandChange, _common_1$FeatureChan);
	  var _super = /*#__PURE__*/_createSuper(StrandChange);
	  function StrandChange(json, options) {
	    var _this;
	    _classCallCheck(this, StrandChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'StrandChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    return _this;
	  }
	  _createClass(StrandChange, [{
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        typeName = this.typeName;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          _changes$ = _changes[0],
	          featureId = _changes$.featureId,
	          newStrand = _changes$.newStrand,
	          oldStrand = _changes$.oldStrand;
	        return {
	          typeName: typeName,
	          changedIds: changedIds,
	          assembly: assembly,
	          featureId: featureId,
	          oldStrand: oldStrand,
	          newStrand: newStrand
	        };
	      }
	      return {
	        typeName: typeName,
	        changedIds: changedIds,
	        assembly: assembly,
	        changes: changes
	      };
	    }
	    /**
	     * Applies the required change to database
	     * @param backend - parameters from backend
	     * @returns
	     */
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var featureModel, session, changes, logger, featuresForChanges, _iterator, _step, _logger$debug, _logger$debug2, entry, featureId, oldStrand, topLevelFeature, errMsg, foundFeature, _errMsg, _errMsg2, _iterator2, _step2, _logger$debug4, _step2$value, idx, change, newStrand, _featuresForChanges$i, feature, _topLevelFeature, _logger$debug3;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              featureModel = backend.featureModel, session = backend.session;
	              changes = this.changes, logger = this.logger;
	              featuresForChanges = []; // Let's first check that all features are found and those old values match with expected ones. We do this just to be sure that all changes can be done.
	              _iterator = _createForOfIteratorHelper(changes);
	              _context.prev = 4;
	              _iterator.s();
	            case 6:
	              if ((_step = _iterator.n()).done) {
	                _context.next = 30;
	                break;
	              }
	              entry = _step.value;
	              featureId = entry.featureId, oldStrand = entry.oldStrand; // Search correct feature
	              _context.next = 11;
	              return featureModel.findOne({
	                allIds: featureId
	              }).session(session).exec();
	            case 11:
	              topLevelFeature = _context.sent;
	              if (topLevelFeature) {
	                _context.next = 16;
	                break;
	              }
	              errMsg = "*** ERROR: The following featureId was not found in database ='".concat(featureId, "'");
	              logger.error(errMsg);
	              throw new Error(errMsg);
	            case 16:
	              (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, "*** Feature found: ".concat(JSON.stringify(topLevelFeature)));
	              foundFeature = this.getFeatureFromId(topLevelFeature, featureId);
	              if (foundFeature) {
	                _context.next = 22;
	                break;
	              }
	              _errMsg = 'ERROR when searching feature by featureId';
	              logger.error(_errMsg);
	              throw new Error(_errMsg);
	            case 22:
	              (_logger$debug2 = logger.debug) === null || _logger$debug2 === void 0 || _logger$debug2.call(logger, "*** Found feature: ".concat(JSON.stringify(foundFeature)));
	              if (!(foundFeature.strand !== oldStrand)) {
	                _context.next = 27;
	                break;
	              }
	              _errMsg2 = "*** ERROR: Feature's current strand \"".concat(topLevelFeature.strand, "\" doesn't match with expected value \"").concat(oldStrand, "\"");
	              logger.error(_errMsg2);
	              throw new Error(_errMsg2);
	            case 27:
	              featuresForChanges.push({
	                feature: foundFeature,
	                topLevelFeature: topLevelFeature
	              });
	            case 28:
	              _context.next = 6;
	              break;
	            case 30:
	              _context.next = 35;
	              break;
	            case 32:
	              _context.prev = 32;
	              _context.t0 = _context["catch"](4);
	              _iterator.e(_context.t0);
	            case 35:
	              _context.prev = 35;
	              _iterator.f();
	              return _context.finish(35);
	            case 38:
	              // Let's update objects.
	              _iterator2 = _createForOfIteratorHelper(changes.entries());
	              _context.prev = 39;
	              _iterator2.s();
	            case 41:
	              if ((_step2 = _iterator2.n()).done) {
	                _context.next = 59;
	                break;
	              }
	              _step2$value = _slicedToArray(_step2.value, 2), idx = _step2$value[0], change = _step2$value[1];
	              newStrand = change.newStrand;
	              _featuresForChanges$i = featuresForChanges[idx], feature = _featuresForChanges$i.feature, _topLevelFeature = _featuresForChanges$i.topLevelFeature;
	              feature.strand = newStrand;
	              if (_topLevelFeature._id.equals(feature._id)) {
	                _topLevelFeature.markModified('strand'); // Mark as modified. Without this save() -method is not updating data in database
	              } else {
	                _topLevelFeature.markModified('children'); // Mark as modified. Without this save() -method is not updating data in database
	              }
	              _context.prev = 47;
	              _context.next = 50;
	              return _topLevelFeature.save();
	            case 50:
	              _context.next = 56;
	              break;
	            case 52:
	              _context.prev = 52;
	              _context.t1 = _context["catch"](47);
	              (_logger$debug3 = logger.debug) === null || _logger$debug3 === void 0 || _logger$debug3.call(logger, "*** FAILED: ".concat(_context.t1));
	              throw _context.t1;
	            case 56:
	              (_logger$debug4 = logger.debug) === null || _logger$debug4 === void 0 || _logger$debug4.call(logger, "*** Object updated in Mongo. New object: ".concat(JSON.stringify(_topLevelFeature)));
	            case 57:
	              _context.next = 41;
	              break;
	            case 59:
	              _context.next = 64;
	              break;
	            case 61:
	              _context.prev = 61;
	              _context.t2 = _context["catch"](39);
	              _iterator2.e(_context.t2);
	            case 64:
	              _context.prev = 64;
	              _iterator2.f();
	              return _context.finish(64);
	            case 67:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this, [[4, 32, 35, 38], [39, 61, 64, 67], [47, 52]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }()
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(dataStore) {
	        var _iterator3, _step3, _step3$value, idx, changedId, feature;
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              if (dataStore) {
	                _context3.next = 2;
	                break;
	              }
	              throw new Error('No data store');
	            case 2:
	              _iterator3 = _createForOfIteratorHelper(this.changedIds.entries());
	              _context3.prev = 3;
	              _iterator3.s();
	            case 5:
	              if ((_step3 = _iterator3.n()).done) {
	                _context3.next = 13;
	                break;
	              }
	              _step3$value = _slicedToArray(_step3.value, 2), idx = _step3$value[0], changedId = _step3$value[1];
	              feature = dataStore.getFeature(changedId);
	              if (feature) {
	                _context3.next = 10;
	                break;
	              }
	              throw new Error("Could not find feature with identifier \"".concat(changedId, "\""));
	            case 10:
	              feature.setStrand(this.changes[idx].newStrand);
	            case 11:
	              _context3.next = 5;
	              break;
	            case 13:
	              _context3.next = 18;
	              break;
	            case 15:
	              _context3.prev = 15;
	              _context3.t0 = _context3["catch"](3);
	              _iterator3.e(_context3.t0);
	            case 18:
	              _context3.prev = 18;
	              _iterator3.f();
	              return _context3.finish(18);
	            case 21:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this, [[3, 15, 18, 21]]);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        logger = this.logger,
	        typeName = this.typeName;
	      var inverseChangedIds = _toConsumableArray(changedIds).reverse();
	      var inverseChanges = _toConsumableArray(changes).reverse().map(function (endChange) {
	        return {
	          featureId: endChange.featureId,
	          oldStrand: endChange.newStrand,
	          newStrand: endChange.oldStrand
	        };
	      });
	      return new StrandChange({
	        changedIds: inverseChangedIds,
	        typeName: typeName,
	        changes: inverseChanges,
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return StrandChange;
	}(common_1$5.FeatureChange);
	StrandChange$1.StrandChange = StrandChange;

	var TypeChange$1 = {};

	Object.defineProperty(TypeChange$1, "__esModule", {
	  value: true
	});
	TypeChange$1.TypeChange = void 0;
	/* eslint-disable @typescript-eslint/restrict-template-expressions */
	/* eslint-disable @typescript-eslint/require-await */
	/* eslint-disable @typescript-eslint/no-unnecessary-condition */
	var common_1$4 = dist$1;
	var TypeChange = /*#__PURE__*/function (_common_1$FeatureChan) {
	  _inherits(TypeChange, _common_1$FeatureChan);
	  var _super = /*#__PURE__*/_createSuper(TypeChange);
	  function TypeChange(json, options) {
	    var _this;
	    _classCallCheck(this, TypeChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'TypeChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    return _this;
	  }
	  _createClass(TypeChange, [{
	    key: "toJSON",
	    value: function toJSON() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        typeName = this.typeName;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          _changes$ = _changes[0],
	          featureId = _changes$.featureId,
	          newType = _changes$.newType,
	          oldType = _changes$.oldType;
	        return {
	          typeName: typeName,
	          changedIds: changedIds,
	          assembly: assembly,
	          featureId: featureId,
	          oldType: oldType,
	          newType: newType
	        };
	      }
	      return {
	        typeName: typeName,
	        changedIds: changedIds,
	        assembly: assembly,
	        changes: changes
	      };
	    }
	    /**
	     * Applies the required change to database
	     * @param backend - parameters from backend
	     * @returns
	     */
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var featureModel, session, changes, logger, featuresForChanges, _iterator, _step, _logger$debug, _logger$debug2, entry, featureId, oldType, topLevelFeature, errMsg, foundFeature, _errMsg, _errMsg2, _iterator2, _step2, _logger$debug4, _step2$value, idx, change, newType, _featuresForChanges$i, feature, _topLevelFeature, _logger$debug3;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              featureModel = backend.featureModel, session = backend.session;
	              changes = this.changes, logger = this.logger;
	              featuresForChanges = []; // Let's first check that all features are found and those old values match with expected ones. We do this just to be sure that all changes can be done.
	              _iterator = _createForOfIteratorHelper(changes);
	              _context.prev = 4;
	              _iterator.s();
	            case 6:
	              if ((_step = _iterator.n()).done) {
	                _context.next = 30;
	                break;
	              }
	              entry = _step.value;
	              featureId = entry.featureId, oldType = entry.oldType; // Search correct feature
	              _context.next = 11;
	              return featureModel.findOne({
	                allIds: featureId
	              }).session(session).exec();
	            case 11:
	              topLevelFeature = _context.sent;
	              if (topLevelFeature) {
	                _context.next = 16;
	                break;
	              }
	              errMsg = "*** ERROR: The following featureId was not found in database ='".concat(featureId, "'");
	              logger.error(errMsg);
	              throw new Error(errMsg);
	            case 16:
	              (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, "*** Feature found: ".concat(JSON.stringify(topLevelFeature)));
	              foundFeature = this.getFeatureFromId(topLevelFeature, featureId);
	              if (foundFeature) {
	                _context.next = 22;
	                break;
	              }
	              _errMsg = 'ERROR when searching feature by featureId';
	              logger.error(_errMsg);
	              throw new Error(_errMsg);
	            case 22:
	              (_logger$debug2 = logger.debug) === null || _logger$debug2 === void 0 || _logger$debug2.call(logger, "*** Found feature: ".concat(JSON.stringify(foundFeature)));
	              if (!(foundFeature.type !== oldType)) {
	                _context.next = 27;
	                break;
	              }
	              _errMsg2 = "*** ERROR: Feature's current type \"".concat(topLevelFeature.type, "\" doesn't match with expected value \"").concat(oldType, "\"");
	              logger.error(_errMsg2);
	              throw new Error(_errMsg2);
	            case 27:
	              featuresForChanges.push({
	                feature: foundFeature,
	                topLevelFeature: topLevelFeature
	              });
	            case 28:
	              _context.next = 6;
	              break;
	            case 30:
	              _context.next = 35;
	              break;
	            case 32:
	              _context.prev = 32;
	              _context.t0 = _context["catch"](4);
	              _iterator.e(_context.t0);
	            case 35:
	              _context.prev = 35;
	              _iterator.f();
	              return _context.finish(35);
	            case 38:
	              // Let's update objects.
	              _iterator2 = _createForOfIteratorHelper(changes.entries());
	              _context.prev = 39;
	              _iterator2.s();
	            case 41:
	              if ((_step2 = _iterator2.n()).done) {
	                _context.next = 59;
	                break;
	              }
	              _step2$value = _slicedToArray(_step2.value, 2), idx = _step2$value[0], change = _step2$value[1];
	              newType = change.newType;
	              _featuresForChanges$i = featuresForChanges[idx], feature = _featuresForChanges$i.feature, _topLevelFeature = _featuresForChanges$i.topLevelFeature;
	              feature.type = newType;
	              if (_topLevelFeature._id.equals(feature._id)) {
	                _topLevelFeature.markModified('type'); // Mark as modified. Without this save() -method is not updating data in database
	              } else {
	                _topLevelFeature.markModified('children'); // Mark as modified. Without this save() -method is not updating data in database
	              }
	              _context.prev = 47;
	              _context.next = 50;
	              return _topLevelFeature.save();
	            case 50:
	              _context.next = 56;
	              break;
	            case 52:
	              _context.prev = 52;
	              _context.t1 = _context["catch"](47);
	              (_logger$debug3 = logger.debug) === null || _logger$debug3 === void 0 || _logger$debug3.call(logger, "*** FAILED: ".concat(_context.t1));
	              throw _context.t1;
	            case 56:
	              (_logger$debug4 = logger.debug) === null || _logger$debug4 === void 0 || _logger$debug4.call(logger, "*** Object updated in Mongo. New object: ".concat(JSON.stringify(_topLevelFeature)));
	            case 57:
	              _context.next = 41;
	              break;
	            case 59:
	              _context.next = 64;
	              break;
	            case 61:
	              _context.prev = 61;
	              _context.t2 = _context["catch"](39);
	              _iterator2.e(_context.t2);
	            case 64:
	              _context.prev = 64;
	              _iterator2.f();
	              return _context.finish(64);
	            case 67:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this, [[4, 32, 35, 38], [39, 61, 64, 67], [47, 52]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }()
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(dataStore) {
	        var _iterator3, _step3, _step3$value, idx, changedId, feature;
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              if (dataStore) {
	                _context3.next = 2;
	                break;
	              }
	              throw new Error('No data store');
	            case 2:
	              _iterator3 = _createForOfIteratorHelper(this.changedIds.entries());
	              _context3.prev = 3;
	              _iterator3.s();
	            case 5:
	              if ((_step3 = _iterator3.n()).done) {
	                _context3.next = 13;
	                break;
	              }
	              _step3$value = _slicedToArray(_step3.value, 2), idx = _step3$value[0], changedId = _step3$value[1];
	              feature = dataStore.getFeature(changedId);
	              if (feature) {
	                _context3.next = 10;
	                break;
	              }
	              throw new Error("Could not find feature with identifier \"".concat(changedId, "\""));
	            case 10:
	              feature.setType(this.changes[idx].newType);
	            case 11:
	              _context3.next = 5;
	              break;
	            case 13:
	              _context3.next = 18;
	              break;
	            case 15:
	              _context3.prev = 15;
	              _context3.t0 = _context3["catch"](3);
	              _iterator3.e(_context3.t0);
	            case 18:
	              _context3.prev = 18;
	              _iterator3.f();
	              return _context3.finish(18);
	            case 21:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this, [[3, 15, 18, 21]]);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var assembly = this.assembly,
	        changedIds = this.changedIds,
	        changes = this.changes,
	        logger = this.logger,
	        typeName = this.typeName;
	      var inverseChangedIds = _toConsumableArray(changedIds).reverse();
	      var inverseChanges = _toConsumableArray(changes).reverse().map(function (endChange) {
	        return {
	          featureId: endChange.featureId,
	          oldType: endChange.newType,
	          newType: endChange.oldType
	        };
	      });
	      return new TypeChange({
	        changedIds: inverseChangedIds,
	        typeName: typeName,
	        changes: inverseChanges,
	        assembly: assembly
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return TypeChange;
	}(common_1$4.FeatureChange);
	TypeChange$1.TypeChange = TypeChange;

	var UserChange$1 = {};

	Object.defineProperty(UserChange$1, "__esModule", {
	  value: true
	});
	UserChange$1.UserChange = void 0;
	/* eslint-disable @typescript-eslint/require-await */
	var common_1$3 = dist$1;
	var UserChange = /*#__PURE__*/function (_common_1$Change) {
	  _inherits(UserChange, _common_1$Change);
	  var _super = /*#__PURE__*/_createSuper(UserChange);
	  function UserChange(json, options) {
	    var _this;
	    _classCallCheck(this, UserChange);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'UserChange');
	    _defineProperty(_assertThisInitialized(_this), "changes", void 0);
	    _defineProperty(_assertThisInitialized(_this), "userId", void 0);
	    _this.changes = 'changes' in json ? json.changes : [json];
	    _this.userId = json.userId;
	    return _this;
	  }
	  _createClass(UserChange, [{
	    key: "toJSON",
	    value: function toJSON() {
	      var changes = this.changes,
	        typeName = this.typeName,
	        userId = this.userId;
	      if (changes.length === 1) {
	        var _changes = _slicedToArray(changes, 1),
	          role = _changes[0].role;
	        return {
	          typeName: typeName,
	          userId: userId,
	          role: role
	        };
	      }
	      return {
	        typeName: typeName,
	        userId: userId,
	        changes: changes
	      };
	    }
	  }, {
	    key: "executeOnServer",
	    value: function () {
	      var _executeOnServer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend) {
	        var session, userModel, changes, logger, userId, _iterator, _step, _logger$debug, change, role, user, errMsg;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              session = backend.session, userModel = backend.userModel;
	              changes = this.changes, logger = this.logger, userId = this.userId;
	              _iterator = _createForOfIteratorHelper(changes);
	              _context.prev = 3;
	              _iterator.s();
	            case 5:
	              if ((_step = _iterator.n()).done) {
	                _context.next = 18;
	                break;
	              }
	              change = _step.value;
	              (_logger$debug = logger.debug) === null || _logger$debug === void 0 || _logger$debug.call(logger, "change: ".concat(JSON.stringify(changes)));
	              role = change.role;
	              _context.next = 11;
	              return userModel.findByIdAndUpdate(userId, {
	                role: role
	              }).session(session).exec();
	            case 11:
	              user = _context.sent;
	              if (user) {
	                _context.next = 16;
	                break;
	              }
	              errMsg = "*** ERROR: User with id \"".concat(userId, "\" not found");
	              logger.error(errMsg);
	              throw new Error(errMsg);
	            case 16:
	              _context.next = 5;
	              break;
	            case 18:
	              _context.next = 23;
	              break;
	            case 20:
	              _context.prev = 20;
	              _context.t0 = _context["catch"](3);
	              _iterator.e(_context.t0);
	            case 23:
	              _context.prev = 23;
	              _iterator.f();
	              return _context.finish(23);
	            case 26:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this, [[3, 20, 23, 26]]);
	      }));
	      function executeOnServer(_x) {
	        return _executeOnServer.apply(this, arguments);
	      }
	      return executeOnServer;
	    }()
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_backend) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2);
	      }));
	      function executeOnLocalGFF3(_x2) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }() // eslint-disable-next-line @typescript-eslint/no-empty-function
	  }, {
	    key: "executeOnClient",
	    value: function () {
	      var _executeOnClient = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_dataStore) {
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3);
	      }));
	      function executeOnClient(_x3) {
	        return _executeOnClient.apply(this, arguments);
	      }
	      return executeOnClient;
	    }()
	  }, {
	    key: "getInverse",
	    value: function getInverse() {
	      var changes = this.changes,
	        logger = this.logger,
	        typeName = this.typeName,
	        userId = this.userId;
	      return new UserChange({
	        typeName: typeName,
	        changes: changes,
	        userId: userId
	      }, {
	        logger: logger
	      });
	    }
	  }]);
	  return UserChange;
	}(common_1$3.Change);
	UserChange$1.UserChange = UserChange;

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.changes = void 0;
	  var tslib_1 = require$$0$1;
	  var AddAssemblyAliasesChange_1 = AddAssemblyAliasesChange$1;
	  var AddAssemblyAndFeaturesFromFileChange_1 = AddAssemblyAndFeaturesFromFileChange$1;
	  var AddAssemblyFromExternalChange_1 = AddAssemblyFromExternalChange$1;
	  var AddAssemblyFromFileChange_1 = AddAssemblyFromFileChange$1;
	  var AddFeatureChange_1 = AddFeatureChange$1;
	  var AddFeaturesFromFileChange_1 = AddFeaturesFromFileChange$1;
	  var AddRefSeqAliasesChange_1 = AddRefSeqAliasesChange$1;
	  var DeleteAssemblyChange_1 = DeleteAssemblyChange$1;
	  var DeleteFeatureChange_1 = DeleteFeatureChange$1;
	  var DeleteUserChange_1 = DeleteUserChange$1;
	  var FeatureAttributeChange_1 = FeatureAttributeChange$1;
	  var ImportJBrowseConfigChange_1 = ImportJBrowseConfigChange$1;
	  var LocationEndChange_1 = LocationEndChange$1;
	  var LocationStartChange_1 = LocationStartChange$1;
	  var MergeExonsChange_1 = MergeExonsChange$1;
	  var MergeTranscriptsChange_1 = MergeTranscriptsChange$1;
	  var SplitExonChange_1 = SplitExonChange$1;
	  var StrandChange_1 = StrandChange$1;
	  var TypeChange_1 = TypeChange$1;
	  var UndoMergeExonsChange_1 = UndoMergeExonsChange$1;
	  var UndoMergeTranscriptsChange_1 = UndoMergeTranscriptsChange$1;
	  var UndoSplitExonChange_1 = UndoSplitExonChange$1;
	  var UserChange_1 = UserChange$1;
	  exports.changes = {
	    AddAssemblyAndFeaturesFromFileChange: AddAssemblyAndFeaturesFromFileChange_1.AddAssemblyAndFeaturesFromFileChange,
	    AddAssemblyFromFileChange: AddAssemblyFromFileChange_1.AddAssemblyFromFileChange,
	    AddAssemblyFromExternalChange: AddAssemblyFromExternalChange_1.AddAssemblyFromExternalChange,
	    AddFeatureChange: AddFeatureChange_1.AddFeatureChange,
	    AddFeaturesFromFileChange: AddFeaturesFromFileChange_1.AddFeaturesFromFileChange,
	    DeleteAssemblyChange: DeleteAssemblyChange_1.DeleteAssemblyChange,
	    DeleteFeatureChange: DeleteFeatureChange_1.DeleteFeatureChange,
	    DeleteUserChange: DeleteUserChange_1.DeleteUserChange,
	    FeatureAttributeChange: FeatureAttributeChange_1.FeatureAttributeChange,
	    ImportJBrowseConfigChange: ImportJBrowseConfigChange_1.ImportJBrowseConfigChange,
	    LocationEndChange: LocationEndChange_1.LocationEndChange,
	    LocationStartChange: LocationStartChange_1.LocationStartChange,
	    MergeExonsChange: MergeExonsChange_1.MergeExonsChange,
	    SplitExonChange: SplitExonChange_1.SplitExonChange,
	    MergeTranscriptsChange: MergeTranscriptsChange_1.MergeTranscriptsChange,
	    UndoMergeExonsChange: UndoMergeExonsChange_1.UndoMergeExonsChange,
	    UndoSplitExonChange: UndoSplitExonChange_1.UndoSplitExonChange,
	    UndoMergeTranscriptsChange: UndoMergeTranscriptsChange_1.UndoMergeTranscriptsChange,
	    StrandChange: StrandChange_1.StrandChange,
	    TypeChange: TypeChange_1.TypeChange,
	    UserChange: UserChange_1.UserChange,
	    AddRefSeqAliasesChange: AddRefSeqAliasesChange_1.AddRefSeqAliasesChange,
	    AddAssemblyAliasesChange: AddAssemblyAliasesChange_1.AddAssemblyAliasesChange
	  };
	  tslib_1.__exportStar(AddAssemblyAndFeaturesFromFileChange$1, exports);
	  tslib_1.__exportStar(AddAssemblyFromFileChange$1, exports);
	  tslib_1.__exportStar(AddAssemblyFromExternalChange$1, exports);
	  tslib_1.__exportStar(AddFeatureChange$1, exports);
	  tslib_1.__exportStar(AddFeaturesFromFileChange$1, exports);
	  tslib_1.__exportStar(DeleteAssemblyChange$1, exports);
	  tslib_1.__exportStar(DeleteFeatureChange$1, exports);
	  tslib_1.__exportStar(DeleteUserChange$1, exports);
	  tslib_1.__exportStar(FeatureAttributeChange$1, exports);
	  tslib_1.__exportStar(ImportJBrowseConfigChange$1, exports);
	  tslib_1.__exportStar(LocationEndChange$1, exports);
	  tslib_1.__exportStar(LocationStartChange$1, exports);
	  tslib_1.__exportStar(MergeExonsChange$1, exports);
	  tslib_1.__exportStar(SplitExonChange$1, exports);
	  tslib_1.__exportStar(MergeTranscriptsChange$1, exports);
	  tslib_1.__exportStar(UndoMergeExonsChange$1, exports);
	  tslib_1.__exportStar(UndoSplitExonChange$1, exports);
	  tslib_1.__exportStar(UndoMergeTranscriptsChange$1, exports);
	  tslib_1.__exportStar(StrandChange$1, exports);
	  tslib_1.__exportStar(TypeChange$1, exports);
	  tslib_1.__exportStar(UserChange$1, exports);
	  tslib_1.__exportStar(AddRefSeqAliasesChange$1, exports);
	  tslib_1.__exportStar(AddAssemblyAliasesChange$1, exports);
	})(Changes);

	var Operations = {};

	var GetAssembliesOperation$1 = {};

	Object.defineProperty(GetAssembliesOperation$1, "__esModule", {
	  value: true
	});
	GetAssembliesOperation$1.GetAssembliesOperation = void 0;
	/* eslint-disable @typescript-eslint/require-await */
	var common_1$2 = dist$1;
	var GetAssembliesOperation = /*#__PURE__*/function (_common_1$Operation) {
	  _inherits(GetAssembliesOperation, _common_1$Operation);
	  var _super = /*#__PURE__*/_createSuper(GetAssembliesOperation);
	  function GetAssembliesOperation() {
	    var _this;
	    _classCallCheck(this, GetAssembliesOperation);
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    _this = _super.call.apply(_super, [this].concat(args));
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'GetAssembliesOperation');
	    return _this;
	  }
	  _createClass(GetAssembliesOperation, [{
	    key: "toJSON",
	    value: function toJSON() {
	      var typeName = this.typeName;
	      return {
	        typeName: typeName
	      };
	    }
	  }, {
	    key: "executeOnServer",
	    value: function executeOnServer(backend) {
	      return backend.assemblyModel.find({
	        status: 0
	      }).exec();
	    }
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_backend) {
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee);
	      }));
	      function executeOnLocalGFF3(_x) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }()
	  }]);
	  return GetAssembliesOperation;
	}(common_1$2.Operation);
	GetAssembliesOperation$1.GetAssembliesOperation = GetAssembliesOperation;

	var GetFeaturesOperation$1 = {};

	Object.defineProperty(GetFeaturesOperation$1, "__esModule", {
	  value: true
	});
	GetFeaturesOperation$1.GetFeaturesOperation = void 0;
	/* eslint-disable @typescript-eslint/require-await */
	var common_1$1 = dist$1;
	var GetFeaturesOperation = /*#__PURE__*/function (_common_1$Operation) {
	  _inherits(GetFeaturesOperation, _common_1$Operation);
	  var _super = /*#__PURE__*/_createSuper(GetFeaturesOperation);
	  function GetFeaturesOperation(json, options) {
	    var _this;
	    _classCallCheck(this, GetFeaturesOperation);
	    _this = _super.call(this, json, options);
	    _defineProperty(_assertThisInitialized(_this), "typeName", 'GetFeaturesOperation');
	    _defineProperty(_assertThisInitialized(_this), "refSeq", void 0);
	    _defineProperty(_assertThisInitialized(_this), "start", void 0);
	    _defineProperty(_assertThisInitialized(_this), "end", void 0);
	    _this.refSeq = json.refSeq;
	    _this.start = json.start;
	    _this.end = json.end;
	    return _this;
	  }
	  _createClass(GetFeaturesOperation, [{
	    key: "toJSON",
	    value: function toJSON() {
	      var end = this.end,
	        refSeq = this.refSeq,
	        start = this.start,
	        typeName = this.typeName;
	      return {
	        typeName: typeName,
	        refSeq: refSeq,
	        start: start,
	        end: end
	      };
	    }
	    /**
	     * Fetch features based on Reference seq, Start and End -values
	     * @param request - Contain search criteria i.e. refSeq, start and end -parameters
	     * @returns Return Array of features if search was successful
	     * or if search data was not found or in case of error throw exception
	     */
	  }, {
	    key: "executeOnServer",
	    value: function executeOnServer(backend) {
	      return backend.featureModel.find({
	        refSeq: this.refSeq,
	        min: {
	          $lte: this.end
	        },
	        max: {
	          $gte: this.start
	        },
	        status: 0
	      }).exec();
	    }
	  }, {
	    key: "executeOnLocalGFF3",
	    value: function () {
	      var _executeOnLocalGFF = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_backend) {
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              throw new Error('executeOnLocalGFF3 not implemented');
	            case 1:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee);
	      }));
	      function executeOnLocalGFF3(_x) {
	        return _executeOnLocalGFF.apply(this, arguments);
	      }
	      return executeOnLocalGFF3;
	    }()
	  }]);
	  return GetFeaturesOperation;
	}(common_1$1.Operation);
	GetFeaturesOperation$1.GetFeaturesOperation = GetFeaturesOperation;

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.operations = void 0;
	  var tslib_1 = require$$0$1;
	  var GetAssembliesOperation_1 = GetAssembliesOperation$1;
	  var GetFeaturesOperation_1 = GetFeaturesOperation$1;
	  exports.operations = {
	    GetAssembliesOperation: GetAssembliesOperation_1.GetAssembliesOperation,
	    GetFeaturesOperation: GetFeaturesOperation_1.GetFeaturesOperation
	  };
	  tslib_1.__exportStar(GetAssembliesOperation$1, exports);
	  tslib_1.__exportStar(GetFeaturesOperation$1, exports);
	})(Operations);

	var Validations = {};

	var Validation$1 = {};

	Object.defineProperty(Validation$1, "__esModule", {
	  value: true
	});
	Validation$1.Validation = void 0;
	Validation$1.isContext = isContext;
	function isContext(thing) {
	  return thing.context !== undefined && thing.reflector !== undefined;
	}
	var Validation = /*#__PURE__*/function () {
	  function Validation() {
	    _classCallCheck(this, Validation);
	  }
	  _createClass(Validation, [{
	    key: "frontendPreValidate",
	    value: function () {
	      var _frontendPreValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_change) {
	        return _regeneratorRuntime().wrap(function _callee$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", {
	                validationName: this.name
	              });
	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee, this);
	      }));
	      function frontendPreValidate(_x) {
	        return _frontendPreValidate.apply(this, arguments);
	      }
	      return frontendPreValidate;
	    }()
	  }, {
	    key: "frontendPostValidate",
	    value: function () {
	      var _frontendPostValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_change, _dataStore) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              return _context3.abrupt("return", {
	                validationName: this.name
	              });
	            case 1:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee2, this);
	      }));
	      function frontendPostValidate(_x2, _x3) {
	        return _frontendPostValidate.apply(this, arguments);
	      }
	      return frontendPostValidate;
	    }()
	  }, {
	    key: "backendPreValidate",
	    value: function () {
	      var _backendPreValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_changeOrContext) {
	        return _regeneratorRuntime().wrap(function _callee3$(_context4) {
	          while (1) switch (_context4.prev = _context4.next) {
	            case 0:
	              return _context4.abrupt("return", {
	                validationName: this.name
	              });
	            case 1:
	            case "end":
	              return _context4.stop();
	          }
	        }, _callee3, this);
	      }));
	      function backendPreValidate(_x4) {
	        return _backendPreValidate.apply(this, arguments);
	      }
	      return backendPreValidate;
	    }()
	  }, {
	    key: "backendPostValidate",
	    value: function () {
	      var _backendPostValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_change, _context) {
	        return _regeneratorRuntime().wrap(function _callee4$(_context5) {
	          while (1) switch (_context5.prev = _context5.next) {
	            case 0:
	              return _context5.abrupt("return", {
	                validationName: this.name
	              });
	            case 1:
	            case "end":
	              return _context5.stop();
	          }
	        }, _callee4, this);
	      }));
	      function backendPostValidate(_x5, _x6) {
	        return _backendPostValidate.apply(this, arguments);
	      }
	      return backendPostValidate;
	    }()
	  }, {
	    key: "possibleValues",
	    value: function () {
	      var _possibleValues = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_key) {
	        return _regeneratorRuntime().wrap(function _callee5$(_context6) {
	          while (1) switch (_context6.prev = _context6.next) {
	            case 0:
	              return _context6.abrupt("return", undefined);
	            case 1:
	            case "end":
	              return _context6.stop();
	          }
	        }, _callee5);
	      }));
	      function possibleValues(_x7) {
	        return _possibleValues.apply(this, arguments);
	      }
	      return possibleValues;
	    }()
	  }]);
	  return Validation;
	}();
	Validation$1.Validation = Validation;

	var ValidationSet$1 = {};

	Object.defineProperty(ValidationSet$1, "__esModule", {
	  value: true
	});
	ValidationSet$1.validationRegistry = ValidationSet$1.ValidationSet = ValidationSet$1.ValidationResultSet = void 0;
	var ValidationResultSet = /*#__PURE__*/function () {
	  function ValidationResultSet() {
	    _classCallCheck(this, ValidationResultSet);
	    _defineProperty(this, "results", []);
	    _defineProperty(this, "ok", true);
	  }
	  _createClass(ValidationResultSet, [{
	    key: "resultsMessages",
	    get: function get() {
	      return this.results.map(function (r) {
	        var _r$error;
	        return (_r$error = r.error) === null || _r$error === void 0 ? void 0 : _r$error.message;
	      }).filter(Boolean).join(', ');
	    }
	  }, {
	    key: "add",
	    value: function add(result) {
	      this.results.push(result);
	      if (result.error) {
	        this.ok = false;
	      }
	    }
	  }]);
	  return ValidationResultSet;
	}();
	ValidationSet$1.ValidationResultSet = ValidationResultSet;
	var ValidationSet = /*#__PURE__*/function () {
	  function ValidationSet() {
	    _classCallCheck(this, ValidationSet);
	    _defineProperty(this, "validations", new Set());
	  }
	  _createClass(ValidationSet, [{
	    key: "registerValidation",
	    value: function registerValidation(validation) {
	      this.validations.add(validation);
	    }
	  }, {
	    key: "frontendPreValidate",
	    value: function () {
	      var _frontendPreValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(change) {
	        var results, _iterator, _step, v, result;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              results = new ValidationResultSet();
	              _iterator = _createForOfIteratorHelper(this.validations);
	              _context.prev = 2;
	              _iterator.s();
	            case 4:
	              if ((_step = _iterator.n()).done) {
	                _context.next = 14;
	                break;
	              }
	              v = _step.value;
	              _context.next = 8;
	              return v.frontendPreValidate(change);
	            case 8:
	              result = _context.sent;
	              results.add(result);
	              if (!result.error) {
	                _context.next = 12;
	                break;
	              }
	              return _context.abrupt("break", 14);
	            case 12:
	              _context.next = 4;
	              break;
	            case 14:
	              _context.next = 19;
	              break;
	            case 16:
	              _context.prev = 16;
	              _context.t0 = _context["catch"](2);
	              _iterator.e(_context.t0);
	            case 19:
	              _context.prev = 19;
	              _iterator.f();
	              return _context.finish(19);
	            case 22:
	              return _context.abrupt("return", results);
	            case 23:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this, [[2, 16, 19, 22]]);
	      }));
	      function frontendPreValidate(_x) {
	        return _frontendPreValidate.apply(this, arguments);
	      }
	      return frontendPreValidate;
	    }()
	  }, {
	    key: "frontendPostValidate",
	    value: function () {
	      var _frontendPostValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(change, dataStore) {
	        var results, _iterator2, _step2, v, result;
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              results = new ValidationResultSet();
	              _iterator2 = _createForOfIteratorHelper(this.validations);
	              _context2.prev = 2;
	              _iterator2.s();
	            case 4:
	              if ((_step2 = _iterator2.n()).done) {
	                _context2.next = 14;
	                break;
	              }
	              v = _step2.value;
	              _context2.next = 8;
	              return v.frontendPostValidate(change, dataStore);
	            case 8:
	              result = _context2.sent;
	              results.add(result);
	              if (!result.error) {
	                _context2.next = 12;
	                break;
	              }
	              return _context2.abrupt("break", 14);
	            case 12:
	              _context2.next = 4;
	              break;
	            case 14:
	              _context2.next = 19;
	              break;
	            case 16:
	              _context2.prev = 16;
	              _context2.t0 = _context2["catch"](2);
	              _iterator2.e(_context2.t0);
	            case 19:
	              _context2.prev = 19;
	              _iterator2.f();
	              return _context2.finish(19);
	            case 22:
	              return _context2.abrupt("return", results);
	            case 23:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2, this, [[2, 16, 19, 22]]);
	      }));
	      function frontendPostValidate(_x2, _x3) {
	        return _frontendPostValidate.apply(this, arguments);
	      }
	      return frontendPostValidate;
	    }()
	  }, {
	    key: "backendPreValidate",
	    value: function () {
	      var _backendPreValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(change) {
	        var results, _iterator3, _step3, v, result;
	        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              results = new ValidationResultSet();
	              _iterator3 = _createForOfIteratorHelper(this.validations);
	              _context3.prev = 2;
	              _iterator3.s();
	            case 4:
	              if ((_step3 = _iterator3.n()).done) {
	                _context3.next = 14;
	                break;
	              }
	              v = _step3.value;
	              _context3.next = 8;
	              return v.backendPreValidate(change);
	            case 8:
	              result = _context3.sent;
	              results.add(result);
	              if (!result.error) {
	                _context3.next = 12;
	                break;
	              }
	              return _context3.abrupt("break", 14);
	            case 12:
	              _context3.next = 4;
	              break;
	            case 14:
	              _context3.next = 19;
	              break;
	            case 16:
	              _context3.prev = 16;
	              _context3.t0 = _context3["catch"](2);
	              _iterator3.e(_context3.t0);
	            case 19:
	              _context3.prev = 19;
	              _iterator3.f();
	              return _context3.finish(19);
	            case 22:
	              return _context3.abrupt("return", results);
	            case 23:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee3, this, [[2, 16, 19, 22]]);
	      }));
	      function backendPreValidate(_x4) {
	        return _backendPreValidate.apply(this, arguments);
	      }
	      return backendPreValidate;
	    }()
	  }, {
	    key: "backendPostValidate",
	    value: function () {
	      var _backendPostValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(change, _ref) {
	        var featureModel, session, results, _iterator4, _step4, v, result;
	        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
	          while (1) switch (_context4.prev = _context4.next) {
	            case 0:
	              featureModel = _ref.featureModel, session = _ref.session;
	              results = new ValidationResultSet();
	              _iterator4 = _createForOfIteratorHelper(this.validations);
	              _context4.prev = 3;
	              _iterator4.s();
	            case 5:
	              if ((_step4 = _iterator4.n()).done) {
	                _context4.next = 15;
	                break;
	              }
	              v = _step4.value;
	              _context4.next = 9;
	              return v.backendPostValidate(change, {
	                featureModel: featureModel,
	                session: session
	              });
	            case 9:
	              result = _context4.sent;
	              results.add(result);
	              if (!result.error) {
	                _context4.next = 13;
	                break;
	              }
	              return _context4.abrupt("break", 15);
	            case 13:
	              _context4.next = 5;
	              break;
	            case 15:
	              _context4.next = 20;
	              break;
	            case 17:
	              _context4.prev = 17;
	              _context4.t0 = _context4["catch"](3);
	              _iterator4.e(_context4.t0);
	            case 20:
	              _context4.prev = 20;
	              _iterator4.f();
	              return _context4.finish(20);
	            case 23:
	              return _context4.abrupt("return", results);
	            case 24:
	            case "end":
	              return _context4.stop();
	          }
	        }, _callee4, this, [[3, 17, 20, 23]]);
	      }));
	      function backendPostValidate(_x5, _x6) {
	        return _backendPostValidate.apply(this, arguments);
	      }
	      return backendPostValidate;
	    }()
	  }, {
	    key: "possibleValues",
	    value: function () {
	      var _possibleValues = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(key) {
	        var _iterator5, _step5, v, vals;
	        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
	          while (1) switch (_context5.prev = _context5.next) {
	            case 0:
	              _iterator5 = _createForOfIteratorHelper(this.validations);
	              _context5.prev = 1;
	              _iterator5.s();
	            case 3:
	              if ((_step5 = _iterator5.n()).done) {
	                _context5.next = 12;
	                break;
	              }
	              v = _step5.value;
	              _context5.next = 7;
	              return v.possibleValues(key);
	            case 7:
	              vals = _context5.sent;
	              if (!vals) {
	                _context5.next = 10;
	                break;
	              }
	              return _context5.abrupt("return", vals);
	            case 10:
	              _context5.next = 3;
	              break;
	            case 12:
	              _context5.next = 17;
	              break;
	            case 14:
	              _context5.prev = 14;
	              _context5.t0 = _context5["catch"](1);
	              _iterator5.e(_context5.t0);
	            case 17:
	              _context5.prev = 17;
	              _iterator5.f();
	              return _context5.finish(17);
	            case 20:
	              return _context5.abrupt("return");
	            case 21:
	            case "end":
	              return _context5.stop();
	          }
	        }, _callee5, this, [[1, 14, 17, 20]]);
	      }));
	      function possibleValues(_x7) {
	        return _possibleValues.apply(this, arguments);
	      }
	      return possibleValues;
	    }()
	  }]);
	  return ValidationSet;
	}();
	ValidationSet$1.ValidationSet = ValidationSet;
	/** global singleton of all known types of changes */
	ValidationSet$1.validationRegistry = /*#__PURE__*/new ValidationSet();

	var CoreValidation$1 = {};

	var soSequenceTypes$1 = {};

	Object.defineProperty(soSequenceTypes$1, "__esModule", {
	  value: true
	});
	var soSequenceTypes = ['2A_self_cleaving_peptide_region', '4_methylcytosine', '5S_SINE_retrotransposon', '5_carboxylcytosine', '5_formylcytosine', '5_hydroxymethylcytosine', '5_methylcytosine', '7SL_SINE_retrotransposon', '8_oxoadenine', '8_oxoguanine', 'AACCCT_box', 'AFLP_fragment', 'AP_1_binding_site', 'ARIA', 'ARRET', 'ARS', 'ARS_consensus_sequence', 'ASPE_primer', 'AUG_initiated_uORF', 'AU_rich_element', 'A_box', 'A_box_type_1', 'A_box_type_2', 'A_minor_RNA_motif', 'A_to_C_transversion', 'A_to_G_transition', 'A_to_T_transversion', 'Ace2_UAS', 'Alu_deletion', 'Alu_insertion', 'BAC', 'BAC_cloned_genomic_insert', 'BAC_end', 'BAC_read_contig', 'BREd_motif', 'BREu_motif', 'B_box', 'Bel_Pao_LTR_retrotransposon', 'Bruno_response_element', 'C-D_H_ACA_box_scaRNA', 'C-D_H_ACA_box_scaRNA_gene', 'CAAT_signal', 'CAAX_box', 'CACTA_TIR_transposon', 'CAGE_cluster', 'CAGE_tag', 'CArG_box', 'CCAAT_motif', 'CCA_tail', 'CDRE_motif', 'CDS', 'CDS_extension', 'CDS_five_prime_extension', 'CDS_fragment', 'CDS_independently_known', 'CDS_predicted', 'CDS_region', 'CDS_supported_by_EST_or_cDNA_data', 'CDS_supported_by_domain_match_data', 'CDS_supported_by_peptide_spectrum_match', 'CDS_supported_by_sequence_similarity_data', 'CDS_three_prime_extension', 'CRE', 'CRISPR', 'CSL_response_element', 'CTCF_binding_site', 'CTG_start_codon', 'C_D_box_scaRNA', 'C_D_box_scaRNA_gene', 'C_D_box_snoRNA', 'C_D_box_snoRNA_gene', 'C_D_box_snoRNA_primary_transcript', 'C_box', 'C_cluster', 'C_gene_segment', 'C_region', 'C_to_A_transversion', 'C_to_G_transversion', 'C_to_T_transition', 'C_to_T_transition_at_pCpG_site', 'ChIP_seq_region', 'Copia_LTR_retrotransposon', 'CpG_island', 'Crick_strand', 'Crypton_YR_transposon', 'CsrB_RsmB_RNA', 'CuRE', 'DArT_marker', 'DCE', 'DCE_SI', 'DCE_SII', 'DCE_SIII', 'DDB_box', 'DHU_loop', 'DIRS_YR_retrotransposon', 'DJ_C_cluster', 'DJ_J_C_cluster', 'DJ_J_cluster', 'DJ_gene_segment', 'DMv1_motif', 'DMv2_motif', 'DMv3_motif', 'DMv4_motif', 'DMv5_motif', 'DNA_aptamer', 'DNA_binding_site', 'DNA_chromosome', 'DNA_constraint_sequence', 'DNA_loop', 'DNA_loop_anchor', 'DNA_motif', 'DNA_sequence_secondary_structure', 'DNA_transposon', 'DNAzyme', 'DNaseI_hypersensitive_site', 'DPE1_motif', 'DPE_motif', 'DRE', 'DRE_motif', 'DSR_motif', 'D_DJ_C_cluster', 'D_DJ_J_C_cluster', 'D_DJ_J_cluster', 'D_DJ_cluster', 'D_J_C_cluster', 'D_J_cluster', 'D_cluster', 'D_gene_recombination_feature', 'D_gene_segment', 'D_loop', 'DsrA_RNA', 'ER_retention_signal', 'EST', 'EST_match', 'E_box_motif', 'Endogenous_Retrovirus_LTR_retrotransposon', 'FLEX_element', 'FRE', 'FRT_site', 'GAGA_motif', 'GATA_box', 'GC_rich_promoter_region', 'GNA_oligo', 'GTT_trinucleotide_repeat', 'GT_dinucleotide_repeat', 'G_box', 'G_quartet', 'G_to_A_transition', 'G_to_C_transversion', 'G_to_T_transversion', 'GcvB_RNA', 'Gypsy_LTR_retrotransposon', 'H2AK5_acetylation_site', 'H2AK9_acetylation_site', 'H2AZK11_acetylation_site', 'H2AZK13_acetylation_site', 'H2AZK15_acetylation_site', 'H2AZK4_acetylation_site', 'H2AZK7_acetylation_site', 'H2BK120_acetylation_site', 'H2BK12_acetylation_site', 'H2BK15_acetylation_site', 'H2BK20_acetylation_site', 'H2BK5_acetylation_site', 'H2BK5_monomethylation_site', 'H2B_ubiquitination_site', 'H3K14_acetylation_site', 'H3K18_acetylation_site', 'H3K20_trimethylation_site', 'H3K23_acetylation_site', 'H3K23_dimethylation_site', 'H3K27_acetylation_site', 'H3K27_dimethylation_site', 'H3K27_methylation_site', 'H3K27_monomethylation_site', 'H3K27_trimethylation_site', 'H3K36_acetylation_site', 'H3K36_dimethylation_site', 'H3K36_methylation_site', 'H3K36_monomethylation_site', 'H3K36_trimethylation_site', 'H3K4_acetylation_site', 'H3K4_dimethylation_site', 'H3K4_methylation_site', 'H3K4_monomethylation_site', 'H3K4_trimethylation', 'H3K56_acetylation_site', 'H3K79_dimethylation_site', 'H3K79_methylation_site', 'H3K79_monomethylation_site', 'H3K79_trimethylation_site', 'H3K9_acetylation_site', 'H3K9_dimethylation_site', 'H3K9_methylation_site', 'H3K9_monomethylation_site', 'H3K9_trimethylation_site', 'H3R2_dimethylation_site', 'H3R2_monomethylation_site', 'H4K12_acetylation_site', 'H4K16_acetylation_site', 'H4K20_monomethylation_site', 'H4K4_trimethylation_site', 'H4K5_acetylation_site', 'H4K8_acetylation_site', 'H4K91_acetylation_site', 'H4K_acylation_region', 'H4R3_dimethylation_site', 'HERV_deletion', 'HERV_insertion', 'HSE', 'H_ACA_box_scaRNA', 'H_ACA_box_scaRNA_gene', 'H_ACA_box_snoRNA', 'H_ACA_box_snoRNA_gene', 'H_ACA_box_snoRNA_primary_transcript', 'H_pseudoknot', 'Hoogsteen_base_pair', 'I-box', 'IG_C_gene', 'IG_C_pseudogene', 'IG_D_gene', 'IG_J_gene', 'IG_J_pseudogene', 'IG_V_gene', 'IG_V_pseudogene', 'INR1_motif', 'INR_motif', 'IRLinv_site', 'IRRinv_site', 'ISRE', 'I_LINE_retrotransposon', 'J_C_cluster', 'J_cluster', 'J_gene_recombination_feature', 'J_gene_segment', 'J_heptamer', 'J_nonamer', 'J_spacer', 'Jockey_LINE_retrotransposon', 'KEN_box', 'K_turn_RNA_motif', 'L1_LINE_retrotransposon', 'LARD', 'LINE1_deletion', 'LINE1_insertion', 'LINE_element', 'LNA_oligo', 'LOZ1_response_element', 'LTR_component', 'LTR_retrotransposon', 'L_box', 'MCB', 'MITE', 'MNP', 'MNV', 'MNV_artifact', 'MTE', 'Mat2P', 'Mat3M', 'Merlin_TIR_transposon', 'MicF_RNA', 'Mutator_TIR_transposon', 'N2_2_prime_O_dimethylguanosine', 'N2_7_2prirme_O_trimethylguanosine', 'N2_7_dimethylguanosine', 'N2_N2_2_prime_O_trimethylguanosine', 'N2_N2_7_trimethylguanosine', 'N2_N2_dimethylguanosine', 'N2_methylguanosine', 'N4_2_prime_O_dimethylcytidine', 'N4_N4_2_prime_O_trimethylcytidine', 'N4_acetyl_2_prime_O_methylcytidine', 'N4_acetylcytidine', 'N4_methylcytidine', 'N6_2_prime_O_dimethyladenosine', 'N6_N6_2_prime_O_trimethyladenosine', 'N6_N6_dimethyladenosine', 'N6_acetyladenosine', 'N6_cis_hydroxyisopentenyl_adenosine', 'N6_glycinylcarbamoyladenosine', 'N6_hydroxynorvalylcarbamoyladenosine', 'N6_isopentenyladenosine', 'N6_methyl_N6_threonylcarbamoyladenosine', 'N6_methyladenine', 'N6_methyladenosine', 'N6_threonylcarbamoyladenosine', 'NDM2_motif', 'NDM3_motif', 'NMD_polymorphic_pseudogene_transcript', 'NMD_transcript', 'NSD_transcript', 'N_region', 'Ngaro_YR_retrotransposon', 'ORF', 'Okazaki_fragment', 'OxyS_RNA', 'PAC', 'PAC_end', 'PCB', 'PCR_product', 'PIF_Harbinger_TIR_transposon', 'PIP_box', 'PNA_oligo', 'PSE_motif', 'P_TIR_transposon', 'Penelope_retrotransposon', 'Phage_RNA_Polymerase_Promoter', 'Pho7_binding_site', 'QTL', 'R2_LINE_retrotransposon', 'RAPD', 'RFLP_fragment', 'RH_map', 'RNA_6S', 'RNA_7SK', 'RNA_7SK_gene', 'RNA_aptamer', 'RNA_chromosome', 'RNA_hook_turn', 'RNA_internal_loop', 'RNA_junction_loop', 'RNA_motif', 'RNA_polymerase_III_TATA_box', 'RNA_polymerase_II_TATA_box', 'RNA_sequence_secondary_structure', 'RNA_stability_element', 'RNA_thermometer', 'RNAi_reagent', 'RNApol_III_promoter', 'RNApol_III_promoter_type_1', 'RNApol_III_promoter_type_2', 'RNApol_III_promoter_type_3', 'RNApol_II_core_promoter', 'RNApol_II_promoter', 'RNApol_I_promoter', 'RNase_MRP_RNA', 'RNase_MRP_RNA_gene', 'RNase_P_RNA', 'RNase_P_RNA_gene', 'RRE_RNA', 'RR_tract', 'RST', 'RST_match', 'RTE_LINE_retrotransposon', 'R_GNA_oligo', 'R_LTR_region', 'R_five_prime_LTR_region', 'R_three_prime_LTR_region', 'Retrovirus_LTR_retrotransposon', 'Robertsonian_fusion', 'RprA_RNA', 'SAGE_tag', 'SECIS_element', 'SHP_box', 'SINE_element', 'SL10_acceptor_site', 'SL11_acceptor_site', 'SL12_acceptor_site', 'SL1_acceptor_site', 'SL2_acceptor_site', 'SL3_acceptor_site', 'SL4_acceptor_site', 'SL5_acceptor_site', 'SL6_acceptor_site', 'SL7_acceptor_site', 'SL8_acceptor_site', 'SL9_acceptor_site', 'SNP', 'SNV', 'SNV_artifact', 'SP6_RNA_Polymerase_Promoter', 'SRP_RNA', 'SRP_RNA_gene', 'SRP_RNA_primary_transcript', 'STREP_motif', 'STS', 'STS_map', 'SUMO_interaction_motif', 'SVA_deletion', 'SVA_insertion', 'S_GNA_oligo', 'S_region', 'Sap1_recognition_motif', 'Shine_Dalgarno_sequence', 'T3_RNA_Polymerase_Promoter', 'T7_RNA_Polymerase_Promoter', 'TATA_box', 'TCS_element', 'TCT_motif', 'TERRA', 'TFRS_collection', 'TFRS_module', 'TF_binding_site', 'TNA_oligo', 'TRIM', 'TR_C_Gene', 'TR_D_Gene', 'TR_J_Gene', 'TR_J_pseudogene', 'TR_V_Gene', 'TR_V_pseudogene', 'TR_box', 'TSS', 'T_cell_receptor_gene', 'T_cell_receptor_pseudogene', 'T_loop', 'T_to_A_transversion', 'T_to_C_transition', 'T_to_G_transversion', 'Tc1_Mariner_TIR_transposon', 'Transib_TIR_transposon', 'U11_snRNA', 'U12_intron', 'U12_snRNA', 'U14_snoRNA', 'U14_snoRNA_gene', 'U14_snoRNA_primary_transcript', 'U1_snRNA', 'U2_intron', 'U2_snRNA', 'U3_LTR_region', 'U3_five_prime_LTR_region', 'U3_snoRNA', 'U3_snoRNA_gene', 'U3_three_prime_LTR_region', 'U4_snRNA', 'U4atac_snRNA', 'U5_LTR_region', 'U5_five_prime_LTR_region', 'U5_snRNA', 'U5_three_prime_LTR_region', 'U6_snRNA', 'U6atac_snRNA', 'U7_snRNA', 'UAA_stop_codon_signal', 'UAG_stop_codon_signal', 'UGA_stop_codon_signal', 'UNAAAC_motif', 'UPD', 'UST', 'UST_match', 'UTR', 'UTR_intron', 'UTR_region', 'U_box', 'VDJ_C_cluster', 'VDJ_J_C_cluster', 'VDJ_J_cluster', 'VDJ_gene_segment', 'VD_gene_segment', 'VJ_C_cluster', 'VJ_J_C_cluster', 'VJ_J_cluster', 'VJ_gene_segment', 'V_DJ_C_cluster', 'V_DJ_J_C_cluster', 'V_DJ_J_cluster', 'V_DJ_cluster', 'V_D_DJ_C_cluster', 'V_D_DJ_J_C_cluster', 'V_D_DJ_J_cluster', 'V_D_DJ_cluster', 'V_D_J_C_cluster', 'V_D_J_cluster', 'V_J_C_cluster', 'V_J_cluster', 'V_VDJ_C_cluster', 'V_VDJ_J_C_cluster', 'V_VDJ_J_cluster', 'V_VDJ_cluster', 'V_VJ_C_cluster', 'V_VJ_J_C_cluster', 'V_VJ_J_cluster', 'V_VJ_cluster', 'V_cluster', 'V_gene_recombination_feature', 'V_gene_segment', 'V_heptamer', 'V_nonamer', 'V_region', 'V_spacer', 'Viper_YR_retrotransposon', 'WC_base_pair', 'W_region', 'Watson_strand', 'X_element', 'X_element_combinatorial_repeat', 'X_region', 'YAC', 'YAC_end', 'YR_retrotransposon', 'Y_RNA', 'Y_RNA_gene', 'Y_RNA_primary_transcript', 'Y_prime_element', 'Y_region', 'Z1_region', 'Z2_region', 'Zas1_recognition_motif', 'aberrant_processed_transcript', 'accessible_DNA_region', 'active_peptide', 'adaptive_island', 'alanine', 'alanine_tRNA_primary_transcript', 'alanyl_tRNA', 'allelic_pseudogene', 'allelic_pseudogenic_rRNA', 'allelic_pseudogenic_tRNA', 'allelically_excluded_gene', 'alpha_beta_motif', 'alpha_helix', 'alternate_sequence_site', 'alternatively_spliced_transcript', 'amber_stop_codon', 'ambisense_ssRNA_viral_sequence', 'amino_acid', 'amplification_origin', 'anchor_binding_site', 'anchor_region', 'androgen_response_element', 'anti_ARRET', 'anticodon', 'anticodon_loop', 'antiparallel_beta_strand', 'antisense_RNA', 'antisense_lncRNA', 'antisense_lncRNA_gene', 'antisense_primary_transcript', 'apicoplast_chromosome', 'apicoplast_gene', 'aptamer', 'archaeal_intron', 'archaeosine', 'arginine', 'arginine_tRNA_primary_transcript', 'arginyl_tRNA', 'asparagine', 'asparagine_tRNA_primary_transcript', 'asparaginyl_tRNA', 'aspartic_acid', 'aspartic_acid_tRNA_primary_transcript', 'aspartyl_tRNA', 'assembly', 'assembly_component', 'assembly_error_correction', 'asx_motif', 'asx_turn', 'asx_turn_left_handed_type_one', 'asx_turn_left_handed_type_two', 'asx_turn_right_handed_type_one', 'asx_turn_right_handed_type_two', 'asymmetric_RNA_internal_loop', 'attB_site', 'attC_site', 'attCtn_site', 'attI_site', 'attL_site', 'attP_site', 'attR_site', 'attenuator', 'autocatalytically_spliced_intron', 'bacterial_RNApol_promoter', 'bacterial_RNApol_promoter_sigma54_element', 'bacterial_RNApol_promoter_sigma_70_element', 'bacterial_RNApol_promoter_sigma_ecf_element', 'bacterial_terminator', 'base', 'base_call_error_correction', 'base_pair', 'beta_bulge', 'beta_bulge_loop', 'beta_bulge_loop_five', 'beta_bulge_loop_six', 'beta_strand', 'beta_turn', 'beta_turn_left_handed_type_one', 'beta_turn_left_handed_type_two', 'beta_turn_right_handed_type_one', 'beta_turn_right_handed_type_two', 'beta_turn_type_eight', 'beta_turn_type_six', 'beta_turn_type_six_a', 'beta_turn_type_six_a_one', 'beta_turn_type_six_a_two', 'beta_turn_type_six_b', 'bidirectional_promoter', 'bidirectional_promoter_lncRNA', 'binding_site', 'biochemical_region_of_peptide', 'biological_region', 'biomaterial_region', 'biosynthetic_gene_cluster', 'blocked_reading_frame', 'blunt_end_restriction_enzyme_cleavage_junction', 'blunt_end_restriction_enzyme_cleavage_site', 'boundary_element', 'branch_site', 'cDNA_clone', 'cDNA_match', 'c_terminal_region', 'candidate_gene', 'canonical_five_prime_splice_site', 'canonical_three_prime_splice_site', 'cap', 'capped_mRNA', 'capped_primary_transcript', 'cassette_pseudogene', 'catalytic_residue', 'catmat_left_handed_four', 'catmat_left_handed_three', 'catmat_right_handed_four', 'catmat_right_handed_three', 'central_hydrophobic_region_of_signal_peptide', 'centromere', 'centromere_DNA_Element_I', 'centromere_DNA_Element_II', 'centromere_DNA_Element_III', 'centromeric_repeat', 'chimeric_cDNA_clone', 'chloroplast_DNA_read', 'chloroplast_chromosome', 'chromatin_regulatory_region', 'chromoplast_chromosome', 'chromoplast_gene', 'chromosomal_regulatory_element', 'chromosomal_structural_element', 'chromosomal_translocation', 'chromosome', 'chromosome_arm', 'chromosome_band', 'chromosome_breakage_sequence', 'chromosome_breakpoint', 'chromosome_part', 'circular_double_stranded_DNA_chromosome', 'circular_double_stranded_RNA_chromosome', 'circular_mRNA', 'circular_ncRNA', 'circular_plasmid', 'circular_single_stranded_DNA_chromosome', 'circular_single_stranded_RNA_chromosome', 'cis_acting_homologous_chromosome_pairing_region', 'cis_regulatory_frameshift_element', 'cis_regulatory_module', 'cis_splice_site', 'class_II_RNA', 'class_I_RNA', 'cleaved_for_gpi_anchor_region', 'cleaved_initiator_methionine', 'cleaved_peptide_region', 'clip', 'clone', 'clone_end', 'clone_insert', 'clone_insert_end', 'clone_insert_start', 'cloned_cDNA_insert', 'cloned_genomic_insert', 'cloned_region', 'coding_conserved_region', 'coding_end', 'coding_exon', 'coding_region_of_exon', 'coding_start', 'coding_transcript_with_retained_intron', 'codon', 'coiled_coil', 'cointegrated_plasmid', 'common_fragile_site', 'complex_chromosomal_rearrangement', 'complex_operon', 'complex_regulon', 'complex_structural_alteration', 'complex_substitution', 'compositionally_biased_region_of_peptide', 'conformational_switch', 'conjugative_transposon', 'consensus_AFLP_fragment', 'consensus_gDNA', 'consensus_mRNA', 'consensus_region', 'conserved_region', 'constitutive_promoter', 'contig', 'contig_collection', 'contig_read', 'copy_number_gain', 'copy_number_loss', 'copy_number_variation', 'core_eukaryotic_promoter_element', 'core_prokaryotic_promoter_element', 'core_promoter_element', 'core_viral_promoter_element', 'cosmid', 'cross_genome_match', 'cryptic_gene', 'cryptic_promoter', 'cryptic_prophage', 'cryptic_splice_site', 'cryptogene', 'ct_gene', 'cyanelle_chromosome', 'cyanelle_gene', 'cyclic_translocation', 'cysteine', 'cysteine_tRNA_primary_transcript', 'cysteinyl_tRNA', 'cytoplasmic_polypeptide_region', 'cytosolic_16S_rRNA', 'cytosolic_18S_rRNA', 'cytosolic_23S_rRNA', 'cytosolic_25S_rRNA', 'cytosolic_28S_rRNA', 'cytosolic_2S_rRNA', 'cytosolic_5S_rRNA', 'cytosolic_5_8S_rRNA', 'cytosolic_LSU_rRNA', 'cytosolic_LSU_rRNA_gene', 'cytosolic_SSU_rRNA', 'cytosolic_SSU_rRNA_gene', 'cytosolic_rRNA', 'cytosolic_rRNA_16S_gene', 'cytosolic_rRNA_18S_gene', 'cytosolic_rRNA_23S_gene', 'cytosolic_rRNA_25S_gene', 'cytosolic_rRNA_28S_gene', 'cytosolic_rRNA_2S_gene', 'cytosolic_rRNA_5S_gene', 'cytosolic_rRNA_5_8S_gene', 'cytosolic_rRNA_gene', 'dCAPS_primer', 'databank_entry', 'decayed_exon', 'defective_conjugative_transposon', 'deficient_translocation', 'deletion', 'deletion_artifact', 'deletion_breakpoint', 'deletion_junction', 'delins', 'destruction_box', 'dg_repeat', 'dh_repeat', 'dicistronic_mRNA', 'dicistronic_primary_transcript', 'dicistronic_transcript', 'dif_site', 'dihydrouridine', 'dinucleotide_repeat_microsatellite_feature', 'direct_repeat', 'direct_tandem_duplication', 'disabled_reading_frame', 'dispersed_repeat', 'distal_duplication', 'distal_promoter_element', 'distant_three_prime_recoding_signal', 'double_stranded_DNA_chromosome', 'double_stranded_RNA_chromosome', 'ds_DNA_viral_sequence', 'ds_RNA_viral_sequence', 'ds_oligo', 'duplicated_pseudogene', 'duplication', 'duplication_artifact', 'dye_terminator_read', 'early_origin_of_replication', 'edited_CDS', 'edited_mRNA', 'edited_transcript', 'edited_transcript_by_A_to_I_substitution', 'edited_transcript_feature', 'editing_block', 'editing_domain', 'endogenous_retroviral_gene', 'endonuclease_spliced_intron', 'endosomal_localization_signal', 'engineered_episome', 'engineered_foreign_gene', 'engineered_foreign_region', 'engineered_foreign_repetitive_element', 'engineered_foreign_transposable_element', 'engineered_foreign_transposable_element_gene', 'engineered_fusion_gene', 'engineered_gene', 'engineered_insert', 'engineered_plasmid', 'engineered_region', 'engineered_rescue_region', 'engineered_tag', 'engineered_transposable_element', 'enhancer', 'enhancerRNA', 'enhancer_binding_site', 'enhancer_blocking_element', 'enhancer_bound_by_factor', 'enhancer_trap_construct', 'enzymatic_RNA', 'enzymatic_RNA_gene', 'epigenetically_modified_gene', 'epigenetically_modified_region', 'epigenomically_modified_region', 'episome', 'epitope', 'epoxyqueuosine', 'eukaryotic_promoter', 'eukaryotic_terminator', 'exemplar_mRNA', 'exon', 'exon_junction', 'exon_of_single_exon_gene', 'exon_region', 'exonic_splice_enhancer', 'exonic_splicing_silencer', 'experimental_feature', 'experimental_result_region', 'experimentally_defined_binding_region', 'expressed_sequence_assembly', 'expressed_sequence_match', 'extended_cis_splice_site', 'extended_intronic_splice_region', 'external_transcribed_spacer_region', 'extrachromosomal_mobile_genetic_element', 'extramembrane_polypeptide_region', 'fingerprint_map', 'five_aminomethyl_two_thiouridine', 'five_carbamoylmethyl_two_prime_O_methyluridine', 'five_carbamoylmethyluridine', 'five_carboxyhydroxymethyl_uridine', 'five_carboxyhydroxymethyl_uridine_methyl_ester', 'five_carboxymethylaminomethyl_two_prime_O_methyluridine', 'five_carboxymethylaminomethyl_two_thiouridine', 'five_carboxymethylaminomethyluridine', 'five_carboxymethyluridine', 'five_formyl_two_prime_O_methylcytidine', 'five_formylcytidine', 'five_hydroxymethylcytidine', 'five_hydroxyuridine', 'five_isopentenylaminomethyl_two_prime_O_methyluridine', 'five_isopentenylaminomethyl_two_thiouridine', 'five_isopentenylaminomethyl_uridine', 'five_methoxycarbonylmethyl_two_prime_O_methyluridine', 'five_methoxycarbonylmethyl_two_thiouridine', 'five_methoxycarbonylmethyluridine', 'five_methoxyuridine', 'five_methyl_2_thiouridine', 'five_methylaminomethyl_two_selenouridine', 'five_methylaminomethyl_two_thiouridine', 'five_methylaminomethyluridine', 'five_methylcytidine', 'five_methyldihydrouridine', 'five_methyluridine', 'five_prime_D_heptamer', 'five_prime_D_nonamer', 'five_prime_D_recombination_signal_sequence', 'five_prime_D_spacer', 'five_prime_EST', 'five_prime_LTR', 'five_prime_LTR_component', 'five_prime_RST', 'five_prime_UST', 'five_prime_UTR', 'five_prime_UTR_intron', 'five_prime_cis_splice_site', 'five_prime_clip', 'five_prime_coding_exon', 'five_prime_coding_exon_coding_region', 'five_prime_coding_exon_noncoding_region', 'five_prime_flanking_region', 'five_prime_intron', 'five_prime_noncoding_exon', 'five_prime_open_reading_frame', 'five_prime_recoding_site', 'five_prime_restriction_enzyme_junction', 'five_prime_sticky_end_restriction_enzyme_cleavage_site', 'five_prime_terminal_inverted_repeat', 'five_taurinomethyl_two_thiouridine', 'five_taurinomethyluridine', 'five_two_prime_O_dimethylcytidine', 'five_two_prime_O_dimethyluridine', 'flanking_region', 'flanking_repeat', 'flanking_three_prime_quadruplet_recoding_signal', 'floxed_gene', 'foldback_element', 'foreign_gene', 'foreign_transposable_element', 'forkhead_motif', 'forward_primer', 'fosmid', 'four_bp_start_codon', 'four_demethylwyosine', 'four_thiouridine', 'fragile_site', 'fragment_assembly', 'functional_candidate_gene', 'functional_gene_region', 'fusion_gene', 'gRNA_gene', 'galactosyl_queuosine', 'gamma_turn', 'gamma_turn_classic', 'gamma_turn_inverse', 'gap', 'gene', 'gene_array', 'gene_cassette', 'gene_cassette_array', 'gene_component_region', 'gene_fragment', 'gene_group', 'gene_member_region', 'gene_rearranged_at_DNA_level', 'gene_segment', 'gene_silenced_by_DNA_methylation', 'gene_silenced_by_DNA_modification', 'gene_silenced_by_RNA_interference', 'gene_silenced_by_histone_deacetylation', 'gene_silenced_by_histone_methylation', 'gene_silenced_by_histone_modification', 'gene_subarray', 'gene_trap_construct', 'gene_with_dicistronic_mRNA', 'gene_with_dicistronic_primary_transcript', 'gene_with_dicistronic_transcript', 'gene_with_edited_transcript', 'gene_with_mRNA_recoded_by_translational_bypass', 'gene_with_mRNA_with_frameshift', 'gene_with_non_canonical_start_codon', 'gene_with_polyadenylated_mRNA', 'gene_with_polycistronic_transcript', 'gene_with_recoded_mRNA', 'gene_with_start_codon_CUG', 'gene_with_stop_codon_read_through', 'gene_with_stop_codon_redefined_as_pyrrolysine', 'gene_with_stop_codon_redefined_as_selenocysteine', 'gene_with_trans_spliced_transcript', 'gene_with_transcript_with_translational_frameshift', 'genetic_marker', 'genomic_DNA_contig', 'genomic_DNA_read', 'genomic_clone', 'genomic_island', 'genomically_contaminated_cDNA_clone', 'glutamic_acid', 'glutamic_acid_tRNA_primary_transcript', 'glutamine', 'glutamine_tRNA_primary_transcript', 'glutaminyl_tRNA', 'glutamyl_tRNA', 'glycine', 'glycine_tRNA_primary_transcript', 'glycyl_tRNA', 'golden_path', 'golden_path_fragment', 'group_1_intron_homing_endonuclease_target_region', 'group_IIA_intron', 'group_IIB_intron', 'group_IIC_intron', 'group_III_intron', 'group_II_intron', 'group_I_intron', 'guide_RNA', 'guide_RNA_region', 'hAT_TIR_transposon', 'hammerhead_ribozyme', 'haplotype_block', 'helitron', 'helix_turn_helix', 'heptamer_of_recombination_feature_of_vertebrate_immune_system_gene', 'heritable_phenotypic_marker', 'high_identity_region', 'histidine', 'histidine_tRNA_primary_transcript', 'histidyl_tRNA', 'histone_2AZ_acetylation_site', 'histone_2A_acetylation_site', 'histone_2B_acetylation_site', 'histone_3_acetylation_site', 'histone_4_acetylation_site', 'histone_acetylation_site', 'histone_acylation_region', 'histone_binding_site', 'histone_methylation_site', 'histone_modification', 'histone_ubiqitination_site', 'homing_endonuclease_binding_site', 'homol_D_box', 'homol_E_box', 'homologous_chromosome_recognition_and_pairing_locus', 'homologous_region', 'hpRNA', 'hpRNA_gene', 'hydrophobic_region_of_peptide', 'hydroxywybutosine', 'iDNA', 'i_motif', 'immature_peptide_region', 'immunoglobulin_gene', 'immunoglobulin_pseudogene', 'immunoglobulin_region', 'imprinting_control_region', 'indel_artifact', 'inducible_promoter', 'inert_DNA_spacer', 'inosine', 'insertion', 'insertion_artifact', 'insertion_breakpoint', 'insertion_sequence', 'insertion_site', 'insulator', 'insulator_binding_site', 'integrated_mobile_genetic_element', 'integrated_plasmid', 'integration_excision_site', 'integron', 'intein', 'intein_encoding_region', 'interband', 'interchromosomal_breakpoint', 'interchromosomal_translocation', 'intergenic_region', 'interior_coding_exon', 'interior_exon', 'interior_intron', 'intermediate_element', 'internal_Shine_Dalgarno_sequence', 'internal_UTR', 'internal_eliminated_sequence', 'internal_guide_sequence', 'internal_ribosome_entry_site', 'internal_transcribed_spacer_region', 'intrachromosomal_breakpoint', 'intrachromosomal_translocation', 'intramembrane_polypeptide_region', 'intrinsically_unstructured_polypeptide_region', 'introgressed_chromosome_region', 'intron', 'intron_base_5', 'intron_domain', 'intronic_regulatory_region', 'intronic_splice_enhancer', 'intronic_splicing_silencer', 'invalidated_cDNA_clone', 'inversion', 'inversion_breakpoint', 'inversion_cum_translocation', 'inversion_site', 'inversion_site_part', 'inverted_intrachromosomal_transposition', 'inverted_repeat', 'inverted_tandem_duplication', 'iron_repressed_GATA_element', 'iron_responsive_element', 'isoleucine', 'isoleucine_tRNA_primary_transcript', 'isoleucyl_tRNA', 'isomiR', 'isowyosine', 'junction', 'kinetoplast_gene', 'knob', 'kozak_sequence', 'lambda_vector', 'lariat_intron', 'late_origin_of_replication', 'left_handed_peptide_helix', 'leucine', 'leucine_tRNA_primary_transcript', 'leucoplast_chromosome', 'leucoplast_gene', 'leucyl_tRNA', 'ligand_binding_site', 'ligation_based_read', 'lincRNA', 'lincRNA_gene', 'linear_double_stranded_DNA_chromosome', 'linear_double_stranded_RNA_chromosome', 'linear_plasmid', 'linear_single_stranded_DNA_chromosome', 'linear_single_stranded_RNA_chromosome', 'linkage_group', 'lipoprotein_signal_peptide', 'lncRNA', 'lncRNA_gene', 'lncRNA_primary_transcript', 'lncRNA_with_retained_intron', 'loR', 'locus_control_region', 'long_terminal_repeat', 'long_terminal_repeat_transcript', 'loop', 'low_complexity_region', 'loxP_site', 'lysidine', 'lysine', 'lysine_tRNA_primary_transcript', 'lysosomal_localization_signal', 'lysyl_tRNA', 'mRNA', 'mRNA_contig', 'mRNA_read', 'mRNA_recoded_by_codon_redefinition', 'mRNA_recoded_by_translational_bypass', 'mRNA_region', 'mRNA_with_frameshift', 'mRNA_with_minus_1_frameshift', 'mRNA_with_minus_2_frameshift', 'mRNA_with_plus_1_frameshift', 'mRNA_with_plus_2_frameshift', 'macronuclear_chromosome', 'macronucleus_destined_segment', 'major_TSS', 'mannosyl_queuosine', 'match', 'match_part', 'maternal_uniparental_disomy', 'maternally_imprinted_gene', 'mathematically_defined_repeat', 'mating_type_M_box', 'mating_type_region', 'mating_type_region_motif', 'mating_type_region_replication_fork_barrier', 'matrix_attachment_site', 'mature_protein_region', 'mature_protein_region_of_CDS', 'mature_transcript', 'mature_transcript_region', 'maxicircle', 'maxicircle_gene', 'meiotic_recombination_region', 'membrane_peptide_loop', 'membrane_structure', 'metabolic_island', 'metal_binding_site', 'methionine', 'methionine_tRNA_primary_transcript', 'methionyl_tRNA', 'methylated_DNA_base_feature', 'methylated_adenine', 'methylated_cytosine', 'methylation_guide_snoRNA', 'methylation_guide_snoRNA_gene', 'methylation_guide_snoRNA_primary_transcript', 'methylinosine', 'methylwyosine', 'miRNA', 'miRNA_antiguide', 'miRNA_gene', 'miRNA_loop', 'miRNA_primary_transcript', 'miRNA_primary_transcript_region', 'miRNA_stem', 'miRNA_target_site', 'miR_encoding_Y_RNA_primary_transcript', 'miR_encoding_lncRNA_primary_transcript', 'miR_encoding_shRNA_primary_transcript', 'miR_encoding_snoRNA_primary_transcript', 'miR_encoding_tRNA_primary_transcript', 'miR_encoding_vaultRNA_primary_transcript', 'miRtron', 'microarray_oligo', 'micronuclear_chromosome', 'microsatellite', 'mini_exon_donor_RNA', 'mini_gene', 'minicircle', 'minicircle_gene', 'minisatellite', 'minor_TSS', 'minus_10_signal', 'minus_12_signal', 'minus_1_translational_frameshift', 'minus_24_signal', 'minus_2_translational_frameshift', 'minus_35_signal', 'mitochondrial_DNA_read', 'mitochondrial_D_loop', 'mitochondrial_chromosome', 'mitochondrial_contig', 'mitochondrial_control_region', 'mitochondrial_supercontig', 'mitochondrial_targeting_signal', 'mitotic_recombination_region', 'moR', 'mobile_element_deletion', 'mobile_element_insertion', 'mobile_genetic_element', 'mobile_intron', 'modified_DNA_base', 'modified_L_alanine', 'modified_L_arginine', 'modified_L_asparagine', 'modified_L_aspartic_acid', 'modified_L_cysteine', 'modified_L_glutamic_acid', 'modified_L_glutamine', 'modified_L_histidine', 'modified_L_isoleucine', 'modified_L_leucine', 'modified_L_lysine', 'modified_L_methionine', 'modified_L_phenylalanine', 'modified_L_proline', 'modified_L_selenocysteine', 'modified_L_serine', 'modified_L_threonine', 'modified_L_tryptophan', 'modified_L_tyrosine', 'modified_L_valine', 'modified_RNA_base_feature', 'modified_adenine', 'modified_adenosine', 'modified_amino_acid_feature', 'modified_cytidine', 'modified_cytosine', 'modified_glycine', 'modified_guanine', 'modified_guanosine', 'modified_inosine', 'modified_uridine', 'molecular_contact_region', 'monocistronic_mRNA', 'monocistronic_primary_transcript', 'monocistronic_transcript', 'monomeric_repeat', 'morpholino_oligo', 'mt_LSU_rRNA', 'mt_LSU_rRNA_gene', 'mt_SSU_rRNA', 'mt_SSU_rRNA_gene', 'mt_gene', 'mt_rRNA', 'mt_rRNA_gene', 'mt_tRNA', 'multiplexing_sequence_identifier', 'mutated_variant_site', 'mutational_hotspot', 'n_terminal_region', 'natural_plasmid', 'natural_transposable_element', 'natural_variant_site', 'ncRNA', 'ncRNA_gene', 'nc_conserved_region', 'nc_primary_transcript', 'negative_sense_ssRNA_viral_sequence', 'negatively_autoregulated_gene', 'nested_repeat', 'nested_tandem_repeat', 'nested_transposon', 'no_output', 'no_sequence_alteration', 'non_AUG_initiated_uORF', 'non_LTR_retrotransposon', 'non_LTR_retrotransposon_polymeric_tract', 'non_adjacent_residues', 'non_allelic_homologous_recombination_region', 'non_canonical_five_prime_splice_site', 'non_canonical_start_codon', 'non_canonical_three_prime_splice_site', 'non_complimentary_stem', 'non_cytoplasmic_polypeptide_region', 'non_processed_pseudogene', 'non_terminal_residue', 'non_transcribed_region', 'nonamer_of_recombination_feature_of_vertebrate_immune_system_gene', 'noncoding_exon', 'noncoding_region_of_exon', 'novel_sequence_insertion', 'nuclear_chromosome', 'nuclear_export_signal', 'nuclear_gene', 'nuclear_localization_signal', 'nuclear_mt_pseudogene', 'nuclear_rim_localization_signal', 'nuclease_binding_site', 'nuclease_hypersensitive_site', 'nuclease_sensitive_site', 'nucleomorph_gene', 'nucleomorphic_chromosome', 'nucleotide_binding_site', 'nucleotide_cleavage_site', 'nucleotide_match', 'nucleotide_motif', 'nucleotide_to_protein_binding_site', 'ochre_stop_codon', 'octamer_motif', 'oligo', 'oligo_U_tail', 'one_methyl_three_three_amino_three_carboxypropyl_pseudouridine', 'one_methyladenosine', 'one_methylguanosine', 'one_methylinosine', 'one_methylpseudouridine', 'one_two_prime_O_dimethyladenosine', 'one_two_prime_O_dimethylguanosine', 'one_two_prime_O_dimethylinosine', 'opal_stop_codon', 'open_chromatin_region', 'operator', 'operon', 'oriC', 'oriT', 'oriV', 'origin_of_replication', 'orphan_CDS', 'orthologous_region', 'outron', 'overlapping_EST_set', 'overlapping_feature_set', 'paired_end_fragment', 'parallel_beta_strand', 'paralogous_region', 'partial_genomic_sequence_assembly', 'partially_processed_cDNA_clone', 'paternal_uniparental_disomy', 'paternally_imprinted_gene', 'pathogenic_island', 'peptide_coil', 'peptide_helix', 'peptide_localization_signal', 'peroxywybutosine', 'phage_sequence', 'phagemid', 'phenylalanine', 'phenylalanine_tRNA_primary_transcript', 'phenylalanyl_tRNA', 'pheromone_response_element', 'phosphorylation_site', 'piRNA', 'piRNA_gene', 'pi_helix', 'piggyBac_TIR_transposon', 'plasmid', 'plasmid_gene', 'plasmid_vector', 'plastid_LSU_rRNA', 'plastid_LSU_rRNA_gene', 'plastid_SSU_rRNA', 'plastid_SSU_rRNA_gene', 'plastid_gene', 'plastid_rRNA', 'plastid_rRNA_gene', 'plus_1_translational_frameshift', 'plus_2_translational_frameshift', 'point_centromere', 'point_mutation', 'polinton', 'polyA_primed_cDNA_clone', 'polyA_sequence', 'polyA_signal_sequence', 'polyA_site', 'polyA_site_cluster', 'polyadenylated_mRNA', 'polycistronic_mRNA', 'polycistronic_primary_transcript', 'polycistronic_transcript', 'polymerase_synthesis_read', 'polymorphic_pseudogene', 'polymorphic_pseudogene_processed_transcript', 'polymorphic_pseudogene_with_retained_intron', 'polypeptide', 'polypeptide_DNA_contact', 'polypeptide_binding_motif', 'polypeptide_calcium_ion_contact_site', 'polypeptide_catalytic_motif', 'polypeptide_cobalt_ion_contact_site', 'polypeptide_conserved_motif', 'polypeptide_conserved_region', 'polypeptide_copper_ion_contact_site', 'polypeptide_domain', 'polypeptide_iron_ion_contact_site', 'polypeptide_ligand_contact', 'polypeptide_magnesium_ion_contact_site', 'polypeptide_manganese_ion_contact_site', 'polypeptide_metal_contact', 'polypeptide_molybdenum_ion_contact_site', 'polypeptide_motif', 'polypeptide_nest_left_right_motif', 'polypeptide_nest_motif', 'polypeptide_nest_right_left_motif', 'polypeptide_nickel_ion_contact_site', 'polypeptide_region', 'polypeptide_repeat', 'polypeptide_secondary_structure', 'polypeptide_sequencing_information', 'polypeptide_structural_motif', 'polypeptide_structural_region', 'polypeptide_tungsten_ion_contact_site', 'polypeptide_turn_motif', 'polypeptide_variation_site', 'polypeptide_zinc_ion_contact_site', 'polypyrimidine_tract', 'positional_candidate_gene', 'positive_sense_ssRNA_viral_sequence', 'positively_autoregulated_gene', 'possible_assembly_error', 'possible_base_call_error', 'post_translationally_modified_region', 'post_translationally_regulated_gene', 'pre_edited_mRNA', 'pre_edited_region', 'pre_miRNA', 'predicted_gene', 'predicted_transcript', 'presence_absence_variation', 'priRNA', 'primary_transcript', 'primary_transcript_region', 'primer', 'primer_binding_site', 'primer_match', 'probe', 'processed_pseudogene', 'processed_pseudogenic_rRNA', 'processed_pseudogenic_tRNA', 'processed_transcript', 'prokaryotic_promoter', 'proline', 'proline_tRNA_primary_transcript', 'prolyl_tRNA', 'promoter', 'promoter_element', 'promoter_flanking_region', 'promoter_targeting_sequence', 'promoter_trap_construct', 'propeptide', 'propeptide_cleavage_site', 'propeptide_region_of_CDS', 'prophage', 'proplastid_gene', 'protease_site', 'protein_binding_site', 'protein_coding_gene', 'protein_coding_primary_transcript', 'protein_hmm_match', 'protein_match', 'protein_protein_contact', 'protein_stability_element', 'proviral_gene', 'proviral_region', 'proximal_promoter_element', 'pseudogene', 'pseudogene_by_unequal_crossing_over', 'pseudogene_processed_transcript', 'pseudogenic_CDS', 'pseudogenic_exon', 'pseudogenic_gene_segment', 'pseudogenic_rRNA', 'pseudogenic_region', 'pseudogenic_tRNA', 'pseudogenic_transcript', 'pseudogenic_transcript_with_retained_intron', 'pseudoknot', 'pseudouridine', 'pseudouridylation_guide_snoRNA', 'pseudouridylation_guide_snoRNA_gene', 'pumilio_response_element', 'purine_to_pyrimidine_transversion', 'purine_transition', 'pyrimidine_to_purine_transversion', 'pyrimidine_transition', 'pyrosequenced_read', 'pyrrolysine', 'pyrrolysine_tRNA_primary_transcript', 'pyrrolysyl_tRNA', 'queuosine', 'rDNA_intergenic_spacer_element', 'rDNA_replication_fork_barrier', 'rRNA', 'rRNA_21S_gene', 'rRNA_cleavage_RNA', 'rRNA_cleavage_snoRNA_primary_transcript', 'rRNA_gene', 'rRNA_large_subunit_primary_transcript', 'rRNA_primary_transcript', 'rRNA_primary_transcript_region', 'rRNA_small_subunit_primary_transcript', 'rare_fragile_site', 'rasiRNA', 'read', 'read_pair', 'reading_frame', 'reagent', 'rearrangement_region', 'reciprocal_chromosomal_translocation', 'recoded_codon', 'recoded_mRNA', 'recoding_pseudoknot', 'recoding_stimulatory_region', 'recombination_enhancer', 'recombination_feature', 'recombination_feature_of_rearranged_gene', 'recombination_hotspot', 'recombination_regulatory_region', 'recombination_signal_sequence', 'recombinationally_inverted_gene', 'recombinationally_rearranged_gene', 'recombinationally_rearranged_vertebrate_immune_system_gene', 'recursive_splice_site', 'ref_miRNA', 'region', 'regional_centromere', 'regional_centromere_central_core', 'regional_centromere_inner_repeat_region', 'regional_centromere_outer_repeat_region', 'regional_centromere_outer_repeat_transcript', 'regulatory_promoter_element', 'regulatory_region', 'regulon', 'remark', 'repeat_component', 'repeat_fragment', 'repeat_instability_region', 'repeat_region', 'repeat_unit', 'replication_regulatory_region', 'replication_start_site', 'replicon', 'rescue_gene', 'rescue_mini_gene', 'rescue_region', 'resolution_site', 'response_element', 'restriction_enzyme_assembly_scar', 'restriction_enzyme_binding_site', 'restriction_enzyme_cleavage_junction', 'restriction_enzyme_five_prime_single_strand_overhang', 'restriction_enzyme_recognition_site', 'restriction_enzyme_region', 'restriction_enzyme_single_strand_overhang', 'restriction_enzyme_three_prime_single_strand_overhang', 'restriction_fragment', 'retinoic_acid_responsive_element', 'retrogene', 'retron', 'retrotransposon', 'reverse_Hoogsteen_base_pair', 'reverse_primer', 'rho_dependent_bacterial_terminator', 'rho_independent_bacterial_terminator', 'ribonuclease_site', 'ribosome_entry_site', 'riboswitch', 'ribothymidine', 'ribozyme', 'ribozyme_gene', 'right_handed_peptide_helix', 'sORF', 'sarcin_like_RNA_motif', 'satellite_DNA', 'sbRNA', 'sbRNA_gene', 'scRNA', 'scRNA_gene', 'scRNA_primary_transcript', 'scaRNA', 'scaRNA_gene', 'schellmann_loop', 'schellmann_loop_seven', 'schellmann_loop_six', 'selection_marker', 'selenocysteine', 'selenocysteine_tRNA_primary_transcript', 'selenocysteinyl_tRNA', 'self_cleaving_ribozyme', 'sense_intronic_ncRNA', 'sense_intronic_ncRNA_gene', 'sense_overlap_ncRNA', 'sense_overlap_ncRNA_gene', 'sequence_alteration', 'sequence_alteration_artifact', 'sequence_assembly', 'sequence_comparison', 'sequence_conflict', 'sequence_difference', 'sequence_feature', 'sequence_length_alteration', 'sequence_motif', 'sequence_rearrangement_feature', 'sequence_secondary_structure', 'sequence_uncertainty', 'sequencing_primer', 'serine', 'serine_tRNA_primary_transcript', 'serine_threonine_motif', 'serine_threonine_staple_motif', 'serine_threonine_turn', 'seryl_tRNA', 'seven_aminomethyl_seven_deazaguanosine', 'seven_cyano_seven_deazaguanosine', 'seven_deazaguanosine', 'seven_methylguanine', 'seven_methylguanosine', 'sgRNA', 'shRNA', 'shRNA_primary_transcript', 'shadow_enhancer', 'short_tandem_repeat_variation', 'siRNA', 'signal_anchor', 'signal_peptide', 'signal_peptide_region_of_CDS', 'signature', 'silenced_gene', 'silencer', 'silent_mating_type_cassette_array', 'simple_operon', 'simple_regulon', 'simple_sequence_length_variation', 'single_strand_restriction_enzyme_cleavage_site', 'single_stranded_DNA_chromosome', 'single_stranded_RNA_chromosome', 'sisRNA', 'site_specific_recombination_target_region', 'smFISH_probe', 'small_regulatory_ncRNA', 'snRNA', 'snRNA_gene', 'snRNA_primary_transcript', 'sncRNA', 'sncRNA_gene', 'snoRNA', 'snoRNA_gene', 'snoRNA_primary_transcript', 'solo_LTR', 'sonicate_fragment', 'specific_recombination_site', 'splice_enhancer', 'splice_junction', 'splice_region', 'splice_site', 'spliced_leader_RNA', 'spliceosomal_intron', 'spliceosomal_intron_region', 'splicing_regulatory_region', 'spot_42_RNA', 'spurious_protein', 'ss_RNA_viral_sequence', 'ss_oligo', 'st_turn_left_handed_type_one', 'st_turn_left_handed_type_two', 'st_turn_right_handed_type_one', 'st_turn_right_handed_type_two', 'start_codon', 'stem', 'stem_loop', 'stem_loop_region', 'sterol_regulatory_element', 'sticky_end_restriction_enzyme_cleavage_site', 'stop_codon', 'stop_codon_read_through', 'stop_codon_redefined_as_pyrrolysine', 'stop_codon_redefined_as_selenocysteine', 'stop_codon_signal', 'structural_alteration', 'substitution', 'substitution_artifact', 'subtelomere', 'sugar_edge_base_pair', 'supercontig', 'symbiosis_island', 'symmetric_RNA_internal_loop', 'syntenic_region', 'synthetic_oligo', 'tRNA', 'tRNA_SINE_retrotransposon', 'tRNA_gene', 'tRNA_intron', 'tRNA_primary_transcript', 'tRNA_region', 'tag', 'tandem_duplication', 'tandem_repeat', 'target_site_duplication', 'targeting_vector', 'tasiRNA', 'tasiRNA_primary_transcript', 'teb1_recognition_motif', 'telomerase_RNA', 'telomerase_RNA_gene', 'telomere', 'telomeric_D_loop', 'telomeric_repeat', 'telomeric_transcript', 'template_region', 'terminal_inverted_repeat', 'terminal_inverted_repeat_element', 'terminal_repeat', 'terminator', 'terminator_of_type_2_RNApol_III_promoter', 'tetraloop', 'tetranucleotide_repeat_microsatellite_feature', 'three_methylcytidine', 'three_methylpseudouridine', 'three_methyluridine', 'three_prime_D_heptamer', 'three_prime_D_nonamer', 'three_prime_D_recombination_signal_sequence', 'three_prime_D_spacer', 'three_prime_EST', 'three_prime_LTR', 'three_prime_LTR_component', 'three_prime_RACE_clone', 'three_prime_RST', 'three_prime_UST', 'three_prime_UTR', 'three_prime_UTR_intron', 'three_prime_cis_splice_site', 'three_prime_clip', 'three_prime_coding_exon', 'three_prime_coding_exon_coding_region', 'three_prime_coding_exon_noncoding_region', 'three_prime_flanking_region', 'three_prime_intron', 'three_prime_noncoding_exon', 'three_prime_overlapping_ncrna', 'three_prime_recoding_site', 'three_prime_repeat_recoding_signal', 'three_prime_restriction_enzyme_junction', 'three_prime_stem_loop_structure', 'three_prime_sticky_end_restriction_enzyme_cleavage_site', 'three_prime_terminal_inverted_repeat', 'three_ten_helix', 'three_three_amino_three_carboxypropyl_uridine', 'three_two_prime_O_dimethyluridine', 'threonine', 'threonine_tRNA_primary_transcript', 'threonyl_tRNA', 'tiling_path', 'tiling_path_clone', 'tiling_path_fragment', 'tmRNA', 'tmRNA_acceptor_piece', 'tmRNA_coding_piece', 'tmRNA_gene', 'tmRNA_primary_transcript', 'tmRNA_region', 'tnaORF', 'topologically_associated_domain', 'topologically_associated_domain_boundary', 'topologically_defined_region', 'trans_splice_acceptor_site', 'trans_splice_donor_site', 'trans_splice_junction', 'trans_splice_site', 'trans_spliced_mRNA', 'trans_spliced_transcript', 'transcribed_cluster', 'transcribed_fragment', 'transcribed_processed_pseudogene', 'transcribed_spacer_region', 'transcribed_unitary_pseudogene', 'transcribed_unprocessed_pseudogene', 'transcript', 'transcript_bound_by_nucleic_acid', 'transcript_bound_by_protein', 'transcript_region', 'transcript_with_translational_frameshift', 'transcription_end_site', 'transcription_factor_regulatory_site', 'transcription_pause_site', 'transcription_start_cluster', 'transcription_termination_signal', 'transcription_unit', 'transcriptional_cis_regulatory_region', 'transgene', 'transgenic_insertion', 'transgenic_transposable_element', 'transit_peptide', 'transit_peptide_region_of_CDS', 'transition', 'translated_nucleotide_match', 'translated_processed_pseudogene', 'translated_unprocessed_pseudogene', 'translation_regulatory_region', 'translational_frameshift', 'translationally_regulated_gene', 'translocation', 'translocation_breakpoint', 'translocation_element', 'transmembrane_helix', 'transmembrane_polypeptide_region', 'transposable_element', 'transposable_element_CDS', 'transposable_element_flanking_region', 'transposable_element_gene', 'transposable_element_insertion_site', 'transposable_element_pseudogene', 'transposon_fragment', 'transversion', 'trinucleotide_repeat_microsatellite_feature', 'tryptophan', 'tryptophan_tRNA_primary_transcript', 'tryptophanyl_tRNA', 'twintron', 'two_methyladenosine', 'two_methylthio_N6_cis_hydroxyisopentenyl_adenosine', 'two_methylthio_N6_hydroxynorvalyl_carbamoyladenosine', 'two_methylthio_N6_isopentenyladenosine', 'two_methylthio_N6_methyladenosine', 'two_methylthio_N6_threonyl_carbamoyladenosine', 'two_prime_O_methyladenosine', 'two_prime_O_methylcytidine', 'two_prime_O_methylguanosine', 'two_prime_O_methylinosine', 'two_prime_O_methylpseudouridine', 'two_prime_O_methyluridine', 'two_prime_O_ribosyladenosine_phosphate', 'two_prime_O_ribosylguanosine_phosphate', 'two_thio_two_prime_O_methyluridine', 'two_thiocytidine', 'two_thiouridine', 'tyrosine', 'tyrosine_tRNA_primary_transcript', 'tyrosyl_tRNA', 'uORF', 'ultracontig', 'unassigned_supercontig', 'unconfirmed_transcript', 'undermodified_hydroxywybutosine', 'unedited_region', 'unigene_cluster', 'unit_of_gene_expression', 'unitary_pseudogene', 'unitary_pseudogenic_rRNA', 'unitary_pseudogenic_tRNA', 'unprocessed_pseudogenic_rRNA', 'unprocessed_pseudogenic_tRNA', 'unspecified_indel', 'untranslated_region_polycistronic_mRNA', 'upstream_AUG_codon', 'uridine_five_oxyacetic_acid', 'uridine_five_oxyacetic_acid_methyl_ester', 'vacuolar_sorting_signal', 'validated_cDNA_clone', 'valine', 'valine_tRNA_primary_transcript', 'valyl_tRNA', 'vaultRNA_primary_transcript', 'vault_RNA', 'vault_RNA_gene', 'vector_replicon', 'vertebrate_immune_system_gene', 'vertebrate_immune_system_gene_recombination_feature', 'vertebrate_immune_system_gene_recombination_signal_feature', 'vertebrate_immune_system_gene_recombination_spacer', 'vertebrate_immune_system_pseudogene', 'vertebrate_immunoglobulin_T_cell_receptor_gene_cluster', 'vertebrate_immunoglobulin_T_cell_receptor_rearranged_gene_cluster', 'vertebrate_immunoglobulin_T_cell_receptor_rearranged_segment', 'vertebrate_immunoglobulin_T_cell_receptor_segment', 'viral_promoter', 'viral_sequence', 'virtual_sequence', 'wild_type_rescue_gene', 'wobble_base_pair', 'wybutosine', 'wyosine', 'zinc_finger_binding_site', 'zinc_repressed_element'];
	soSequenceTypes$1["default"] = soSequenceTypes;

	Object.defineProperty(CoreValidation$1, "__esModule", {
	  value: true
	});
	CoreValidation$1.CoreValidation = void 0;
	CoreValidation$1.isTypeChange = isTypeChange;
	var tslib_1$2 = require$$0$1;
	var Validation_1$1 = Validation$1;
	var soSequenceTypes_1 = /*#__PURE__*/tslib_1$2.__importDefault(soSequenceTypes$1);
	function isTypeChange(thing) {
	  return 'oldType' in thing && 'newType' in thing;
	}
	var CoreValidation = /*#__PURE__*/function (_Validation_1$Validat) {
	  _inherits(CoreValidation, _Validation_1$Validat);
	  var _super = /*#__PURE__*/_createSuper(CoreValidation);
	  function CoreValidation() {
	    var _this;
	    _classCallCheck(this, CoreValidation);
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    _this = _super.call.apply(_super, [this].concat(args));
	    _defineProperty(_assertThisInitialized(_this), "name", 'Core');
	    return _this;
	  }
	  _createClass(CoreValidation, [{
	    key: "frontendPreValidate",
	    value: function () {
	      var _frontendPreValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(change) {
	        var _iterator, _step, subChange;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              if (!isTypeChange(change)) {
	                _context.next = 18;
	                break;
	              }
	              _iterator = _createForOfIteratorHelper(change.changes);
	              _context.prev = 2;
	              _iterator.s();
	            case 4:
	              if ((_step = _iterator.n()).done) {
	                _context.next = 10;
	                break;
	              }
	              subChange = _step.value;
	              if (soSequenceTypes_1["default"].includes(subChange.newType)) {
	                _context.next = 8;
	                break;
	              }
	              return _context.abrupt("return", {
	                validationName: this.name,
	                error: {
	                  message: "\"".concat(subChange.newType, "\" is not a valid SO sequence_feature term")
	                }
	              });
	            case 8:
	              _context.next = 4;
	              break;
	            case 10:
	              _context.next = 15;
	              break;
	            case 12:
	              _context.prev = 12;
	              _context.t0 = _context["catch"](2);
	              _iterator.e(_context.t0);
	            case 15:
	              _context.prev = 15;
	              _iterator.f();
	              return _context.finish(15);
	            case 18:
	              return _context.abrupt("return", {
	                validationName: this.name
	              });
	            case 19:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this, [[2, 12, 15, 18]]);
	      }));
	      function frontendPreValidate(_x) {
	        return _frontendPreValidate.apply(this, arguments);
	      }
	      return frontendPreValidate;
	    }()
	  }, {
	    key: "possibleValues",
	    value: function () {
	      var _possibleValues = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key) {
	        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	          while (1) switch (_context2.prev = _context2.next) {
	            case 0:
	              if (!(key === 'type')) {
	                _context2.next = 2;
	                break;
	              }
	              return _context2.abrupt("return", soSequenceTypes_1["default"]);
	            case 2:
	              return _context2.abrupt("return");
	            case 3:
	            case "end":
	              return _context2.stop();
	          }
	        }, _callee2);
	      }));
	      function possibleValues(_x2) {
	        return _possibleValues.apply(this, arguments);
	      }
	      return possibleValues;
	    }()
	  }]);
	  return CoreValidation;
	}(Validation_1$1.Validation);
	CoreValidation$1.CoreValidation = CoreValidation;

	var ParentChildValidation$1 = {};

	var util$1 = {};

	Object.defineProperty(util$1, "__esModule", {
	  value: true
	});
	util$1.splitStringIntoChunks = splitStringIntoChunks;
	util$1.getPrintableId = getPrintableId;
	function splitStringIntoChunks(input, chunkSize) {
	  var chunks = [];
	  for (var i = 0; i < input.length; i += chunkSize) {
	    var chunk = input.slice(i, i + chunkSize);
	    chunks.push(chunk);
	  }
	  return chunks;
	}
	function getPrintableId(feature) {
	  var _ff$attributes$get, _ff$attributes$get2;
	  var ff = feature;
	  var gff_id = (_ff$attributes$get = ff.attributes.get('gff_id')) === null || _ff$attributes$get === void 0 ? void 0 : _ff$attributes$get.join(',');
	  if (gff_id) {
	    return "ID=".concat(gff_id, " (_id: ").concat(feature._id.toString(), ")");
	  }
	  var gff_name = (_ff$attributes$get2 = ff.attributes.get('gff_name')) === null || _ff$attributes$get2 === void 0 ? void 0 : _ff$attributes$get2.join(',');
	  if (gff_name) {
	    return "Name=".concat(gff_name, " (_id: ").concat(feature._id.toString(), ")");
	  }
	  return "_id: ".concat(feature._id.toString());
	}

	/* eslint-disable @typescript-eslint/no-unnecessary-condition */
	Object.defineProperty(ParentChildValidation$1, "__esModule", {
	  value: true
	});
	ParentChildValidation$1.ParentChildValidation = void 0;
	var Changes_1 = Changes;
	var util_1$1 = util$1;
	var Validation_1 = Validation$1;
	var ParentChildValidation = /*#__PURE__*/function (_Validation_1$Validat) {
	  _inherits(ParentChildValidation, _Validation_1$Validat);
	  var _super = /*#__PURE__*/_createSuper(ParentChildValidation);
	  function ParentChildValidation() {
	    var _this;
	    _classCallCheck(this, ParentChildValidation);
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    _this = _super.call.apply(_super, [this].concat(args));
	    _defineProperty(_assertThisInitialized(_this), "name", 'ParentChildValidation');
	    return _this;
	  }
	  _createClass(ParentChildValidation, [{
	    key: "backendPostValidate",
	    value: function () {
	      var _backendPostValidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(change, _ref) {
	        var featureModel, session;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              featureModel = _ref.featureModel, session = _ref.session;
	              if (!((0, Changes_1.isLocationEndChange)(change) || (0, Changes_1.isLocationStartChange)(change))) {
	                _context.next = 3;
	                break;
	              }
	              return _context.abrupt("return", this.validateParentChildRelationships(change, {
	                session: session,
	                featureModel: featureModel
	              }));
	            case 3:
	              return _context.abrupt("return", {
	                validationName: this.name
	              });
	            case 4:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this);
	      }));
	      function backendPostValidate(_x, _x2) {
	        return _backendPostValidate.apply(this, arguments);
	      }
	      return backendPostValidate;
	    }()
	  }, {
	    key: "validateParentChildRelationships",
	    value: function () {
	      var _validateParentChildRelationships = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(change, _ref2) {
	        var featureModel, session, topLevelFeatures, _iterator, _step, _loop, _i, _topLevelFeatures, topLevelFeature;
	        return _regeneratorRuntime().wrap(function _callee2$(_context3) {
	          while (1) switch (_context3.prev = _context3.next) {
	            case 0:
	              featureModel = _ref2.featureModel, session = _ref2.session;
	              topLevelFeatures = [];
	              _iterator = _createForOfIteratorHelper(change.changes);
	              _context3.prev = 3;
	              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
	                var ch, featureId, topLevelFeature, errMsg;
	                return _regeneratorRuntime().wrap(function _loop$(_context2) {
	                  while (1) switch (_context2.prev = _context2.next) {
	                    case 0:
	                      ch = _step.value;
	                      featureId = ch.featureId; // Search correct feature
	                      _context2.next = 4;
	                      return featureModel.findOne({
	                        allIds: featureId
	                      }).session(session).exec();
	                    case 4:
	                      topLevelFeature = _context2.sent;
	                      if (topLevelFeature) {
	                        _context2.next = 8;
	                        break;
	                      }
	                      errMsg = "ERROR: The following featureId was not found in database ='".concat(featureId, "'");
	                      throw new Error(errMsg);
	                    case 8:
	                      if (!topLevelFeatures.some(function (f) {
	                        return f._id === topLevelFeature._id;
	                      })) {
	                        topLevelFeatures.push(topLevelFeature);
	                      }
	                    case 9:
	                    case "end":
	                      return _context2.stop();
	                  }
	                }, _loop);
	              });
	              _iterator.s();
	            case 6:
	              if ((_step = _iterator.n()).done) {
	                _context3.next = 10;
	                break;
	              }
	              return _context3.delegateYield(_loop(), "t0", 8);
	            case 8:
	              _context3.next = 6;
	              break;
	            case 10:
	              _context3.next = 15;
	              break;
	            case 12:
	              _context3.prev = 12;
	              _context3.t1 = _context3["catch"](3);
	              _iterator.e(_context3.t1);
	            case 15:
	              _context3.prev = 15;
	              _iterator.f();
	              return _context3.finish(15);
	            case 18:
	              _i = 0, _topLevelFeatures = topLevelFeatures;
	            case 19:
	              if (!(_i < _topLevelFeatures.length)) {
	                _context3.next = 31;
	                break;
	              }
	              topLevelFeature = _topLevelFeatures[_i];
	              _context3.prev = 21;
	              this.checkChildFeatureBoundaries(topLevelFeature);
	              _context3.next = 28;
	              break;
	            case 25:
	              _context3.prev = 25;
	              _context3.t2 = _context3["catch"](21);
	              return _context3.abrupt("return", {
	                validationName: this.name,
	                error: {
	                  message: String(_context3.t2)
	                }
	              });
	            case 28:
	              _i++;
	              _context3.next = 19;
	              break;
	            case 31:
	              return _context3.abrupt("return", {
	                validationName: this.name
	              });
	            case 32:
	            case "end":
	              return _context3.stop();
	          }
	        }, _callee2, this, [[3, 12, 15, 18], [21, 25]]);
	      }));
	      function validateParentChildRelationships(_x3, _x4) {
	        return _validateParentChildRelationships.apply(this, arguments);
	      }
	      return validateParentChildRelationships;
	    }()
	  }, {
	    key: "checkChildFeatureBoundaries",
	    value: function checkChildFeatureBoundaries(feature) {
	      if (!feature.children) {
	        return;
	      }
	      var _iterator2 = _createForOfIteratorHelper(feature.children || new Map()),
	        _step2;
	      try {
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          var _step2$value = _slicedToArray(_step2.value, 2),
	            childFeature = _step2$value[1];
	          if (feature.min !== null && feature.max !== null && childFeature.min !== null && childFeature.max !== null && (childFeature.max > feature.max || childFeature.min < feature.min)) {
	            throw new Error("Feature ".concat((0, util_1$1.getPrintableId)(childFeature), " exceeds the bounds of its parent, ").concat((0, util_1$1.getPrintableId)(feature)));
	          }
	          this.checkChildFeatureBoundaries(childFeature);
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }
	    }
	  }]);
	  return ParentChildValidation;
	}(Validation_1.Validation);
	ParentChildValidation$1.ParentChildValidation = ParentChildValidation;

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var tslib_1 = require$$0$1;
	  tslib_1.__exportStar(Validation$1, exports);
	  tslib_1.__exportStar(ValidationSet$1, exports);
	  tslib_1.__exportStar(CoreValidation$1, exports);
	  tslib_1.__exportStar(ParentChildValidation$1, exports);
	})(Validations);

	var Common = {};

	var jwtPayload = {};

	function e(e) {
	  this.message = e;
	}
	e.prototype = /*#__PURE__*/new Error(), e.prototype.name = "InvalidCharacterError";
	var r = "undefined" != typeof window && window.atob && /*#__PURE__*/window.atob.bind(window) || function (r) {
	  var t = String(r).replace(/=+$/, "");
	  if (t.length % 4 == 1) throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
	  for (var n, o, a = 0, i = 0, c = ""; o = t.charAt(i++); ~o && (n = a % 4 ? 64 * n + o : o, a++ % 4) ? c += String.fromCharCode(255 & n >> (-2 * a & 6)) : 0) o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o);
	  return c;
	};
	function t(e) {
	  var t = e.replace(/-/g, "+").replace(/_/g, "/");
	  switch (t.length % 4) {
	    case 0:
	      break;
	    case 2:
	      t += "==";
	      break;
	    case 3:
	      t += "=";
	      break;
	    default:
	      throw "Illegal base64url string!";
	  }
	  try {
	    return function (e) {
	      return decodeURIComponent(r(e).replace(/(.)/g, function (e, r) {
	        var t = r.charCodeAt(0).toString(16).toUpperCase();
	        return t.length < 2 && (t = "0" + t), "%" + t;
	      }));
	    }(t);
	  } catch (e) {
	    return r(t);
	  }
	}
	function n(e) {
	  this.message = e;
	}
	function o(e, r) {
	  if ("string" != typeof e) throw new n("Invalid token specified");
	  var o = !0 === (r = r || {}).header ? 0 : 1;
	  try {
	    return JSON.parse(t(e.split(".")[o]));
	  } catch (e) {
	    throw new n("Invalid token specified: " + e.message);
	  }
	}
	n.prototype = /*#__PURE__*/new Error(), n.prototype.name = "InvalidTokenError";

	var jwtDecode_esm = {
		__proto__: null,
		'default': o,
		InvalidTokenError: n
	};

	var require$$1 = /*@__PURE__*/getAugmentedNamespace(jwtDecode_esm);

	Object.defineProperty(jwtPayload, "__esModule", {
	  value: true
	});
	jwtPayload.makeUserSessionId = makeUserSessionId;
	jwtPayload.getDecodedToken = getDecodedToken;
	var tslib_1$1 = require$$0$1;
	var jwt_decode_1 = /*#__PURE__*/tslib_1$1.__importDefault(require$$1);
	function makeUserSessionId(userOrToken) {
	  var user = typeof userOrToken === 'string' ? (0, jwt_decode_1["default"])(userOrToken) : userOrToken;
	  return "".concat(user.id, "-").concat(user.iat);
	}
	function getDecodedToken(token) {
	  return (0, jwt_decode_1["default"])(token);
	}

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var tslib_1 = require$$0$1;
	  tslib_1.__exportStar(jwtPayload, exports);
	})(Common);

	var Checks = {};

	var CDSCheck$1 = {};

	Object.defineProperty(CDSCheck$1, "__esModule", {
	  value: true
	});
	CDSCheck$1.CDSCheck = void 0;
	var tslib_1 = require$$0$1;
	var common_1 = dist$1;
	var util_1 = require$$1__default$1["default"];
	var bson_objectid_1 = /*#__PURE__*/tslib_1.__importDefault(objectid);
	var STOP_CODONS;
	(function (STOP_CODONS) {
	  STOP_CODONS[STOP_CODONS["TAG"] = 0] = "TAG";
	  STOP_CODONS[STOP_CODONS["TAA"] = 1] = "TAA";
	  STOP_CODONS[STOP_CODONS["TGA"] = 2] = "TGA";
	})(STOP_CODONS || (STOP_CODONS = {}));
	var START_CODONS;
	(function (START_CODONS) {
	  START_CODONS[START_CODONS["ATG"] = 0] = "ATG";
	})(START_CODONS || (START_CODONS = {}));
	var CHECK_NAME = 'CDSCheck';
	var CAUSES;
	(function (CAUSES) {
	  CAUSES[CAUSES["InternalStopCodon"] = 0] = "InternalStopCodon";
	  CAUSES[CAUSES["MissingStartCodon"] = 1] = "MissingStartCodon";
	  CAUSES[CAUSES["MissingStopCodon"] = 2] = "MissingStopCodon";
	  CAUSES[CAUSES["MultipleOfThree"] = 3] = "MultipleOfThree";
	})(CAUSES || (CAUSES = {}));
	var iupacComplements = {
	  G: 'C',
	  A: 'T',
	  T: 'A',
	  C: 'G',
	  R /* G or A */: 'Y',
	  Y /* T or C */: 'R',
	  M /* A or C */: 'K',
	  K /* G or T */: 'M',
	  S /* G or C */: 'S',
	  W /* A or T */: 'W',
	  H /* A or C or T */: 'D',
	  B /* G or T or C */: 'V',
	  V /* G or C or A */: 'B',
	  D /* G or A or T */: 'H',
	  N /* G or A or T or C */: 'N'
	};
	function reverseComplement(dna) {
	  var complement = [];
	  var _iterator = _createForOfIteratorHelper(dna),
	    _step;
	  try {
	    for (_iterator.s(); !(_step = _iterator.n()).done;) {
	      var nt = _step.value;
	      var rc = iupacComplements[nt.toUpperCase()];
	      if (rc === undefined) {
	        throw new TypeError("Cannot complement nucleotide: \"".concat(nt, "\""));
	      }
	      if (nt === nt.toLowerCase()) {
	        complement.push(rc.toLowerCase());
	      } else {
	        complement.push(rc);
	      }
	    }
	  } catch (err) {
	    _iterator.e(err);
	  } finally {
	    _iterator.f();
	  }
	  return complement.reverse().join('');
	}
	function getCDSSequence(_x, _x2, _x3) {
	  return _getCDSSequence.apply(this, arguments);
	}
	function _getCDSSequence() {
	  _getCDSSequence = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(cdsLocation, strand, getSequence) {
	    var sequences, seq;
	    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
	      while (1) switch (_context2.prev = _context2.next) {
	        case 0:
	          _context2.next = 2;
	          return Promise.all(cdsLocation.map(function (_ref5) {
	            var max = _ref5.max,
	              min = _ref5.min;
	            return getSequence(min, max);
	          }));
	        case 2:
	          sequences = _context2.sent;
	          seq = sequences.join('');
	          if (strand === -1) {
	            seq = reverseComplement(seq);
	          }
	          return _context2.abrupt("return", seq);
	        case 6:
	        case "end":
	          return _context2.stop();
	      }
	    }, _callee2);
	  }));
	  return _getCDSSequence.apply(this, arguments);
	}
	function splitSequenceInCodons(cds) {
	  var codons = [];
	  for (var i = 0; i <= cds.length - 3; i += 3) {
	    codons.push(cds.slice(i, i + 3));
	  }
	  return codons;
	}
	function cmp(pos, max, strand) {
	  if (strand === -1) {
	    return pos > max;
	  }
	  return pos < max;
	}
	function getOriginalCodonLocation(cdsLocation, strand, index) {
	  // Index 0 is the start codon, so reverse the CDS locations if strand is -1
	  var sortedLocation = structuredClone(cdsLocation);
	  if (strand === -1) {
	    sortedLocation.sort(function (a, b) {
	      return a.min < b.min ? 1 : -1;
	    });
	  } else {
	    sortedLocation.sort(function (a, b) {
	      return a.min < b.min ? -1 : 1;
	    });
	  }
	  var i = 0;
	  var currentStart = undefined;
	  var currentEnd = undefined;
	  for (var iloc = 0; iloc < sortedLocation.length; iloc++) {
	    var loc = sortedLocation[iloc];
	    var phase = loc.phase;
	    // On the reverse strand start iterating from the right and end on the left
	    var startAt = strand === -1 ? loc.max - phase : loc.min + phase;
	    var endAt = strand === -1 ? loc.min : loc.max;
	    for (var pos = startAt; cmp(pos, endAt, strand); pos = strand === -1 ? pos - 3 : pos + 3) {
	      currentStart = pos;
	      currentEnd = strand === -1 ? currentStart - 3 : currentStart + 3;
	      // These if conditions occur if a codon is split between two exons
	      if (strand === -1 && currentEnd < loc.min) {
	        currentEnd = sortedLocation[iloc + 1].max - sortedLocation[iloc + 1].phase;
	      } else if (currentEnd > loc.max) {
	        currentEnd = sortedLocation[iloc + 1].min + sortedLocation[iloc + 1].phase;
	      }
	      if (i === index) {
	        return [currentStart, currentEnd].sort(function (a, b) {
	          return a - b;
	        });
	      }
	      i++;
	    }
	  }
	  return undefined;
	}
	function checkMRNA(_x4, _x5) {
	  return _checkMRNA.apply(this, arguments);
	}
	function _checkMRNA() {
	  _checkMRNA = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(feature, getSequence) {
	    var checkResults, _id, max, min, refSeq, strand, cdsLocations, ids, _iterator3, _step3, cdsLocation, sequence, codons, start_codon, _cdsLocation$at$max, _cdsLocation$at, _cdsLocation$at$min, _cdsLocation$at2, cdsStart, lastCodon, _cdsLocation$at$min2, _cdsLocation$at3, _cdsLocation$at$max2, _cdsLocation$at4, cdsEnd, _iterator4, _step4, _step4$value, idx, codon, location, _location, codonStart, codonEnd;
	    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
	      while (1) switch (_context3.prev = _context3.next) {
	        case 0:
	          checkResults = [];
	          _id = feature._id, max = feature.max, min = feature.min, refSeq = feature.refSeq, strand = feature.strand;
	          cdsLocations = getCDSLocations(feature);
	          if (cdsLocations) {
	            _context3.next = 5;
	            break;
	          }
	          return _context3.abrupt("return", checkResults);
	        case 5:
	          ids = [_id];
	          _iterator3 = _createForOfIteratorHelper(cdsLocations);
	          _context3.prev = 7;
	          _iterator3.s();
	        case 9:
	          if ((_step3 = _iterator3.n()).done) {
	            _context3.next = 37;
	            break;
	          }
	          cdsLocation = _step3.value;
	          _context3.next = 13;
	          return getCDSSequence(cdsLocation, strand, getSequence);
	        case 13:
	          sequence = _context3.sent;
	          codons = splitSequenceInCodons(sequence);
	          if (sequence.length % 3 === 0) {
	            start_codon = codons.at(0);
	            if (start_codon && !(start_codon.toUpperCase() in START_CODONS)) {
	              cdsStart = strand === -1 ? (_cdsLocation$at$max = (_cdsLocation$at = cdsLocation.at(-1)) === null || _cdsLocation$at === void 0 ? void 0 : _cdsLocation$at.max) !== null && _cdsLocation$at$max !== void 0 ? _cdsLocation$at$max : max : (_cdsLocation$at$min = (_cdsLocation$at2 = cdsLocation.at(0)) === null || _cdsLocation$at2 === void 0 ? void 0 : _cdsLocation$at2.min) !== null && _cdsLocation$at$min !== void 0 ? _cdsLocation$at$min : min;
	              cdsStart = strand === -1 ? cdsStart - 3 : cdsStart;
	              checkResults.push({
	                _id: new bson_objectid_1["default"]().toHexString(),
	                name: CHECK_NAME,
	                cause: CAUSES[CAUSES.MissingStartCodon],
	                ids: ids,
	                refSeq: refSeq.toString(),
	                start: cdsStart,
	                end: cdsStart,
	                message: "Unexpected start codon in feature \"".concat(_id, "\": ").concat(start_codon)
	              });
	            }
	            lastCodon = codons.at(-1); // Last codon is supposed to be a stop
	            if (lastCodon && !(lastCodon.toUpperCase() in STOP_CODONS)) {
	              cdsEnd = strand === -1 ? (_cdsLocation$at$min2 = (_cdsLocation$at3 = cdsLocation.at(0)) === null || _cdsLocation$at3 === void 0 ? void 0 : _cdsLocation$at3.min) !== null && _cdsLocation$at$min2 !== void 0 ? _cdsLocation$at$min2 : min : (_cdsLocation$at$max2 = (_cdsLocation$at4 = cdsLocation.at(-1)) === null || _cdsLocation$at4 === void 0 ? void 0 : _cdsLocation$at4.max) !== null && _cdsLocation$at$max2 !== void 0 ? _cdsLocation$at$max2 : max;
	              checkResults.push({
	                _id: new bson_objectid_1["default"]().toHexString(),
	                name: CHECK_NAME,
	                cause: CAUSES[CAUSES.MissingStopCodon],
	                ids: ids,
	                refSeq: refSeq.toString(),
	                start: cdsEnd,
	                end: cdsEnd,
	                message: "Missing stop codon for feature \"".concat(_id, "\"")
	              });
	            }
	          } else {
	            checkResults.push({
	              _id: new bson_objectid_1["default"]().toHexString(),
	              name: CHECK_NAME,
	              cause: CAUSES[CAUSES.MultipleOfThree],
	              ids: ids,
	              refSeq: refSeq.toString(),
	              start: min,
	              end: max,
	              message: "The coding sequence for feature \"".concat(_id, "\" is not a multiple of three")
	            });
	          }
	          _iterator4 = _createForOfIteratorHelper(codons.entries());
	          _context3.prev = 17;
	          _iterator4.s();
	        case 19:
	          if ((_step4 = _iterator4.n()).done) {
	            _context3.next = 27;
	            break;
	          }
	          _step4$value = _slicedToArray(_step4.value, 2), idx = _step4$value[0], codon = _step4$value[1];
	          if (!(idx === codons.length - 1)) {
	            _context3.next = 23;
	            break;
	          }
	          return _context3.abrupt("break", 27);
	        case 23:
	          location = getOriginalCodonLocation(cdsLocation, strand, idx);
	          if (location && codon.toUpperCase() in STOP_CODONS) {
	            _location = _slicedToArray(location, 2), codonStart = _location[0], codonEnd = _location[1];
	            checkResults.push({
	              _id: new bson_objectid_1["default"]().toHexString(),
	              name: CHECK_NAME,
	              cause: CAUSES[CAUSES.InternalStopCodon],
	              ids: ids,
	              refSeq: refSeq.toString(),
	              start: codonStart,
	              end: codonEnd,
	              message: "The coding sequence for feature \"".concat(_id, "\" has an internal stop codon")
	            });
	          }
	        case 25:
	          _context3.next = 19;
	          break;
	        case 27:
	          _context3.next = 32;
	          break;
	        case 29:
	          _context3.prev = 29;
	          _context3.t0 = _context3["catch"](17);
	          _iterator4.e(_context3.t0);
	        case 32:
	          _context3.prev = 32;
	          _iterator4.f();
	          return _context3.finish(32);
	        case 35:
	          _context3.next = 9;
	          break;
	        case 37:
	          _context3.next = 42;
	          break;
	        case 39:
	          _context3.prev = 39;
	          _context3.t1 = _context3["catch"](7);
	          _iterator3.e(_context3.t1);
	        case 42:
	          _context3.prev = 42;
	          _iterator3.f();
	          return _context3.finish(42);
	        case 45:
	          return _context3.abrupt("return", checkResults);
	        case 46:
	        case "end":
	          return _context3.stop();
	      }
	    }, _callee3, null, [[7, 39, 42, 45], [17, 29, 32, 35]]);
	  }));
	  return _checkMRNA.apply(this, arguments);
	}
	function getCDSLocations(feature) {
	  if (feature.type !== 'mRNA') {
	    return;
	  }
	  var children = feature.children,
	    strand = feature.strand;
	  if (!children) {
	    return;
	  }
	  var cdsChildren = Object.values(children).filter(function (child) {
	    return child.type === 'CDS';
	  });
	  if (cdsChildren.length === 0) {
	    return;
	  }
	  var cdsLocations = [];
	  var _iterator2 = _createForOfIteratorHelper(cdsChildren),
	    _step2;
	  try {
	    var _loop = function _loop() {
	      var cds = _step2.value;
	      var cdsMax = cds.max,
	        cdsMin = cds.min;
	      var locs = [];
	      for (var _i = 0, _Object$values = Object.values(children); _i < _Object$values.length; _i++) {
	        var child = _Object$values[_i];
	        if (child.type !== 'exon') {
	          continue;
	        }
	        var _ref = (0, util_1.intersection2)(cdsMin, cdsMax, child.min, child.max),
	          _ref2 = _slicedToArray(_ref, 2),
	          start = _ref2[0],
	          end = _ref2[1];
	        if (start !== undefined && end !== undefined) {
	          locs.push({
	            min: start,
	            max: end
	          });
	        }
	      }
	      locs.sort(function (_ref3, _ref4) {
	        var a = _ref3.min;
	        var b = _ref4.min;
	        return a - b;
	      });
	      if (strand === -1) {
	        locs.reverse();
	      }
	      var nextPhase = 0;
	      var phasedLocs = locs.map(function (loc) {
	        var phase = nextPhase;
	        nextPhase = (3 - (loc.max - loc.min - phase + 3) % 3) % 3;
	        return _objectSpread2(_objectSpread2({}, loc), {}, {
	          phase: phase
	        });
	      });
	      phasedLocs.sort(function (a, b) {
	        return a.min < b.min ? -1 : 1;
	      });
	      cdsLocations.push(phasedLocs);
	    };
	    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	      _loop();
	    }
	  } catch (err) {
	    _iterator2.e(err);
	  } finally {
	    _iterator2.f();
	  }
	  if (cdsLocations.length > 1) {
	    cdsLocations.sort(function (a, b) {
	      return a[0].min < b[0].min ? -1 : 1;
	    });
	  }
	  return cdsLocations;
	}
	function getCauses() {
	  return Object.values(CAUSES).filter(function (x) {
	    return Number.isNaN(Number(x));
	  });
	}
	var CDSCheck = /*#__PURE__*/function (_common_1$Check) {
	  _inherits(CDSCheck, _common_1$Check);
	  var _super = /*#__PURE__*/_createSuper(CDSCheck);
	  function CDSCheck() {
	    var _this;
	    _classCallCheck(this, CDSCheck);
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    _this = _super.call.apply(_super, [this].concat(args));
	    _defineProperty(_assertThisInitialized(_this), "name", CHECK_NAME);
	    _defineProperty(_assertThisInitialized(_this), "causes", getCauses());
	    _defineProperty(_assertThisInitialized(_this), "version", 1);
	    _defineProperty(_assertThisInitialized(_this), "default", true);
	    return _this;
	  }
	  _createClass(CDSCheck, [{
	    key: "checkFeature",
	    value: function () {
	      var _checkFeature = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(feature, getSequence) {
	        var checkResults, _i2, _Object$values2, child;
	        return _regeneratorRuntime().wrap(function _callee$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              if (!(feature.type === 'mRNA')) {
	                _context.next = 2;
	                break;
	              }
	              return _context.abrupt("return", checkMRNA(feature, getSequence));
	            case 2:
	              if (feature.children) {
	                _context.next = 4;
	                break;
	              }
	              return _context.abrupt("return", []);
	            case 4:
	              checkResults = [];
	              _i2 = 0, _Object$values2 = Object.values(feature.children);
	            case 6:
	              if (!(_i2 < _Object$values2.length)) {
	                _context.next = 19;
	                break;
	              }
	              child = _Object$values2[_i2];
	              _context.t0 = checkResults.push;
	              _context.t1 = checkResults;
	              _context.t2 = _toConsumableArray;
	              _context.next = 13;
	              return this.checkFeature(child, getSequence);
	            case 13:
	              _context.t3 = _context.sent;
	              _context.t4 = (0, _context.t2)(_context.t3);
	              _context.t0.apply.call(_context.t0, _context.t1, _context.t4);
	            case 16:
	              _i2++;
	              _context.next = 6;
	              break;
	            case 19:
	              return _context.abrupt("return", checkResults);
	            case 20:
	            case "end":
	              return _context.stop();
	          }
	        }, _callee, this);
	      }));
	      function checkFeature(_x6, _x7) {
	        return _checkFeature.apply(this, arguments);
	      }
	      return checkFeature;
	    }()
	  }]);
	  return CDSCheck;
	}(common_1.Check);
	CDSCheck$1.CDSCheck = CDSCheck;

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var tslib_1 = require$$0$1;
	  tslib_1.__exportStar(CDSCheck$1, exports);
	})(Checks);

	var Messages = {};

	Object.defineProperty(Messages, "__esModule", {
	  value: true
	});

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var tslib_1 = require$$0$1;
	  tslib_1.__exportStar(Changes, exports);
	  tslib_1.__exportStar(Operations, exports);
	  tslib_1.__exportStar(Validations, exports);
	  tslib_1.__exportStar(Common, exports);
	  tslib_1.__exportStar(Checks, exports);
	  tslib_1.__exportStar(util$1, exports);
	  tslib_1.__exportStar(Messages, exports);
	  tslib_1.__exportStar(GFF3, exports);
	})(dist$2);

	var Add = {};

	var interopRequireDefault = {exports: {}};

	(function (module) {
	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      "default": obj
	    };
	  }
	  module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
	})(interopRequireDefault);

	var createSvgIcon = {};

	(function (exports) {
	  'use client';

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  Object.defineProperty(exports, "default", {
	    enumerable: true,
	    get: function get() {
	      return _utils.createSvgIcon;
	    }
	  });
	  var _utils = require$$0__default["default"];
	})(createSvgIcon);

	var _interopRequireDefault$p = interopRequireDefault.exports;
	Object.defineProperty(Add, "__esModule", {
	  value: true
	});
	var default_1$p = Add["default"] = void 0;
	var _createSvgIcon$p = /*#__PURE__*/_interopRequireDefault$p(createSvgIcon);
	var _jsxRuntime$p = require$$2__default["default"];
	var _default$r = /*#__PURE__*/(0, _createSvgIcon$p["default"])( /*#__PURE__*/(0, _jsxRuntime$p.jsx)("path", {
	  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"
	}), 'Add');
	default_1$p = Add["default"] = _default$r;

	var version = "0.3.7";

	const ApolloConfigSchema = configuration.ConfigurationSchema('ApolloInternetAccount', {
	    baseURL: {
	        description: 'Location of Apollo server',
	        type: 'string',
	        defaultValue: '',
	    },
	    tokenType: {
	        description: 'A custom name for a token to include in the header',
	        type: 'string',
	        defaultValue: 'Bearer',
	    },
	}, { baseConfiguration: pluggableElementTypes.BaseInternetAccountConfig, explicitlyTyped: true });

	var PACKET_TYPES = /*#__PURE__*/Object.create(null); // no Map = no polyfill
	PACKET_TYPES["open"] = "0";
	PACKET_TYPES["close"] = "1";
	PACKET_TYPES["ping"] = "2";
	PACKET_TYPES["pong"] = "3";
	PACKET_TYPES["message"] = "4";
	PACKET_TYPES["upgrade"] = "5";
	PACKET_TYPES["noop"] = "6";
	var PACKET_TYPES_REVERSE = /*#__PURE__*/Object.create(null);
	Object.keys(PACKET_TYPES).forEach(function (key) {
	  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
	});
	var ERROR_PACKET = {
	  type: "error",
	  data: "parser error"
	};

	var withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && /*#__PURE__*/Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
	var withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
	// ArrayBuffer.isView method is not defined in IE10
	var isView$1 = function isView(obj) {
	  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
	};
	var encodePacket = function encodePacket(_ref, supportsBinary, callback) {
	  var type = _ref.type,
	    data = _ref.data;
	  if (withNativeBlob$1 && data instanceof Blob) {
	    if (supportsBinary) {
	      return callback(data);
	    } else {
	      return encodeBlobAsBase64(data, callback);
	    }
	  } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {
	    if (supportsBinary) {
	      return callback(data);
	    } else {
	      return encodeBlobAsBase64(new Blob([data]), callback);
	    }
	  }
	  // plain string
	  return callback(PACKET_TYPES[type] + (data || ""));
	};
	var encodeBlobAsBase64 = function encodeBlobAsBase64(data, callback) {
	  var fileReader = new FileReader();
	  fileReader.onload = function () {
	    var content = fileReader.result.split(",")[1];
	    callback("b" + (content || ""));
	  };
	  return fileReader.readAsDataURL(data);
	};
	function toArray$2(data) {
	  if (data instanceof Uint8Array) {
	    return data;
	  } else if (data instanceof ArrayBuffer) {
	    return new Uint8Array(data);
	  } else {
	    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
	  }
	}
	var TEXT_ENCODER;
	function encodePacketToBinary(packet, callback) {
	  if (withNativeBlob$1 && packet.data instanceof Blob) {
	    return packet.data.arrayBuffer().then(toArray$2).then(callback);
	  } else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {
	    return callback(toArray$2(packet.data));
	  }
	  encodePacket(packet, false, function (encoded) {
	    if (!TEXT_ENCODER) {
	      TEXT_ENCODER = new TextEncoder();
	    }
	    callback(TEXT_ENCODER.encode(encoded));
	  });
	}

	// imported from https://github.com/socketio/base64-arraybuffer
	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	// Use a lookup table to find the index.
	var lookup$1 = typeof Uint8Array === 'undefined' ? [] : /*#__PURE__*/new Uint8Array(256);
	for (var i = 0; i < chars.length; i++) {
	  lookup$1[/*#__PURE__*/chars.charCodeAt(i)] = i;
	}
	var decode$1 = function decode(base64) {
	  var bufferLength = base64.length * 0.75,
	    len = base64.length,
	    i,
	    p = 0,
	    encoded1,
	    encoded2,
	    encoded3,
	    encoded4;
	  if (base64[base64.length - 1] === '=') {
	    bufferLength--;
	    if (base64[base64.length - 2] === '=') {
	      bufferLength--;
	    }
	  }
	  var arraybuffer = new ArrayBuffer(bufferLength),
	    bytes = new Uint8Array(arraybuffer);
	  for (i = 0; i < len; i += 4) {
	    encoded1 = lookup$1[base64.charCodeAt(i)];
	    encoded2 = lookup$1[base64.charCodeAt(i + 1)];
	    encoded3 = lookup$1[base64.charCodeAt(i + 2)];
	    encoded4 = lookup$1[base64.charCodeAt(i + 3)];
	    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
	    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
	    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
	  }
	  return arraybuffer;
	};

	var withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
	var decodePacket = function decodePacket(encodedPacket, binaryType) {
	  if (typeof encodedPacket !== "string") {
	    return {
	      type: "message",
	      data: mapBinary(encodedPacket, binaryType)
	    };
	  }
	  var type = encodedPacket.charAt(0);
	  if (type === "b") {
	    return {
	      type: "message",
	      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
	    };
	  }
	  var packetType = PACKET_TYPES_REVERSE[type];
	  if (!packetType) {
	    return ERROR_PACKET;
	  }
	  return encodedPacket.length > 1 ? {
	    type: PACKET_TYPES_REVERSE[type],
	    data: encodedPacket.substring(1)
	  } : {
	    type: PACKET_TYPES_REVERSE[type]
	  };
	};
	var decodeBase64Packet = function decodeBase64Packet(data, binaryType) {
	  if (withNativeArrayBuffer$1) {
	    var decoded = decode$1(data);
	    return mapBinary(decoded, binaryType);
	  } else {
	    return {
	      base64: true,
	      data: data
	    }; // fallback for old browsers
	  }
	};

	var mapBinary = function mapBinary(data, binaryType) {
	  switch (binaryType) {
	    case "blob":
	      if (data instanceof Blob) {
	        // from WebSocket + binaryType "blob"
	        return data;
	      } else {
	        // from HTTP long-polling or WebTransport
	        return new Blob([data]);
	      }
	    case "arraybuffer":
	    default:
	      if (data instanceof ArrayBuffer) {
	        // from HTTP long-polling (base64) or WebSocket + binaryType "arraybuffer"
	        return data;
	      } else {
	        // from WebTransport (Uint8Array)
	        return data.buffer;
	      }
	  }
	};

	var SEPARATOR = /*#__PURE__*/String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
	var encodePayload = function encodePayload(packets, callback) {
	  // some packets may be added to the array while encoding, so the initial length must be saved
	  var length = packets.length;
	  var encodedPackets = new Array(length);
	  var count = 0;
	  packets.forEach(function (packet, i) {
	    // force base64 encoding for binary packets
	    encodePacket(packet, false, function (encodedPacket) {
	      encodedPackets[i] = encodedPacket;
	      if (++count === length) {
	        callback(encodedPackets.join(SEPARATOR));
	      }
	    });
	  });
	};
	var decodePayload = function decodePayload(encodedPayload, binaryType) {
	  var encodedPackets = encodedPayload.split(SEPARATOR);
	  var packets = [];
	  for (var i = 0; i < encodedPackets.length; i++) {
	    var decodedPacket = decodePacket(encodedPackets[i], binaryType);
	    packets.push(decodedPacket);
	    if (decodedPacket.type === "error") {
	      break;
	    }
	  }
	  return packets;
	};
	function createPacketEncoderStream() {
	  return new TransformStream({
	    transform: function transform(packet, controller) {
	      encodePacketToBinary(packet, function (encodedPacket) {
	        var payloadLength = encodedPacket.length;
	        var header;
	        // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length
	        if (payloadLength < 126) {
	          header = new Uint8Array(1);
	          new DataView(header.buffer).setUint8(0, payloadLength);
	        } else if (payloadLength < 65536) {
	          header = new Uint8Array(3);
	          var view = new DataView(header.buffer);
	          view.setUint8(0, 126);
	          view.setUint16(1, payloadLength);
	        } else {
	          header = new Uint8Array(9);
	          var _view = new DataView(header.buffer);
	          _view.setUint8(0, 127);
	          _view.setBigUint64(1, BigInt(payloadLength));
	        }
	        // first bit indicates whether the payload is plain text (0) or binary (1)
	        if (packet.data && typeof packet.data !== "string") {
	          header[0] |= 0x80;
	        }
	        controller.enqueue(header);
	        controller.enqueue(encodedPacket);
	      });
	    }
	  });
	}
	var TEXT_DECODER;
	function totalLength(chunks) {
	  return chunks.reduce(function (acc, chunk) {
	    return acc + chunk.length;
	  }, 0);
	}
	function concatChunks(chunks, size) {
	  if (chunks[0].length === size) {
	    return chunks.shift();
	  }
	  var buffer = new Uint8Array(size);
	  var j = 0;
	  for (var i = 0; i < size; i++) {
	    buffer[i] = chunks[0][j++];
	    if (j === chunks[0].length) {
	      chunks.shift();
	      j = 0;
	    }
	  }
	  if (chunks.length && j < chunks[0].length) {
	    chunks[0] = chunks[0].slice(j);
	  }
	  return buffer;
	}
	function createPacketDecoderStream(maxPayload, binaryType) {
	  if (!TEXT_DECODER) {
	    TEXT_DECODER = new TextDecoder();
	  }
	  var chunks = [];
	  var state = 0 /* READ_HEADER */;
	  var expectedLength = -1;
	  var isBinary = false;
	  return new TransformStream({
	    transform: function transform(chunk, controller) {
	      chunks.push(chunk);
	      while (true) {
	        if (state === 0 /* READ_HEADER */) {
	          if (totalLength(chunks) < 1) {
	            break;
	          }
	          var header = concatChunks(chunks, 1);
	          isBinary = (header[0] & 0x80) === 0x80;
	          expectedLength = header[0] & 0x7f;
	          if (expectedLength < 126) {
	            state = 3 /* READ_PAYLOAD */;
	          } else if (expectedLength === 126) {
	            state = 1 /* READ_EXTENDED_LENGTH_16 */;
	          } else {
	            state = 2 /* READ_EXTENDED_LENGTH_64 */;
	          }
	        } else if (state === 1 /* READ_EXTENDED_LENGTH_16 */) {
	          if (totalLength(chunks) < 2) {
	            break;
	          }
	          var headerArray = concatChunks(chunks, 2);
	          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
	          state = 3 /* READ_PAYLOAD */;
	        } else if (state === 2 /* READ_EXTENDED_LENGTH_64 */) {
	          if (totalLength(chunks) < 8) {
	            break;
	          }
	          var _headerArray = concatChunks(chunks, 8);
	          var view = new DataView(_headerArray.buffer, _headerArray.byteOffset, _headerArray.length);
	          var n = view.getUint32(0);
	          if (n > Math.pow(2, 53 - 32) - 1) {
	            // the maximum safe integer in JavaScript is 2^53 - 1
	            controller.enqueue(ERROR_PACKET);
	            break;
	          }
	          expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
	          state = 3 /* READ_PAYLOAD */;
	        } else {
	          if (totalLength(chunks) < expectedLength) {
	            break;
	          }
	          var data = concatChunks(chunks, expectedLength);
	          controller.enqueue(decodePacket(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
	          state = 0 /* READ_HEADER */;
	        }

	        if (expectedLength === 0 || expectedLength > maxPayload) {
	          controller.enqueue(ERROR_PACKET);
	          break;
	        }
	      }
	    }
	  });
	}
	var protocol$1 = 4;

	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */

	function Emitter(obj) {
	  if (obj) return mixin(obj);
	}

	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */

	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}

	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
	  return this;
	};

	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.once = function (event, fn) {
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};

	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
	  this._callbacks = this._callbacks || {};

	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }

	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;

	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }

	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }

	  // Remove event specific arrays for event types that no
	  // one is subscribed for to avoid memory leak.
	  if (callbacks.length === 0) {
	    delete this._callbacks['$' + event];
	  }
	  return this;
	};

	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */

	Emitter.prototype.emit = function (event) {
	  this._callbacks = this._callbacks || {};
	  var args = new Array(arguments.length - 1),
	    callbacks = this._callbacks['$' + event];
	  for (var i = 1; i < arguments.length; i++) {
	    args[i - 1] = arguments[i];
	  }
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	  return this;
	};

	// alias used for reserved events (protected method)
	Emitter.prototype.emitReserved = Emitter.prototype.emit;

	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */

	Emitter.prototype.listeners = function (event) {
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};

	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */

	Emitter.prototype.hasListeners = function (event) {
	  return !!this.listeners(event).length;
	};

	var globalThisShim = /*#__PURE__*/function () {
	  if (typeof self !== "undefined") {
	    return self;
	  } else if (typeof window !== "undefined") {
	    return window;
	  } else {
	    return Function("return this")();
	  }
	}();

	function pick(obj) {
	  for (var _len = arguments.length, attr = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    attr[_key - 1] = arguments[_key];
	  }
	  return attr.reduce(function (acc, k) {
	    if (obj.hasOwnProperty(k)) {
	      acc[k] = obj[k];
	    }
	    return acc;
	  }, {});
	}
	// Keep a reference to the real timeout functions so they can be used when overridden
	var NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
	var NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
	function installTimerFunctions(obj, opts) {
	  if (opts.useNativeTimers) {
	    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
	    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
	  } else {
	    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
	    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
	  }
	}
	// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)
	var BASE64_OVERHEAD = 1.33;
	// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9
	function byteLength(obj) {
	  if (typeof obj === "string") {
	    return utf8Length(obj);
	  }
	  // arraybuffer or blob
	  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
	}
	function utf8Length(str) {
	  var c = 0,
	    length = 0;
	  for (var i = 0, l = str.length; i < l; i++) {
	    c = str.charCodeAt(i);
	    if (c < 0x80) {
	      length += 1;
	    } else if (c < 0x800) {
	      length += 2;
	    } else if (c < 0xd800 || c >= 0xe000) {
	      length += 3;
	    } else {
	      i++;
	      length += 4;
	    }
	  }
	  return length;
	}

	// imported from https://github.com/galkn/querystring
	/**
	 * Compiles a querystring
	 * Returns string representation of the object
	 *
	 * @param {Object}
	 * @api private
	 */
	function encode$1(obj) {
	  var str = '';
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      if (str.length) str += '&';
	      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
	    }
	  }
	  return str;
	}
	/**
	 * Parses a simple querystring into an object
	 *
	 * @param {String} qs
	 * @api private
	 */
	function decode(qs) {
	  var qry = {};
	  var pairs = qs.split('&');
	  for (var i = 0, l = pairs.length; i < l; i++) {
	    var pair = pairs[i].split('=');
	    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	  }
	  return qry;
	}

	var TransportError = /*#__PURE__*/function (_Error) {
	  _inherits(TransportError, _Error);
	  var _super = /*#__PURE__*/_createSuper(TransportError);
	  function TransportError(reason, description, context) {
	    var _this;
	    _classCallCheck(this, TransportError);
	    _this = _super.call(this, reason);
	    _this.description = description;
	    _this.context = context;
	    _this.type = "TransportError";
	    return _this;
	  }
	  return _createClass(TransportError);
	}( /*#__PURE__*/_wrapNativeSuper(Error));
	var Transport = /*#__PURE__*/function (_Emitter) {
	  _inherits(Transport, _Emitter);
	  var _super2 = /*#__PURE__*/_createSuper(Transport);
	  /**
	   * Transport abstract constructor.
	   *
	   * @param {Object} opts - options
	   * @protected
	   */
	  function Transport(opts) {
	    var _this2;
	    _classCallCheck(this, Transport);
	    _this2 = _super2.call(this);
	    _this2.writable = false;
	    installTimerFunctions(_assertThisInitialized(_this2), opts);
	    _this2.opts = opts;
	    _this2.query = opts.query;
	    _this2.socket = opts.socket;
	    return _this2;
	  }
	  /**
	   * Emits an error.
	   *
	   * @param {String} reason
	   * @param description
	   * @param context - the error context
	   * @return {Transport} for chaining
	   * @protected
	   */
	  _createClass(Transport, [{
	    key: "onError",
	    value: function onError(reason, description, context) {
	      _get(_getPrototypeOf(Transport.prototype), "emitReserved", this).call(this, "error", new TransportError(reason, description, context));
	      return this;
	    }
	    /**
	     * Opens the transport.
	     */
	  }, {
	    key: "open",
	    value: function open() {
	      this.readyState = "opening";
	      this.doOpen();
	      return this;
	    }
	    /**
	     * Closes the transport.
	     */
	  }, {
	    key: "close",
	    value: function close() {
	      if (this.readyState === "opening" || this.readyState === "open") {
	        this.doClose();
	        this.onClose();
	      }
	      return this;
	    }
	    /**
	     * Sends multiple packets.
	     *
	     * @param {Array} packets
	     */
	  }, {
	    key: "send",
	    value: function send(packets) {
	      if (this.readyState === "open") {
	        this.write(packets);
	      }
	    }
	    /**
	     * Called upon open
	     *
	     * @protected
	     */
	  }, {
	    key: "onOpen",
	    value: function onOpen() {
	      this.readyState = "open";
	      this.writable = true;
	      _get(_getPrototypeOf(Transport.prototype), "emitReserved", this).call(this, "open");
	    }
	    /**
	     * Called with data.
	     *
	     * @param {String} data
	     * @protected
	     */
	  }, {
	    key: "onData",
	    value: function onData(data) {
	      var packet = decodePacket(data, this.socket.binaryType);
	      this.onPacket(packet);
	    }
	    /**
	     * Called with a decoded packet.
	     *
	     * @protected
	     */
	  }, {
	    key: "onPacket",
	    value: function onPacket(packet) {
	      _get(_getPrototypeOf(Transport.prototype), "emitReserved", this).call(this, "packet", packet);
	    }
	    /**
	     * Called upon close.
	     *
	     * @protected
	     */
	  }, {
	    key: "onClose",
	    value: function onClose(details) {
	      this.readyState = "closed";
	      _get(_getPrototypeOf(Transport.prototype), "emitReserved", this).call(this, "close", details);
	    }
	    /**
	     * Pauses the transport, in order not to lose packets during an upgrade.
	     *
	     * @param onPause
	     */
	  }, {
	    key: "pause",
	    value: function pause(onPause) {}
	  }, {
	    key: "createUri",
	    value: function createUri(schema) {
	      var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
	    }
	  }, {
	    key: "_hostname",
	    value: function _hostname() {
	      var hostname = this.opts.hostname;
	      return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
	    }
	  }, {
	    key: "_port",
	    value: function _port() {
	      if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
	        return ":" + this.opts.port;
	      } else {
	        return "";
	      }
	    }
	  }, {
	    key: "_query",
	    value: function _query(query) {
	      var encodedQuery = encode$1(query);
	      return encodedQuery.length ? "?" + encodedQuery : "";
	    }
	  }]);
	  return Transport;
	}(Emitter);

	// imported from https://github.com/unshiftio/yeast

	var alphabet = /*#__PURE__*/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
	  length$1 = 64;
	var seed = 0,
	  prev$1;
	/**
	 * Return a string representing the specified number.
	 *
	 * @param {Number} num The number to convert.
	 * @returns {String} The string representation of the number.
	 * @api public
	 */
	function encode(num) {
	  var encoded = '';
	  do {
	    encoded = alphabet[num % length$1] + encoded;
	    num = Math.floor(num / length$1);
	  } while (num > 0);
	  return encoded;
	}
	/**
	 * Yeast: A tiny growing id generator.
	 *
	 * @returns {String} A unique id.
	 * @api public
	 */
	function yeast() {
	  var now = encode(+new Date());
	  if (now !== prev$1) return seed = 0, prev$1 = now;
	  return now + '.' + encode(seed++);
	}

	// imported from https://github.com/component/has-cors
	var value = false;
	try {
	  value = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in /*#__PURE__*/new XMLHttpRequest();
	} catch (err) {
	  // if XMLHttp support is disabled in IE then it will throw
	  // when trying to create
	}
	var hasCORS = value;

	// browser shim for xmlhttprequest module
	function XHR(opts) {
	  var xdomain = opts.xdomain;
	  // XMLHttpRequest can be disabled on IE
	  try {
	    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
	      return new XMLHttpRequest();
	    }
	  } catch (e) {}
	  if (!xdomain) {
	    try {
	      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
	    } catch (e) {}
	  }
	}
	function createCookieJar() {}

	function empty$1() {}
	var hasXHR2 = /*#__PURE__*/function () {
	  var xhr = /*#__PURE__*/new XHR({
	    xdomain: false
	  });
	  return null != xhr.responseType;
	}();
	var Polling = /*#__PURE__*/function (_Transport) {
	  _inherits(Polling, _Transport);
	  var _super = /*#__PURE__*/_createSuper(Polling);
	  /**
	   * XHR Polling constructor.
	   *
	   * @param {Object} opts
	   * @package
	   */
	  function Polling(opts) {
	    var _this;
	    _classCallCheck(this, Polling);
	    _this = _super.call(this, opts);
	    _this.polling = false;
	    if (typeof location !== "undefined") {
	      var isSSL = "https:" === location.protocol;
	      var port = location.port;
	      // some user agents have empty `location.port`
	      if (!port) {
	        port = isSSL ? "443" : "80";
	      }
	      _this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
	    }
	    /**
	     * XHR supports binary
	     */
	    var forceBase64 = opts && opts.forceBase64;
	    _this.supportsBinary = hasXHR2 && !forceBase64;
	    if (_this.opts.withCredentials) {
	      _this.cookieJar = createCookieJar();
	    }
	    return _this;
	  }
	  _createClass(Polling, [{
	    key: "name",
	    get: function get() {
	      return "polling";
	    }
	    /**
	     * Opens the socket (triggers polling). We write a PING message to determine
	     * when the transport is open.
	     *
	     * @protected
	     */
	  }, {
	    key: "doOpen",
	    value: function doOpen() {
	      this.poll();
	    }
	    /**
	     * Pauses polling.
	     *
	     * @param {Function} onPause - callback upon buffers are flushed and transport is paused
	     * @package
	     */
	  }, {
	    key: "pause",
	    value: function pause(onPause) {
	      var _this2 = this;
	      this.readyState = "pausing";
	      var pause = function pause() {
	        _this2.readyState = "paused";
	        onPause();
	      };
	      if (this.polling || !this.writable) {
	        var total = 0;
	        if (this.polling) {
	          total++;
	          this.once("pollComplete", function () {
	            --total || pause();
	          });
	        }
	        if (!this.writable) {
	          total++;
	          this.once("drain", function () {
	            --total || pause();
	          });
	        }
	      } else {
	        pause();
	      }
	    }
	    /**
	     * Starts polling cycle.
	     *
	     * @private
	     */
	  }, {
	    key: "poll",
	    value: function poll() {
	      this.polling = true;
	      this.doPoll();
	      this.emitReserved("poll");
	    }
	    /**
	     * Overloads onData to detect payloads.
	     *
	     * @protected
	     */
	  }, {
	    key: "onData",
	    value: function onData(data) {
	      var _this3 = this;
	      var callback = function callback(packet) {
	        // if its the first message we consider the transport open
	        if ("opening" === _this3.readyState && packet.type === "open") {
	          _this3.onOpen();
	        }
	        // if its a close packet, we close the ongoing requests
	        if ("close" === packet.type) {
	          _this3.onClose({
	            description: "transport closed by the server"
	          });
	          return false;
	        }
	        // otherwise bypass onData and handle the message
	        _this3.onPacket(packet);
	      };
	      // decode payload
	      decodePayload(data, this.socket.binaryType).forEach(callback);
	      // if an event did not trigger closing
	      if ("closed" !== this.readyState) {
	        // if we got data we're not polling
	        this.polling = false;
	        this.emitReserved("pollComplete");
	        if ("open" === this.readyState) {
	          this.poll();
	        }
	      }
	    }
	    /**
	     * For polling, send a close packet.
	     *
	     * @protected
	     */
	  }, {
	    key: "doClose",
	    value: function doClose() {
	      var _this4 = this;
	      var close = function close() {
	        _this4.write([{
	          type: "close"
	        }]);
	      };
	      if ("open" === this.readyState) {
	        close();
	      } else {
	        // in case we're trying to close while
	        // handshaking is in progress (GH-164)
	        this.once("open", close);
	      }
	    }
	    /**
	     * Writes a packets payload.
	     *
	     * @param {Array} packets - data packets
	     * @protected
	     */
	  }, {
	    key: "write",
	    value: function write(packets) {
	      var _this5 = this;
	      this.writable = false;
	      encodePayload(packets, function (data) {
	        _this5.doWrite(data, function () {
	          _this5.writable = true;
	          _this5.emitReserved("drain");
	        });
	      });
	    }
	    /**
	     * Generates uri for connection.
	     *
	     * @private
	     */
	  }, {
	    key: "uri",
	    value: function uri() {
	      var schema = this.opts.secure ? "https" : "http";
	      var query = this.query || {};
	      // cache busting is forced
	      if (false !== this.opts.timestampRequests) {
	        query[this.opts.timestampParam] = yeast();
	      }
	      if (!this.supportsBinary && !query.sid) {
	        query.b64 = 1;
	      }
	      return this.createUri(schema, query);
	    }
	    /**
	     * Creates a request.
	     *
	     * @param {String} method
	     * @private
	     */
	  }, {
	    key: "request",
	    value: function request() {
	      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      Object.assign(opts, {
	        xd: this.xd,
	        cookieJar: this.cookieJar
	      }, this.opts);
	      return new Request(this.uri(), opts);
	    }
	    /**
	     * Sends data.
	     *
	     * @param {String} data to send.
	     * @param {Function} called upon flush.
	     * @private
	     */
	  }, {
	    key: "doWrite",
	    value: function doWrite(data, fn) {
	      var _this6 = this;
	      var req = this.request({
	        method: "POST",
	        data: data
	      });
	      req.on("success", fn);
	      req.on("error", function (xhrStatus, context) {
	        _this6.onError("xhr post error", xhrStatus, context);
	      });
	    }
	    /**
	     * Starts a poll cycle.
	     *
	     * @private
	     */
	  }, {
	    key: "doPoll",
	    value: function doPoll() {
	      var _this7 = this;
	      var req = this.request();
	      req.on("data", this.onData.bind(this));
	      req.on("error", function (xhrStatus, context) {
	        _this7.onError("xhr poll error", xhrStatus, context);
	      });
	      this.pollXhr = req;
	    }
	  }]);
	  return Polling;
	}(Transport);
	var Request = /*#__PURE__*/function (_Emitter) {
	  _inherits(Request, _Emitter);
	  var _super2 = /*#__PURE__*/_createSuper(Request);
	  /**
	   * Request constructor
	   *
	   * @param {Object} options
	   * @package
	   */
	  function Request(uri, opts) {
	    var _this8;
	    _classCallCheck(this, Request);
	    _this8 = _super2.call(this);
	    installTimerFunctions(_assertThisInitialized(_this8), opts);
	    _this8.opts = opts;
	    _this8.method = opts.method || "GET";
	    _this8.uri = uri;
	    _this8.data = undefined !== opts.data ? opts.data : null;
	    _this8.create();
	    return _this8;
	  }
	  /**
	   * Creates the XHR object and sends the request.
	   *
	   * @private
	   */
	  _createClass(Request, [{
	    key: "create",
	    value: function create() {
	      var _this9 = this;
	      var _a;
	      var opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
	      opts.xdomain = !!this.opts.xd;
	      var xhr = this.xhr = new XHR(opts);
	      try {
	        xhr.open(this.method, this.uri, true);
	        try {
	          if (this.opts.extraHeaders) {
	            xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
	            for (var i in this.opts.extraHeaders) {
	              if (this.opts.extraHeaders.hasOwnProperty(i)) {
	                xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
	              }
	            }
	          }
	        } catch (e) {}
	        if ("POST" === this.method) {
	          try {
	            xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
	          } catch (e) {}
	        }
	        try {
	          xhr.setRequestHeader("Accept", "*/*");
	        } catch (e) {}
	        (_a = this.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
	        // ie6 check
	        if ("withCredentials" in xhr) {
	          xhr.withCredentials = this.opts.withCredentials;
	        }
	        if (this.opts.requestTimeout) {
	          xhr.timeout = this.opts.requestTimeout;
	        }
	        xhr.onreadystatechange = function () {
	          var _a;
	          if (xhr.readyState === 3) {
	            (_a = _this9.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(xhr);
	          }
	          if (4 !== xhr.readyState) return;
	          if (200 === xhr.status || 1223 === xhr.status) {
	            _this9.onLoad();
	          } else {
	            // make sure the `error` event handler that's user-set
	            // does not throw in the same tick and gets caught here
	            _this9.setTimeoutFn(function () {
	              _this9.onError(typeof xhr.status === "number" ? xhr.status : 0);
	            }, 0);
	          }
	        };
	        xhr.send(this.data);
	      } catch (e) {
	        // Need to defer since .create() is called directly from the constructor
	        // and thus the 'error' event can only be only bound *after* this exception
	        // occurs.  Therefore, also, we cannot throw here at all.
	        this.setTimeoutFn(function () {
	          _this9.onError(e);
	        }, 0);
	        return;
	      }
	      if (typeof document !== "undefined") {
	        this.index = Request.requestsCount++;
	        Request.requests[this.index] = this;
	      }
	    }
	    /**
	     * Called upon error.
	     *
	     * @private
	     */
	  }, {
	    key: "onError",
	    value: function onError(err) {
	      this.emitReserved("error", err, this.xhr);
	      this.cleanup(true);
	    }
	    /**
	     * Cleans up house.
	     *
	     * @private
	     */
	  }, {
	    key: "cleanup",
	    value: function cleanup(fromError) {
	      if ("undefined" === typeof this.xhr || null === this.xhr) {
	        return;
	      }
	      this.xhr.onreadystatechange = empty$1;
	      if (fromError) {
	        try {
	          this.xhr.abort();
	        } catch (e) {}
	      }
	      if (typeof document !== "undefined") {
	        delete Request.requests[this.index];
	      }
	      this.xhr = null;
	    }
	    /**
	     * Called upon load.
	     *
	     * @private
	     */
	  }, {
	    key: "onLoad",
	    value: function onLoad() {
	      var data = this.xhr.responseText;
	      if (data !== null) {
	        this.emitReserved("data", data);
	        this.emitReserved("success");
	        this.cleanup();
	      }
	    }
	    /**
	     * Aborts the request.
	     *
	     * @package
	     */
	  }, {
	    key: "abort",
	    value: function abort() {
	      this.cleanup();
	    }
	  }]);
	  return Request;
	}(Emitter);
	Request.requestsCount = 0;
	Request.requests = {};
	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */
	if (typeof document !== "undefined") {
	  // @ts-ignore
	  if (typeof attachEvent === "function") {
	    // @ts-ignore
	    attachEvent("onunload", unloadHandler);
	  } else if (typeof addEventListener === "function") {
	    var terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
	    addEventListener(terminationEvent, unloadHandler, false);
	  }
	}
	function unloadHandler() {
	  for (var i in Request.requests) {
	    if (Request.requests.hasOwnProperty(i)) {
	      Request.requests[i].abort();
	    }
	  }
	}

	var nextTick = /*#__PURE__*/function () {
	  var isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
	  if (isPromiseAvailable) {
	    return function (cb) {
	      return Promise.resolve().then(cb);
	    };
	  } else {
	    return function (cb, setTimeoutFn) {
	      return setTimeoutFn(cb, 0);
	    };
	  }
	}();
	var WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
	var usingBrowserWebSocket = true;
	var defaultBinaryType = "arraybuffer";

	// detect ReactNative environment
	var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && /*#__PURE__*/navigator.product.toLowerCase() === "reactnative";
	var WS = /*#__PURE__*/function (_Transport) {
	  _inherits(WS, _Transport);
	  var _super = /*#__PURE__*/_createSuper(WS);
	  /**
	   * WebSocket transport constructor.
	   *
	   * @param {Object} opts - connection options
	   * @protected
	   */
	  function WS(opts) {
	    var _this;
	    _classCallCheck(this, WS);
	    _this = _super.call(this, opts);
	    _this.supportsBinary = !opts.forceBase64;
	    return _this;
	  }
	  _createClass(WS, [{
	    key: "name",
	    get: function get() {
	      return "websocket";
	    }
	  }, {
	    key: "doOpen",
	    value: function doOpen() {
	      if (!this.check()) {
	        // let probe timeout
	        return;
	      }
	      var uri = this.uri();
	      var protocols = this.opts.protocols;
	      // React Native only supports the 'headers' option, and will print a warning if anything else is passed
	      var opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
	      if (this.opts.extraHeaders) {
	        opts.headers = this.opts.extraHeaders;
	      }
	      try {
	        this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
	      } catch (err) {
	        return this.emitReserved("error", err);
	      }
	      this.ws.binaryType = this.socket.binaryType;
	      this.addEventListeners();
	    }
	    /**
	     * Adds event listeners to the socket
	     *
	     * @private
	     */
	  }, {
	    key: "addEventListeners",
	    value: function addEventListeners() {
	      var _this2 = this;
	      this.ws.onopen = function () {
	        if (_this2.opts.autoUnref) {
	          _this2.ws._socket.unref();
	        }
	        _this2.onOpen();
	      };
	      this.ws.onclose = function (closeEvent) {
	        return _this2.onClose({
	          description: "websocket connection closed",
	          context: closeEvent
	        });
	      };
	      this.ws.onmessage = function (ev) {
	        return _this2.onData(ev.data);
	      };
	      this.ws.onerror = function (e) {
	        return _this2.onError("websocket error", e);
	      };
	    }
	  }, {
	    key: "write",
	    value: function write(packets) {
	      var _this3 = this;
	      this.writable = false;
	      // encodePacket efficient as it uses WS framing
	      // no need for encodePayload
	      var _loop = function _loop() {
	        var packet = packets[i];
	        var lastPacket = i === packets.length - 1;
	        encodePacket(packet, _this3.supportsBinary, function (data) {
	          // always create a new object (GH-437)
	          var opts = {};
	          // Sometimes the websocket has already been closed but the browser didn't
	          // have a chance of informing us about it yet, in that case send will
	          // throw an error
	          try {
	            if (usingBrowserWebSocket) {
	              // TypeError is thrown when passing the second argument on Safari
	              _this3.ws.send(data);
	            }
	          } catch (e) {}
	          if (lastPacket) {
	            // fake drain
	            // defer to next tick to allow Socket to clear writeBuffer
	            nextTick(function () {
	              _this3.writable = true;
	              _this3.emitReserved("drain");
	            }, _this3.setTimeoutFn);
	          }
	        });
	      };
	      for (var i = 0; i < packets.length; i++) {
	        _loop();
	      }
	    }
	  }, {
	    key: "doClose",
	    value: function doClose() {
	      if (typeof this.ws !== "undefined") {
	        this.ws.close();
	        this.ws = null;
	      }
	    }
	    /**
	     * Generates uri for connection.
	     *
	     * @private
	     */
	  }, {
	    key: "uri",
	    value: function uri() {
	      var schema = this.opts.secure ? "wss" : "ws";
	      var query = this.query || {};
	      // append timestamp to URI
	      if (this.opts.timestampRequests) {
	        query[this.opts.timestampParam] = yeast();
	      }
	      // communicate binary support capabilities
	      if (!this.supportsBinary) {
	        query.b64 = 1;
	      }
	      return this.createUri(schema, query);
	    }
	    /**
	     * Feature detection for WebSocket.
	     *
	     * @return {Boolean} whether this transport is available.
	     * @private
	     */
	  }, {
	    key: "check",
	    value: function check() {
	      return !!WebSocket;
	    }
	  }]);
	  return WS;
	}(Transport);

	var WT = /*#__PURE__*/function (_Transport) {
	  _inherits(WT, _Transport);
	  var _super = /*#__PURE__*/_createSuper(WT);
	  function WT() {
	    _classCallCheck(this, WT);
	    return _super.apply(this, arguments);
	  }
	  _createClass(WT, [{
	    key: "name",
	    get: function get() {
	      return "webtransport";
	    }
	  }, {
	    key: "doOpen",
	    value: function doOpen() {
	      var _this = this;
	      // @ts-ignore
	      if (typeof WebTransport !== "function") {
	        return;
	      }
	      // @ts-ignore
	      this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
	      this.transport.closed.then(function () {
	        _this.onClose();
	      })["catch"](function (err) {
	        _this.onError("webtransport error", err);
	      });
	      // note: we could have used async/await, but that would require some additional polyfills
	      this.transport.ready.then(function () {
	        _this.transport.createBidirectionalStream().then(function (stream) {
	          var decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, _this.socket.binaryType);
	          var reader = stream.readable.pipeThrough(decoderStream).getReader();
	          var encoderStream = createPacketEncoderStream();
	          encoderStream.readable.pipeTo(stream.writable);
	          _this.writer = encoderStream.writable.getWriter();
	          var read = function read() {
	            reader.read().then(function (_ref) {
	              var done = _ref.done,
	                value = _ref.value;
	              if (done) {
	                return;
	              }
	              _this.onPacket(value);
	              read();
	            })["catch"](function (err) {});
	          };
	          read();
	          var packet = {
	            type: "open"
	          };
	          if (_this.query.sid) {
	            packet.data = "{\"sid\":\"".concat(_this.query.sid, "\"}");
	          }
	          _this.writer.write(packet).then(function () {
	            return _this.onOpen();
	          });
	        });
	      });
	    }
	  }, {
	    key: "write",
	    value: function write(packets) {
	      var _this2 = this;
	      this.writable = false;
	      var _loop = function _loop() {
	        var packet = packets[i];
	        var lastPacket = i === packets.length - 1;
	        _this2.writer.write(packet).then(function () {
	          if (lastPacket) {
	            nextTick(function () {
	              _this2.writable = true;
	              _this2.emitReserved("drain");
	            }, _this2.setTimeoutFn);
	          }
	        });
	      };
	      for (var i = 0; i < packets.length; i++) {
	        _loop();
	      }
	    }
	  }, {
	    key: "doClose",
	    value: function doClose() {
	      var _a;
	      (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();
	    }
	  }]);
	  return WT;
	}(Transport);

	var transports = {
	  websocket: WS,
	  webtransport: WT,
	  polling: Polling
	};

	// imported from https://github.com/galkn/parseuri
	/**
	 * Parses a URI
	 *
	 * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.
	 *
	 * See:
	 * - https://developer.mozilla.org/en-US/docs/Web/API/URL
	 * - https://caniuse.com/url
	 * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B
	 *
	 * History of the parse() method:
	 * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c
	 * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3
	 * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */
	var re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
	var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
	function parse$1(str) {
	  var src = str,
	    b = str.indexOf('['),
	    e = str.indexOf(']');
	  if (b != -1 && e != -1) {
	    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
	  }
	  var m = re.exec(str || ''),
	    uri = {},
	    i = 14;
	  while (i--) {
	    uri[parts[i]] = m[i] || '';
	  }
	  if (b != -1 && e != -1) {
	    uri.source = src;
	    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
	    uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
	    uri.ipv6uri = true;
	  }
	  uri.pathNames = pathNames(uri, uri['path']);
	  uri.queryKey = queryKey(uri, uri['query']);
	  return uri;
	}
	function pathNames(obj, path) {
	  var regx = /\/{2,9}/g,
	    names = path.replace(regx, "/").split("/");
	  if (path.slice(0, 1) == '/' || path.length === 0) {
	    names.splice(0, 1);
	  }
	  if (path.slice(-1) == '/') {
	    names.splice(names.length - 1, 1);
	  }
	  return names;
	}
	function queryKey(uri, query) {
	  var data = {};
	  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
	    if ($1) {
	      data[$1] = $2;
	    }
	  });
	  return data;
	}

	var Socket$1 = /*#__PURE__*/function (_Emitter) {
	  _inherits(Socket, _Emitter);
	  var _super = /*#__PURE__*/_createSuper(Socket);
	  /**
	   * Socket constructor.
	   *
	   * @param {String|Object} uri - uri or options
	   * @param {Object} opts - options
	   */
	  function Socket(uri) {
	    var _this;
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    _classCallCheck(this, Socket);
	    _this = _super.call(this);
	    _this.binaryType = defaultBinaryType;
	    _this.writeBuffer = [];
	    if (uri && "object" === _typeof(uri)) {
	      opts = uri;
	      uri = null;
	    }
	    if (uri) {
	      uri = parse$1(uri);
	      opts.hostname = uri.host;
	      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
	      opts.port = uri.port;
	      if (uri.query) opts.query = uri.query;
	    } else if (opts.host) {
	      opts.hostname = parse$1(opts.host).host;
	    }
	    installTimerFunctions(_assertThisInitialized(_this), opts);
	    _this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
	    if (opts.hostname && !opts.port) {
	      // if no port is specified manually, use the protocol default
	      opts.port = _this.secure ? "443" : "80";
	    }
	    _this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
	    _this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : _this.secure ? "443" : "80");
	    _this.transports = opts.transports || ["polling", "websocket", "webtransport"];
	    _this.writeBuffer = [];
	    _this.prevBufferLen = 0;
	    _this.opts = Object.assign({
	      path: "/engine.io",
	      agent: false,
	      withCredentials: false,
	      upgrade: true,
	      timestampParam: "t",
	      rememberUpgrade: false,
	      addTrailingSlash: true,
	      rejectUnauthorized: true,
	      perMessageDeflate: {
	        threshold: 1024
	      },
	      transportOptions: {},
	      closeOnBeforeunload: false
	    }, opts);
	    _this.opts.path = _this.opts.path.replace(/\/$/, "") + (_this.opts.addTrailingSlash ? "/" : "");
	    if (typeof _this.opts.query === "string") {
	      _this.opts.query = decode(_this.opts.query);
	    }
	    // set on handshake
	    _this.id = null;
	    _this.upgrades = null;
	    _this.pingInterval = null;
	    _this.pingTimeout = null;
	    // set on heartbeat
	    _this.pingTimeoutTimer = null;
	    if (typeof addEventListener === "function") {
	      if (_this.opts.closeOnBeforeunload) {
	        // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
	        // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
	        // closed/reloaded)
	        _this.beforeunloadEventListener = function () {
	          if (_this.transport) {
	            // silently close the transport
	            _this.transport.removeAllListeners();
	            _this.transport.close();
	          }
	        };
	        addEventListener("beforeunload", _this.beforeunloadEventListener, false);
	      }
	      if (_this.hostname !== "localhost") {
	        _this.offlineEventListener = function () {
	          _this.onClose("transport close", {
	            description: "network connection lost"
	          });
	        };
	        addEventListener("offline", _this.offlineEventListener, false);
	      }
	    }
	    _this.open();
	    return _this;
	  }
	  /**
	   * Creates transport of the given type.
	   *
	   * @param {String} name - transport name
	   * @return {Transport}
	   * @private
	   */
	  _createClass(Socket, [{
	    key: "createTransport",
	    value: function createTransport(name) {
	      var query = Object.assign({}, this.opts.query);
	      // append engine.io protocol identifier
	      query.EIO = protocol$1;
	      // transport name
	      query.transport = name;
	      // session id if we already have one
	      if (this.id) query.sid = this.id;
	      var opts = Object.assign({}, this.opts, {
	        query: query,
	        socket: this,
	        hostname: this.hostname,
	        secure: this.secure,
	        port: this.port
	      }, this.opts.transportOptions[name]);
	      return new transports[name](opts);
	    }
	    /**
	     * Initializes transport to use and starts probe.
	     *
	     * @private
	     */
	  }, {
	    key: "open",
	    value: function open() {
	      var _this2 = this;
	      var transport;
	      if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
	        transport = "websocket";
	      } else if (0 === this.transports.length) {
	        // Emit error on next tick so it can be listened to
	        this.setTimeoutFn(function () {
	          _this2.emitReserved("error", "No transports available");
	        }, 0);
	        return;
	      } else {
	        transport = this.transports[0];
	      }
	      this.readyState = "opening";
	      // Retry with the next transport if the transport is disabled (jsonp: false)
	      try {
	        transport = this.createTransport(transport);
	      } catch (e) {
	        this.transports.shift();
	        this.open();
	        return;
	      }
	      transport.open();
	      this.setTransport(transport);
	    }
	    /**
	     * Sets the current transport. Disables the existing one (if any).
	     *
	     * @private
	     */
	  }, {
	    key: "setTransport",
	    value: function setTransport(transport) {
	      var _this3 = this;
	      if (this.transport) {
	        this.transport.removeAllListeners();
	      }
	      // set up transport
	      this.transport = transport;
	      // set up transport listeners
	      transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", function (reason) {
	        return _this3.onClose("transport close", reason);
	      });
	    }
	    /**
	     * Probes a transport.
	     *
	     * @param {String} name - transport name
	     * @private
	     */
	  }, {
	    key: "probe",
	    value: function probe(name) {
	      var _this4 = this;
	      var transport = this.createTransport(name);
	      var failed = false;
	      Socket.priorWebsocketSuccess = false;
	      var onTransportOpen = function onTransportOpen() {
	        if (failed) return;
	        transport.send([{
	          type: "ping",
	          data: "probe"
	        }]);
	        transport.once("packet", function (msg) {
	          if (failed) return;
	          if ("pong" === msg.type && "probe" === msg.data) {
	            _this4.upgrading = true;
	            _this4.emitReserved("upgrading", transport);
	            if (!transport) return;
	            Socket.priorWebsocketSuccess = "websocket" === transport.name;
	            _this4.transport.pause(function () {
	              if (failed) return;
	              if ("closed" === _this4.readyState) return;
	              cleanup();
	              _this4.setTransport(transport);
	              transport.send([{
	                type: "upgrade"
	              }]);
	              _this4.emitReserved("upgrade", transport);
	              transport = null;
	              _this4.upgrading = false;
	              _this4.flush();
	            });
	          } else {
	            var err = new Error("probe error");
	            // @ts-ignore
	            err.transport = transport.name;
	            _this4.emitReserved("upgradeError", err);
	          }
	        });
	      };
	      function freezeTransport() {
	        if (failed) return;
	        // Any callback called by transport should be ignored since now
	        failed = true;
	        cleanup();
	        transport.close();
	        transport = null;
	      }
	      // Handle any error that happens while probing
	      var onerror = function onerror(err) {
	        var error = new Error("probe error: " + err);
	        // @ts-ignore
	        error.transport = transport.name;
	        freezeTransport();
	        _this4.emitReserved("upgradeError", error);
	      };
	      function onTransportClose() {
	        onerror("transport closed");
	      }
	      // When the socket is closed while we're probing
	      function onclose() {
	        onerror("socket closed");
	      }
	      // When the socket is upgraded while we're probing
	      function onupgrade(to) {
	        if (transport && to.name !== transport.name) {
	          freezeTransport();
	        }
	      }
	      // Remove all listeners on the transport and on self
	      var cleanup = function cleanup() {
	        transport.removeListener("open", onTransportOpen);
	        transport.removeListener("error", onerror);
	        transport.removeListener("close", onTransportClose);
	        _this4.off("close", onclose);
	        _this4.off("upgrading", onupgrade);
	      };
	      transport.once("open", onTransportOpen);
	      transport.once("error", onerror);
	      transport.once("close", onTransportClose);
	      this.once("close", onclose);
	      this.once("upgrading", onupgrade);
	      if (this.upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
	        // favor WebTransport
	        this.setTimeoutFn(function () {
	          if (!failed) {
	            transport.open();
	          }
	        }, 200);
	      } else {
	        transport.open();
	      }
	    }
	    /**
	     * Called when connection is deemed open.
	     *
	     * @private
	     */
	  }, {
	    key: "onOpen",
	    value: function onOpen() {
	      this.readyState = "open";
	      Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
	      this.emitReserved("open");
	      this.flush();
	      // we check for `readyState` in case an `open`
	      // listener already closed the socket
	      if ("open" === this.readyState && this.opts.upgrade) {
	        var i = 0;
	        var l = this.upgrades.length;
	        for (; i < l; i++) {
	          this.probe(this.upgrades[i]);
	        }
	      }
	    }
	    /**
	     * Handles a packet.
	     *
	     * @private
	     */
	  }, {
	    key: "onPacket",
	    value: function onPacket(packet) {
	      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
	        this.emitReserved("packet", packet);
	        // Socket is live - any packet counts
	        this.emitReserved("heartbeat");
	        this.resetPingTimeout();
	        switch (packet.type) {
	          case "open":
	            this.onHandshake(JSON.parse(packet.data));
	            break;
	          case "ping":
	            this.sendPacket("pong");
	            this.emitReserved("ping");
	            this.emitReserved("pong");
	            break;
	          case "error":
	            var err = new Error("server error");
	            // @ts-ignore
	            err.code = packet.data;
	            this.onError(err);
	            break;
	          case "message":
	            this.emitReserved("data", packet.data);
	            this.emitReserved("message", packet.data);
	            break;
	        }
	      }
	    }
	    /**
	     * Called upon handshake completion.
	     *
	     * @param {Object} data - handshake obj
	     * @private
	     */
	  }, {
	    key: "onHandshake",
	    value: function onHandshake(data) {
	      this.emitReserved("handshake", data);
	      this.id = data.sid;
	      this.transport.query.sid = data.sid;
	      this.upgrades = this.filterUpgrades(data.upgrades);
	      this.pingInterval = data.pingInterval;
	      this.pingTimeout = data.pingTimeout;
	      this.maxPayload = data.maxPayload;
	      this.onOpen();
	      // In case open handler closes socket
	      if ("closed" === this.readyState) return;
	      this.resetPingTimeout();
	    }
	    /**
	     * Sets and resets ping timeout timer based on server pings.
	     *
	     * @private
	     */
	  }, {
	    key: "resetPingTimeout",
	    value: function resetPingTimeout() {
	      var _this5 = this;
	      this.clearTimeoutFn(this.pingTimeoutTimer);
	      this.pingTimeoutTimer = this.setTimeoutFn(function () {
	        _this5.onClose("ping timeout");
	      }, this.pingInterval + this.pingTimeout);
	      if (this.opts.autoUnref) {
	        this.pingTimeoutTimer.unref();
	      }
	    }
	    /**
	     * Called on `drain` event
	     *
	     * @private
	     */
	  }, {
	    key: "onDrain",
	    value: function onDrain() {
	      this.writeBuffer.splice(0, this.prevBufferLen);
	      // setting prevBufferLen = 0 is very important
	      // for example, when upgrading, upgrade packet is sent over,
	      // and a nonzero prevBufferLen could cause problems on `drain`
	      this.prevBufferLen = 0;
	      if (0 === this.writeBuffer.length) {
	        this.emitReserved("drain");
	      } else {
	        this.flush();
	      }
	    }
	    /**
	     * Flush write buffers.
	     *
	     * @private
	     */
	  }, {
	    key: "flush",
	    value: function flush() {
	      if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
	        var packets = this.getWritablePackets();
	        this.transport.send(packets);
	        // keep track of current length of writeBuffer
	        // splice writeBuffer and callbackBuffer on `drain`
	        this.prevBufferLen = packets.length;
	        this.emitReserved("flush");
	      }
	    }
	    /**
	     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
	     * long-polling)
	     *
	     * @private
	     */
	  }, {
	    key: "getWritablePackets",
	    value: function getWritablePackets() {
	      var shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
	      if (!shouldCheckPayloadSize) {
	        return this.writeBuffer;
	      }
	      var payloadSize = 1; // first packet type
	      for (var i = 0; i < this.writeBuffer.length; i++) {
	        var data = this.writeBuffer[i].data;
	        if (data) {
	          payloadSize += byteLength(data);
	        }
	        if (i > 0 && payloadSize > this.maxPayload) {
	          return this.writeBuffer.slice(0, i);
	        }
	        payloadSize += 2; // separator + packet type
	      }

	      return this.writeBuffer;
	    }
	    /**
	     * Sends a message.
	     *
	     * @param {String} msg - message.
	     * @param {Object} options.
	     * @param {Function} callback function.
	     * @return {Socket} for chaining.
	     */
	  }, {
	    key: "write",
	    value: function write(msg, options, fn) {
	      this.sendPacket("message", msg, options, fn);
	      return this;
	    }
	  }, {
	    key: "send",
	    value: function send(msg, options, fn) {
	      this.sendPacket("message", msg, options, fn);
	      return this;
	    }
	    /**
	     * Sends a packet.
	     *
	     * @param {String} type: packet type.
	     * @param {String} data.
	     * @param {Object} options.
	     * @param {Function} fn - callback function.
	     * @private
	     */
	  }, {
	    key: "sendPacket",
	    value: function sendPacket(type, data, options, fn) {
	      if ("function" === typeof data) {
	        fn = data;
	        data = undefined;
	      }
	      if ("function" === typeof options) {
	        fn = options;
	        options = null;
	      }
	      if ("closing" === this.readyState || "closed" === this.readyState) {
	        return;
	      }
	      options = options || {};
	      options.compress = false !== options.compress;
	      var packet = {
	        type: type,
	        data: data,
	        options: options
	      };
	      this.emitReserved("packetCreate", packet);
	      this.writeBuffer.push(packet);
	      if (fn) this.once("flush", fn);
	      this.flush();
	    }
	    /**
	     * Closes the connection.
	     */
	  }, {
	    key: "close",
	    value: function close() {
	      var _this6 = this;
	      var close = function close() {
	        _this6.onClose("forced close");
	        _this6.transport.close();
	      };
	      var cleanupAndClose = function cleanupAndClose() {
	        _this6.off("upgrade", cleanupAndClose);
	        _this6.off("upgradeError", cleanupAndClose);
	        close();
	      };
	      var waitForUpgrade = function waitForUpgrade() {
	        // wait for upgrade to finish since we can't send packets while pausing a transport
	        _this6.once("upgrade", cleanupAndClose);
	        _this6.once("upgradeError", cleanupAndClose);
	      };
	      if ("opening" === this.readyState || "open" === this.readyState) {
	        this.readyState = "closing";
	        if (this.writeBuffer.length) {
	          this.once("drain", function () {
	            if (_this6.upgrading) {
	              waitForUpgrade();
	            } else {
	              close();
	            }
	          });
	        } else if (this.upgrading) {
	          waitForUpgrade();
	        } else {
	          close();
	        }
	      }
	      return this;
	    }
	    /**
	     * Called upon transport error
	     *
	     * @private
	     */
	  }, {
	    key: "onError",
	    value: function onError(err) {
	      Socket.priorWebsocketSuccess = false;
	      this.emitReserved("error", err);
	      this.onClose("transport error", err);
	    }
	    /**
	     * Called upon transport close.
	     *
	     * @private
	     */
	  }, {
	    key: "onClose",
	    value: function onClose(reason, description) {
	      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
	        // clear timers
	        this.clearTimeoutFn(this.pingTimeoutTimer);
	        // stop event from firing again for transport
	        this.transport.removeAllListeners("close");
	        // ensure transport won't stay open
	        this.transport.close();
	        // ignore further transport communication
	        this.transport.removeAllListeners();
	        if (typeof removeEventListener === "function") {
	          removeEventListener("beforeunload", this.beforeunloadEventListener, false);
	          removeEventListener("offline", this.offlineEventListener, false);
	        }
	        // set ready state
	        this.readyState = "closed";
	        // clear session id
	        this.id = null;
	        // emit close event
	        this.emitReserved("close", reason, description);
	        // clean buffers after, so users can still
	        // grab the buffers on `close` event
	        this.writeBuffer = [];
	        this.prevBufferLen = 0;
	      }
	    }
	    /**
	     * Filters upgrades, returning only those matching client transports.
	     *
	     * @param {Array} upgrades - server upgrades
	     * @private
	     */
	  }, {
	    key: "filterUpgrades",
	    value: function filterUpgrades(upgrades) {
	      var filteredUpgrades = [];
	      var i = 0;
	      var j = upgrades.length;
	      for (; i < j; i++) {
	        if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);
	      }
	      return filteredUpgrades;
	    }
	  }]);
	  return Socket;
	}(Emitter);
	Socket$1.protocol = protocol$1;

	/**
	 * URL parser.
	 *
	 * @param uri - url
	 * @param path - the request path of the connection
	 * @param loc - An object meant to mimic window.location.
	 *        Defaults to window.location.
	 * @public
	 */
	function url(uri) {
	  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
	  var loc = arguments.length > 2 ? arguments[2] : undefined;
	  var obj = uri;
	  // default to window.location
	  loc = loc || typeof location !== "undefined" && location;
	  if (null == uri) uri = loc.protocol + "//" + loc.host;
	  // relative path support
	  if (typeof uri === "string") {
	    if ("/" === uri.charAt(0)) {
	      if ("/" === uri.charAt(1)) {
	        uri = loc.protocol + uri;
	      } else {
	        uri = loc.host + uri;
	      }
	    }
	    if (!/^(https?|wss?):\/\//.test(uri)) {
	      if ("undefined" !== typeof loc) {
	        uri = loc.protocol + "//" + uri;
	      } else {
	        uri = "https://" + uri;
	      }
	    }
	    // parse
	    obj = parse$1(uri);
	  }
	  // make sure we treat `localhost:80` and `localhost` equally
	  if (!obj.port) {
	    if (/^(http|ws)$/.test(obj.protocol)) {
	      obj.port = "80";
	    } else if (/^(http|ws)s$/.test(obj.protocol)) {
	      obj.port = "443";
	    }
	  }
	  obj.path = obj.path || "/";
	  var ipv6 = obj.host.indexOf(":") !== -1;
	  var host = ipv6 ? "[" + obj.host + "]" : obj.host;
	  // define unique id
	  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
	  // define href
	  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
	  return obj;
	}

	var withNativeArrayBuffer = typeof ArrayBuffer === "function";
	var isView = function isView(obj) {
	  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
	};
	var toString = Object.prototype.toString;
	var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && /*#__PURE__*/toString.call(Blob) === "[object BlobConstructor]";
	var withNativeFile = typeof File === "function" || typeof File !== "undefined" && /*#__PURE__*/toString.call(File) === "[object FileConstructor]";
	/**
	 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
	 *
	 * @private
	 */
	function isBinary(obj) {
	  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
	}
	function hasBinary(obj, toJSON) {
	  if (!obj || _typeof(obj) !== "object") {
	    return false;
	  }
	  if (Array.isArray(obj)) {
	    for (var i = 0, l = obj.length; i < l; i++) {
	      if (hasBinary(obj[i])) {
	        return true;
	      }
	    }
	    return false;
	  }
	  if (isBinary(obj)) {
	    return true;
	  }
	  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
	    return hasBinary(obj.toJSON(), true);
	  }
	  for (var key in obj) {
	    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @public
	 */
	function deconstructPacket(packet) {
	  var buffers = [];
	  var packetData = packet.data;
	  var pack = packet;
	  pack.data = _deconstructPacket(packetData, buffers);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return {
	    packet: pack,
	    buffers: buffers
	  };
	}
	function _deconstructPacket(data, buffers) {
	  if (!data) return data;
	  if (isBinary(data)) {
	    var placeholder = {
	      _placeholder: true,
	      num: buffers.length
	    };
	    buffers.push(data);
	    return placeholder;
	  } else if (Array.isArray(data)) {
	    var newData = new Array(data.length);
	    for (var i = 0; i < data.length; i++) {
	      newData[i] = _deconstructPacket(data[i], buffers);
	    }
	    return newData;
	  } else if (_typeof(data) === "object" && !(data instanceof Date)) {
	    var _newData = {};
	    for (var key in data) {
	      if (Object.prototype.hasOwnProperty.call(data, key)) {
	        _newData[key] = _deconstructPacket(data[key], buffers);
	      }
	    }
	    return _newData;
	  }
	  return data;
	}
	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @public
	 */
	function reconstructPacket(packet, buffers) {
	  packet.data = _reconstructPacket(packet.data, buffers);
	  delete packet.attachments; // no longer useful
	  return packet;
	}
	function _reconstructPacket(data, buffers) {
	  if (!data) return data;
	  if (data && data._placeholder === true) {
	    var isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
	    if (isIndexValid) {
	      return buffers[data.num]; // appropriate buffer (should be natural order anyway)
	    } else {
	      throw new Error("illegal attachments");
	    }
	  } else if (Array.isArray(data)) {
	    for (var i = 0; i < data.length; i++) {
	      data[i] = _reconstructPacket(data[i], buffers);
	    }
	  } else if (_typeof(data) === "object") {
	    for (var key in data) {
	      if (Object.prototype.hasOwnProperty.call(data, key)) {
	        data[key] = _reconstructPacket(data[key], buffers);
	      }
	    }
	  }
	  return data;
	}

	/**
	 * These strings must not be used as event names, as they have a special meaning.
	 */
	var RESERVED_EVENTS$1 = ["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener" // used by the Node.js EventEmitter
	];
	/**
	 * Protocol version.
	 *
	 * @public
	 */
	var protocol = 5;
	var PacketType;
	(function (PacketType) {
	  PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
	  PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
	  PacketType[PacketType["EVENT"] = 2] = "EVENT";
	  PacketType[PacketType["ACK"] = 3] = "ACK";
	  PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
	  PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
	  PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
	})(PacketType || (PacketType = {}));
	/**
	 * A socket.io Encoder instance
	 */
	var Encoder = /*#__PURE__*/function () {
	  /**
	   * Encoder constructor
	   *
	   * @param {function} replacer - custom replacer to pass down to JSON.parse
	   */
	  function Encoder(replacer) {
	    _classCallCheck(this, Encoder);
	    this.replacer = replacer;
	  }
	  /**
	   * Encode a packet as a single string if non-binary, or as a
	   * buffer sequence, depending on packet type.
	   *
	   * @param {Object} obj - packet object
	   */
	  _createClass(Encoder, [{
	    key: "encode",
	    value: function encode(obj) {
	      if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
	        if (hasBinary(obj)) {
	          return this.encodeAsBinary({
	            type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
	            nsp: obj.nsp,
	            data: obj.data,
	            id: obj.id
	          });
	        }
	      }
	      return [this.encodeAsString(obj)];
	    }
	    /**
	     * Encode packet as string.
	     */
	  }, {
	    key: "encodeAsString",
	    value: function encodeAsString(obj) {
	      // first is type
	      var str = "" + obj.type;
	      // attachments if we have them
	      if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
	        str += obj.attachments + "-";
	      }
	      // if we have a namespace other than `/`
	      // we append it followed by a comma `,`
	      if (obj.nsp && "/" !== obj.nsp) {
	        str += obj.nsp + ",";
	      }
	      // immediately followed by the id
	      if (null != obj.id) {
	        str += obj.id;
	      }
	      // json data
	      if (null != obj.data) {
	        str += JSON.stringify(obj.data, this.replacer);
	      }
	      return str;
	    }
	    /**
	     * Encode packet as 'buffer sequence' by removing blobs, and
	     * deconstructing packet into object with placeholders and
	     * a list of buffers.
	     */
	  }, {
	    key: "encodeAsBinary",
	    value: function encodeAsBinary(obj) {
	      var deconstruction = deconstructPacket(obj);
	      var pack = this.encodeAsString(deconstruction.packet);
	      var buffers = deconstruction.buffers;
	      buffers.unshift(pack); // add packet info to beginning of data list
	      return buffers; // write all the buffers
	    }
	  }]);
	  return Encoder;
	}();
	// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript
	function isObject$1(value) {
	  return Object.prototype.toString.call(value) === "[object Object]";
	}
	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 */
	var Decoder = /*#__PURE__*/function (_Emitter) {
	  _inherits(Decoder, _Emitter);
	  var _super = /*#__PURE__*/_createSuper(Decoder);
	  /**
	   * Decoder constructor
	   *
	   * @param {function} reviver - custom reviver to pass down to JSON.stringify
	   */
	  function Decoder(reviver) {
	    var _this;
	    _classCallCheck(this, Decoder);
	    _this = _super.call(this);
	    _this.reviver = reviver;
	    return _this;
	  }
	  /**
	   * Decodes an encoded packet string into packet JSON.
	   *
	   * @param {String} obj - encoded packet
	   */
	  _createClass(Decoder, [{
	    key: "add",
	    value: function add(obj) {
	      var packet;
	      if (typeof obj === "string") {
	        if (this.reconstructor) {
	          throw new Error("got plaintext data when reconstructing a packet");
	        }
	        packet = this.decodeString(obj);
	        var isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
	        if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
	          packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
	          // binary packet's json
	          this.reconstructor = new BinaryReconstructor(packet);
	          // no attachments, labeled binary but no binary data to follow
	          if (packet.attachments === 0) {
	            _get(_getPrototypeOf(Decoder.prototype), "emitReserved", this).call(this, "decoded", packet);
	          }
	        } else {
	          // non-binary full packet
	          _get(_getPrototypeOf(Decoder.prototype), "emitReserved", this).call(this, "decoded", packet);
	        }
	      } else if (isBinary(obj) || obj.base64) {
	        // raw binary data
	        if (!this.reconstructor) {
	          throw new Error("got binary data when not reconstructing a packet");
	        } else {
	          packet = this.reconstructor.takeBinaryData(obj);
	          if (packet) {
	            // received final buffer
	            this.reconstructor = null;
	            _get(_getPrototypeOf(Decoder.prototype), "emitReserved", this).call(this, "decoded", packet);
	          }
	        }
	      } else {
	        throw new Error("Unknown type: " + obj);
	      }
	    }
	    /**
	     * Decode a packet String (JSON data)
	     *
	     * @param {String} str
	     * @return {Object} packet
	     */
	  }, {
	    key: "decodeString",
	    value: function decodeString(str) {
	      var i = 0;
	      // look up type
	      var p = {
	        type: Number(str.charAt(0))
	      };
	      if (PacketType[p.type] === undefined) {
	        throw new Error("unknown packet type " + p.type);
	      }
	      // look up attachments if type binary
	      if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
	        var start = i + 1;
	        while (str.charAt(++i) !== "-" && i != str.length) {}
	        var buf = str.substring(start, i);
	        if (buf != Number(buf) || str.charAt(i) !== "-") {
	          throw new Error("Illegal attachments");
	        }
	        p.attachments = Number(buf);
	      }
	      // look up namespace (if any)
	      if ("/" === str.charAt(i + 1)) {
	        var _start = i + 1;
	        while (++i) {
	          var c = str.charAt(i);
	          if ("," === c) break;
	          if (i === str.length) break;
	        }
	        p.nsp = str.substring(_start, i);
	      } else {
	        p.nsp = "/";
	      }
	      // look up id
	      var next = str.charAt(i + 1);
	      if ("" !== next && Number(next) == next) {
	        var _start2 = i + 1;
	        while (++i) {
	          var _c = str.charAt(i);
	          if (null == _c || Number(_c) != _c) {
	            --i;
	            break;
	          }
	          if (i === str.length) break;
	        }
	        p.id = Number(str.substring(_start2, i + 1));
	      }
	      // look up json data
	      if (str.charAt(++i)) {
	        var payload = this.tryParse(str.substr(i));
	        if (Decoder.isPayloadValid(p.type, payload)) {
	          p.data = payload;
	        } else {
	          throw new Error("invalid payload");
	        }
	      }
	      return p;
	    }
	  }, {
	    key: "tryParse",
	    value: function tryParse(str) {
	      try {
	        return JSON.parse(str, this.reviver);
	      } catch (e) {
	        return false;
	      }
	    }
	  }, {
	    key: "destroy",
	    value:
	    /**
	     * Deallocates a parser's resources
	     */
	    function destroy() {
	      if (this.reconstructor) {
	        this.reconstructor.finishedReconstruction();
	        this.reconstructor = null;
	      }
	    }
	  }], [{
	    key: "isPayloadValid",
	    value: function isPayloadValid(type, payload) {
	      switch (type) {
	        case PacketType.CONNECT:
	          return isObject$1(payload);
	        case PacketType.DISCONNECT:
	          return payload === undefined;
	        case PacketType.CONNECT_ERROR:
	          return typeof payload === "string" || isObject$1(payload);
	        case PacketType.EVENT:
	        case PacketType.BINARY_EVENT:
	          return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);
	        case PacketType.ACK:
	        case PacketType.BINARY_ACK:
	          return Array.isArray(payload);
	      }
	    }
	  }]);
	  return Decoder;
	}(Emitter);
	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 */
	var BinaryReconstructor = /*#__PURE__*/function () {
	  function BinaryReconstructor(packet) {
	    _classCallCheck(this, BinaryReconstructor);
	    this.packet = packet;
	    this.buffers = [];
	    this.reconPack = packet;
	  }
	  /**
	   * Method to be called when binary data received from connection
	   * after a BINARY_EVENT packet.
	   *
	   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	   * @return {null | Object} returns null if more binary data is expected or
	   *   a reconstructed packet object if all buffers have been received.
	   */
	  _createClass(BinaryReconstructor, [{
	    key: "takeBinaryData",
	    value: function takeBinaryData(binData) {
	      this.buffers.push(binData);
	      if (this.buffers.length === this.reconPack.attachments) {
	        // done with buffer list
	        var packet = reconstructPacket(this.reconPack, this.buffers);
	        this.finishedReconstruction();
	        return packet;
	      }
	      return null;
	    }
	    /**
	     * Cleans up binary packet reconstruction variables.
	     */
	  }, {
	    key: "finishedReconstruction",
	    value: function finishedReconstruction() {
	      this.reconPack = null;
	      this.buffers = [];
	    }
	  }]);
	  return BinaryReconstructor;
	}();

	var parser = {
		__proto__: null,
		protocol: protocol,
		get PacketType () { return PacketType; },
		Encoder: Encoder,
		Decoder: Decoder
	};

	function on(obj, ev, fn) {
	  obj.on(ev, fn);
	  return function subDestroy() {
	    obj.off(ev, fn);
	  };
	}

	/**
	 * Internal events.
	 * These events can't be emitted by the user.
	 */
	var RESERVED_EVENTS = /*#__PURE__*/Object.freeze({
	  connect: 1,
	  connect_error: 1,
	  disconnect: 1,
	  disconnecting: 1,
	  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
	  newListener: 1,
	  removeListener: 1
	});
	/**
	 * A Socket is the fundamental class for interacting with the server.
	 *
	 * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.
	 *
	 * @example
	 * const socket = io();
	 *
	 * socket.on("connect", () => {
	 *   console.log("connected");
	 * });
	 *
	 * // send an event to the server
	 * socket.emit("foo", "bar");
	 *
	 * socket.on("foobar", () => {
	 *   // an event was received from the server
	 * });
	 *
	 * // upon disconnection
	 * socket.on("disconnect", (reason) => {
	 *   console.log(`disconnected due to ${reason}`);
	 * });
	 */
	var Socket = /*#__PURE__*/function (_Emitter) {
	  _inherits(Socket, _Emitter);
	  var _super = /*#__PURE__*/_createSuper(Socket);
	  /**
	   * `Socket` constructor.
	   */
	  function Socket(io, nsp, opts) {
	    var _this;
	    _classCallCheck(this, Socket);
	    _this = _super.call(this);
	    /**
	     * Whether the socket is currently connected to the server.
	     *
	     * @example
	     * const socket = io();
	     *
	     * socket.on("connect", () => {
	     *   console.log(socket.connected); // true
	     * });
	     *
	     * socket.on("disconnect", () => {
	     *   console.log(socket.connected); // false
	     * });
	     */
	    _this.connected = false;
	    /**
	     * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
	     * be transmitted by the server.
	     */
	    _this.recovered = false;
	    /**
	     * Buffer for packets received before the CONNECT packet
	     */
	    _this.receiveBuffer = [];
	    /**
	     * Buffer for packets that will be sent once the socket is connected
	     */
	    _this.sendBuffer = [];
	    /**
	     * The queue of packets to be sent with retry in case of failure.
	     *
	     * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.
	     * @private
	     */
	    _this._queue = [];
	    /**
	     * A sequence to generate the ID of the {@link QueuedPacket}.
	     * @private
	     */
	    _this._queueSeq = 0;
	    _this.ids = 0;
	    _this.acks = {};
	    _this.flags = {};
	    _this.io = io;
	    _this.nsp = nsp;
	    if (opts && opts.auth) {
	      _this.auth = opts.auth;
	    }
	    _this._opts = Object.assign({}, opts);
	    if (_this.io._autoConnect) _this.open();
	    return _this;
	  }
	  /**
	   * Whether the socket is currently disconnected
	   *
	   * @example
	   * const socket = io();
	   *
	   * socket.on("connect", () => {
	   *   console.log(socket.disconnected); // false
	   * });
	   *
	   * socket.on("disconnect", () => {
	   *   console.log(socket.disconnected); // true
	   * });
	   */
	  _createClass(Socket, [{
	    key: "disconnected",
	    get: function get() {
	      return !this.connected;
	    }
	    /**
	     * Subscribe to open, close and packet events
	     *
	     * @private
	     */
	  }, {
	    key: "subEvents",
	    value: function subEvents() {
	      if (this.subs) return;
	      var io = this.io;
	      this.subs = [on(io, "open", this.onopen.bind(this)), on(io, "packet", this.onpacket.bind(this)), on(io, "error", this.onerror.bind(this)), on(io, "close", this.onclose.bind(this))];
	    }
	    /**
	     * Whether the Socket will try to reconnect when its Manager connects or reconnects.
	     *
	     * @example
	     * const socket = io();
	     *
	     * console.log(socket.active); // true
	     *
	     * socket.on("disconnect", (reason) => {
	     *   if (reason === "io server disconnect") {
	     *     // the disconnection was initiated by the server, you need to manually reconnect
	     *     console.log(socket.active); // false
	     *   }
	     *   // else the socket will automatically try to reconnect
	     *   console.log(socket.active); // true
	     * });
	     */
	  }, {
	    key: "active",
	    get: function get() {
	      return !!this.subs;
	    }
	    /**
	     * "Opens" the socket.
	     *
	     * @example
	     * const socket = io({
	     *   autoConnect: false
	     * });
	     *
	     * socket.connect();
	     */
	  }, {
	    key: "connect",
	    value: function connect() {
	      if (this.connected) return this;
	      this.subEvents();
	      if (!this.io["_reconnecting"]) this.io.open(); // ensure open
	      if ("open" === this.io._readyState) this.onopen();
	      return this;
	    }
	    /**
	     * Alias for {@link connect()}.
	     */
	  }, {
	    key: "open",
	    value: function open() {
	      return this.connect();
	    }
	    /**
	     * Sends a `message` event.
	     *
	     * This method mimics the WebSocket.send() method.
	     *
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
	     *
	     * @example
	     * socket.send("hello");
	     *
	     * // this is equivalent to
	     * socket.emit("message", "hello");
	     *
	     * @return self
	     */
	  }, {
	    key: "send",
	    value: function send() {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	      args.unshift("message");
	      this.emit.apply(this, args);
	      return this;
	    }
	    /**
	     * Override `emit`.
	     * If the event is in `events`, it's emitted normally.
	     *
	     * @example
	     * socket.emit("hello", "world");
	     *
	     * // all serializable datastructures are supported (no need to call JSON.stringify)
	     * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
	     *
	     * // with an acknowledgement from the server
	     * socket.emit("hello", "world", (val) => {
	     *   // ...
	     * });
	     *
	     * @return self
	     */
	  }, {
	    key: "emit",
	    value: function emit(ev) {
	      if (RESERVED_EVENTS.hasOwnProperty(ev)) {
	        throw new Error('"' + ev.toString() + '" is a reserved event name');
	      }
	      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	        args[_key2 - 1] = arguments[_key2];
	      }
	      args.unshift(ev);
	      if (this._opts.retries && !this.flags.fromQueue && !this.flags["volatile"]) {
	        this._addToQueue(args);
	        return this;
	      }
	      var packet = {
	        type: PacketType.EVENT,
	        data: args
	      };
	      packet.options = {};
	      packet.options.compress = this.flags.compress !== false;
	      // event ack callback
	      if ("function" === typeof args[args.length - 1]) {
	        var id = this.ids++;
	        var ack = args.pop();
	        this._registerAckCallback(id, ack);
	        packet.id = id;
	      }
	      var isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
	      var discardPacket = this.flags["volatile"] && (!isTransportWritable || !this.connected);
	      if (discardPacket) ; else if (this.connected) {
	        this.notifyOutgoingListeners(packet);
	        this.packet(packet);
	      } else {
	        this.sendBuffer.push(packet);
	      }
	      this.flags = {};
	      return this;
	    }
	    /**
	     * @private
	     */
	  }, {
	    key: "_registerAckCallback",
	    value: function _registerAckCallback(id, ack) {
	      var _this2 = this;
	      var _a;
	      var timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
	      if (timeout === undefined) {
	        this.acks[id] = ack;
	        return;
	      }
	      // @ts-ignore
	      var timer = this.io.setTimeoutFn(function () {
	        delete _this2.acks[id];
	        for (var i = 0; i < _this2.sendBuffer.length; i++) {
	          if (_this2.sendBuffer[i].id === id) {
	            _this2.sendBuffer.splice(i, 1);
	          }
	        }
	        ack.call(_this2, new Error("operation has timed out"));
	      }, timeout);
	      this.acks[id] = function () {
	        // @ts-ignore
	        _this2.io.clearTimeoutFn(timer);
	        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	          args[_key3] = arguments[_key3];
	        }
	        ack.apply(_this2, [null].concat(args));
	      };
	    }
	    /**
	     * Emits an event and waits for an acknowledgement
	     *
	     * @example
	     * // without timeout
	     * const response = await socket.emitWithAck("hello", "world");
	     *
	     * // with a specific timeout
	     * try {
	     *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
	     * } catch (err) {
	     *   // the server did not acknowledge the event in the given delay
	     * }
	     *
	     * @return a Promise that will be fulfilled when the server acknowledges the event
	     */
	  }, {
	    key: "emitWithAck",
	    value: function emitWithAck(ev) {
	      var _this3 = this;
	      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
	        args[_key4 - 1] = arguments[_key4];
	      }
	      // the timeout flag is optional
	      var withErr = this.flags.timeout !== undefined || this._opts.ackTimeout !== undefined;
	      return new Promise(function (resolve, reject) {
	        args.push(function (arg1, arg2) {
	          if (withErr) {
	            return arg1 ? reject(arg1) : resolve(arg2);
	          } else {
	            return resolve(arg1);
	          }
	        });
	        _this3.emit.apply(_this3, [ev].concat(args));
	      });
	    }
	    /**
	     * Add the packet to the queue.
	     * @param args
	     * @private
	     */
	  }, {
	    key: "_addToQueue",
	    value: function _addToQueue(args) {
	      var _this4 = this;
	      var ack;
	      if (typeof args[args.length - 1] === "function") {
	        ack = args.pop();
	      }
	      var packet = {
	        id: this._queueSeq++,
	        tryCount: 0,
	        pending: false,
	        args: args,
	        flags: Object.assign({
	          fromQueue: true
	        }, this.flags)
	      };
	      args.push(function (err) {
	        if (packet !== _this4._queue[0]) {
	          // the packet has already been acknowledged
	          return;
	        }
	        var hasError = err !== null;
	        if (hasError) {
	          if (packet.tryCount > _this4._opts.retries) {
	            _this4._queue.shift();
	            if (ack) {
	              ack(err);
	            }
	          }
	        } else {
	          _this4._queue.shift();
	          if (ack) {
	            for (var _len5 = arguments.length, responseArgs = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
	              responseArgs[_key5 - 1] = arguments[_key5];
	            }
	            ack.apply(void 0, [null].concat(responseArgs));
	          }
	        }
	        packet.pending = false;
	        return _this4._drainQueue();
	      });
	      this._queue.push(packet);
	      this._drainQueue();
	    }
	    /**
	     * Send the first packet of the queue, and wait for an acknowledgement from the server.
	     * @param force - whether to resend a packet that has not been acknowledged yet
	     *
	     * @private
	     */
	  }, {
	    key: "_drainQueue",
	    value: function _drainQueue() {
	      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	      if (!this.connected || this._queue.length === 0) {
	        return;
	      }
	      var packet = this._queue[0];
	      if (packet.pending && !force) {
	        return;
	      }
	      packet.pending = true;
	      packet.tryCount++;
	      this.flags = packet.flags;
	      this.emit.apply(this, packet.args);
	    }
	    /**
	     * Sends a packet.
	     *
	     * @param packet
	     * @private
	     */
	  }, {
	    key: "packet",
	    value: function packet(_packet) {
	      _packet.nsp = this.nsp;
	      this.io._packet(_packet);
	    }
	    /**
	     * Called upon engine `open`.
	     *
	     * @private
	     */
	  }, {
	    key: "onopen",
	    value: function onopen() {
	      var _this5 = this;
	      if (typeof this.auth == "function") {
	        this.auth(function (data) {
	          _this5._sendConnectPacket(data);
	        });
	      } else {
	        this._sendConnectPacket(this.auth);
	      }
	    }
	    /**
	     * Sends a CONNECT packet to initiate the Socket.IO session.
	     *
	     * @param data
	     * @private
	     */
	  }, {
	    key: "_sendConnectPacket",
	    value: function _sendConnectPacket(data) {
	      this.packet({
	        type: PacketType.CONNECT,
	        data: this._pid ? Object.assign({
	          pid: this._pid,
	          offset: this._lastOffset
	        }, data) : data
	      });
	    }
	    /**
	     * Called upon engine or manager `error`.
	     *
	     * @param err
	     * @private
	     */
	  }, {
	    key: "onerror",
	    value: function onerror(err) {
	      if (!this.connected) {
	        this.emitReserved("connect_error", err);
	      }
	    }
	    /**
	     * Called upon engine `close`.
	     *
	     * @param reason
	     * @param description
	     * @private
	     */
	  }, {
	    key: "onclose",
	    value: function onclose(reason, description) {
	      this.connected = false;
	      delete this.id;
	      this.emitReserved("disconnect", reason, description);
	    }
	    /**
	     * Called with socket packet.
	     *
	     * @param packet
	     * @private
	     */
	  }, {
	    key: "onpacket",
	    value: function onpacket(packet) {
	      var sameNamespace = packet.nsp === this.nsp;
	      if (!sameNamespace) return;
	      switch (packet.type) {
	        case PacketType.CONNECT:
	          if (packet.data && packet.data.sid) {
	            this.onconnect(packet.data.sid, packet.data.pid);
	          } else {
	            this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
	          }
	          break;
	        case PacketType.EVENT:
	        case PacketType.BINARY_EVENT:
	          this.onevent(packet);
	          break;
	        case PacketType.ACK:
	        case PacketType.BINARY_ACK:
	          this.onack(packet);
	          break;
	        case PacketType.DISCONNECT:
	          this.ondisconnect();
	          break;
	        case PacketType.CONNECT_ERROR:
	          this.destroy();
	          var err = new Error(packet.data.message);
	          // @ts-ignore
	          err.data = packet.data.data;
	          this.emitReserved("connect_error", err);
	          break;
	      }
	    }
	    /**
	     * Called upon a server event.
	     *
	     * @param packet
	     * @private
	     */
	  }, {
	    key: "onevent",
	    value: function onevent(packet) {
	      var args = packet.data || [];
	      if (null != packet.id) {
	        args.push(this.ack(packet.id));
	      }
	      if (this.connected) {
	        this.emitEvent(args);
	      } else {
	        this.receiveBuffer.push(Object.freeze(args));
	      }
	    }
	  }, {
	    key: "emitEvent",
	    value: function emitEvent(args) {
	      if (this._anyListeners && this._anyListeners.length) {
	        var listeners = this._anyListeners.slice();
	        var _iterator = _createForOfIteratorHelper(listeners),
	          _step;
	        try {
	          for (_iterator.s(); !(_step = _iterator.n()).done;) {
	            var listener = _step.value;
	            listener.apply(this, args);
	          }
	        } catch (err) {
	          _iterator.e(err);
	        } finally {
	          _iterator.f();
	        }
	      }
	      _get(_getPrototypeOf(Socket.prototype), "emit", this).apply(this, args);
	      if (this._pid && args.length && typeof args[args.length - 1] === "string") {
	        this._lastOffset = args[args.length - 1];
	      }
	    }
	    /**
	     * Produces an ack callback to emit with an event.
	     *
	     * @private
	     */
	  }, {
	    key: "ack",
	    value: function ack(id) {
	      var self = this;
	      var sent = false;
	      return function () {
	        // prevent double callbacks
	        if (sent) return;
	        sent = true;
	        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	          args[_key6] = arguments[_key6];
	        }
	        self.packet({
	          type: PacketType.ACK,
	          id: id,
	          data: args
	        });
	      };
	    }
	    /**
	     * Called upon a server acknowlegement.
	     *
	     * @param packet
	     * @private
	     */
	  }, {
	    key: "onack",
	    value: function onack(packet) {
	      var ack = this.acks[packet.id];
	      if ("function" === typeof ack) {
	        ack.apply(this, packet.data);
	        delete this.acks[packet.id];
	      }
	    }
	    /**
	     * Called upon server connect.
	     *
	     * @private
	     */
	  }, {
	    key: "onconnect",
	    value: function onconnect(id, pid) {
	      this.id = id;
	      this.recovered = pid && this._pid === pid;
	      this._pid = pid; // defined only if connection state recovery is enabled
	      this.connected = true;
	      this.emitBuffered();
	      this.emitReserved("connect");
	      this._drainQueue(true);
	    }
	    /**
	     * Emit buffered events (received and emitted).
	     *
	     * @private
	     */
	  }, {
	    key: "emitBuffered",
	    value: function emitBuffered() {
	      var _this6 = this;
	      this.receiveBuffer.forEach(function (args) {
	        return _this6.emitEvent(args);
	      });
	      this.receiveBuffer = [];
	      this.sendBuffer.forEach(function (packet) {
	        _this6.notifyOutgoingListeners(packet);
	        _this6.packet(packet);
	      });
	      this.sendBuffer = [];
	    }
	    /**
	     * Called upon server disconnect.
	     *
	     * @private
	     */
	  }, {
	    key: "ondisconnect",
	    value: function ondisconnect() {
	      this.destroy();
	      this.onclose("io server disconnect");
	    }
	    /**
	     * Called upon forced client/server side disconnections,
	     * this method ensures the manager stops tracking us and
	     * that reconnections don't get triggered for this.
	     *
	     * @private
	     */
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      if (this.subs) {
	        // clean subscriptions to avoid reconnections
	        this.subs.forEach(function (subDestroy) {
	          return subDestroy();
	        });
	        this.subs = undefined;
	      }
	      this.io["_destroy"](this);
	    }
	    /**
	     * Disconnects the socket manually. In that case, the socket will not try to reconnect.
	     *
	     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
	     *
	     * @example
	     * const socket = io();
	     *
	     * socket.on("disconnect", (reason) => {
	     *   // console.log(reason); prints "io client disconnect"
	     * });
	     *
	     * socket.disconnect();
	     *
	     * @return self
	     */
	  }, {
	    key: "disconnect",
	    value: function disconnect() {
	      if (this.connected) {
	        this.packet({
	          type: PacketType.DISCONNECT
	        });
	      }
	      // remove socket from pool
	      this.destroy();
	      if (this.connected) {
	        // fire events
	        this.onclose("io client disconnect");
	      }
	      return this;
	    }
	    /**
	     * Alias for {@link disconnect()}.
	     *
	     * @return self
	     */
	  }, {
	    key: "close",
	    value: function close() {
	      return this.disconnect();
	    }
	    /**
	     * Sets the compress flag.
	     *
	     * @example
	     * socket.compress(false).emit("hello");
	     *
	     * @param compress - if `true`, compresses the sending data
	     * @return self
	     */
	  }, {
	    key: "compress",
	    value: function compress(_compress) {
	      this.flags.compress = _compress;
	      return this;
	    }
	    /**
	     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
	     * ready to send messages.
	     *
	     * @example
	     * socket.volatile.emit("hello"); // the server may or may not receive it
	     *
	     * @returns self
	     */
	  }, {
	    key: "volatile",
	    get: function get() {
	      this.flags["volatile"] = true;
	      return this;
	    }
	    /**
	     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
	     * given number of milliseconds have elapsed without an acknowledgement from the server:
	     *
	     * @example
	     * socket.timeout(5000).emit("my-event", (err) => {
	     *   if (err) {
	     *     // the server did not acknowledge the event in the given delay
	     *   }
	     * });
	     *
	     * @returns self
	     */
	  }, {
	    key: "timeout",
	    value: function timeout(_timeout) {
	      this.flags.timeout = _timeout;
	      return this;
	    }
	    /**
	     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
	     * callback.
	     *
	     * @example
	     * socket.onAny((event, ...args) => {
	     *   console.log(`got ${event}`);
	     * });
	     *
	     * @param listener
	     */
	  }, {
	    key: "onAny",
	    value: function onAny(listener) {
	      this._anyListeners = this._anyListeners || [];
	      this._anyListeners.push(listener);
	      return this;
	    }
	    /**
	     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
	     * callback. The listener is added to the beginning of the listeners array.
	     *
	     * @example
	     * socket.prependAny((event, ...args) => {
	     *   console.log(`got event ${event}`);
	     * });
	     *
	     * @param listener
	     */
	  }, {
	    key: "prependAny",
	    value: function prependAny(listener) {
	      this._anyListeners = this._anyListeners || [];
	      this._anyListeners.unshift(listener);
	      return this;
	    }
	    /**
	     * Removes the listener that will be fired when any event is emitted.
	     *
	     * @example
	     * const catchAllListener = (event, ...args) => {
	     *   console.log(`got event ${event}`);
	     * }
	     *
	     * socket.onAny(catchAllListener);
	     *
	     * // remove a specific listener
	     * socket.offAny(catchAllListener);
	     *
	     * // or remove all listeners
	     * socket.offAny();
	     *
	     * @param listener
	     */
	  }, {
	    key: "offAny",
	    value: function offAny(listener) {
	      if (!this._anyListeners) {
	        return this;
	      }
	      if (listener) {
	        var listeners = this._anyListeners;
	        for (var i = 0; i < listeners.length; i++) {
	          if (listener === listeners[i]) {
	            listeners.splice(i, 1);
	            return this;
	          }
	        }
	      } else {
	        this._anyListeners = [];
	      }
	      return this;
	    }
	    /**
	     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
	     * e.g. to remove listeners.
	     */
	  }, {
	    key: "listenersAny",
	    value: function listenersAny() {
	      return this._anyListeners || [];
	    }
	    /**
	     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
	     * callback.
	     *
	     * Note: acknowledgements sent to the server are not included.
	     *
	     * @example
	     * socket.onAnyOutgoing((event, ...args) => {
	     *   console.log(`sent event ${event}`);
	     * });
	     *
	     * @param listener
	     */
	  }, {
	    key: "onAnyOutgoing",
	    value: function onAnyOutgoing(listener) {
	      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
	      this._anyOutgoingListeners.push(listener);
	      return this;
	    }
	    /**
	     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
	     * callback. The listener is added to the beginning of the listeners array.
	     *
	     * Note: acknowledgements sent to the server are not included.
	     *
	     * @example
	     * socket.prependAnyOutgoing((event, ...args) => {
	     *   console.log(`sent event ${event}`);
	     * });
	     *
	     * @param listener
	     */
	  }, {
	    key: "prependAnyOutgoing",
	    value: function prependAnyOutgoing(listener) {
	      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
	      this._anyOutgoingListeners.unshift(listener);
	      return this;
	    }
	    /**
	     * Removes the listener that will be fired when any event is emitted.
	     *
	     * @example
	     * const catchAllListener = (event, ...args) => {
	     *   console.log(`sent event ${event}`);
	     * }
	     *
	     * socket.onAnyOutgoing(catchAllListener);
	     *
	     * // remove a specific listener
	     * socket.offAnyOutgoing(catchAllListener);
	     *
	     * // or remove all listeners
	     * socket.offAnyOutgoing();
	     *
	     * @param [listener] - the catch-all listener (optional)
	     */
	  }, {
	    key: "offAnyOutgoing",
	    value: function offAnyOutgoing(listener) {
	      if (!this._anyOutgoingListeners) {
	        return this;
	      }
	      if (listener) {
	        var listeners = this._anyOutgoingListeners;
	        for (var i = 0; i < listeners.length; i++) {
	          if (listener === listeners[i]) {
	            listeners.splice(i, 1);
	            return this;
	          }
	        }
	      } else {
	        this._anyOutgoingListeners = [];
	      }
	      return this;
	    }
	    /**
	     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
	     * e.g. to remove listeners.
	     */
	  }, {
	    key: "listenersAnyOutgoing",
	    value: function listenersAnyOutgoing() {
	      return this._anyOutgoingListeners || [];
	    }
	    /**
	     * Notify the listeners for each packet sent
	     *
	     * @param packet
	     *
	     * @private
	     */
	  }, {
	    key: "notifyOutgoingListeners",
	    value: function notifyOutgoingListeners(packet) {
	      if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
	        var listeners = this._anyOutgoingListeners.slice();
	        var _iterator2 = _createForOfIteratorHelper(listeners),
	          _step2;
	        try {
	          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	            var listener = _step2.value;
	            listener.apply(this, packet.data);
	          }
	        } catch (err) {
	          _iterator2.e(err);
	        } finally {
	          _iterator2.f();
	        }
	      }
	    }
	  }]);
	  return Socket;
	}(Emitter);

	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */
	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}
	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */
	Backoff.prototype.duration = function () {
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand = Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};
	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */
	Backoff.prototype.reset = function () {
	  this.attempts = 0;
	};
	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */
	Backoff.prototype.setMin = function (min) {
	  this.ms = min;
	};
	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */
	Backoff.prototype.setMax = function (max) {
	  this.max = max;
	};
	/**
	 * Set the jitter
	 *
	 * @api public
	 */
	Backoff.prototype.setJitter = function (jitter) {
	  this.jitter = jitter;
	};

	var Manager = /*#__PURE__*/function (_Emitter) {
	  _inherits(Manager, _Emitter);
	  var _super = /*#__PURE__*/_createSuper(Manager);
	  function Manager(uri, opts) {
	    var _this;
	    _classCallCheck(this, Manager);
	    var _a;
	    _this = _super.call(this);
	    _this.nsps = {};
	    _this.subs = [];
	    if (uri && "object" === _typeof(uri)) {
	      opts = uri;
	      uri = undefined;
	    }
	    opts = opts || {};
	    opts.path = opts.path || "/socket.io";
	    _this.opts = opts;
	    installTimerFunctions(_assertThisInitialized(_this), opts);
	    _this.reconnection(opts.reconnection !== false);
	    _this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	    _this.reconnectionDelay(opts.reconnectionDelay || 1000);
	    _this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	    _this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
	    _this.backoff = new Backoff({
	      min: _this.reconnectionDelay(),
	      max: _this.reconnectionDelayMax(),
	      jitter: _this.randomizationFactor()
	    });
	    _this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	    _this._readyState = "closed";
	    _this.uri = uri;
	    var _parser = opts.parser || parser;
	    _this.encoder = new _parser.Encoder();
	    _this.decoder = new _parser.Decoder();
	    _this._autoConnect = opts.autoConnect !== false;
	    if (_this._autoConnect) _this.open();
	    return _this;
	  }
	  _createClass(Manager, [{
	    key: "reconnection",
	    value: function reconnection(v) {
	      if (!arguments.length) return this._reconnection;
	      this._reconnection = !!v;
	      return this;
	    }
	  }, {
	    key: "reconnectionAttempts",
	    value: function reconnectionAttempts(v) {
	      if (v === undefined) return this._reconnectionAttempts;
	      this._reconnectionAttempts = v;
	      return this;
	    }
	  }, {
	    key: "reconnectionDelay",
	    value: function reconnectionDelay(v) {
	      var _a;
	      if (v === undefined) return this._reconnectionDelay;
	      this._reconnectionDelay = v;
	      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
	      return this;
	    }
	  }, {
	    key: "randomizationFactor",
	    value: function randomizationFactor(v) {
	      var _a;
	      if (v === undefined) return this._randomizationFactor;
	      this._randomizationFactor = v;
	      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
	      return this;
	    }
	  }, {
	    key: "reconnectionDelayMax",
	    value: function reconnectionDelayMax(v) {
	      var _a;
	      if (v === undefined) return this._reconnectionDelayMax;
	      this._reconnectionDelayMax = v;
	      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
	      return this;
	    }
	  }, {
	    key: "timeout",
	    value: function timeout(v) {
	      if (!arguments.length) return this._timeout;
	      this._timeout = v;
	      return this;
	    }
	    /**
	     * Starts trying to reconnect if reconnection is enabled and we have not
	     * started reconnecting yet
	     *
	     * @private
	     */
	  }, {
	    key: "maybeReconnectOnOpen",
	    value: function maybeReconnectOnOpen() {
	      // Only try to reconnect if it's the first time we're connecting
	      if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
	        // keeps reconnection from firing twice for the same reconnection loop
	        this.reconnect();
	      }
	    }
	    /**
	     * Sets the current transport `socket`.
	     *
	     * @param {Function} fn - optional, callback
	     * @return self
	     * @public
	     */
	  }, {
	    key: "open",
	    value: function open(fn) {
	      var _this2 = this;
	      if (~this._readyState.indexOf("open")) return this;
	      this.engine = new Socket$1(this.uri, this.opts);
	      var socket = this.engine;
	      var self = this;
	      this._readyState = "opening";
	      this.skipReconnect = false;
	      // emit `open`
	      var openSubDestroy = on(socket, "open", function () {
	        self.onopen();
	        fn && fn();
	      });
	      var onError = function onError(err) {
	        _this2.cleanup();
	        _this2._readyState = "closed";
	        _this2.emitReserved("error", err);
	        if (fn) {
	          fn(err);
	        } else {
	          // Only do this if there is no fn to handle the error
	          _this2.maybeReconnectOnOpen();
	        }
	      };
	      // emit `error`
	      var errorSub = on(socket, "error", onError);
	      if (false !== this._timeout) {
	        var timeout = this._timeout;
	        // set timer
	        var timer = this.setTimeoutFn(function () {
	          openSubDestroy();
	          onError(new Error("timeout"));
	          socket.close();
	        }, timeout);
	        if (this.opts.autoUnref) {
	          timer.unref();
	        }
	        this.subs.push(function () {
	          _this2.clearTimeoutFn(timer);
	        });
	      }
	      this.subs.push(openSubDestroy);
	      this.subs.push(errorSub);
	      return this;
	    }
	    /**
	     * Alias for open()
	     *
	     * @return self
	     * @public
	     */
	  }, {
	    key: "connect",
	    value: function connect(fn) {
	      return this.open(fn);
	    }
	    /**
	     * Called upon transport open.
	     *
	     * @private
	     */
	  }, {
	    key: "onopen",
	    value: function onopen() {
	      // clear old subs
	      this.cleanup();
	      // mark as open
	      this._readyState = "open";
	      this.emitReserved("open");
	      // add new subs
	      var socket = this.engine;
	      this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
	    }
	    /**
	     * Called upon a ping.
	     *
	     * @private
	     */
	  }, {
	    key: "onping",
	    value: function onping() {
	      this.emitReserved("ping");
	    }
	    /**
	     * Called with data.
	     *
	     * @private
	     */
	  }, {
	    key: "ondata",
	    value: function ondata(data) {
	      try {
	        this.decoder.add(data);
	      } catch (e) {
	        this.onclose("parse error", e);
	      }
	    }
	    /**
	     * Called when parser fully decodes a packet.
	     *
	     * @private
	     */
	  }, {
	    key: "ondecoded",
	    value: function ondecoded(packet) {
	      var _this3 = this;
	      // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a "parse error"
	      nextTick(function () {
	        _this3.emitReserved("packet", packet);
	      }, this.setTimeoutFn);
	    }
	    /**
	     * Called upon socket error.
	     *
	     * @private
	     */
	  }, {
	    key: "onerror",
	    value: function onerror(err) {
	      this.emitReserved("error", err);
	    }
	    /**
	     * Creates a new socket for the given `nsp`.
	     *
	     * @return {Socket}
	     * @public
	     */
	  }, {
	    key: "socket",
	    value: function socket(nsp, opts) {
	      var socket = this.nsps[nsp];
	      if (!socket) {
	        socket = new Socket(this, nsp, opts);
	        this.nsps[nsp] = socket;
	      } else if (this._autoConnect && !socket.active) {
	        socket.connect();
	      }
	      return socket;
	    }
	    /**
	     * Called upon a socket close.
	     *
	     * @param socket
	     * @private
	     */
	  }, {
	    key: "_destroy",
	    value: function _destroy(socket) {
	      var nsps = Object.keys(this.nsps);
	      for (var _i = 0, _nsps = nsps; _i < _nsps.length; _i++) {
	        var nsp = _nsps[_i];
	        var _socket = this.nsps[nsp];
	        if (_socket.active) {
	          return;
	        }
	      }
	      this._close();
	    }
	    /**
	     * Writes a packet.
	     *
	     * @param packet
	     * @private
	     */
	  }, {
	    key: "_packet",
	    value: function _packet(packet) {
	      var encodedPackets = this.encoder.encode(packet);
	      for (var i = 0; i < encodedPackets.length; i++) {
	        this.engine.write(encodedPackets[i], packet.options);
	      }
	    }
	    /**
	     * Clean up transport subscriptions and packet buffer.
	     *
	     * @private
	     */
	  }, {
	    key: "cleanup",
	    value: function cleanup() {
	      this.subs.forEach(function (subDestroy) {
	        return subDestroy();
	      });
	      this.subs.length = 0;
	      this.decoder.destroy();
	    }
	    /**
	     * Close the current socket.
	     *
	     * @private
	     */
	  }, {
	    key: "_close",
	    value: function _close() {
	      this.skipReconnect = true;
	      this._reconnecting = false;
	      this.onclose("forced close");
	      if (this.engine) this.engine.close();
	    }
	    /**
	     * Alias for close()
	     *
	     * @private
	     */
	  }, {
	    key: "disconnect",
	    value: function disconnect() {
	      return this._close();
	    }
	    /**
	     * Called upon engine close.
	     *
	     * @private
	     */
	  }, {
	    key: "onclose",
	    value: function onclose(reason, description) {
	      this.cleanup();
	      this.backoff.reset();
	      this._readyState = "closed";
	      this.emitReserved("close", reason, description);
	      if (this._reconnection && !this.skipReconnect) {
	        this.reconnect();
	      }
	    }
	    /**
	     * Attempt a reconnection.
	     *
	     * @private
	     */
	  }, {
	    key: "reconnect",
	    value: function reconnect() {
	      var _this4 = this;
	      if (this._reconnecting || this.skipReconnect) return this;
	      var self = this;
	      if (this.backoff.attempts >= this._reconnectionAttempts) {
	        this.backoff.reset();
	        this.emitReserved("reconnect_failed");
	        this._reconnecting = false;
	      } else {
	        var delay = this.backoff.duration();
	        this._reconnecting = true;
	        var timer = this.setTimeoutFn(function () {
	          if (self.skipReconnect) return;
	          _this4.emitReserved("reconnect_attempt", self.backoff.attempts);
	          // check again for the case socket closed in above events
	          if (self.skipReconnect) return;
	          self.open(function (err) {
	            if (err) {
	              self._reconnecting = false;
	              self.reconnect();
	              _this4.emitReserved("reconnect_error", err);
	            } else {
	              self.onreconnect();
	            }
	          });
	        }, delay);
	        if (this.opts.autoUnref) {
	          timer.unref();
	        }
	        this.subs.push(function () {
	          _this4.clearTimeoutFn(timer);
	        });
	      }
	    }
	    /**
	     * Called upon successful reconnect.
	     *
	     * @private
	     */
	  }, {
	    key: "onreconnect",
	    value: function onreconnect() {
	      var attempt = this.backoff.attempts;
	      this._reconnecting = false;
	      this.backoff.reset();
	      this.emitReserved("reconnect", attempt);
	    }
	  }]);
	  return Manager;
	}(Emitter);

	/**
	 * Managers cache.
	 */
	var cache = {};
	function lookup(uri, opts) {
	  if (_typeof(uri) === "object") {
	    opts = uri;
	    uri = undefined;
	  }
	  opts = opts || {};
	  var parsed = url(uri, opts.path || "/socket.io");
	  var source = parsed.source;
	  var id = parsed.id;
	  var path = parsed.path;
	  var sameNamespace = cache[id] && path in cache[id]["nsps"];
	  var newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
	  var io;
	  if (newConnection) {
	    io = new Manager(source, opts);
	  } else {
	    if (!cache[id]) {
	      cache[id] = new Manager(source, opts);
	    }
	    io = cache[id];
	  }
	  if (parsed.query && !opts.query) {
	    opts.query = parsed.queryKey;
	  }
	  return io.socket(parsed.path, opts);
	}
	// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
	// namespace (e.g. `io.connect(...)`), for backward compatibility
	Object.assign(lookup, {
	  Manager: Manager,
	  Socket: Socket,
	  io: lookup,
	  connect: lookup
	});

	// This constructor is used to store event handlers. Instantiating this is
	// faster than explicitly calling `Object.create(null)` to get a "clean" empty
	// object (tested with v8 v4.9).
	function EventHandlers() {}
	EventHandlers.prototype = /*#__PURE__*/Object.create(null);
	function EventEmitter() {
	  EventEmitter.init.call(this);
	}

	// nodejs oddity
	// require('events') === require('events').EventEmitter
	EventEmitter.EventEmitter = EventEmitter;
	EventEmitter.usingDomains = false;
	EventEmitter.prototype.domain = undefined;
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	EventEmitter.init = function () {
	  this.domain = null;
	  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
	    this._events = new EventHandlers();
	    this._eventsCount = 0;
	  }
	  this._maxListeners = this._maxListeners || undefined;
	};

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
	  if (typeof n !== 'number' || n < 0 || isNaN(n)) throw new TypeError('"n" argument must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	function $getMaxListeners(that) {
	  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
	  return that._maxListeners;
	}
	EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
	  return $getMaxListeners(this);
	};

	// These standalone emit* functions are used to optimize calling of event
	// handlers for fast cases because emit() itself often has a variable number of
	// arguments and can be deoptimized because of that. These functions always have
	// the same number of arguments and thus do not get deoptimized, so the code
	// inside them can execute faster.
	function emitNone(handler, isFn, self) {
	  if (isFn) handler.call(self);else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i) listeners[i].call(self);
	  }
	}
	function emitOne(handler, isFn, self, arg1) {
	  if (isFn) handler.call(self, arg1);else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1);
	  }
	}
	function emitTwo(handler, isFn, self, arg1, arg2) {
	  if (isFn) handler.call(self, arg1, arg2);else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);
	  }
	}
	function emitThree(handler, isFn, self, arg1, arg2, arg3) {
	  if (isFn) handler.call(self, arg1, arg2, arg3);else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3);
	  }
	}
	function emitMany(handler, isFn, self, args) {
	  if (isFn) handler.apply(self, args);else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i) listeners[i].apply(self, args);
	  }
	}
	EventEmitter.prototype.emit = function emit(type) {
	  var er, handler, len, args, i, events, domain;
	  var doError = type === 'error';
	  events = this._events;
	  if (events) doError = doError && events.error == null;else if (!doError) return false;
	  domain = this.domain;

	  // If there is no 'error' event listener then throw.
	  if (doError) {
	    er = arguments[1];
	    if (domain) {
	      if (!er) er = new Error('Uncaught, unspecified "error" event');
	      er.domainEmitter = this;
	      er.domain = domain;
	      er.domainThrown = false;
	      domain.emit('error', er);
	    } else if (er instanceof Error) {
	      throw er; // Unhandled 'error' event
	    } else {
	      // At least give some kind of context to the user
	      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	      err.context = er;
	      throw err;
	    }
	    return false;
	  }
	  handler = events[type];
	  if (!handler) return false;
	  var isFn = typeof handler === 'function';
	  len = arguments.length;
	  switch (len) {
	    // fast cases
	    case 1:
	      emitNone(handler, isFn, this);
	      break;
	    case 2:
	      emitOne(handler, isFn, this, arguments[1]);
	      break;
	    case 3:
	      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
	      break;
	    case 4:
	      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
	      break;
	    // slower
	    default:
	      args = new Array(len - 1);
	      for (i = 1; i < len; i++) args[i - 1] = arguments[i];
	      emitMany(handler, isFn, this, args);
	  }
	  return true;
	};
	function _addListener(target, type, listener, prepend) {
	  var m;
	  var events;
	  var existing;
	  if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
	  events = target._events;
	  if (!events) {
	    events = target._events = new EventHandlers();
	    target._eventsCount = 0;
	  } else {
	    // To avoid recursion in the case that type === "newListener"! Before
	    // adding it to the listeners, first emit "newListener".
	    if (events.newListener) {
	      target.emit('newListener', type, listener.listener ? listener.listener : listener);

	      // Re-assign `events` because a newListener handler could have caused the
	      // this._events to be assigned to a new object
	      events = target._events;
	    }
	    existing = events[type];
	  }
	  if (!existing) {
	    // Optimize the case of one listener. Don't need the extra array object.
	    existing = events[type] = listener;
	    ++target._eventsCount;
	  } else {
	    if (typeof existing === 'function') {
	      // Adding the second element, need to change to array.
	      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
	    } else {
	      // If we've already got an array, just append.
	      if (prepend) {
	        existing.unshift(listener);
	      } else {
	        existing.push(listener);
	      }
	    }

	    // Check for listener leak
	    if (!existing.warned) {
	      m = $getMaxListeners(target);
	      if (m && m > 0 && existing.length > m) {
	        existing.warned = true;
	        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + type + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit');
	        w.name = 'MaxListenersExceededWarning';
	        w.emitter = target;
	        w.type = type;
	        w.count = existing.length;
	        emitWarning(w);
	      }
	    }
	  }
	  return target;
	}
	function emitWarning(e) {
	  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
	}
	EventEmitter.prototype.addListener = function addListener(type, listener) {
	  return _addListener(this, type, listener, false);
	};
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	EventEmitter.prototype.prependListener = function prependListener(type, listener) {
	  return _addListener(this, type, listener, true);
	};
	function _onceWrap(target, type, listener) {
	  var fired = false;
	  function g() {
	    target.removeListener(type, g);
	    if (!fired) {
	      fired = true;
	      listener.apply(target, arguments);
	    }
	  }
	  g.listener = listener;
	  return g;
	}
	EventEmitter.prototype.once = function once(type, listener) {
	  if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
	  this.on(type, _onceWrap(this, type, listener));
	  return this;
	};
	EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
	  if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
	  this.prependListener(type, _onceWrap(this, type, listener));
	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function removeListener(type, listener) {
	  var list, events, position, i, originalListener;
	  if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
	  events = this._events;
	  if (!events) return this;
	  list = events[type];
	  if (!list) return this;
	  if (list === listener || list.listener && list.listener === listener) {
	    if (--this._eventsCount === 0) this._events = new EventHandlers();else {
	      delete events[type];
	      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
	    }
	  } else if (typeof list !== 'function') {
	    position = -1;
	    for (i = list.length; i-- > 0;) {
	      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
	        originalListener = list[i].listener;
	        position = i;
	        break;
	      }
	    }
	    if (position < 0) return this;
	    if (list.length === 1) {
	      list[0] = undefined;
	      if (--this._eventsCount === 0) {
	        this._events = new EventHandlers();
	        return this;
	      } else {
	        delete events[type];
	      }
	    } else {
	      spliceOne(list, position);
	    }
	    if (events.removeListener) this.emit('removeListener', type, originalListener || listener);
	  }
	  return this;
	};
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
	  var listeners, events;
	  events = this._events;
	  if (!events) return this;

	  // not listening for removeListener, no need to emit
	  if (!events.removeListener) {
	    if (arguments.length === 0) {
	      this._events = new EventHandlers();
	      this._eventsCount = 0;
	    } else if (events[type]) {
	      if (--this._eventsCount === 0) this._events = new EventHandlers();else delete events[type];
	    }
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    var keys = Object.keys(events);
	    for (var i = 0, key; i < keys.length; ++i) {
	      key = keys[i];
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = new EventHandlers();
	    this._eventsCount = 0;
	    return this;
	  }
	  listeners = events[type];
	  if (typeof listeners === 'function') {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    do {
	      this.removeListener(type, listeners[listeners.length - 1]);
	    } while (listeners[0]);
	  }
	  return this;
	};
	EventEmitter.prototype.listeners = function listeners(type) {
	  var evlistener;
	  var ret;
	  var events = this._events;
	  if (!events) ret = [];else {
	    evlistener = events[type];
	    if (!evlistener) ret = [];else if (typeof evlistener === 'function') ret = [evlistener.listener || evlistener];else ret = unwrapListeners(evlistener);
	  }
	  return ret;
	};
	EventEmitter.listenerCount = function (emitter, type) {
	  if (typeof emitter.listenerCount === 'function') {
	    return emitter.listenerCount(type);
	  } else {
	    return listenerCount$1.call(emitter, type);
	  }
	};
	EventEmitter.prototype.listenerCount = listenerCount$1;
	function listenerCount$1(type) {
	  var events = this._events;
	  if (events) {
	    var evlistener = events[type];
	    if (typeof evlistener === 'function') {
	      return 1;
	    } else if (evlistener) {
	      return evlistener.length;
	    }
	  }
	  return 0;
	}
	EventEmitter.prototype.eventNames = function eventNames() {
	  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
	};

	// About 1.5x faster than the two-arg version of Array#splice().
	function spliceOne(list, index) {
	  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];
	  list.pop();
	}
	function arrayClone(arr, i) {
	  var copy = new Array(i);
	  while (i--) copy[i] = arr[i];
	  return copy;
	}
	function unwrapListeners(arr) {
	  var ret = new Array(arr.length);
	  for (var i = 0; i < ret.length; ++i) {
	    ret[i] = arr[i].listener || arr[i];
	  }
	  return ret;
	}

	var inherits;
	if (typeof Object.create === 'function') {
	  inherits = function inherits(ctor, superCtor) {
	    // implementation from standard node.js 'util' module
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  inherits = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function TempCtor() {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}
	var inherits$1 = inherits;

	var formatRegExp = /%[sdj%]/g;
	function format(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function (x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s':
	        return String(args[i++]);
	      case '%d':
	        return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	}

	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	function deprecate(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global$1.process)) {
	    return function () {
	      return deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	  if (process$1.noDeprecation === true) {
	    return fn;
	  }
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process$1.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process$1.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	  return deprecated;
	}
	var debugs = {};
	var debugEnviron;
	function debuglog(set) {
	  if (isUndefined(debugEnviron)) debugEnviron = process$1.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = 0;
	      debugs[set] = function () {
	        var msg = format.apply(null, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function () {};
	    }
	  }
	  return debugs[set];
	}

	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    _extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}

	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold': [1, 22],
	  'italic': [3, 23],
	  'underline': [4, 24],
	  'inverse': [7, 27],
	  'white': [37, 39],
	  'grey': [90, 39],
	  'black': [30, 39],
	  'blue': [34, 39],
	  'cyan': [36, 39],
	  'green': [32, 39],
	  'magenta': [35, 39],
	  'red': [31, 39],
	  'yellow': [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	  if (style) {
	    return "\x1B[" + inspect.colors[style][0] + 'm' + str + "\x1B[" + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	function arrayToHash(array) {
	  var hash = {};
	  array.forEach(function (val, idx) {
	    hash[val] = true;
	  });
	  return hash;
	}
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect && value && isFunction$2(value.inspect) &&
	  // Filter out the util module, it's inspect function is special
	  value.inspect !== inspect &&
	  // Also filter out any prototype objects using the circular check.
	  !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction$2(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate$1(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	  var base = '',
	    array = false,
	    braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray$3(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction$2(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate$1(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	  ctx.seen.push(value);
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function (key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	  ctx.seen.pop();
	  return reduceToSingleString(output, base, braces);
	}
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value)) return ctx.stylize('' + value, 'number');
	  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value)) return ctx.stylize('null', 'null');
	}
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty$1(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function (key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
	    }
	  });
	  return output;
	}
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || {
	    value: value[key]
	  };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty$1(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function (line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function (line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	  return name + ': ' + str;
	}
	function reduceToSingleString(output, base, braces) {
	  var length = output.reduce(function (prev, cur) {
	    if (cur.indexOf('\n') >= 0) ;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	  if (length > 60) {
	    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
	  }
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray$3(ar) {
	  return Array.isArray(ar);
	}
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	function isNull(arg) {
	  return arg === null;
	}
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	function isString(arg) {
	  return typeof arg === 'string';
	}
	function isUndefined(arg) {
	  return arg === void 0;
	}
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	function isObject(arg) {
	  return _typeof(arg) === 'object' && arg !== null;
	}
	function isDate$1(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	function isError(e) {
	  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	function isFunction$2(arg) {
	  return typeof arg === 'function';
	}
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	function _extend(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	}
	function hasOwnProperty$1(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	function BufferList() {
	  this.head = null;
	  this.tail = null;
	  this.length = 0;
	}
	BufferList.prototype.push = function (v) {
	  var entry = {
	    data: v,
	    next: null
	  };
	  if (this.length > 0) this.tail.next = entry;else this.head = entry;
	  this.tail = entry;
	  ++this.length;
	};
	BufferList.prototype.unshift = function (v) {
	  var entry = {
	    data: v,
	    next: this.head
	  };
	  if (this.length === 0) this.tail = entry;
	  this.head = entry;
	  ++this.length;
	};
	BufferList.prototype.shift = function () {
	  if (this.length === 0) return;
	  var ret = this.head.data;
	  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	  --this.length;
	  return ret;
	};
	BufferList.prototype.clear = function () {
	  this.head = this.tail = null;
	  this.length = 0;
	};
	BufferList.prototype.join = function (s) {
	  if (this.length === 0) return '';
	  var p = this.head;
	  var ret = '' + p.data;
	  while (p = p.next) {
	    ret += s + p.data;
	  }
	  return ret;
	};
	BufferList.prototype.concat = function (n) {
	  if (this.length === 0) return Buffer.alloc(0);
	  if (this.length === 1) return this.head.data;
	  var ret = Buffer.allocUnsafe(n >>> 0);
	  var p = this.head;
	  var i = 0;
	  while (p) {
	    p.data.copy(ret, i);
	    i += p.data.length;
	    p = p.next;
	  }
	  return ret;
	};

	// Copyright Joyent, Inc. and other Node contributors.
	var isBufferEncoding = Buffer.isEncoding || function (encoding) {
	  switch (encoding && encoding.toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	    case 'raw':
	      return true;
	    default:
	      return false;
	  }
	};
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	function StringDecoder(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	}

	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function (buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	  charStr += buffer.toString(this.encoding, 0, end);
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function (buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = buffer.length >= 3 ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	StringDecoder.prototype.end = function (buffer) {
	  var res = '';
	  if (buffer && buffer.length) res = this.write(buffer);
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	  return res;
	};
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}

	Readable.ReadableState = ReadableState;
	var debug = /*#__PURE__*/debuglog('stream');
	inherits$1(Readable, EventEmitter);
	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') {
	    return emitter.prependListener(event, fn);
	  } else {
	    // This is a hack to make sure that our error handler is attached before any
	    // userland ones.  NEVER DO THIS. This is here only because this code needs
	    // to continue to work with older versions of Node.js that do not include
	    // the prependListener() method. The goal is to eventually remove this hack.
	    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	  }
	}
	function listenerCount(emitter, type) {
	  return emitter.listeners(type).length;
	}
	function ReadableState(options, stream) {
	  options = options || {};

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	function Readable(options) {
	  if (!(this instanceof Readable)) return new Readable(options);
	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;
	  if (options && typeof options.read === 'function') this._read = options.read;
	  EventEmitter.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = Buffer.from(chunk, encoding);
	      encoding = '';
	    }
	  }
	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var _e = new Error('stream.unshift() after end event');
	      stream.emit('error', _e);
	    } else {
	      var skipAdd;
	      if (state.decoder && !addToFront && !encoding) {
	        chunk = state.decoder.write(chunk);
	        skipAdd = !state.objectMode && chunk.length === 0;
	      }
	      if (!addToFront) state.reading = false;

	      // Don't add to the buffer if we've decoded to an empty string chunk and
	      // we're not in object mode
	      if (!skipAdd) {
	        // if we want the data now, just emit it.
	        if (state.flowing && state.length === 0 && !state.sync) {
	          stream.emit('data', chunk);
	          stream.read(0);
	        } else {
	          // update the buffer info.
	          state.length += state.objectMode ? 1 : chunk.length;
	          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	          if (state.needReadable) emitReadable(stream);
	        }
	      }
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	  return needMoreData(state);
	}

	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}

	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;
	  if (n !== 0) state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }
	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;
	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  } else {
	    state.length -= n;
	  }
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;

	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	  if (ret !== null) this.emit('data', ret);
	  return ret;
	};
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!isBuffer$1(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) nextTick$1(emitReadable_, stream);else emitReadable_(stream);
	  }
	}
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}

	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    nextTick$1(maybeReadMore_, stream, state);
	  }
	}
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('not implemented'));
	};
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	  var doEnd = !pipeOpts || pipeOpts.end !== false;
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted) nextTick$1(endFn);else src.once('end', endFn);
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }
	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);
	    cleanedUp = true;

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }

	  // If the user pushes more data while we're writing to dest then we'll end up
	  // in ondata again. However, we only want to increase awaitDrain once because
	  // dest will only emit one 'drain' event for the multiple writes.
	  // => Introduce a guard on increasing awaitDrain.
	  var increasedAwaitDrain = false;
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    increasedAwaitDrain = false;
	    var ret = dest.write(chunk);
	    if (false === ret && !increasedAwaitDrain) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', src._readableState.awaitDrain);
	        src._readableState.awaitDrain++;
	        increasedAwaitDrain = true;
	      }
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (listenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }

	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	  return dest;
	};
	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && src.listeners('data').length) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;
	    if (!dest) dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    for (var _i = 0; _i < len; _i++) {
	      dests[_i].emit('unpipe', this);
	    }
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1) return this;
	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
	  dest.emit('unpipe', this);
	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = EventEmitter.prototype.on.call(this, ev, fn);
	  if (ev === 'data') {
	    // Start flowing on next tick if stream isn't explicitly paused
	    if (this._readableState.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    var state = this._readableState;
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.emittedReadable = false;
	      if (!state.reading) {
	        nextTick$1(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this);
	      }
	    }
	  }
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    nextTick$1(resume_, stream, state);
	  }
	}
	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }
	  state.resumeScheduled = false;
	  state.awaitDrain = 0;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null) {}
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var state = this._readableState;
	  var paused = false;
	  var self = this;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) self.push(chunk);
	    }
	    self.push(null);
	  });
	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function (ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	  return self;
	};

	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;
	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = fromListPartial(n, state.buffer, state.decoder);
	  }
	  return ret;
	}

	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
	  var ret;
	  if (n < list.head.data.length) {
	    // slice is the same for buffers and strings
	    ret = list.head.data.slice(0, n);
	    list.head.data = list.head.data.slice(n);
	  } else if (n === list.head.data.length) {
	    // first chunk is a perfect match
	    ret = list.shift();
	  } else {
	    // result spans more than one buffer
	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
	  }
	  return ret;
	}

	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
	  var p = list.head;
	  var c = 1;
	  var ret = p.data;
	  n -= ret.length;
	  while (p = p.next) {
	    var str = p.data;
	    var nb = n > str.length ? str.length : n;
	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
	    n -= nb;
	    if (n === 0) {
	      if (nb === str.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = str.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}

	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
	  var ret = Buffer.allocUnsafe(n);
	  var p = list.head;
	  var c = 1;
	  p.data.copy(ret);
	  n -= p.data.length;
	  while (p = p.next) {
	    var buf = p.data;
	    var nb = n > buf.length ? buf.length : n;
	    buf.copy(ret, ret.length - n, 0, nb);
	    n -= nb;
	    if (n === 0) {
	      if (nb === buf.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = buf.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
	  if (!state.endEmitted) {
	    state.ended = true;
	    nextTick$1(endReadableNT, state, stream);
	  }
	}
	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}
	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	// A bit simpler than readable streams.
	Writable.WritableState = WritableState;
	inherits$1(Writable, EventEmitter);
	function nop() {}
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}
	function WritableState(options, stream) {
	  Object.defineProperty(this, 'buffer', {
	    get: deprecate(function () {
	      return this.getBuffer();
	    }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
	  });
	  options = options || {};

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;

	  // count buffered requests
	  this.bufferedRequestCount = 0;

	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}
	WritableState.prototype.getBuffer = function writableStateGetBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	function Writable(options) {
	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	    if (typeof options.writev === 'function') this._writev = options.writev;
	  }
	  EventEmitter.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe, not readable'));
	};
	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  nextTick$1(cb, er);
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  var er = false;
	  // Always throw error if a null is written
	  // if we are not in object mode then throw
	  // if it is not a buffer, string, or undefined.
	  if (chunk === null) {
	    er = new TypeError('May not write null values to stream');
	  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  if (er) {
	    stream.emit('error', er);
	    nextTick$1(cb, er);
	    valid = false;
	  }
	  return valid;
	}
	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	  if (typeof cb !== 'function') cb = nop;
	  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }
	  return ret;
	};
	Writable.prototype.cork = function () {
	  var state = this._writableState;
	  state.corked++;
	};
	Writable.prototype.uncork = function () {
	  var state = this._writableState;
	  if (state.corked) {
	    state.corked--;
	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = Buffer.from(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	  state.length += len;
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }
	  return ret;
	}
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) nextTick$1(cb, er);else cb(er);
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	  onwriteStateUpdate(state);
	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);
	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }
	    if (sync) {
	      /*<replacement>*/
	      nextTick$1(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}

	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;
	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;
	    var count = 0;
	    while (entry) {
	      buffer[count] = entry;
	      entry = entry.next;
	      count += 1;
	    }
	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }
	    if (entry === null) state.lastBufferedRequest = null;
	  }
	  state.bufferedRequestCount = 0;
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}
	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};
	Writable.prototype._writev = null;
	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished) endWritable(this, state, cb);
	};
	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}
	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) nextTick$1(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}

	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;
	  this.next = null;
	  this.entry = null;
	  this.finish = function (err) {
	    var entry = _this.entry;
	    _this.entry = null;
	    while (entry) {
	      var cb = entry.callback;
	      state.pendingcb--;
	      cb(err);
	      entry = entry.next;
	    }
	    if (state.corkedRequestsFree) {
	      state.corkedRequestsFree.next = _this;
	    } else {
	      state.corkedRequestsFree = _this;
	    }
	  };
	}

	inherits$1(Duplex, Readable);
	var keys = /*#__PURE__*/Object.keys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	}
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);
	  Readable.call(this, options);
	  Writable.call(this, options);
	  if (options && options.readable === false) this.readable = false;
	  if (options && options.writable === false) this.writable = false;
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  nextTick$1(onEndNT, this);
	}
	function onEndNT(self) {
	  self.end();
	}

	// a transform stream is a readable/writable stream where you do
	inherits$1(Transform, Duplex);
	function TransformState(stream) {
	  this.afterTransform = function (er, data) {
	    return afterTransform(stream, er, data);
	  };
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	  this.writeencoding = null;
	}
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	  var cb = ts.writecb;
	  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
	  ts.writechunk = null;
	  ts.writecb = null;
	  if (data !== null && data !== undefined) stream.push(data);
	  cb(er);
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);
	  Duplex.call(this, options);
	  this._transformState = new TransformState(this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }
	  this.once('prefinish', function () {
	    if (typeof this._flush === 'function') this._flush(function (er) {
	      done(stream, er);
	    });else done(stream);
	  });
	}
	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('Not implemented');
	};
	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;
	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	function done(stream, er) {
	  if (er) return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;
	  if (ws.length) throw new Error('Calling transform done when ws.length != 0');
	  if (ts.transforming) throw new Error('Calling transform done when still transforming');
	  return stream.push(null);
	}

	inherits$1(PassThrough, Transform);
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	  Transform.call(this, options);
	}
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

	inherits$1(Stream, EventEmitter);
	Stream.Readable = Readable;
	Stream.Writable = Writable;
	Stream.Duplex = Duplex;
	Stream.Transform = Transform;
	Stream.PassThrough = PassThrough;

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;

	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EventEmitter.call(this);
	}
	Stream.prototype.pipe = function (dest, options) {
	  var source = this;
	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }
	  source.on('data', ondata);
	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }
	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }
	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	    dest.end();
	  }
	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EventEmitter.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);
	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);
	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);
	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);
	    dest.removeListener('close', cleanup);
	  }
	  source.on('end', cleanup);
	  source.on('close', cleanup);
	  dest.on('close', cleanup);
	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};

	// Fast, low-level functions for parsing and formatting GFF3.
	// JavaScript port of Robert Buels's Bio::GFF3::LowLevel Perl module.
	/**
	 * Unescape a string value used in a GFF3 attribute.
	 *
	 * @param stringVal - Escaped GFF3 string value
	 * @returns An unescaped string value
	 */
	function unescape(stringVal) {
	  return stringVal.replace(/%([0-9A-Fa-f]{2})/g, function (_match, seq) {
	    return String.fromCharCode(parseInt(seq, 16));
	  });
	}
	function _escape(regex, s) {
	  return String(s).replace(regex, function (ch) {
	    var hex = ch.charCodeAt(0).toString(16).toUpperCase().padStart(2, '0');
	    return "%".concat(hex);
	  });
	}
	/**
	 * Escape a value for use in a GFF3 attribute value.
	 *
	 * @param rawVal - Raw GFF3 attribute value
	 * @returns An escaped string value
	 */
	function escape(rawVal) {
	  return _escape(/[\n;\r\t=%&,\x00-\x1f\x7f-\xff]/g, rawVal);
	}
	/**
	 * Escape a value for use in a GFF3 column value.
	 *
	 * @param rawVal - Raw GFF3 column value
	 * @returns An escaped column value
	 */
	function escapeColumn(rawVal) {
	  return _escape(/[\n\r\t%\x00-\x1f\x7f-\xff]/g, rawVal);
	}
	/**
	 * Parse the 9th column (attributes) of a GFF3 feature line.
	 *
	 * @param attrString - String of GFF3 9th column
	 * @returns Parsed attributes
	 */
	function parseAttributes(attrString) {
	  if (!(attrString && attrString.length) || attrString === '.') return {};
	  var attrs = {};
	  attrString.replace(/\r?\n$/, '').split(';').forEach(function (a) {
	    var _arec;
	    var nv = a.split('=', 2);
	    if (!(nv[1] && nv[1].length)) return;
	    nv[0] = nv[0].trim();
	    var arec = attrs[nv[0].trim()];
	    if (!arec) {
	      arec = [];
	      attrs[nv[0]] = arec;
	    }
	    (_arec = arec).push.apply(_arec, _toConsumableArray(nv[1].split(',').map(function (s) {
	      return s.trim();
	    }).map(unescape)));
	  });
	  return attrs;
	}
	/**
	 * Parse a GFF3 feature line
	 *
	 * @param line - GFF3 feature line
	 * @returns The parsed feature
	 */
	function parseFeature(line) {
	  // split the line into columns and replace '.' with null in each column
	  var f = line.split('\t').map(function (a) {
	    return a === '.' || a === '' ? null : a;
	  });
	  // unescape only the ref, source, and type columns
	  var parsed = {
	    seq_id: f[0] && unescape(f[0]),
	    source: f[1] && unescape(f[1]),
	    type: f[2] && unescape(f[2]),
	    start: f[3] === null ? null : parseInt(f[3], 10),
	    end: f[4] === null ? null : parseInt(f[4], 10),
	    score: f[5] === null ? null : parseFloat(f[5]),
	    strand: f[6],
	    phase: f[7],
	    attributes: f[8] === null ? null : parseAttributes(f[8])
	  };
	  return parsed;
	}
	/**
	 * Parse a GFF3 directive line.
	 *
	 * @param line - GFF3 directive line
	 * @returns The parsed directive
	 */
	function parseDirective(line) {
	  var match = /^\s*##\s*(\S+)\s*(.*)/.exec(line);
	  if (!match) return null;
	  var _match2 = _slicedToArray(match, 2),
	    name = _match2[1];
	  var _match3 = _slicedToArray(match, 3),
	    contents = _match3[2];
	  var parsed = {
	    directive: name
	  };
	  if (contents.length) {
	    contents = contents.replace(/\r?\n$/, '');
	    parsed.value = contents;
	  }
	  // do a little additional parsing for sequence-region and genome-build directives
	  if (name === 'sequence-region') {
	    var c = contents.split(/\s+/, 3);
	    return _objectSpread2(_objectSpread2({}, parsed), {}, {
	      seq_id: c[0],
	      start: c[1] && c[1].replace(/\D/g, ''),
	      end: c[2] && c[2].replace(/\D/g, '')
	    });
	  } else if (name === 'genome-build') {
	    var _contents$split = contents.split(/\s+/, 2),
	      _contents$split2 = _slicedToArray(_contents$split, 2),
	      source = _contents$split2[0],
	      buildName = _contents$split2[1];
	    return _objectSpread2(_objectSpread2({}, parsed), {}, {
	      source: source,
	      buildName: buildName
	    });
	  }
	  return parsed;
	}
	/**
	 * Format an attributes object into a string suitable for the 9th column of GFF3.
	 *
	 * @param attrs - Attributes
	 * @returns GFF3 9th column string
	 */
	function formatAttributes(attrs) {
	  var attrOrder = [];
	  Object.entries(attrs).forEach(function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 2),
	      tag = _ref2[0],
	      val = _ref2[1];
	    if (!val) return;
	    var valstring;
	    if (val.hasOwnProperty('toString')) {
	      valstring = escape(val.toString());
	      // } else if (Array.isArray(val.values)) {
	      //   valstring = val.values.map(escape).join(',')
	    } else if (Array.isArray(val)) {
	      valstring = val.map(escape).join(',');
	    } else {
	      valstring = escape(val);
	    }
	    attrOrder.push("".concat(escape(tag), "=").concat(valstring));
	  });
	  return attrOrder.length ? attrOrder.join(';') : '.';
	}
	function _formatSingleFeature(f, seenFeature) {
	  var attrString = f.attributes === null || f.attributes === undefined ? '.' : formatAttributes(f.attributes);
	  var fields = [f.seq_id === null ? '.' : escapeColumn(f.seq_id), f.source === null ? '.' : escapeColumn(f.source), f.type === null ? '.' : escapeColumn(f.type), f.start === null ? '.' : escapeColumn(f.start), f.end === null ? '.' : escapeColumn(f.end), f.score === null ? '.' : escapeColumn(f.score), f.strand === null ? '.' : escapeColumn(f.strand), f.phase === null ? '.' : escapeColumn(f.phase), attrString];
	  var formattedString = "".concat(fields.join('\t'), "\n");
	  // if we have already output this exact feature, skip it
	  if (seenFeature[formattedString]) {
	    return '';
	  }
	  seenFeature[formattedString] = true;
	  return formattedString;
	}
	function _formatFeature(feature, seenFeature) {
	  if (Array.isArray(feature)) {
	    return feature.map(function (f) {
	      return _formatFeature(f, seenFeature);
	    }).join('');
	  }
	  var strings = [_formatSingleFeature(feature, seenFeature)];
	  if (_isFeatureLineWithRefs(feature)) {
	    strings.push.apply(strings, _toConsumableArray(feature.child_features.map(function (f) {
	      return _formatFeature(f, seenFeature);
	    })).concat(_toConsumableArray(feature.derived_features.map(function (f) {
	      return _formatFeature(f, seenFeature);
	    }))));
	  }
	  return strings.join('');
	}
	/**
	 * Format a feature object or array of feature objects into one or more lines of
	 * GFF3.
	 *
	 * @param featureOrFeatures - A feature object or array of feature objects
	 * @returns A string of one or more GFF3 lines
	 */
	function formatFeature(featureOrFeatures) {
	  var seen = {};
	  return _formatFeature(featureOrFeatures, seen);
	}
	/**
	 * Format a directive into a line of GFF3.
	 *
	 * @param directive - A directive object
	 * @returns A directive line string
	 */
	function formatDirective(directive) {
	  var str = "##".concat(directive.directive);
	  if (directive.value) str += " ".concat(directive.value);
	  str += '\n';
	  return str;
	}
	/**
	 * Format a comment into a GFF3 comment.
	 * Yes I know this is just adding a # and a newline.
	 *
	 * @param comment - A comment object
	 * @returns A comment line string
	 */
	function formatComment(comment) {
	  return "# ".concat(comment.comment, "\n");
	}
	/**
	 * Format a sequence object as FASTA
	 *
	 * @param seq - A sequence object
	 * @returns Formatted single FASTA sequence string
	 */
	function formatSequence$1(seq) {
	  return ">".concat(seq.id).concat(seq.description ? " ".concat(seq.description) : '', "\n").concat(seq.sequence, "\n");
	}
	/**
	 * Format a directive, comment, sequence, or feature, or array of such items,
	 * into one or more lines of GFF3.
	 *
	 * @param itemOrItems - A comment, sequence, or feature, or array of such items
	 * @returns A formatted string or array of strings
	 */
	function formatItem(itemOrItems) {
	  function formatSingleItem(item) {
	    if ('attributes' in item) return formatFeature(item);
	    if ('directive' in item) return formatDirective(item);
	    if ('sequence' in item) return formatSequence$1(item);
	    if ('comment' in item) return formatComment(item);
	    return '# (invalid item found during format)\n';
	  }
	  if (Array.isArray(itemOrItems)) {
	    return itemOrItems.map(formatSingleItem);
	  }
	  return formatSingleItem(itemOrItems);
	}
	function _isFeatureLineWithRefs(featureLine) {
	  return featureLine.child_features !== undefined && featureLine.derived_features !== undefined;
	}

	var util = {
		__proto__: null,
		unescape: unescape,
		escape: escape,
		escapeColumn: escapeColumn,
		parseAttributes: parseAttributes,
		parseFeature: parseFeature,
		parseDirective: parseDirective,
		formatAttributes: formatAttributes,
		formatFeature: formatFeature,
		formatDirective: formatDirective,
		formatComment: formatComment,
		formatSequence: formatSequence$1,
		formatItem: formatItem
	};

	var containerAttributes = {
	  Parent: 'child_features',
	  Derives_from: 'derived_features'
	};
	var FASTAParser = /*#__PURE__*/function () {
	  function FASTAParser(seqCallback) {
	    _classCallCheck(this, FASTAParser);
	    this.seqCallback = seqCallback;
	    this.currentSequence = undefined;
	  }
	  _createClass(FASTAParser, [{
	    key: "addLine",
	    value: function addLine(line) {
	      var defMatch = /^>\s*(\S+)\s*(.*)/.exec(line);
	      if (defMatch) {
	        this._flush();
	        this.currentSequence = {
	          id: defMatch[1],
	          sequence: ''
	        };
	        if (defMatch[2]) this.currentSequence.description = defMatch[2].trim();
	      } else if (this.currentSequence && /\S/.test(line)) {
	        this.currentSequence.sequence += line.replace(/\s/g, '');
	      }
	    }
	  }, {
	    key: "_flush",
	    value: function _flush() {
	      if (this.currentSequence) this.seqCallback(this.currentSequence);
	    }
	  }, {
	    key: "finish",
	    value: function finish() {
	      this._flush();
	    }
	  }]);
	  return FASTAParser;
	}();
	var Parser = /*#__PURE__*/function () {
	  function Parser(args) {
	    _classCallCheck(this, Parser);
	    this.fastaParser = undefined;
	    // if this is true, the parser ignores the
	    // rest of the lines in the file.  currently
	    // set when the file switches over to FASTA
	    this.eof = false;
	    this.lineNumber = 0;
	    // features that we have to keep on hand for now because they
	    // might be referenced by something else
	    this._underConstructionTopLevel = [];
	    // index of the above by ID
	    this._underConstructionById = {};
	    this._completedReferences = {};
	    // features that reference something we have not seen yet
	    // structured as:
	    // {  'some_id' : {
	    //     'Parent' : [ orphans that have a Parent attr referencing it ],
	    //     'Derives_from' : [ orphans that have a Derives_from attr referencing it ],
	    //    }
	    // }
	    this._underConstructionOrphans = {};
	    // eslint-disable-next-line @typescript-eslint/no-empty-function
	    var nullFunc = function nullFunc() {};
	    this.featureCallback = args.featureCallback || nullFunc;
	    this.endCallback = args.endCallback || nullFunc;
	    this.commentCallback = args.commentCallback || nullFunc;
	    this.errorCallback = args.errorCallback || nullFunc;
	    this.directiveCallback = args.directiveCallback || nullFunc;
	    this.sequenceCallback = args.sequenceCallback || nullFunc;
	    // number of lines to buffer
	    this.bufferSize = args.bufferSize === undefined ? 1000 : args.bufferSize;
	  }
	  _createClass(Parser, [{
	    key: "addLine",
	    value: function addLine(line) {
	      // if we have transitioned to a fasta section, just delegate to that parser
	      if (this.fastaParser) {
	        this.fastaParser.addLine(line);
	        return;
	      }
	      if (this.eof) {
	        // otherwise, if we are done, ignore this line
	        return;
	      }
	      this.lineNumber += 1;
	      if (/^\s*[^#\s>]/.test(line)) {
	        // feature line, most common case
	        this._bufferLine(line);
	        return;
	      }
	      var match = /^\s*(#+)(.*)/.exec(line);
	      if (match) {
	        // directive or comment
	        var _match = _slicedToArray(match, 2),
	          hashsigns = _match[1];
	        var _match2 = _slicedToArray(match, 3),
	          contents = _match2[2];
	        if (hashsigns.length === 3) {
	          // sync directive, all forward-references are resolved.
	          this._emitAllUnderConstructionFeatures();
	        } else if (hashsigns.length === 2) {
	          var directive = parseDirective(line);
	          if (directive) {
	            if (directive.directive === 'FASTA') {
	              this._emitAllUnderConstructionFeatures();
	              this.eof = true;
	              this.fastaParser = new FASTAParser(this.sequenceCallback);
	            } else {
	              this._emitItem(directive);
	            }
	          }
	        } else {
	          contents = contents.replace(/\s*/, '');
	          this._emitItem({
	            comment: contents
	          });
	        }
	      } else if (/^\s*$/.test(line)) ; else if (/^\s*>/.test(line)) {
	        // implicit beginning of a FASTA section
	        this._emitAllUnderConstructionFeatures();
	        this.eof = true;
	        this.fastaParser = new FASTAParser(this.sequenceCallback);
	        this.fastaParser.addLine(line);
	      } else {
	        // it's a parse error
	        var errLine = line.replace(/\r?\n?$/g, '');
	        throw new Error("GFF3 parse error.  Cannot parse '".concat(errLine, "'."));
	      }
	    }
	  }, {
	    key: "finish",
	    value: function finish() {
	      this._emitAllUnderConstructionFeatures();
	      if (this.fastaParser) this.fastaParser.finish();
	      this.endCallback();
	    }
	  }, {
	    key: "_emitItem",
	    value: function _emitItem(i) {
	      if (Array.isArray(i)) this.featureCallback(i);else if ('directive' in i) this.directiveCallback(i);else if ('comment' in i) this.commentCallback(i);
	    }
	  }, {
	    key: "_enforceBufferSizeLimit",
	    value: function _enforceBufferSizeLimit() {
	      var _this = this;
	      var additionalItemCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	      var _unbufferItem = function _unbufferItem(item) {
	        if (item && Array.isArray(item) && item[0].attributes && item[0].attributes.ID && item[0].attributes.ID[0]) {
	          var ids = item[0].attributes.ID;
	          ids.forEach(function (id) {
	            delete _this._underConstructionById[id];
	            delete _this._completedReferences[id];
	          });
	          item.forEach(function (i) {
	            if (i.child_features) i.child_features.forEach(function (c) {
	              return _unbufferItem(c);
	            });
	            if (i.derived_features) i.derived_features.forEach(function (d) {
	              return _unbufferItem(d);
	            });
	          });
	        }
	      };
	      while (this._underConstructionTopLevel.length + additionalItemCount > this.bufferSize) {
	        var item = this._underConstructionTopLevel.shift();
	        if (item) {
	          this._emitItem(item);
	          _unbufferItem(item);
	        }
	      }
	    }
	    /**
	     * return all under-construction features, called when we know
	     * there will be no additional data to attach to them
	     */
	  }, {
	    key: "_emitAllUnderConstructionFeatures",
	    value: function _emitAllUnderConstructionFeatures() {
	      this._underConstructionTopLevel.forEach(this._emitItem.bind(this));
	      this._underConstructionTopLevel = [];
	      this._underConstructionById = {};
	      this._completedReferences = {};
	      // if we have any orphans hanging around still, this is a
	      // problem. die with a parse error
	      if (Array.from(Object.values(this._underConstructionOrphans)).length) {
	        throw new Error("some features reference other features that do not exist in the file (or in the same '###' scope). ".concat(JSON.stringify(this._underConstructionOrphans)));
	      }
	    }
	    // do the right thing with a newly-parsed feature line
	  }, {
	    key: "_bufferLine",
	    value: function _bufferLine(line) {
	      var _this2 = this;
	      var _a, _b, _c;
	      var rawFeatureLine = parseFeature(line);
	      var featureLine = _objectSpread2(_objectSpread2({}, rawFeatureLine), {}, {
	        child_features: [],
	        derived_features: []
	      });
	      // featureLine._lineNumber = this.lineNumber //< debugging aid
	      // NOTE: a feature is an arrayref of one or more feature lines.
	      var ids = ((_a = featureLine.attributes) === null || _a === void 0 ? void 0 : _a.ID) || [];
	      var parents = ((_b = featureLine.attributes) === null || _b === void 0 ? void 0 : _b.Parent) || [];
	      var derives = ((_c = featureLine.attributes) === null || _c === void 0 ? void 0 : _c.Derives_from) || [];
	      if (!ids.length && !parents.length && !derives.length) {
	        // if it has no IDs and does not refer to anything, we can just
	        // output it
	        this._emitItem([featureLine]);
	        return;
	      }
	      var feature = undefined;
	      ids.forEach(function (id) {
	        var existing = _this2._underConstructionById[id];
	        if (existing) {
	          // another location of the same feature
	          if (existing[existing.length - 1].type !== featureLine.type) {
	            _this2._parseError("multi-line feature \"".concat(id, "\" has inconsistent types: \"").concat(featureLine.type, "\", \"").concat(existing[existing.length - 1].type, "\""));
	          }
	          existing.push(featureLine);
	          feature = existing;
	        } else {
	          // haven't seen it yet, so buffer it so we can attach
	          // child features to it
	          feature = [featureLine];
	          _this2._enforceBufferSizeLimit(1);
	          if (!parents.length && !derives.length) {
	            _this2._underConstructionTopLevel.push(feature);
	          }
	          _this2._underConstructionById[id] = feature;
	          // see if we have anything buffered that refers to it
	          _this2._resolveReferencesTo(feature, id);
	        }
	      });
	      // try to resolve all its references
	      this._resolveReferencesFrom(feature || [featureLine], {
	        Parent: parents,
	        Derives_from: derives
	      }, ids);
	    }
	  }, {
	    key: "_resolveReferencesTo",
	    value: function _resolveReferencesTo(feature, id) {
	      var references = this._underConstructionOrphans[id];
	      //   references is of the form
	      //   {
	      //     'Parent' : [ orphans that have a Parent attr referencing this feature ],
	      //     'Derives_from' : [ orphans that have a Derives_from attr referencing this feature ],
	      //    }
	      if (!references) return;
	      feature.forEach(function (loc) {
	        var _loc$child_features;
	        (_loc$child_features = loc.child_features).push.apply(_loc$child_features, _toConsumableArray(references.Parent));
	      });
	      feature.forEach(function (loc) {
	        var _loc$derived_features;
	        (_loc$derived_features = loc.derived_features).push.apply(_loc$derived_features, _toConsumableArray(references.Derives_from));
	      });
	      delete this._underConstructionOrphans[id];
	    }
	  }, {
	    key: "_parseError",
	    value: function _parseError(message) {
	      this.eof = true;
	      this.errorCallback("".concat(this.lineNumber, ": ").concat(message));
	    }
	  }, {
	    key: "_resolveReferencesFrom",
	    value: function _resolveReferencesFrom(feature, references, ids) {
	      var _this3 = this;
	      // this is all a bit more awkward in javascript than it was in perl
	      function postSet(obj, slot1, slot2) {
	        var subObj = obj[slot1];
	        if (!subObj) {
	          subObj = {};
	          obj[slot1] = subObj;
	        }
	        var returnVal = subObj[slot2] || false;
	        subObj[slot2] = true;
	        return returnVal;
	      }
	      references.Parent.forEach(function (toId) {
	        var otherFeature = _this3._underConstructionById[toId];
	        if (otherFeature) {
	          var pname = containerAttributes.Parent;
	          if (!ids.filter(function (id) {
	            return postSet(_this3._completedReferences, id, "Parent,".concat(toId));
	          }).length) {
	            otherFeature.forEach(function (location) {
	              location[pname].push(feature);
	            });
	          }
	        } else {
	          var ref = _this3._underConstructionOrphans[toId];
	          if (!ref) {
	            ref = {
	              Parent: [],
	              Derives_from: []
	            };
	            _this3._underConstructionOrphans[toId] = ref;
	          }
	          ref.Parent.push(feature);
	        }
	      });
	      references.Derives_from.forEach(function (toId) {
	        var otherFeature = _this3._underConstructionById[toId];
	        if (otherFeature) {
	          var pname = containerAttributes.Derives_from;
	          if (!ids.filter(function (id) {
	            return postSet(_this3._completedReferences, id, "Derives_from,".concat(toId));
	          }).length) {
	            otherFeature.forEach(function (location) {
	              location[pname].push(feature);
	            });
	          }
	        } else {
	          var ref = _this3._underConstructionOrphans[toId];
	          if (!ref) {
	            ref = {
	              Parent: [],
	              Derives_from: []
	            };
	            _this3._underConstructionOrphans[toId] = ref;
	          }
	          ref.Derives_from.push(feature);
	        }
	      });
	    }
	  }]);
	  return Parser;
	}();

	// call a callback on the next process tick if running in
	// an environment that supports it
	function _callback(callback) {
	  if (process$1 && nextTick$1) nextTick$1(callback);else callback();
	}
	// shared arg processing for the parse routines
	function _processParseOptions(options) {
	  var out = _objectSpread2({
	    encoding: 'utf8',
	    parseFeatures: true,
	    parseDirectives: false,
	    parseSequences: true,
	    parseComments: false,
	    bufferSize: 1000
	  }, options);
	  if (options.parseAll) {
	    out.parseFeatures = true;
	    out.parseDirectives = true;
	    out.parseComments = true;
	    out.parseSequences = true;
	  }
	  return out;
	}
	var GFFTransform = /*#__PURE__*/function (_Transform) {
	  _inherits(GFFTransform, _Transform);
	  var _super = /*#__PURE__*/_createSuper(GFFTransform);
	  function GFFTransform() {
	    var _this;
	    var inputOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    _classCallCheck(this, GFFTransform);
	    _this = _super.call(this, {
	      objectMode: true
	    });
	    _this.textBuffer = '';
	    var options = _processParseOptions(inputOptions);
	    _this.encoding = inputOptions.encoding || 'utf8';
	    _this.decoder = new StringDecoder();
	    var push = _this.push.bind(_assertThisInitialized(_this));
	    _this.parser = new Parser({
	      featureCallback: options.parseFeatures ? push : undefined,
	      directiveCallback: options.parseDirectives ? push : undefined,
	      commentCallback: options.parseComments ? push : undefined,
	      sequenceCallback: options.parseSequences ? push : undefined,
	      errorCallback: function errorCallback(err) {
	        return _this.emit('error', err);
	      },
	      bufferSize: options.bufferSize
	    });
	    return _this;
	  }
	  _createClass(GFFTransform, [{
	    key: "_addLine",
	    value: function _addLine(data) {
	      if (data) {
	        this.parser.addLine(data);
	      }
	    }
	  }, {
	    key: "_nextText",
	    value: function _nextText(buffer) {
	      var _this2 = this;
	      var pieces = (this.textBuffer + buffer).split(/\r?\n/);
	      this.textBuffer = pieces.pop() || '';
	      pieces.forEach(function (piece) {
	        return _this2._addLine(piece);
	      });
	    }
	  }, {
	    key: "_transform",
	    value: function _transform(chunk, _encoding, callback) {
	      this._nextText(this.decoder.write(chunk));
	      _callback(callback);
	    }
	  }, {
	    key: "_flush",
	    value: function _flush(callback) {
	      if (this.decoder.end) this._nextText(this.decoder.end());
	      if (this.textBuffer != null) this._addLine(this.textBuffer);
	      this.parser.finish();
	      _callback(callback);
	    }
	  }]);
	  return GFFTransform;
	}(Transform);
	/**
	 * Parse a stream of text data into a stream of feature, directive, comment,
	 * an sequence objects.
	 *
	 * @param options - Parsing options
	 * @returns stream (in objectMode) of parsed items
	 */
	function parseStream() {
	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  return new GFFTransform(options);
	}
	function parseStringSync(str) {
	  var inputOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  if (!str) return [];
	  var options = _processParseOptions(inputOptions);
	  var items = [];
	  var push = items.push.bind(items);
	  var parser = new Parser({
	    featureCallback: options.parseFeatures ? push : undefined,
	    directiveCallback: options.parseDirectives ? push : undefined,
	    commentCallback: options.parseComments ? push : undefined,
	    sequenceCallback: options.parseSequences ? push : undefined,
	    bufferSize: Infinity,
	    errorCallback: function errorCallback(err) {
	      throw err;
	    }
	  });
	  str.split(/\r?\n/).forEach(parser.addLine.bind(parser));
	  parser.finish();
	  return items;
	}
	/**
	 * Format an array of GFF3 items (features,directives,comments) into string of
	 * GFF3. Does not insert synchronization (###) marks.
	 *
	 * @param items - Array of features, directives, comments and/or sequences
	 * @returns the formatted GFF3
	 */
	function formatSync(items) {
	  // sort items into seq and other
	  var other = [];
	  var sequences = [];
	  items.forEach(function (i) {
	    if ('sequence' in i) sequences.push(i);else other.push(i);
	  });
	  var str = other.map(formatItem).join('');
	  if (sequences.length) {
	    str += '##FASTA\n';
	    str += sequences.map(formatSequence$1).join('');
	  }
	  return str;
	}
	var FormattingTransform = /*#__PURE__*/function (_Transform2) {
	  _inherits(FormattingTransform, _Transform2);
	  var _super2 = /*#__PURE__*/_createSuper(FormattingTransform);
	  function FormattingTransform() {
	    var _this3;
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    _classCallCheck(this, FormattingTransform);
	    _this3 = _super2.call(this, Object.assign(options, {
	      objectMode: true
	    }));
	    _this3.linesSinceLastSyncMark = 0;
	    _this3.haveWeEmittedData = false;
	    _this3.fastaMode = false;
	    _this3.minLinesBetweenSyncMarks = options.minSyncLines || 100;
	    _this3.insertVersionDirective = options.insertVersionDirective || false;
	    return _this3;
	  }
	  _createClass(FormattingTransform, [{
	    key: "_transform",
	    value: function _transform(chunk, _encoding, callback) {
	      // if we have not emitted anything yet, and this first
	      // chunk is not a gff-version directive, emit one
	      var str;
	      if (!this.haveWeEmittedData && this.insertVersionDirective) {
	        var thisChunk = Array.isArray(chunk) ? chunk[0] : chunk;
	        if ('directive' in thisChunk) {
	          if (thisChunk.directive !== 'gff-version') {
	            this.push('##gff-version 3\n');
	          }
	        }
	      }
	      // if it's a sequence chunk coming down, emit a FASTA directive and
	      // change to FASTA mode
	      if ('sequence' in chunk && !this.fastaMode) {
	        this.push('##FASTA\n');
	        this.fastaMode = true;
	      }
	      if (Array.isArray(chunk)) str = chunk.map(formatItem).join('');else str = formatItem(chunk);
	      this.push(str);
	      if (this.linesSinceLastSyncMark >= this.minLinesBetweenSyncMarks) {
	        this.push('###\n');
	        this.linesSinceLastSyncMark = 0;
	      } else {
	        // count the number of newlines in this chunk
	        var count = 0;
	        for (var i = 0; i < str.length; i += 1) {
	          if (str[i] === '\n') count += 1;
	        }
	        this.linesSinceLastSyncMark += count;
	      }
	      this.haveWeEmittedData = true;
	      _callback(callback);
	    }
	  }]);
	  return FormattingTransform;
	}(Transform);
	/**
	 * Format a stream of features, directives, comments and/or sequences into a
	 * stream of GFF3 text.
	 *
	 * Inserts synchronization (###) marks automatically.
	 *
	 * @param options - parser options
	 */
	function formatStream() {
	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  return new FormattingTransform(options);
	}
	/**
	 * Format a stream of features, directives, comments and/or sequences into a
	 * GFF3 file and write it to the filesystem.

	 * Inserts synchronization (###) marks and a ##gff-version
	 * directive automatically (if one is not already present).
	 *
	 * @param stream - the stream to write to the file
	 * @param filename - the file path to write to
	 * @param options - parser options
	 * @returns promise for null that resolves when the stream has been written
	 */
	function formatFile(stream, writeStream) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var newOptions = _objectSpread2({
	    insertVersionDirective: true
	  }, options);
	  return new Promise(function (resolve, reject) {
	    stream.pipe(new FormattingTransform(newOptions)).on('end', function () {
	      return resolve(null);
	    }).on('error', reject).pipe(writeStream);
	  });
	}

	var gff = {
	  parseStream: parseStream,
	  parseStringSync: parseStringSync,
	  formatSync: formatSync,
	  formatStream: formatStream,
	  formatFile: formatFile,
	  util: util
	};

	async function loadAssemblyIntoClient(assemblyId, gff3FileText, apolloDataStore) {
	    const featuresAndSequences = gff.parseStringSync(gff3FileText, {
	        parseSequences: true,
	        parseComments: true,
	        parseDirectives: false,
	        parseFeatures: true,
	    });
	    if (featuresAndSequences.length === 0) {
	        throw new Error('No features found in GFF3 file');
	    }
	    let sequenceFeatureCount = 0;
	    let assembly = apolloDataStore.assemblies.get(assemblyId);
	    if (!assembly) {
	        assembly = apolloDataStore.addAssembly(assemblyId, 'InMemoryFileDriver');
	    }
	    for (const seqLine of featuresAndSequences) {
	        if (Array.isArray(seqLine)) {
	            // regular feature
	            const feature = dist$2.gff3ToAnnotationFeature(seqLine);
	            const ref = assembly.refSeqs.get(feature.refSeq) ??
	                assembly.addRefSeq(feature.refSeq, feature.refSeq);
	            if (!ref.features.has(feature._id)) {
	                ref.addFeature(feature);
	            }
	        }
	        else if ('comment' in seqLine) {
	            assembly.addComment(seqLine.comment);
	        }
	        else {
	            sequenceFeatureCount++;
	            // sequence feature
	            let ref = assembly.refSeqs.get(seqLine.id);
	            if (!ref) {
	                ref = assembly.addRefSeq(seqLine.id, seqLine.id, seqLine.description);
	            }
	            if (seqLine.description && !ref.description) {
	                ref.setDescription(seqLine.description);
	            }
	            ref.addSequence({
	                start: 0,
	                stop: seqLine.sequence.length,
	                sequence: seqLine.sequence,
	            });
	        }
	    }
	    if (sequenceFeatureCount === 0) {
	        throw new Error('No embedded FASTA section found in GFF3');
	    }
	    const checkResults = await checkFeatures(assembly);
	    apolloDataStore.addCheckResults(checkResults);
	    return assembly;
	}
	async function checkFeatures(assembly) {
	    const checkResults = [];
	    for (const ref of assembly.refSeqs.values()) {
	        for (const feature of ref.features.values()) {
	            for (const check of dist$3.checkRegistry.getChecks().values()) {
	                const result = await check.checkFeature(require$$1$3.getSnapshot(feature), (start, stop) => Promise.resolve(ref.getSequence(start, stop)));
	                checkResults.push(...result);
	            }
	        }
	    }
	    return checkResults;
	}

	function getFeatureName$1(feature) {
	    const { attributes } = feature;
	    const name = attributes.get('gff_name');
	    if (name) {
	        return name[0];
	    }
	    return '';
	}
	function getFeatureId$2(feature) {
	    const { attributes } = feature;
	    const id = attributes.get('gff_id');
	    const transcript_id = attributes.get('transcript_id');
	    const exon_id = attributes.get('exon_id');
	    const protein_id = attributes.get('protein_id');
	    if (id) {
	        return id[0];
	    }
	    if (transcript_id) {
	        return transcript_id[0];
	    }
	    if (exon_id) {
	        return exon_id[0];
	    }
	    if (protein_id) {
	        return protein_id[0];
	    }
	    return '';
	}
	function getFeatureNameOrId$1(feature) {
	    const name = getFeatureName$1(feature);
	    const id = getFeatureId$2(feature);
	    if (name) {
	        return `: ${name}`;
	    }
	    if (id) {
	        return `: ${id}`;
	    }
	    return '';
	}
	function getStrand(strand) {
	    if (strand === 1) {
	        return 'Forward';
	    }
	    if (strand === -1) {
	        return 'Reverse';
	    }
	    return '';
	}
	function getChildren(feature) {
	    const children = [];
	    //
	    if (feature.children) {
	        for (const [, ff] of feature.children) {
	            children.push(ff);
	        }
	    }
	    return children;
	}
	function getParents(feature) {
	    const parents = [];
	    let { parent } = feature;
	    while (parent) {
	        parents.push(parent);
	        ({ parent } = parent);
	    }
	    return parents;
	}
	function getFeaturesUnderClick(mousePosition, includeSiblings = false) {
	    const clickedFeatures = [];
	    if (!mousePosition.featureAndGlyphUnderMouse) {
	        return clickedFeatures;
	    }
	    clickedFeatures.push(mousePosition.featureAndGlyphUnderMouse.feature);
	    for (const x of getParents(mousePosition.featureAndGlyphUnderMouse.feature)) {
	        clickedFeatures.push(x);
	    }
	    const { bp } = mousePosition;
	    const children = getChildren(mousePosition.featureAndGlyphUnderMouse.feature);
	    for (const child of children) {
	        if (child.min < bp && child.max >= bp) {
	            clickedFeatures.push(child);
	        }
	    }
	    if (!includeSiblings) {
	        return clickedFeatures;
	    }
	    // Also add siblings , i.e. features having the same parent as the clicked
	    // one and intersecting the click position
	    if (mousePosition.featureAndGlyphUnderMouse.feature.parent) {
	        const siblings = mousePosition.featureAndGlyphUnderMouse.feature.parent.children;
	        if (siblings) {
	            for (const [, sib] of siblings) {
	                if (sib._id == mousePosition.featureAndGlyphUnderMouse.feature._id) {
	                    continue;
	                }
	                if (sib.min < bp && sib.max >= bp) {
	                    clickedFeatures.push(sib);
	                }
	            }
	        }
	    }
	    return clickedFeatures;
	}

	function getMinAndMaxPx(feature, refName, regionNumber, lgv) {
	    const minPxInfo = lgv.bpToPx({
	        refName,
	        coord: feature.min,
	        regionNumber,
	    });
	    const maxPxInfo = lgv.bpToPx({
	        refName,
	        coord: feature.max,
	        regionNumber,
	    });
	    if (minPxInfo === undefined || maxPxInfo === undefined) {
	        return;
	    }
	    const { offsetPx } = lgv;
	    const minPx = minPxInfo.offsetPx - offsetPx;
	    const maxPx = maxPxInfo.offsetPx - offsetPx;
	    return [minPx, maxPx];
	}
	function getOverlappingEdge(feature, x, minMax) {
	    const [minPx, maxPx] = minMax;
	    // Feature is too small to tell if we're overlapping an edge
	    if (Math.abs(maxPx - minPx) < 8) {
	        return;
	    }
	    if (Math.abs(minPx - x) < 4) {
	        return { feature, edge: 'min' };
	    }
	    if (Math.abs(maxPx - x) < 4) {
	        return { feature, edge: 'max' };
	    }
	    return;
	}

	function expandFeatures(feature, newLocation, edge) {
	    const featureId = feature._id;
	    const oldLocation = feature[edge];
	    const changes = [{ featureId, oldLocation, newLocation }];
	    const { parent } = feature;
	    if (parent &&
	        ((edge === 'min' && parent[edge] > newLocation) ||
	            (edge === 'max' && parent[edge] < newLocation))) {
	        changes.push(...expandFeatures(parent, newLocation, edge));
	    }
	    return changes;
	}
	function shrinkFeatures(feature, newLocation, edge, shrinkParent, childIdToSkip) {
	    const featureId = feature._id;
	    const oldLocation = feature[edge];
	    const changes = [{ featureId, oldLocation, newLocation }];
	    const { parent, children } = feature;
	    if (children) {
	        for (const [, child] of children) {
	            if (child._id === childIdToSkip) {
	                continue;
	            }
	            if ((edge === 'min' && child[edge] < newLocation) ||
	                (edge === 'max' && child[edge] > newLocation)) {
	                changes.push(...shrinkFeatures(child, newLocation, edge, shrinkParent));
	            }
	        }
	    }
	    if (parent && shrinkParent) {
	        const siblings = [];
	        if (parent.children) {
	            for (const [, c] of parent.children) {
	                if (c._id === featureId) {
	                    continue;
	                }
	                siblings.push(c);
	            }
	        }
	        if (siblings.length === 0) {
	            changes.push(...shrinkFeatures(parent, newLocation, edge, shrinkParent, featureId));
	        }
	        else {
	            const oldLocation = parent[edge];
	            const boundedLocation = Math[edge](...siblings.map((s) => s[edge]), newLocation);
	            if (boundedLocation !== oldLocation) {
	                changes.push(...shrinkFeatures(parent, boundedLocation, edge, shrinkParent, featureId));
	            }
	        }
	    }
	    return changes;
	}
	function getPropagatedLocationChanges(feature, newLocation, edge, shrinkParent = false) {
	    const oldLocation = feature[edge];
	    if (newLocation === oldLocation) {
	        throw new Error(`New and existing locations are the same: "${newLocation}"`);
	    }
	    if (edge === 'min') {
	        if (newLocation > oldLocation) {
	            // shrinking feature, may need to shrink children and/or parents
	            return shrinkFeatures(feature, newLocation, edge, shrinkParent);
	        }
	        return expandFeatures(feature, newLocation, edge);
	    }
	    if (newLocation < oldLocation) {
	        return shrinkFeatures(feature, newLocation, edge, shrinkParent);
	    }
	    return expandFeatures(feature, newLocation, edge);
	}

	async function createFetchErrorMessage(response, additionalText) {
	    let errorMessage;
	    try {
	        errorMessage = await response.text();
	    }
	    catch {
	        errorMessage = '';
	    }
	    const responseMessage = `${response.status} ${response.statusText}${errorMessage ? ` (${errorMessage})` : ''}`;
	    return `${additionalText ? `${additionalText} — ` : ''}${responseMessage}`;
	}
	/** given a session, get our ApolloInternetAccount */
	function getApolloInternetAccount(session) {
	    const { internetAccounts } = require$$1$3.getParent(session);
	    return internetAccounts.find((ia) => ia.type === 'ApolloInternetAccount');
	}

	var Info = {};

	var _interopRequireDefault$o = interopRequireDefault.exports;
	Object.defineProperty(Info, "__esModule", {
	  value: true
	});
	var default_1$o = Info["default"] = void 0;
	var _createSvgIcon$o = /*#__PURE__*/_interopRequireDefault$o(createSvgIcon);
	var _jsxRuntime$o = require$$2__default["default"];
	var _default$q = /*#__PURE__*/(0, _createSvgIcon$o["default"])( /*#__PURE__*/(0, _jsxRuntime$o.jsx)("path", {
	  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"
	}), 'Info');
	default_1$o = Info["default"] = _default$q;

	var Link = {};

	var _interopRequireDefault$n = interopRequireDefault.exports;
	Object.defineProperty(Link, "__esModule", {
	  value: true
	});
	var default_1$n = Link["default"] = void 0;
	var _createSvgIcon$n = /*#__PURE__*/_interopRequireDefault$n(createSvgIcon);
	var _jsxRuntime$n = require$$2__default["default"];
	var _default$p = /*#__PURE__*/(0, _createSvgIcon$n["default"])( /*#__PURE__*/(0, _jsxRuntime$n.jsx)("path", {
	  d: "M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"
	}), 'Link');
	default_1$n = Link["default"] = _default$p;

	var RadioButtonChecked = {};

	var _interopRequireDefault$m = interopRequireDefault.exports;
	Object.defineProperty(RadioButtonChecked, "__esModule", {
	  value: true
	});
	var default_1$m = RadioButtonChecked["default"] = void 0;
	var _createSvgIcon$m = /*#__PURE__*/_interopRequireDefault$m(createSvgIcon);
	var _jsxRuntime$m = require$$2__default["default"];
	var _default$o = /*#__PURE__*/(0, _createSvgIcon$m["default"])( /*#__PURE__*/(0, _jsxRuntime$m.jsx)("path", {
	  d: "M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
	}), 'RadioButtonChecked');
	default_1$m = RadioButtonChecked["default"] = _default$o;

	var RadioButtonUnchecked = {};

	var _interopRequireDefault$l = interopRequireDefault.exports;
	Object.defineProperty(RadioButtonUnchecked, "__esModule", {
	  value: true
	});
	var default_1$l = RadioButtonUnchecked["default"] = void 0;
	var _createSvgIcon$l = /*#__PURE__*/_interopRequireDefault$l(createSvgIcon);
	var _jsxRuntime$l = require$$2__default["default"];
	var _default$n = /*#__PURE__*/(0, _createSvgIcon$l["default"])( /*#__PURE__*/(0, _jsxRuntime$l.jsx)("path", {
	  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
	}), 'RadioButtonUnchecked');
	default_1$l = RadioButtonUnchecked["default"] = _default$n;

	var Close = {};

	var _interopRequireDefault$k = interopRequireDefault.exports;
	Object.defineProperty(Close, "__esModule", {
	  value: true
	});
	var default_1$k = Close["default"] = void 0;
	var _createSvgIcon$k = /*#__PURE__*/_interopRequireDefault$k(createSvgIcon);
	var _jsxRuntime$k = require$$2__default["default"];
	var _default$m = /*#__PURE__*/(0, _createSvgIcon$k["default"])( /*#__PURE__*/(0, _jsxRuntime$k.jsx)("path", {
	  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
	}), 'Close');
	default_1$k = Close["default"] = _default$m;

	/* eslint-disable @typescript-eslint/unbound-method */
	const useStyles$g = mui.makeStyles()((theme) => ({
	    dialogTitle: {
	        background: theme.palette.primary.main,
	        color: theme.palette.primary.contrastText,
	        padding: theme.spacing(2),
	    },
	    closeButton: {
	        position: 'absolute',
	        right: theme.spacing(1),
	        top: theme.spacing(1.5),
	        color: theme.palette.primary.contrastText,
	    },
	}));
	const Dialog = mobxReact.observer(function JBrowseDialog(props) {
	    const { classes } = useStyles$g();
	    const { handleClose, title, ...other } = props;
	    return (React__default["default"].createElement(ui.Dialog, { ...other, header: React__default["default"].createElement(React__default["default"].Fragment, null,
	            React__default["default"].createElement(material.DialogTitle, { className: classes.dialogTitle }, title),
	            React__default["default"].createElement(material.IconButton, { "aria-label": "close", onClick: handleClose, className: classes.closeButton },
	                React__default["default"].createElement(default_1$k, null))) }));
	});

	/* eslint-disable @typescript-eslint/unbound-method */
	var FileType;
	(function (FileType) {
	    FileType["GFF3"] = "text/x-gff3";
	    FileType["FASTA"] = "text/x-fasta";
	    FileType["BGZIP_FASTA"] = "application/x-bgzip-fasta";
	    FileType["FAI"] = "text/x-fai";
	    FileType["GZI"] = "application/x-gzi";
	    FileType["EXTERNAL"] = "text/x-external";
	})(FileType || (FileType = {}));
	const useStyles$f = mui.makeStyles()((theme) => ({
	    accordion: {
	        border: `1px solid ${theme.palette.divider}`,
	        '&:not(:last-child)': {
	            borderBottom: 0,
	        },
	    },
	    accordionSummary: {
	        flexDirection: 'row-reverse',
	    },
	    accordionDetails: {
	        padding: theme.spacing(2),
	        borderTop: '1px solid rgba(0, 0, 0, .125)',
	    },
	    radioIcon: {
	        color: theme?.palette?.tertiary?.contrastText,
	    },
	    dialog: {
	        // minHeight: 500,
	        minWidth: 550,
	        maxWidth: 800,
	    },
	}));
	function checkSumbission(validAsm, sequenceIsEditable, fileType, fastaFile, fastaIndexFile, fastaGziIndexFile, validFastaUrl, validFastaIndexUrl, validFastaGziIndexUrl) {
	    if (!validAsm) {
	        return false;
	    }
	    if (sequenceIsEditable && fastaFile) {
	        return true;
	    }
	    if (fileType === FileType.GFF3 && fastaFile) {
	        return true;
	    }
	    if (fastaFile && fastaIndexFile && fastaGziIndexFile) {
	        return true;
	    }
	    if (validFastaUrl && validFastaIndexUrl && validFastaGziIndexUrl) {
	        return true;
	    }
	    return false;
	}
	function AddAssembly({ changeManager, handleClose, session, }) {
	    const { classes } = useStyles$f();
	    const { internetAccounts } = require$$1$3.getRoot(session);
	    const { notify } = session;
	    const apolloInternetAccounts = internetAccounts.filter((ia) => ia.type === 'ApolloInternetAccount');
	    if (apolloInternetAccounts.length === 0) {
	        throw new Error('No Apollo internet account found');
	    }
	    const [assemblyName, setAssemblyName] = React.useState('');
	    const [errorMessage, setErrorMessage] = React.useState('');
	    const [validAsm, setValidAsm] = React.useState(false);
	    const [fileType, setFileType] = React.useState(FileType.BGZIP_FASTA);
	    const [importFeatures, setImportFeatures] = React.useState(true);
	    const [sequenceIsEditable, setSequenceIsEditable] = React.useState(false);
	    const [submitted, setSubmitted] = React.useState(false);
	    const [fastaFile, setFastaFile] = React.useState(null);
	    const [fastaIndexFile, setFastaIndexFile] = React.useState(null);
	    const [fastaGziIndexFile, setFastaGziIndexFile] = React.useState(null);
	    const [fastaUrl, setFastaUrl] = React.useState('');
	    const [fastaIndexUrl, setFastaIndexUrl] = React.useState('');
	    const [fastaGziIndexUrl, setFastaGziIndexUrl] = React.useState('');
	    const [loading, setLoading] = React.useState(false);
	    const [isGzip, setIsGzip] = React.useState(false);
	    React.useEffect(() => {
	        setFastaIndexUrl(fastaUrl ? `${fastaUrl}.fai` : '');
	    }, [fastaUrl]);
	    React.useEffect(() => {
	        setFastaGziIndexUrl(fastaUrl ? `${fastaUrl}.gzi` : '');
	    }, [fastaUrl]);
	    React.useEffect(() => {
	        if (sequenceIsEditable || fileType === FileType.GFF3) {
	            setIsGzip(fastaFile?.name.toLocaleLowerCase().endsWith('.gz') ? true : false);
	        }
	        else {
	            setIsGzip(true);
	        }
	    }, [fastaFile, sequenceIsEditable, fileType]);
	    function checkAssemblyName(assembly) {
	        const { assemblies } = session;
	        const checkAsm = assemblies.find((asm) => configuration.readConfObject(asm, 'displayName') === assembly);
	        if (checkAsm) {
	            setValidAsm(false);
	            setErrorMessage(`Assembly ${assembly} already exists.`);
	        }
	        else {
	            setValidAsm(true);
	            setErrorMessage('');
	        }
	    }
	    async function uploadFile(file, fileType) {
	        const { jobsManager } = session;
	        const controller = new AbortController();
	        const [{ baseURL, getFetcher }] = apolloInternetAccounts;
	        const url = new URL('files', baseURL);
	        url.searchParams.set('type', fileType);
	        const uri = url.href;
	        const formData = new FormData();
	        let filename = file.name;
	        if (fileType === FileType.FAI || fileType === FileType.GZI) {
	            filename = `${filename}.txt`;
	        }
	        else if (isGzip && !file.name.toLocaleLowerCase().endsWith('.gz')) {
	            filename = `${filename}.gz`;
	        }
	        else if (!isGzip && file.name.toLocaleLowerCase().endsWith('.gz')) {
	            filename = `${filename}.txt`;
	        }
	        formData.append('file', file, filename);
	        formData.append('type', fileType);
	        const apolloFetchFile = getFetcher({
	            locationType: 'UriLocation',
	            uri,
	        });
	        if (apolloFetchFile) {
	            const job = {
	                name: `UploadAssemblyFile for ${assemblyName}`,
	                statusMessage: 'Pre-validating',
	                progressPct: 0,
	                cancelCallback: () => {
	                    controller.abort();
	                    jobsManager.abortJob(job.name);
	                },
	            };
	            jobsManager.runJob(job);
	            jobsManager.update(job.name, `Uploading ${file.name}, this may take awhile`);
	            const { signal } = controller;
	            const response = await apolloFetchFile(uri, {
	                method: 'POST',
	                body: formData,
	                signal,
	            });
	            if (!response.ok) {
	                const newErrorMessage = await createFetchErrorMessage(response, 'Error when inserting new assembly (while uploading file)');
	                jobsManager.abortJob(job.name, newErrorMessage);
	                setErrorMessage(newErrorMessage);
	                return '';
	            }
	            const result = await response.json();
	            const fileId = result._id;
	            jobsManager.done(job);
	            return fileId;
	        }
	        throw new Error('Failed to fetch');
	    }
	    async function onSubmit(event) {
	        event.preventDefault();
	        setErrorMessage('');
	        setSubmitted(true);
	        setLoading(true);
	        notify(`Assembly "${assemblyName}" is being added`, 'info');
	        handleClose();
	        event.preventDefault();
	        let change;
	        if (fileType === FileType.EXTERNAL) {
	            change = new dist$2.AddAssemblyFromExternalChange({
	                typeName: 'AddAssemblyFromExternalChange',
	                assembly: new objectid().toHexString(),
	                assemblyName,
	                externalLocation: {
	                    fa: fastaUrl,
	                    fai: fastaIndexUrl,
	                    gzi: fastaGziIndexUrl,
	                },
	            });
	        }
	        else {
	            if (!fastaFile) {
	                throw new Error('Missing fasta file');
	            }
	            if (fileType === FileType.GFF3 && importFeatures) {
	                const faId = await uploadFile(fastaFile, FileType.GFF3);
	                change = new dist$2.AddAssemblyAndFeaturesFromFileChange({
	                    typeName: 'AddAssemblyAndFeaturesFromFileChange',
	                    assembly: new objectid().toHexString(),
	                    assemblyName,
	                    fileIds: { fa: faId },
	                });
	            }
	            else if (fileType === FileType.GFF3) {
	                const faId = await uploadFile(fastaFile, FileType.GFF3);
	                change = new dist$2.AddAssemblyFromFileChange({
	                    typeName: 'AddAssemblyFromFileChange',
	                    assembly: new objectid().toHexString(),
	                    assemblyName,
	                    fileIds: {
	                        fa: faId,
	                    },
	                });
	            }
	            else if (sequenceIsEditable) {
	                const faId = await uploadFile(fastaFile, FileType.FASTA);
	                change = new dist$2.AddAssemblyFromFileChange({
	                    typeName: 'AddAssemblyFromFileChange',
	                    assembly: new objectid().toHexString(),
	                    assemblyName,
	                    fileIds: {
	                        fa: faId,
	                    },
	                });
	            }
	            else {
	                if (!fastaIndexFile || !fastaGziIndexFile) {
	                    throw new Error('Missing fasta index files');
	                }
	                const faId = await uploadFile(fastaFile, FileType.BGZIP_FASTA);
	                const faiId = await uploadFile(fastaIndexFile, FileType.FAI);
	                const gziId = await uploadFile(fastaGziIndexFile, FileType.GZI);
	                change = new dist$2.AddAssemblyFromFileChange({
	                    typeName: 'AddAssemblyFromFileChange',
	                    assembly: new objectid().toHexString(),
	                    assemblyName,
	                    fileIds: {
	                        fa: faId,
	                        fai: faiId,
	                        gzi: gziId,
	                    },
	                });
	            }
	        }
	        const [{ internetAccountId }] = apolloInternetAccounts;
	        await changeManager.submit(change, {
	            internetAccountId,
	            updateJobsManager: true,
	        });
	        setSubmitted(false);
	        setLoading(false);
	    }
	    let validFastaUrl = false;
	    try {
	        const url = new URL(fastaUrl);
	        if (url.protocol === 'http:' || url.protocol === 'https:') {
	            validFastaUrl = true;
	        }
	    }
	    catch {
	        // pass
	    }
	    let validFastaIndexUrl = false;
	    try {
	        const url = new URL(fastaIndexUrl);
	        if (url.protocol === 'http:' || url.protocol === 'https:') {
	            validFastaIndexUrl = true;
	        }
	    }
	    catch {
	        // pass
	    }
	    let validFastaGziIndexUrl = false;
	    try {
	        const url = new URL(fastaGziIndexUrl);
	        if (url.protocol === 'http:' || url.protocol === 'https:') {
	            validFastaGziIndexUrl = true;
	        }
	    }
	    catch {
	        // pass
	    }
	    const [expanded, setExpanded] = React__default["default"].useState('panelFastaInput');
	    const handleAccordionChange = (panel) => (event, newExpanded) => {
	        if (newExpanded) {
	            setExpanded(panel);
	        }
	        if (panel === 'panelGffInput') {
	            setIsGzip(false);
	        }
	        else {
	            setIsGzip(true);
	        }
	    };
	    return (React__default["default"].createElement(Dialog, { open: true, handleClose: handleClose, "data-testid": "add-assembly-dialog", title: "Add new assembly", maxWidth: false },
	        React__default["default"].createElement("form", { onSubmit: onSubmit, "data-testid": "submit-form" },
	            React__default["default"].createElement(material.DialogContent, { className: classes.dialog },
	                loading ? React__default["default"].createElement(material.LinearProgress, null) : null,
	                React__default["default"].createElement(material.TextField, { margin: "dense", id: "name", label: "Assembly name", type: "TextField", fullWidth: true, variant: "outlined", onChange: (e) => {
	                        setSubmitted(false);
	                        setAssemblyName(e.target.value);
	                        checkAssemblyName(e.target.value);
	                    }, disabled: submitted && !errorMessage }),
	                React__default["default"].createElement(material.Accordion, { disableGutters: true, elevation: 0, square: true, className: classes.accordion, expanded: expanded === 'panelFastaInput', onChange: handleAccordionChange('panelFastaInput') },
	                    React__default["default"].createElement(material.AccordionSummary, { className: classes.accordionSummary, expandIcon: expanded === 'panelFastaInput' ? (React__default["default"].createElement(default_1$m, { className: classes.radioIcon, sx: { fontSize: '1.2rem', ml: 5 } })) : (React__default["default"].createElement(default_1$l, { className: classes.radioIcon, sx: { fontSize: '1.2rem', mr: 5 } })), "aria-controls": "panelFastaInputd-content", id: "panelFastaInputd-header" },
	                        React__default["default"].createElement(material.Typography, { component: "span" }, "FASTA input")),
	                    React__default["default"].createElement(material.AccordionDetails, { className: classes.accordionDetails },
	                        React__default["default"].createElement(material.FormGroup, null,
	                            React__default["default"].createElement(material.FormControlLabel, { "data-testid": "files-on-url-checkbox", control: React__default["default"].createElement(material.Checkbox, { onChange: () => {
	                                        setFileType(fileType === FileType.EXTERNAL
	                                            ? FileType.BGZIP_FASTA
	                                            : FileType.EXTERNAL);
	                                        if (fileType === FileType.EXTERNAL) {
	                                            setSequenceIsEditable(false);
	                                        }
	                                    }, checked: fileType === FileType.EXTERNAL, disabled: sequenceIsEditable && fileType !== FileType.GFF3 }), label: React__default["default"].createElement(material.Box, { display: "flex", alignItems: "center" },
	                                    "Use external URLs",
	                                    React__default["default"].createElement(material.Tooltip, { title: "Use external URLs to provide FASTA and index files. Does not copy the files to the Apollo collaboration server, so ensure the URLs are stable.", placement: "top-start" },
	                                        React__default["default"].createElement(material.IconButton, { size: "small" },
	                                            React__default["default"].createElement(default_1$o, { sx: { fontSize: 18 } })))) }),
	                            React__default["default"].createElement(material.FormControlLabel, { "data-testid": "sequence-is-editable-checkbox", control: React__default["default"].createElement(material.Checkbox, { onChange: () => {
	                                        setSequenceIsEditable(!sequenceIsEditable);
	                                    } }), checked: sequenceIsEditable, disabled: fileType === FileType.EXTERNAL, label: React__default["default"].createElement(material.Box, { display: "flex", alignItems: "center" },
	                                    "Store sequence in database",
	                                    React__default["default"].createElement(material.Tooltip, { title: "Enables users to edit the genomic sequence, but comes with performance impacts. Use with care.", placement: "top-start" },
	                                        React__default["default"].createElement(material.IconButton, { size: "small" },
	                                            React__default["default"].createElement(default_1$o, { sx: { fontSize: 18 } })))) }),
	                            React__default["default"].createElement(material.FormControlLabel, { "data-testid": "fasta-is-gzip-checkbox", control: React__default["default"].createElement(material.Checkbox, { checked: isGzip, onChange: () => {
	                                        if (sequenceIsEditable) {
	                                            setIsGzip(!isGzip);
	                                        }
	                                        else {
	                                            setIsGzip(true);
	                                        }
	                                    }, disabled: !sequenceIsEditable }), label: "FASTA is gzip compressed" }),
	                            fileType === FileType.BGZIP_FASTA ||
	                                fileType === FileType.GFF3 ? (React__default["default"].createElement(material.Table, { size: "small", sx: { mt: 2 } },
	                                React__default["default"].createElement(material.TableBody, null,
	                                    React__default["default"].createElement(material.TableRow, null,
	                                        React__default["default"].createElement(material.TableCell, { style: { borderBottomWidth: 0 } },
	                                            React__default["default"].createElement(material.Box, { display: "flex", alignItems: "center" },
	                                                React__default["default"].createElement("span", null, "FASTA"),
	                                                React__default["default"].createElement(material.Tooltip, { title: 'Unless "Store sequence in database" enabled, FASTA input must be compressed with bgzip and indexed with samtools faidx (or equivalent). Compression is optional for sequences stored in the database.' },
	                                                    React__default["default"].createElement(material.IconButton, { size: "small" },
	                                                        React__default["default"].createElement(default_1$o, { sx: { fontSize: 18 } }))))),
	                                        React__default["default"].createElement(material.TableCell, { style: { borderBottomWidth: 0 } },
	                                            React__default["default"].createElement("input", { "data-testid": "fasta-input-file", type: "file", onChange: (e) => {
	                                                    setFastaFile(e.target.files?.item(0) ?? null);
	                                                }, disabled: submitted && !errorMessage }))),
	                                    React__default["default"].createElement(material.TableRow, null,
	                                        React__default["default"].createElement(material.TableCell, { style: { borderBottomWidth: 0 } }, "FASTA index (.fai)"),
	                                        React__default["default"].createElement(material.TableCell, { style: { borderBottomWidth: 0 } },
	                                            React__default["default"].createElement("input", { "data-testid": "fai-input-file", type: "file", onChange: (e) => {
	                                                    setFastaIndexFile(e.target.files?.item(0) ?? null);
	                                                }, disabled: (submitted && !errorMessage) || sequenceIsEditable }))),
	                                    React__default["default"].createElement(material.TableRow, null,
	                                        React__default["default"].createElement(material.TableCell, { style: { borderBottomWidth: 0 } }, "FASTA binary index (.gzi)"),
	                                        React__default["default"].createElement(material.TableCell, { style: { borderBottomWidth: 0 } },
	                                            React__default["default"].createElement("input", { "data-testid": "gzi-input-file", type: "file", onChange: (e) => {
	                                                    setFastaGziIndexFile(e.target.files?.item(0) ?? null);
	                                                }, disabled: (submitted && !errorMessage) || sequenceIsEditable })))))) : (React__default["default"].createElement(material.Table, { size: "small", sx: { mt: 2 } },
	                                React__default["default"].createElement(material.TableBody, null,
	                                    React__default["default"].createElement(material.TableRow, null,
	                                        React__default["default"].createElement(material.TableCell, { style: { borderBottomWidth: 0 } },
	                                            React__default["default"].createElement(material.Box, { display: "flex", alignItems: "center" },
	                                                React__default["default"].createElement("span", null, "FASTA"),
	                                                React__default["default"].createElement(material.Tooltip, { title: "Remote FASTA input must be compressed with bgzip and indexed with samtools faidx (or equivalent)" },
	                                                    React__default["default"].createElement(material.IconButton, { size: "small" },
	                                                        React__default["default"].createElement(default_1$o, { sx: { fontSize: 18 } }))))),
	                                        React__default["default"].createElement(material.TableCell, { style: { borderBottomWidth: 0 } },
	                                            React__default["default"].createElement(material.TextField, { "data-testid": "fasta-input-url", variant: "outlined", value: fastaUrl, error: !validFastaUrl, onChange: (e) => {
	                                                    setFastaUrl(e.target.value);
	                                                }, disabled: submitted && !errorMessage, slotProps: {
	                                                    input: {
	                                                        startAdornment: (React__default["default"].createElement(material.InputAdornment, { position: "start" },
	                                                            React__default["default"].createElement(default_1$n, null))),
	                                                    },
	                                                } }))),
	                                    React__default["default"].createElement(material.TableRow, null,
	                                        React__default["default"].createElement(material.TableCell, { style: { borderBottomWidth: 0 } }, "FASTA index (.fai)"),
	                                        React__default["default"].createElement(material.TableCell, { style: { borderBottomWidth: 0 } },
	                                            React__default["default"].createElement(material.TextField, { "data-testid": "fai-input-url", variant: "outlined", value: fastaIndexUrl, error: !validFastaIndexUrl, onChange: (e) => {
	                                                    setFastaIndexUrl(e.target.value);
	                                                }, disabled: submitted && !errorMessage, slotProps: {
	                                                    input: {
	                                                        startAdornment: (React__default["default"].createElement(material.InputAdornment, { position: "start" },
	                                                            React__default["default"].createElement(default_1$n, null))),
	                                                    },
	                                                } }))),
	                                    React__default["default"].createElement(material.TableRow, null,
	                                        React__default["default"].createElement(material.TableCell, { style: { borderBottomWidth: 0 } }, "FASTA binary index (.gzi)"),
	                                        React__default["default"].createElement(material.TableCell, { style: { borderBottomWidth: 0 } },
	                                            React__default["default"].createElement(material.TextField, { "data-testid": "gzi-input-url", variant: "outlined", value: fastaGziIndexUrl, error: !validFastaGziIndexUrl, onChange: (e) => {
	                                                    setFastaGziIndexUrl(e.target.value);
	                                                }, disabled: submitted && !errorMessage, slotProps: {
	                                                    input: {
	                                                        startAdornment: (React__default["default"].createElement(material.InputAdornment, { position: "start" },
	                                                            React__default["default"].createElement(default_1$n, null))),
	                                                    },
	                                                } }))))))))),
	                React__default["default"].createElement(material.Accordion, { disableGutters: true, elevation: 0, square: true, className: classes.accordion, expanded: expanded === 'panelGffInput', onChange: handleAccordionChange('panelGffInput') },
	                    React__default["default"].createElement(material.AccordionSummary, { className: classes.accordionSummary, expandIcon: expanded === 'panelGffInput' ? (React__default["default"].createElement(default_1$m, { className: classes.radioIcon, sx: { fontSize: '1.2rem', ml: 5 } })) : (React__default["default"].createElement(default_1$l, { className: classes.radioIcon, sx: { fontSize: '1.2rem', mr: 5 } })), "aria-controls": "panelGffInputd-content" },
	                        React__default["default"].createElement(material.Typography, { component: "span" },
	                            "GFF3 input",
	                            React__default["default"].createElement(material.Tooltip, { title: "GFF3 must includes FASTA sequences. File can be gzip compressed." },
	                                React__default["default"].createElement(default_1$o, { className: classes.radioIcon, sx: { fontSize: 18 } })))),
	                    React__default["default"].createElement(material.AccordionDetails, { className: classes.accordionDetails },
	                        React__default["default"].createElement(material.Box, { style: { marginTop: 20 } },
	                            React__default["default"].createElement("input", { "data-testid": "gff3-input-file", type: "file", disabled: submitted && !errorMessage, onChange: (e) => {
	                                    setFastaFile(e.target.files?.item(0) ?? null);
	                                    setFileType(FileType.GFF3);
	                                } }),
	                            React__default["default"].createElement(material.FormGroup, { style: { display: 'grid' } },
	                                React__default["default"].createElement(material.FormControlLabel, { control: React__default["default"].createElement(material.Checkbox, { checked: importFeatures, onChange: () => {
	                                            setImportFeatures(!importFeatures);
	                                        }, disabled: submitted && !errorMessage }), label: "Load features from GFF3 file" }),
	                                React__default["default"].createElement(material.FormControlLabel, { "data-testid": "gff3-is-gzip-checkbox", control: React__default["default"].createElement(material.Checkbox, { checked: isGzip, onChange: () => {
	                                            setIsGzip(!isGzip);
	                                        }, disabled: submitted && !errorMessage }), label: "GFF3 is gzip compressed" })))))),
	            React__default["default"].createElement(material.DialogActions, null,
	                React__default["default"].createElement(material.Button, { disabled: !checkSumbission(validAsm, sequenceIsEditable, fileType, fastaFile, fastaIndexFile, fastaGziIndexFile, validFastaUrl, validFastaIndexUrl, validFastaGziIndexUrl) || submitted, variant: "contained", type: "submit", "data-testid": "submit-button" }, submitted ? 'Submitting...' : 'Submit'),
	                React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: handleClose }, "Cancel"))),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	var instanceOfAny = function instanceOfAny(object, constructors) {
	  return constructors.some(function (c) {
	    return object instanceof c;
	  });
	};
	var idbProxyableTypes;
	var cursorAdvanceMethods;
	// This is a function to prevent it throwing up in node environments.
	function getIdbProxyableTypes() {
	  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);
	}
	// This is a function to prevent it throwing up in node environments.
	function getCursorAdvanceMethods() {
	  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype["continue"], IDBCursor.prototype.continuePrimaryKey]);
	}
	var cursorRequestMap = /*#__PURE__*/new WeakMap();
	var transactionDoneMap = /*#__PURE__*/new WeakMap();
	var transactionStoreNamesMap = /*#__PURE__*/new WeakMap();
	var transformCache = /*#__PURE__*/new WeakMap();
	var reverseTransformCache = /*#__PURE__*/new WeakMap();
	function promisifyRequest(request) {
	  var promise = new Promise(function (resolve, reject) {
	    var unlisten = function unlisten() {
	      request.removeEventListener('success', success);
	      request.removeEventListener('error', error);
	    };
	    var success = function success() {
	      resolve(wrap(request.result));
	      unlisten();
	    };
	    var error = function error() {
	      reject(request.error);
	      unlisten();
	    };
	    request.addEventListener('success', success);
	    request.addEventListener('error', error);
	  });
	  promise.then(function (value) {
	    // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval
	    // (see wrapFunction).
	    if (value instanceof IDBCursor) {
	      cursorRequestMap.set(value, request);
	    }
	    // Catching to avoid "Uncaught Promise exceptions"
	  })["catch"](function () {});
	  // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This
	  // is because we create many promises from a single IDBRequest.
	  reverseTransformCache.set(promise, request);
	  return promise;
	}
	function cacheDonePromiseForTransaction(tx) {
	  // Early bail if we've already created a done promise for this transaction.
	  if (transactionDoneMap.has(tx)) return;
	  var done = new Promise(function (resolve, reject) {
	    var unlisten = function unlisten() {
	      tx.removeEventListener('complete', complete);
	      tx.removeEventListener('error', error);
	      tx.removeEventListener('abort', error);
	    };
	    var complete = function complete() {
	      resolve();
	      unlisten();
	    };
	    var error = function error() {
	      reject(tx.error || new DOMException('AbortError', 'AbortError'));
	      unlisten();
	    };
	    tx.addEventListener('complete', complete);
	    tx.addEventListener('error', error);
	    tx.addEventListener('abort', error);
	  });
	  // Cache it for later retrieval.
	  transactionDoneMap.set(tx, done);
	}
	var idbProxyTraps = {
	  get: function get(target, prop, receiver) {
	    if (target instanceof IDBTransaction) {
	      // Special handling for transaction.done.
	      if (prop === 'done') return transactionDoneMap.get(target);
	      // Polyfill for objectStoreNames because of Edge.
	      if (prop === 'objectStoreNames') {
	        return target.objectStoreNames || transactionStoreNamesMap.get(target);
	      }
	      // Make tx.store return the only store in the transaction, or undefined if there are many.
	      if (prop === 'store') {
	        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);
	      }
	    }
	    // Else transform whatever we get back.
	    return wrap(target[prop]);
	  },
	  set: function set(target, prop, value) {
	    target[prop] = value;
	    return true;
	  },
	  has: function has(target, prop) {
	    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {
	      return true;
	    }
	    return prop in target;
	  }
	};
	function replaceTraps(callback) {
	  idbProxyTraps = callback(idbProxyTraps);
	}
	function wrapFunction(func) {
	  // Due to expected object equality (which is enforced by the caching in `wrap`), we
	  // only create one new func per func.
	  // Edge doesn't support objectStoreNames (booo), so we polyfill it here.
	  if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {
	    return function (storeNames) {
	      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	      var tx = func.call.apply(func, [unwrap(this), storeNames].concat(args));
	      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
	      return wrap(tx);
	    };
	  }
	  // Cursor methods are special, as the behaviour is a little more different to standard IDB. In
	  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the
	  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense
	  // with real promises, so each advance methods returns a new promise for the cursor object, or
	  // undefined if the end of the cursor has been reached.
	  if (getCursorAdvanceMethods().includes(func)) {
	    return function () {
	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }
	      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
	      // the original object.
	      func.apply(unwrap(this), args);
	      return wrap(cursorRequestMap.get(this));
	    };
	  }
	  return function () {
	    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	      args[_key3] = arguments[_key3];
	    }
	    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
	    // the original object.
	    return wrap(func.apply(unwrap(this), args));
	  };
	}
	function transformCachableValue(value) {
	  if (typeof value === 'function') return wrapFunction(value);
	  // This doesn't return, it just creates a 'done' promise for the transaction,
	  // which is later returned for transaction.done (see idbObjectHandler).
	  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);
	  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);
	  // Return the same value back if we're not going to transform it.
	  return value;
	}
	function wrap(value) {
	  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because
	  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.
	  if (value instanceof IDBRequest) return promisifyRequest(value);
	  // If we've already transformed this value before, reuse the transformed value.
	  // This is faster, but it also provides object equality.
	  if (transformCache.has(value)) return transformCache.get(value);
	  var newValue = transformCachableValue(value);
	  // Not all types are transformed.
	  // These may be primitive types, so they can't be WeakMap keys.
	  if (newValue !== value) {
	    transformCache.set(value, newValue);
	    reverseTransformCache.set(newValue, value);
	  }
	  return newValue;
	}
	var unwrap = function unwrap(value) {
	  return reverseTransformCache.get(value);
	};

	/**
	 * Open a database.
	 *
	 * @param name Name of the database.
	 * @param version Schema version.
	 * @param callbacks Additional callbacks.
	 */
	function openDB(name, version) {
	  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
	    blocked = _ref.blocked,
	    upgrade = _ref.upgrade,
	    blocking = _ref.blocking,
	    terminated = _ref.terminated;
	  var request = indexedDB.open(name, version);
	  var openPromise = wrap(request);
	  if (upgrade) {
	    request.addEventListener('upgradeneeded', function (event) {
	      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
	    });
	  }
	  if (blocked) {
	    request.addEventListener('blocked', function (event) {
	      return blocked(
	      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
	      event.oldVersion, event.newVersion, event);
	    });
	  }
	  openPromise.then(function (db) {
	    if (terminated) db.addEventListener('close', function () {
	      return terminated();
	    });
	    if (blocking) {
	      db.addEventListener('versionchange', function (event) {
	        return blocking(event.oldVersion, event.newVersion, event);
	      });
	    }
	  })["catch"](function () {});
	  return openPromise;
	}
	/**
	 * Delete a database.
	 *
	 * @param name Name of the database.
	 */
	function deleteDB(name) {
	  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    blocked = _ref2.blocked;
	  var request = indexedDB.deleteDatabase(name);
	  if (blocked) {
	    request.addEventListener('blocked', function (event) {
	      return blocked(
	      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
	      event.oldVersion, event);
	    });
	  }
	  return wrap(request).then(function () {
	    return undefined;
	  });
	}
	var readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];
	var writeMethods = ['put', 'add', 'delete', 'clear'];
	var cachedMethods = /*#__PURE__*/new Map();
	function getMethod(target, prop) {
	  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {
	    return;
	  }
	  if (cachedMethods.get(prop)) return cachedMethods.get(prop);
	  var targetFuncName = prop.replace(/FromIndex$/, '');
	  var useIndex = prop !== targetFuncName;
	  var isWrite = writeMethods.includes(targetFuncName);
	  if (
	  // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
	  !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {
	    return;
	  }
	  var method = /*#__PURE__*/function () {
	    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(storeName) {
	      var _target;
	      var tx,
	        target,
	        _len,
	        args,
	        _key,
	        _args = arguments;
	      return _regeneratorRuntime().wrap(function _callee$(_context) {
	        while (1) switch (_context.prev = _context.next) {
	          case 0:
	            // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(
	            tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
	            target = tx.store;
	            for (_len = _args.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	              args[_key - 1] = _args[_key];
	            }
	            if (useIndex) target = target.index(args.shift());
	            // Must reject if op rejects.
	            // If it's a write operation, must reject if tx.done rejects.
	            // Must reject with op rejection first.
	            // Must resolve with op value.
	            // Must handle both promises (no unhandled rejections)
	            _context.next = 6;
	            return Promise.all([(_target = target)[targetFuncName].apply(_target, args), isWrite && tx.done]);
	          case 6:
	            return _context.abrupt("return", _context.sent[0]);
	          case 7:
	          case "end":
	            return _context.stop();
	        }
	      }, _callee, this);
	    }));
	    return function method(_x) {
	      return _ref3.apply(this, arguments);
	    };
	  }();
	  cachedMethods.set(prop, method);
	  return method;
	}
	replaceTraps(function (oldTraps) {
	  return _objectSpread2(_objectSpread2({}, oldTraps), {}, {
	    get: function get(target, prop, receiver) {
	      return getMethod(target, prop) || oldTraps.get(target, prop, receiver);
	    },
	    has: function has(target, prop) {
	      return !!getMethod(target, prop) || oldTraps.has(target, prop);
	    }
	  });
	});

	var advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];
	var methodMap = {};
	var advanceResults = /*#__PURE__*/new WeakMap();
	var ittrProxiedCursorToOriginalProxy = /*#__PURE__*/new WeakMap();
	var cursorIteratorTraps = {
	  get: function get(target, prop) {
	    if (!advanceMethodProps.includes(prop)) return target[prop];
	    var cachedFunc = methodMap[prop];
	    if (!cachedFunc) {
	      cachedFunc = methodMap[prop] = function () {
	        var _ittrProxiedCursorToO;
	        advanceResults.set(this, (_ittrProxiedCursorToO = ittrProxiedCursorToOriginalProxy.get(this))[prop].apply(_ittrProxiedCursorToO, arguments));
	      };
	    }
	    return cachedFunc;
	  }
	};
	function iterate() {
	  return _iterate.apply(this, arguments);
	}
	function _iterate() {
	  _iterate = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
	    var cursor,
	      _cursor,
	      proxiedCursor,
	      _args = arguments;
	    return _regeneratorRuntime().wrap(function _callee$(_context) {
	      while (1) switch (_context.prev = _context.next) {
	        case 0:
	          // tslint:disable-next-line:no-this-assignment
	          cursor = this;
	          if (cursor instanceof IDBCursor) {
	            _context.next = 5;
	            break;
	          }
	          _context.next = 4;
	          return _awaitAsyncGenerator((_cursor = cursor).openCursor.apply(_cursor, _args));
	        case 4:
	          cursor = _context.sent;
	        case 5:
	          if (cursor) {
	            _context.next = 7;
	            break;
	          }
	          return _context.abrupt("return");
	        case 7:
	          cursor = cursor;
	          proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
	          ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
	          // Map this double-proxy back to the original, so other cursor methods work.
	          reverseTransformCache.set(proxiedCursor, unwrap(cursor));
	        case 11:
	          if (!cursor) {
	            _context.next = 20;
	            break;
	          }
	          _context.next = 14;
	          return proxiedCursor;
	        case 14:
	          _context.next = 16;
	          return _awaitAsyncGenerator(advanceResults.get(proxiedCursor) || cursor["continue"]());
	        case 16:
	          cursor = _context.sent;
	          advanceResults["delete"](proxiedCursor);
	          _context.next = 11;
	          break;
	        case 20:
	        case "end":
	          return _context.stop();
	      }
	    }, _callee, this);
	  }));
	  return _iterate.apply(this, arguments);
	}
	function isIteratorProp(target, prop) {
	  return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore]);
	}
	replaceTraps(function (oldTraps) {
	  return _objectSpread2(_objectSpread2({}, oldTraps), {}, {
	    get: function get(target, prop, receiver) {
	      if (isIteratorProp(target, prop)) return iterate;
	      return oldTraps.get(target, prop, receiver);
	    },
	    has: function has(target, prop) {
	      return isIteratorProp(target, prop) || oldTraps.has(target, prop);
	    }
	  });
	});

	var aborting = {};

	var cjs = {};

	var Observable$1 = {};

	var Subscriber = {};

	var isFunction$1 = {};

	Object.defineProperty(isFunction$1, "__esModule", {
	  value: true
	});
	isFunction$1.isFunction = void 0;
	function isFunction(value) {
	  return typeof value === 'function';
	}
	isFunction$1.isFunction = isFunction;

	var Subscription$1 = {};

	var UnsubscriptionError = {};

	var createErrorClass$1 = {};

	Object.defineProperty(createErrorClass$1, "__esModule", {
	  value: true
	});
	createErrorClass$1.createErrorClass = void 0;
	function createErrorClass(createImpl) {
	  var _super = function _super(instance) {
	    Error.call(instance);
	    instance.stack = new Error().stack;
	  };
	  var ctorFunc = createImpl(_super);
	  ctorFunc.prototype = Object.create(Error.prototype);
	  ctorFunc.prototype.constructor = ctorFunc;
	  return ctorFunc;
	}
	createErrorClass$1.createErrorClass = createErrorClass;

	Object.defineProperty(UnsubscriptionError, "__esModule", {
	  value: true
	});
	UnsubscriptionError.UnsubscriptionError = void 0;
	var createErrorClass_1$5 = createErrorClass$1;
	UnsubscriptionError.UnsubscriptionError = /*#__PURE__*/createErrorClass_1$5.createErrorClass(function (_super) {
	  return function UnsubscriptionErrorImpl(errors) {
	    _super(this);
	    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) {
	      return i + 1 + ") " + err.toString();
	    }).join('\n  ') : '';
	    this.name = 'UnsubscriptionError';
	    this.errors = errors;
	  };
	});

	var arrRemove$1 = {};

	Object.defineProperty(arrRemove$1, "__esModule", {
	  value: true
	});
	arrRemove$1.arrRemove = void 0;
	function arrRemove(arr, item) {
	  if (arr) {
	    var index = arr.indexOf(item);
	    0 <= index && arr.splice(index, 1);
	  }
	}
	arrRemove$1.arrRemove = arrRemove;

	var __values$8 = commonjsGlobal && commonjsGlobal.__values || function (o) {
	  var s = typeof Symbol === "function" && Symbol.iterator,
	    m = s && o[s],
	    i = 0;
	  if (m) return m.call(o);
	  if (o && typeof o.length === "number") return {
	    next: function next() {
	      if (o && i >= o.length) o = void 0;
	      return {
	        value: o && o[i++],
	        done: !o
	      };
	    }
	  };
	  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var __read$h = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	var __spreadArray$g = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	  return to;
	};
	Object.defineProperty(Subscription$1, "__esModule", {
	  value: true
	});
	Subscription$1.isSubscription = Subscription$1.EMPTY_SUBSCRIPTION = Subscription$1.Subscription = void 0;
	var isFunction_1$p = isFunction$1;
	var UnsubscriptionError_1 = UnsubscriptionError;
	var arrRemove_1$7 = arrRemove$1;
	var Subscription = /*#__PURE__*/function () {
	  function Subscription(initialTeardown) {
	    this.initialTeardown = initialTeardown;
	    this.closed = false;
	    this._parentage = null;
	    this._finalizers = null;
	  }
	  Subscription.prototype.unsubscribe = function () {
	    var e_1, _a, e_2, _b;
	    var errors;
	    if (!this.closed) {
	      this.closed = true;
	      var _parentage = this._parentage;
	      if (_parentage) {
	        this._parentage = null;
	        if (Array.isArray(_parentage)) {
	          try {
	            for (var _parentage_1 = __values$8(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
	              var parent_1 = _parentage_1_1.value;
	              parent_1.remove(this);
	            }
	          } catch (e_1_1) {
	            e_1 = {
	              error: e_1_1
	            };
	          } finally {
	            try {
	              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1["return"])) _a.call(_parentage_1);
	            } finally {
	              if (e_1) throw e_1.error;
	            }
	          }
	        } else {
	          _parentage.remove(this);
	        }
	      }
	      var initialFinalizer = this.initialTeardown;
	      if (isFunction_1$p.isFunction(initialFinalizer)) {
	        try {
	          initialFinalizer();
	        } catch (e) {
	          errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
	        }
	      }
	      var _finalizers = this._finalizers;
	      if (_finalizers) {
	        this._finalizers = null;
	        try {
	          for (var _finalizers_1 = __values$8(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
	            var finalizer = _finalizers_1_1.value;
	            try {
	              execFinalizer(finalizer);
	            } catch (err) {
	              errors = errors !== null && errors !== void 0 ? errors : [];
	              if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                errors = __spreadArray$g(__spreadArray$g([], __read$h(errors)), __read$h(err.errors));
	              } else {
	                errors.push(err);
	              }
	            }
	          }
	        } catch (e_2_1) {
	          e_2 = {
	            error: e_2_1
	          };
	        } finally {
	          try {
	            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1["return"])) _b.call(_finalizers_1);
	          } finally {
	            if (e_2) throw e_2.error;
	          }
	        }
	      }
	      if (errors) {
	        throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	      }
	    }
	  };
	  Subscription.prototype.add = function (teardown) {
	    var _a;
	    if (teardown && teardown !== this) {
	      if (this.closed) {
	        execFinalizer(teardown);
	      } else {
	        if (teardown instanceof Subscription) {
	          if (teardown.closed || teardown._hasParent(this)) {
	            return;
	          }
	          teardown._addParent(this);
	        }
	        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
	      }
	    }
	  };
	  Subscription.prototype._hasParent = function (parent) {
	    var _parentage = this._parentage;
	    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
	  };
	  Subscription.prototype._addParent = function (parent) {
	    var _parentage = this._parentage;
	    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
	  };
	  Subscription.prototype._removeParent = function (parent) {
	    var _parentage = this._parentage;
	    if (_parentage === parent) {
	      this._parentage = null;
	    } else if (Array.isArray(_parentage)) {
	      arrRemove_1$7.arrRemove(_parentage, parent);
	    }
	  };
	  Subscription.prototype.remove = function (teardown) {
	    var _finalizers = this._finalizers;
	    _finalizers && arrRemove_1$7.arrRemove(_finalizers, teardown);
	    if (teardown instanceof Subscription) {
	      teardown._removeParent(this);
	    }
	  };
	  Subscription.EMPTY = /*#__PURE__*/function () {
	    var empty = /*#__PURE__*/new Subscription();
	    empty.closed = true;
	    return empty;
	  }();
	  return Subscription;
	}();
	Subscription$1.Subscription = Subscription;
	Subscription$1.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
	function isSubscription(value) {
	  return value instanceof Subscription || value && 'closed' in value && isFunction_1$p.isFunction(value.remove) && isFunction_1$p.isFunction(value.add) && isFunction_1$p.isFunction(value.unsubscribe);
	}
	Subscription$1.isSubscription = isSubscription;
	function execFinalizer(finalizer) {
	  if (isFunction_1$p.isFunction(finalizer)) {
	    finalizer();
	  } else {
	    finalizer.unsubscribe();
	  }
	}

	var config = {};

	Object.defineProperty(config, "__esModule", {
	  value: true
	});
	config.config = void 0;
	config.config = {
	  onUnhandledError: null,
	  onStoppedNotification: null,
	  Promise: undefined,
	  useDeprecatedSynchronousErrorHandling: false,
	  useDeprecatedNextContext: false
	};

	var reportUnhandledError$1 = {};

	var timeoutProvider = {};

	(function (exports) {

	  var __read = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o),
	      r,
	      ar = [],
	      e;
	    try {
	      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    } catch (error) {
	      e = {
	        error: error
	      };
	    } finally {
	      try {
	        if (r && !r.done && (m = i["return"])) m.call(i);
	      } finally {
	        if (e) throw e.error;
	      }
	    }
	    return ar;
	  };
	  var __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	    return to;
	  };
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.timeoutProvider = void 0;
	  exports.timeoutProvider = {
	    setTimeout: /*#__PURE__*/function (_setTimeout) {
	      function setTimeout(_x, _x2) {
	        return _setTimeout.apply(this, arguments);
	      }
	      setTimeout.toString = function () {
	        return _setTimeout.toString();
	      };
	      return setTimeout;
	    }(function (handler, timeout) {
	      var args = [];
	      for (var _i = 2; _i < arguments.length; _i++) {
	        args[_i - 2] = arguments[_i];
	      }
	      var delegate = exports.timeoutProvider.delegate;
	      if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
	        return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
	      }
	      return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
	    }),
	    clearTimeout: /*#__PURE__*/function (_clearTimeout) {
	      function clearTimeout(_x3) {
	        return _clearTimeout.apply(this, arguments);
	      }
	      clearTimeout.toString = function () {
	        return _clearTimeout.toString();
	      };
	      return clearTimeout;
	    }(function (handle) {
	      var delegate = exports.timeoutProvider.delegate;
	      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
	    }),
	    delegate: undefined
	  };
	})(timeoutProvider);

	Object.defineProperty(reportUnhandledError$1, "__esModule", {
	  value: true
	});
	reportUnhandledError$1.reportUnhandledError = void 0;
	var config_1$2 = config;
	var timeoutProvider_1 = timeoutProvider;
	function reportUnhandledError(err) {
	  timeoutProvider_1.timeoutProvider.setTimeout(function () {
	    var onUnhandledError = config_1$2.config.onUnhandledError;
	    if (onUnhandledError) {
	      onUnhandledError(err);
	    } else {
	      throw err;
	    }
	  });
	}
	reportUnhandledError$1.reportUnhandledError = reportUnhandledError;

	var noop$1 = {};

	Object.defineProperty(noop$1, "__esModule", {
	  value: true
	});
	noop$1.noop = void 0;
	function noop() {}
	noop$1.noop = noop;

	var NotificationFactories = {};

	Object.defineProperty(NotificationFactories, "__esModule", {
	  value: true
	});
	NotificationFactories.createNotification = NotificationFactories.nextNotification = NotificationFactories.errorNotification = NotificationFactories.COMPLETE_NOTIFICATION = void 0;
	NotificationFactories.COMPLETE_NOTIFICATION = /*#__PURE__*/function () {
	  return createNotification('C', undefined, undefined);
	}();
	function errorNotification(error) {
	  return createNotification('E', undefined, error);
	}
	NotificationFactories.errorNotification = errorNotification;
	function nextNotification(value) {
	  return createNotification('N', value, undefined);
	}
	NotificationFactories.nextNotification = nextNotification;
	function createNotification(kind, value, error) {
	  return {
	    kind: kind,
	    value: value,
	    error: error
	  };
	}
	NotificationFactories.createNotification = createNotification;

	var errorContext$1 = {};

	Object.defineProperty(errorContext$1, "__esModule", {
	  value: true
	});
	errorContext$1.captureError = errorContext$1.errorContext = void 0;
	var config_1$1 = config;
	var context = null;
	function errorContext(cb) {
	  if (config_1$1.config.useDeprecatedSynchronousErrorHandling) {
	    var isRoot = !context;
	    if (isRoot) {
	      context = {
	        errorThrown: false,
	        error: null
	      };
	    }
	    cb();
	    if (isRoot) {
	      var _a = context,
	        errorThrown = _a.errorThrown,
	        error = _a.error;
	      context = null;
	      if (errorThrown) {
	        throw error;
	      }
	    }
	  } else {
	    cb();
	  }
	}
	errorContext$1.errorContext = errorContext;
	function captureError(err) {
	  if (config_1$1.config.useDeprecatedSynchronousErrorHandling && context) {
	    context.errorThrown = true;
	    context.error = err;
	  }
	}
	errorContext$1.captureError = captureError;

	(function (exports) {

	  var __extends = commonjsGlobal && commonjsGlobal.__extends || /*#__PURE__*/function () {
	    var _extendStatics = function extendStatics(d, b) {
	      _extendStatics = Object.setPrototypeOf || {
	        __proto__: []
	      } instanceof Array && function (d, b) {
	        d.__proto__ = b;
	      } || function (d, b) {
	        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	      };
	      return _extendStatics(d, b);
	    };
	    return function (d, b) {
	      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	      _extendStatics(d, b);
	      function __() {
	        this.constructor = d;
	      }
	      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	  }();
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = void 0;
	  var isFunction_1 = isFunction$1;
	  var Subscription_1 = Subscription$1;
	  var config_1 = config;
	  var reportUnhandledError_1 = reportUnhandledError$1;
	  var noop_1 = noop$1;
	  var NotificationFactories_1 = NotificationFactories;
	  var timeoutProvider_1 = timeoutProvider;
	  var errorContext_1 = errorContext$1;
	  var Subscriber = /*#__PURE__*/function (_super) {
	    __extends(Subscriber, _super);
	    function Subscriber(destination) {
	      var _this = _super.call(this) || this;
	      _this.isStopped = false;
	      if (destination) {
	        _this.destination = destination;
	        if (Subscription_1.isSubscription(destination)) {
	          destination.add(_this);
	        }
	      } else {
	        _this.destination = exports.EMPTY_OBSERVER;
	      }
	      return _this;
	    }
	    Subscriber.create = function (next, error, complete) {
	      return new SafeSubscriber(next, error, complete);
	    };
	    Subscriber.prototype.next = function (value) {
	      if (this.isStopped) {
	        handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
	      } else {
	        this._next(value);
	      }
	    };
	    Subscriber.prototype.error = function (err) {
	      if (this.isStopped) {
	        handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
	      } else {
	        this.isStopped = true;
	        this._error(err);
	      }
	    };
	    Subscriber.prototype.complete = function () {
	      if (this.isStopped) {
	        handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
	      } else {
	        this.isStopped = true;
	        this._complete();
	      }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	      if (!this.closed) {
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	        this.destination = null;
	      }
	    };
	    Subscriber.prototype._next = function (value) {
	      this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	      try {
	        this.destination.error(err);
	      } finally {
	        this.unsubscribe();
	      }
	    };
	    Subscriber.prototype._complete = function () {
	      try {
	        this.destination.complete();
	      } finally {
	        this.unsubscribe();
	      }
	    };
	    return Subscriber;
	  }(Subscription_1.Subscription);
	  exports.Subscriber = Subscriber;
	  var _bind = Function.prototype.bind;
	  function bind(fn, thisArg) {
	    return _bind.call(fn, thisArg);
	  }
	  var ConsumerObserver = /*#__PURE__*/function () {
	    function ConsumerObserver(partialObserver) {
	      this.partialObserver = partialObserver;
	    }
	    ConsumerObserver.prototype.next = function (value) {
	      var partialObserver = this.partialObserver;
	      if (partialObserver.next) {
	        try {
	          partialObserver.next(value);
	        } catch (error) {
	          handleUnhandledError(error);
	        }
	      }
	    };
	    ConsumerObserver.prototype.error = function (err) {
	      var partialObserver = this.partialObserver;
	      if (partialObserver.error) {
	        try {
	          partialObserver.error(err);
	        } catch (error) {
	          handleUnhandledError(error);
	        }
	      } else {
	        handleUnhandledError(err);
	      }
	    };
	    ConsumerObserver.prototype.complete = function () {
	      var partialObserver = this.partialObserver;
	      if (partialObserver.complete) {
	        try {
	          partialObserver.complete();
	        } catch (error) {
	          handleUnhandledError(error);
	        }
	      }
	    };
	    return ConsumerObserver;
	  }();
	  var SafeSubscriber = /*#__PURE__*/function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(observerOrNext, error, complete) {
	      var _this = _super.call(this) || this;
	      var partialObserver;
	      if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
	        partialObserver = {
	          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined,
	          error: error !== null && error !== void 0 ? error : undefined,
	          complete: complete !== null && complete !== void 0 ? complete : undefined
	        };
	      } else {
	        var context_1;
	        if (_this && config_1.config.useDeprecatedNextContext) {
	          context_1 = Object.create(observerOrNext);
	          context_1.unsubscribe = function () {
	            return _this.unsubscribe();
	          };
	          partialObserver = {
	            next: observerOrNext.next && bind(observerOrNext.next, context_1),
	            error: observerOrNext.error && bind(observerOrNext.error, context_1),
	            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
	          };
	        } else {
	          partialObserver = observerOrNext;
	        }
	      }
	      _this.destination = new ConsumerObserver(partialObserver);
	      return _this;
	    }
	    return SafeSubscriber;
	  }(Subscriber);
	  exports.SafeSubscriber = SafeSubscriber;
	  function handleUnhandledError(error) {
	    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
	      errorContext_1.captureError(error);
	    } else {
	      reportUnhandledError_1.reportUnhandledError(error);
	    }
	  }
	  function defaultErrorHandler(err) {
	    throw err;
	  }
	  function handleStoppedNotification(notification, subscriber) {
	    var onStoppedNotification = config_1.config.onStoppedNotification;
	    onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function () {
	      return onStoppedNotification(notification, subscriber);
	    });
	  }
	  exports.EMPTY_OBSERVER = {
	    closed: true,
	    next: noop_1.noop,
	    error: defaultErrorHandler,
	    complete: noop_1.noop
	  };
	})(Subscriber);

	var observable = {};

	Object.defineProperty(observable, "__esModule", {
	  value: true
	});
	observable.observable = void 0;
	observable.observable = /*#__PURE__*/function () {
	  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
	}();

	var pipe$1 = {};

	var identity$1 = {};

	Object.defineProperty(identity$1, "__esModule", {
	  value: true
	});
	identity$1.identity = void 0;
	function identity(x) {
	  return x;
	}
	identity$1.identity = identity;

	Object.defineProperty(pipe$1, "__esModule", {
	  value: true
	});
	pipe$1.pipeFromArray = pipe$1.pipe = void 0;
	var identity_1$e = identity$1;
	function pipe() {
	  var fns = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    fns[_i] = arguments[_i];
	  }
	  return pipeFromArray(fns);
	}
	pipe$1.pipe = pipe;
	function pipeFromArray(fns) {
	  if (fns.length === 0) {
	    return identity_1$e.identity;
	  }
	  if (fns.length === 1) {
	    return fns[0];
	  }
	  return function piped(input) {
	    return fns.reduce(function (prev, fn) {
	      return fn(prev);
	    }, input);
	  };
	}
	pipe$1.pipeFromArray = pipeFromArray;

	Object.defineProperty(Observable$1, "__esModule", {
	  value: true
	});
	Observable$1.Observable = void 0;
	var Subscriber_1$3 = Subscriber;
	var Subscription_1$8 = Subscription$1;
	var observable_1$2 = observable;
	var pipe_1$2 = pipe$1;
	var config_1 = config;
	var isFunction_1$o = isFunction$1;
	var errorContext_1$1 = errorContext$1;
	var Observable = /*#__PURE__*/function () {
	  function Observable(subscribe) {
	    if (subscribe) {
	      this._subscribe = subscribe;
	    }
	  }
	  Observable.prototype.lift = function (operator) {
	    var observable = new Observable();
	    observable.source = this;
	    observable.operator = operator;
	    return observable;
	  };
	  Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	    var _this = this;
	    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1$3.SafeSubscriber(observerOrNext, error, complete);
	    errorContext_1$1.errorContext(function () {
	      var _a = _this,
	        operator = _a.operator,
	        source = _a.source;
	      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
	    });
	    return subscriber;
	  };
	  Observable.prototype._trySubscribe = function (sink) {
	    try {
	      return this._subscribe(sink);
	    } catch (err) {
	      sink.error(err);
	    }
	  };
	  Observable.prototype.forEach = function (_next, promiseCtor) {
	    var _this = this;
	    promiseCtor = getPromiseCtor(promiseCtor);
	    return new promiseCtor(function (resolve, reject) {
	      var subscriber = new Subscriber_1$3.SafeSubscriber({
	        next: function next(value) {
	          try {
	            _next(value);
	          } catch (err) {
	            reject(err);
	            subscriber.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	      _this.subscribe(subscriber);
	    });
	  };
	  Observable.prototype._subscribe = function (subscriber) {
	    var _a;
	    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
	  };
	  Observable.prototype[observable_1$2.observable] = function () {
	    return this;
	  };
	  Observable.prototype.pipe = function () {
	    var operations = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	      operations[_i] = arguments[_i];
	    }
	    return pipe_1$2.pipeFromArray(operations)(this);
	  };
	  Observable.prototype.toPromise = function (promiseCtor) {
	    var _this = this;
	    promiseCtor = getPromiseCtor(promiseCtor);
	    return new promiseCtor(function (resolve, reject) {
	      var value;
	      _this.subscribe(function (x) {
	        return value = x;
	      }, function (err) {
	        return reject(err);
	      }, function () {
	        return resolve(value);
	      });
	    });
	  };
	  Observable.create = function (subscribe) {
	    return new Observable(subscribe);
	  };
	  return Observable;
	}();
	Observable$1.Observable = Observable;
	function getPromiseCtor(promiseCtor) {
	  var _a;
	  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
	}
	function isObserver(value) {
	  return value && isFunction_1$o.isFunction(value.next) && isFunction_1$o.isFunction(value.error) && isFunction_1$o.isFunction(value.complete);
	}
	function isSubscriber(value) {
	  return value && value instanceof Subscriber_1$3.Subscriber || isObserver(value) && Subscription_1$8.isSubscription(value);
	}

	var ConnectableObservable$1 = {};

	var refCount$1 = {};

	var lift = {};

	Object.defineProperty(lift, "__esModule", {
	  value: true
	});
	lift.operate = lift.hasLift = void 0;
	var isFunction_1$n = isFunction$1;
	function hasLift(source) {
	  return isFunction_1$n.isFunction(source === null || source === void 0 ? void 0 : source.lift);
	}
	lift.hasLift = hasLift;
	function operate(init) {
	  return function (source) {
	    if (hasLift(source)) {
	      return source.lift(function (liftedSource) {
	        try {
	          return init(liftedSource, this);
	        } catch (err) {
	          this.error(err);
	        }
	      });
	    }
	    throw new TypeError('Unable to lift unknown Observable type');
	  };
	}
	lift.operate = operate;

	var OperatorSubscriber$1 = {};

	var __extends$f = commonjsGlobal && commonjsGlobal.__extends || /*#__PURE__*/function () {
	  var _extendStatics = function extendStatics(d, b) {
	    _extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return _extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    _extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(OperatorSubscriber$1, "__esModule", {
	  value: true
	});
	OperatorSubscriber$1.OperatorSubscriber = OperatorSubscriber$1.createOperatorSubscriber = void 0;
	var Subscriber_1$2 = Subscriber;
	function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
	  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
	}
	OperatorSubscriber$1.createOperatorSubscriber = createOperatorSubscriber;
	var OperatorSubscriber = /*#__PURE__*/function (_super) {
	  __extends$f(OperatorSubscriber, _super);
	  function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
	    var _this = _super.call(this, destination) || this;
	    _this.onFinalize = onFinalize;
	    _this.shouldUnsubscribe = shouldUnsubscribe;
	    _this._next = onNext ? function (value) {
	      try {
	        onNext(value);
	      } catch (err) {
	        destination.error(err);
	      }
	    } : _super.prototype._next;
	    _this._error = onError ? function (err) {
	      try {
	        onError(err);
	      } catch (err) {
	        destination.error(err);
	      } finally {
	        this.unsubscribe();
	      }
	    } : _super.prototype._error;
	    _this._complete = onComplete ? function () {
	      try {
	        onComplete();
	      } catch (err) {
	        destination.error(err);
	      } finally {
	        this.unsubscribe();
	      }
	    } : _super.prototype._complete;
	    return _this;
	  }
	  OperatorSubscriber.prototype.unsubscribe = function () {
	    var _a;
	    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
	      var closed_1 = this.closed;
	      _super.prototype.unsubscribe.call(this);
	      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
	    }
	  };
	  return OperatorSubscriber;
	}(Subscriber_1$2.Subscriber);
	OperatorSubscriber$1.OperatorSubscriber = OperatorSubscriber;

	Object.defineProperty(refCount$1, "__esModule", {
	  value: true
	});
	refCount$1.refCount = void 0;
	var lift_1$14 = lift;
	var OperatorSubscriber_1$V = OperatorSubscriber$1;
	function refCount() {
	  return lift_1$14.operate(function (source, subscriber) {
	    var connection = null;
	    source._refCount++;
	    var refCounter = OperatorSubscriber_1$V.createOperatorSubscriber(subscriber, undefined, undefined, undefined, function () {
	      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
	        connection = null;
	        return;
	      }
	      var sharedConnection = source._connection;
	      var conn = connection;
	      connection = null;
	      if (sharedConnection && (!conn || sharedConnection === conn)) {
	        sharedConnection.unsubscribe();
	      }
	      subscriber.unsubscribe();
	    });
	    source.subscribe(refCounter);
	    if (!refCounter.closed) {
	      connection = source.connect();
	    }
	  });
	}
	refCount$1.refCount = refCount;

	var __extends$e = commonjsGlobal && commonjsGlobal.__extends || /*#__PURE__*/function () {
	  var _extendStatics = function extendStatics(d, b) {
	    _extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return _extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    _extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(ConnectableObservable$1, "__esModule", {
	  value: true
	});
	ConnectableObservable$1.ConnectableObservable = void 0;
	var Observable_1$n = Observable$1;
	var Subscription_1$7 = Subscription$1;
	var refCount_1 = refCount$1;
	var OperatorSubscriber_1$U = OperatorSubscriber$1;
	var lift_1$13 = lift;
	var ConnectableObservable = /*#__PURE__*/function (_super) {
	  __extends$e(ConnectableObservable, _super);
	  function ConnectableObservable(source, subjectFactory) {
	    var _this = _super.call(this) || this;
	    _this.source = source;
	    _this.subjectFactory = subjectFactory;
	    _this._subject = null;
	    _this._refCount = 0;
	    _this._connection = null;
	    if (lift_1$13.hasLift(source)) {
	      _this.lift = source.lift;
	    }
	    return _this;
	  }
	  ConnectableObservable.prototype._subscribe = function (subscriber) {
	    return this.getSubject().subscribe(subscriber);
	  };
	  ConnectableObservable.prototype.getSubject = function () {
	    var subject = this._subject;
	    if (!subject || subject.isStopped) {
	      this._subject = this.subjectFactory();
	    }
	    return this._subject;
	  };
	  ConnectableObservable.prototype._teardown = function () {
	    this._refCount = 0;
	    var _connection = this._connection;
	    this._subject = this._connection = null;
	    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
	  };
	  ConnectableObservable.prototype.connect = function () {
	    var _this = this;
	    var connection = this._connection;
	    if (!connection) {
	      connection = this._connection = new Subscription_1$7.Subscription();
	      var subject_1 = this.getSubject();
	      connection.add(this.source.subscribe(OperatorSubscriber_1$U.createOperatorSubscriber(subject_1, undefined, function () {
	        _this._teardown();
	        subject_1.complete();
	      }, function (err) {
	        _this._teardown();
	        subject_1.error(err);
	      }, function () {
	        return _this._teardown();
	      })));
	      if (connection.closed) {
	        this._connection = null;
	        connection = Subscription_1$7.Subscription.EMPTY;
	      }
	    }
	    return connection;
	  };
	  ConnectableObservable.prototype.refCount = function () {
	    return refCount_1.refCount()(this);
	  };
	  return ConnectableObservable;
	}(Observable_1$n.Observable);
	ConnectableObservable$1.ConnectableObservable = ConnectableObservable;

	var animationFrames$1 = {};

	var performanceTimestampProvider = {};

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.performanceTimestampProvider = void 0;
	  exports.performanceTimestampProvider = {
	    now: function now() {
	      return (exports.performanceTimestampProvider.delegate || performance).now();
	    },
	    delegate: undefined
	  };
	})(performanceTimestampProvider);

	var animationFrameProvider = {};

	(function (exports) {

	  var __read = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o),
	      r,
	      ar = [],
	      e;
	    try {
	      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    } catch (error) {
	      e = {
	        error: error
	      };
	    } finally {
	      try {
	        if (r && !r.done && (m = i["return"])) m.call(i);
	      } finally {
	        if (e) throw e.error;
	      }
	    }
	    return ar;
	  };
	  var __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	    return to;
	  };
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.animationFrameProvider = void 0;
	  var Subscription_1 = Subscription$1;
	  exports.animationFrameProvider = {
	    schedule: function schedule(callback) {
	      var request = requestAnimationFrame;
	      var cancel = cancelAnimationFrame;
	      var delegate = exports.animationFrameProvider.delegate;
	      if (delegate) {
	        request = delegate.requestAnimationFrame;
	        cancel = delegate.cancelAnimationFrame;
	      }
	      var handle = request(function (timestamp) {
	        cancel = undefined;
	        callback(timestamp);
	      });
	      return new Subscription_1.Subscription(function () {
	        return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
	      });
	    },
	    requestAnimationFrame: /*#__PURE__*/function (_requestAnimationFrame) {
	      function requestAnimationFrame() {
	        return _requestAnimationFrame.apply(this, arguments);
	      }
	      requestAnimationFrame.toString = function () {
	        return _requestAnimationFrame.toString();
	      };
	      return requestAnimationFrame;
	    }(function () {
	      var args = [];
	      for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	      }
	      var delegate = exports.animationFrameProvider.delegate;
	      return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
	    }),
	    cancelAnimationFrame: /*#__PURE__*/function (_cancelAnimationFrame) {
	      function cancelAnimationFrame() {
	        return _cancelAnimationFrame.apply(this, arguments);
	      }
	      cancelAnimationFrame.toString = function () {
	        return _cancelAnimationFrame.toString();
	      };
	      return cancelAnimationFrame;
	    }(function () {
	      var args = [];
	      for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	      }
	      var delegate = exports.animationFrameProvider.delegate;
	      return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
	    }),
	    delegate: undefined
	  };
	})(animationFrameProvider);

	Object.defineProperty(animationFrames$1, "__esModule", {
	  value: true
	});
	animationFrames$1.animationFrames = void 0;
	var Observable_1$m = Observable$1;
	var performanceTimestampProvider_1 = performanceTimestampProvider;
	var animationFrameProvider_1$1 = animationFrameProvider;
	function animationFrames(timestampProvider) {
	  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
	}
	animationFrames$1.animationFrames = animationFrames;
	function animationFramesFactory(timestampProvider) {
	  return new Observable_1$m.Observable(function (subscriber) {
	    var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
	    var start = provider.now();
	    var id = 0;
	    var run = function run() {
	      if (!subscriber.closed) {
	        id = animationFrameProvider_1$1.animationFrameProvider.requestAnimationFrame(function (timestamp) {
	          id = 0;
	          var now = provider.now();
	          subscriber.next({
	            timestamp: timestampProvider ? now : timestamp,
	            elapsed: now - start
	          });
	          run();
	        });
	      }
	    };
	    run();
	    return function () {
	      if (id) {
	        animationFrameProvider_1$1.animationFrameProvider.cancelAnimationFrame(id);
	      }
	    };
	  });
	}
	var DEFAULT_ANIMATION_FRAMES = /*#__PURE__*/animationFramesFactory();

	var Subject$1 = {};

	var ObjectUnsubscribedError = {};

	Object.defineProperty(ObjectUnsubscribedError, "__esModule", {
	  value: true
	});
	ObjectUnsubscribedError.ObjectUnsubscribedError = void 0;
	var createErrorClass_1$4 = createErrorClass$1;
	ObjectUnsubscribedError.ObjectUnsubscribedError = /*#__PURE__*/createErrorClass_1$4.createErrorClass(function (_super) {
	  return function ObjectUnsubscribedErrorImpl() {
	    _super(this);
	    this.name = 'ObjectUnsubscribedError';
	    this.message = 'object unsubscribed';
	  };
	});

	var __extends$d = commonjsGlobal && commonjsGlobal.__extends || /*#__PURE__*/function () {
	  var _extendStatics = function extendStatics(d, b) {
	    _extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return _extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    _extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	var __values$7 = commonjsGlobal && commonjsGlobal.__values || function (o) {
	  var s = typeof Symbol === "function" && Symbol.iterator,
	    m = s && o[s],
	    i = 0;
	  if (m) return m.call(o);
	  if (o && typeof o.length === "number") return {
	    next: function next() {
	      if (o && i >= o.length) o = void 0;
	      return {
	        value: o && o[i++],
	        done: !o
	      };
	    }
	  };
	  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(Subject$1, "__esModule", {
	  value: true
	});
	Subject$1.AnonymousSubject = Subject$1.Subject = void 0;
	var Observable_1$l = Observable$1;
	var Subscription_1$6 = Subscription$1;
	var ObjectUnsubscribedError_1 = ObjectUnsubscribedError;
	var arrRemove_1$6 = arrRemove$1;
	var errorContext_1 = errorContext$1;
	var Subject = /*#__PURE__*/function (_super) {
	  __extends$d(Subject, _super);
	  function Subject() {
	    var _this = _super.call(this) || this;
	    _this.closed = false;
	    _this.currentObservers = null;
	    _this.observers = [];
	    _this.isStopped = false;
	    _this.hasError = false;
	    _this.thrownError = null;
	    return _this;
	  }
	  Subject.prototype.lift = function (operator) {
	    var subject = new AnonymousSubject(this, this);
	    subject.operator = operator;
	    return subject;
	  };
	  Subject.prototype._throwIfClosed = function () {
	    if (this.closed) {
	      throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	    }
	  };
	  Subject.prototype.next = function (value) {
	    var _this = this;
	    errorContext_1.errorContext(function () {
	      var e_1, _a;
	      _this._throwIfClosed();
	      if (!_this.isStopped) {
	        if (!_this.currentObservers) {
	          _this.currentObservers = Array.from(_this.observers);
	        }
	        try {
	          for (var _b = __values$7(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
	            var observer = _c.value;
	            observer.next(value);
	          }
	        } catch (e_1_1) {
	          e_1 = {
	            error: e_1_1
	          };
	        } finally {
	          try {
	            if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
	          } finally {
	            if (e_1) throw e_1.error;
	          }
	        }
	      }
	    });
	  };
	  Subject.prototype.error = function (err) {
	    var _this = this;
	    errorContext_1.errorContext(function () {
	      _this._throwIfClosed();
	      if (!_this.isStopped) {
	        _this.hasError = _this.isStopped = true;
	        _this.thrownError = err;
	        var observers = _this.observers;
	        while (observers.length) {
	          observers.shift().error(err);
	        }
	      }
	    });
	  };
	  Subject.prototype.complete = function () {
	    var _this = this;
	    errorContext_1.errorContext(function () {
	      _this._throwIfClosed();
	      if (!_this.isStopped) {
	        _this.isStopped = true;
	        var observers = _this.observers;
	        while (observers.length) {
	          observers.shift().complete();
	        }
	      }
	    });
	  };
	  Subject.prototype.unsubscribe = function () {
	    this.isStopped = this.closed = true;
	    this.observers = this.currentObservers = null;
	  };
	  Object.defineProperty(Subject.prototype, "observed", {
	    get: function get() {
	      var _a;
	      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Subject.prototype._trySubscribe = function (subscriber) {
	    this._throwIfClosed();
	    return _super.prototype._trySubscribe.call(this, subscriber);
	  };
	  Subject.prototype._subscribe = function (subscriber) {
	    this._throwIfClosed();
	    this._checkFinalizedStatuses(subscriber);
	    return this._innerSubscribe(subscriber);
	  };
	  Subject.prototype._innerSubscribe = function (subscriber) {
	    var _this = this;
	    var _a = this,
	      hasError = _a.hasError,
	      isStopped = _a.isStopped,
	      observers = _a.observers;
	    if (hasError || isStopped) {
	      return Subscription_1$6.EMPTY_SUBSCRIPTION;
	    }
	    this.currentObservers = null;
	    observers.push(subscriber);
	    return new Subscription_1$6.Subscription(function () {
	      _this.currentObservers = null;
	      arrRemove_1$6.arrRemove(observers, subscriber);
	    });
	  };
	  Subject.prototype._checkFinalizedStatuses = function (subscriber) {
	    var _a = this,
	      hasError = _a.hasError,
	      thrownError = _a.thrownError,
	      isStopped = _a.isStopped;
	    if (hasError) {
	      subscriber.error(thrownError);
	    } else if (isStopped) {
	      subscriber.complete();
	    }
	  };
	  Subject.prototype.asObservable = function () {
	    var observable = new Observable_1$l.Observable();
	    observable.source = this;
	    return observable;
	  };
	  Subject.create = function (destination, source) {
	    return new AnonymousSubject(destination, source);
	  };
	  return Subject;
	}(Observable_1$l.Observable);
	Subject$1.Subject = Subject;
	var AnonymousSubject = /*#__PURE__*/function (_super) {
	  __extends$d(AnonymousSubject, _super);
	  function AnonymousSubject(destination, source) {
	    var _this = _super.call(this) || this;
	    _this.destination = destination;
	    _this.source = source;
	    return _this;
	  }
	  AnonymousSubject.prototype.next = function (value) {
	    var _a, _b;
	    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
	  };
	  AnonymousSubject.prototype.error = function (err) {
	    var _a, _b;
	    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
	  };
	  AnonymousSubject.prototype.complete = function () {
	    var _a, _b;
	    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
	  };
	  AnonymousSubject.prototype._subscribe = function (subscriber) {
	    var _a, _b;
	    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1$6.EMPTY_SUBSCRIPTION;
	  };
	  return AnonymousSubject;
	}(Subject);
	Subject$1.AnonymousSubject = AnonymousSubject;

	var BehaviorSubject$1 = {};

	var __extends$c = commonjsGlobal && commonjsGlobal.__extends || /*#__PURE__*/function () {
	  var _extendStatics = function extendStatics(d, b) {
	    _extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return _extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    _extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(BehaviorSubject$1, "__esModule", {
	  value: true
	});
	BehaviorSubject$1.BehaviorSubject = void 0;
	var Subject_1$e = Subject$1;
	var BehaviorSubject = /*#__PURE__*/function (_super) {
	  __extends$c(BehaviorSubject, _super);
	  function BehaviorSubject(_value) {
	    var _this = _super.call(this) || this;
	    _this._value = _value;
	    return _this;
	  }
	  Object.defineProperty(BehaviorSubject.prototype, "value", {
	    get: function get() {
	      return this.getValue();
	    },
	    enumerable: false,
	    configurable: true
	  });
	  BehaviorSubject.prototype._subscribe = function (subscriber) {
	    var subscription = _super.prototype._subscribe.call(this, subscriber);
	    !subscription.closed && subscriber.next(this._value);
	    return subscription;
	  };
	  BehaviorSubject.prototype.getValue = function () {
	    var _a = this,
	      hasError = _a.hasError,
	      thrownError = _a.thrownError,
	      _value = _a._value;
	    if (hasError) {
	      throw thrownError;
	    }
	    this._throwIfClosed();
	    return _value;
	  };
	  BehaviorSubject.prototype.next = function (value) {
	    _super.prototype.next.call(this, this._value = value);
	  };
	  return BehaviorSubject;
	}(Subject_1$e.Subject);
	BehaviorSubject$1.BehaviorSubject = BehaviorSubject;

	var ReplaySubject$1 = {};

	var dateTimestampProvider = {};

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.dateTimestampProvider = void 0;
	  exports.dateTimestampProvider = {
	    now: function now() {
	      return (exports.dateTimestampProvider.delegate || Date).now();
	    },
	    delegate: undefined
	  };
	})(dateTimestampProvider);

	var __extends$b = commonjsGlobal && commonjsGlobal.__extends || /*#__PURE__*/function () {
	  var _extendStatics = function extendStatics(d, b) {
	    _extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return _extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    _extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(ReplaySubject$1, "__esModule", {
	  value: true
	});
	ReplaySubject$1.ReplaySubject = void 0;
	var Subject_1$d = Subject$1;
	var dateTimestampProvider_1$2 = dateTimestampProvider;
	var ReplaySubject = /*#__PURE__*/function (_super) {
	  __extends$b(ReplaySubject, _super);
	  function ReplaySubject(_bufferSize, _windowTime, _timestampProvider) {
	    if (_bufferSize === void 0) {
	      _bufferSize = Infinity;
	    }
	    if (_windowTime === void 0) {
	      _windowTime = Infinity;
	    }
	    if (_timestampProvider === void 0) {
	      _timestampProvider = dateTimestampProvider_1$2.dateTimestampProvider;
	    }
	    var _this = _super.call(this) || this;
	    _this._bufferSize = _bufferSize;
	    _this._windowTime = _windowTime;
	    _this._timestampProvider = _timestampProvider;
	    _this._buffer = [];
	    _this._infiniteTimeWindow = true;
	    _this._infiniteTimeWindow = _windowTime === Infinity;
	    _this._bufferSize = Math.max(1, _bufferSize);
	    _this._windowTime = Math.max(1, _windowTime);
	    return _this;
	  }
	  ReplaySubject.prototype.next = function (value) {
	    var _a = this,
	      isStopped = _a.isStopped,
	      _buffer = _a._buffer,
	      _infiniteTimeWindow = _a._infiniteTimeWindow,
	      _timestampProvider = _a._timestampProvider,
	      _windowTime = _a._windowTime;
	    if (!isStopped) {
	      _buffer.push(value);
	      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
	    }
	    this._trimBuffer();
	    _super.prototype.next.call(this, value);
	  };
	  ReplaySubject.prototype._subscribe = function (subscriber) {
	    this._throwIfClosed();
	    this._trimBuffer();
	    var subscription = this._innerSubscribe(subscriber);
	    var _a = this,
	      _infiniteTimeWindow = _a._infiniteTimeWindow,
	      _buffer = _a._buffer;
	    var copy = _buffer.slice();
	    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
	      subscriber.next(copy[i]);
	    }
	    this._checkFinalizedStatuses(subscriber);
	    return subscription;
	  };
	  ReplaySubject.prototype._trimBuffer = function () {
	    var _a = this,
	      _bufferSize = _a._bufferSize,
	      _timestampProvider = _a._timestampProvider,
	      _buffer = _a._buffer,
	      _infiniteTimeWindow = _a._infiniteTimeWindow;
	    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
	    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
	    if (!_infiniteTimeWindow) {
	      var now = _timestampProvider.now();
	      var last = 0;
	      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
	        last = i;
	      }
	      last && _buffer.splice(0, last + 1);
	    }
	  };
	  return ReplaySubject;
	}(Subject_1$d.Subject);
	ReplaySubject$1.ReplaySubject = ReplaySubject;

	var AsyncSubject$1 = {};

	var __extends$a = commonjsGlobal && commonjsGlobal.__extends || /*#__PURE__*/function () {
	  var _extendStatics = function extendStatics(d, b) {
	    _extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return _extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    _extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(AsyncSubject$1, "__esModule", {
	  value: true
	});
	AsyncSubject$1.AsyncSubject = void 0;
	var Subject_1$c = Subject$1;
	var AsyncSubject = /*#__PURE__*/function (_super) {
	  __extends$a(AsyncSubject, _super);
	  function AsyncSubject() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	    _this._value = null;
	    _this._hasValue = false;
	    _this._isComplete = false;
	    return _this;
	  }
	  AsyncSubject.prototype._checkFinalizedStatuses = function (subscriber) {
	    var _a = this,
	      hasError = _a.hasError,
	      _hasValue = _a._hasValue,
	      _value = _a._value,
	      thrownError = _a.thrownError,
	      isStopped = _a.isStopped,
	      _isComplete = _a._isComplete;
	    if (hasError) {
	      subscriber.error(thrownError);
	    } else if (isStopped || _isComplete) {
	      _hasValue && subscriber.next(_value);
	      subscriber.complete();
	    }
	  };
	  AsyncSubject.prototype.next = function (value) {
	    if (!this.isStopped) {
	      this._value = value;
	      this._hasValue = true;
	    }
	  };
	  AsyncSubject.prototype.complete = function () {
	    var _a = this,
	      _hasValue = _a._hasValue,
	      _value = _a._value,
	      _isComplete = _a._isComplete;
	    if (!_isComplete) {
	      this._isComplete = true;
	      _hasValue && _super.prototype.next.call(this, _value);
	      _super.prototype.complete.call(this);
	    }
	  };
	  return AsyncSubject;
	}(Subject_1$c.Subject);
	AsyncSubject$1.AsyncSubject = AsyncSubject;

	var asap = {};

	var AsapAction$1 = {};

	var AsyncAction$1 = {};

	var Action$1 = {};

	var __extends$9 = commonjsGlobal && commonjsGlobal.__extends || /*#__PURE__*/function () {
	  var _extendStatics = function extendStatics(d, b) {
	    _extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return _extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    _extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(Action$1, "__esModule", {
	  value: true
	});
	Action$1.Action = void 0;
	var Subscription_1$5 = Subscription$1;
	var Action = /*#__PURE__*/function (_super) {
	  __extends$9(Action, _super);
	  function Action(scheduler, work) {
	    return _super.call(this) || this;
	  }
	  Action.prototype.schedule = function (state, delay) {
	    return this;
	  };
	  return Action;
	}(Subscription_1$5.Subscription);
	Action$1.Action = Action;

	var intervalProvider = {};

	(function (exports) {

	  var __read = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o),
	      r,
	      ar = [],
	      e;
	    try {
	      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    } catch (error) {
	      e = {
	        error: error
	      };
	    } finally {
	      try {
	        if (r && !r.done && (m = i["return"])) m.call(i);
	      } finally {
	        if (e) throw e.error;
	      }
	    }
	    return ar;
	  };
	  var __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	    return to;
	  };
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.intervalProvider = void 0;
	  exports.intervalProvider = {
	    setInterval: /*#__PURE__*/function (_setInterval) {
	      function setInterval(_x, _x2) {
	        return _setInterval.apply(this, arguments);
	      }
	      setInterval.toString = function () {
	        return _setInterval.toString();
	      };
	      return setInterval;
	    }(function (handler, timeout) {
	      var args = [];
	      for (var _i = 2; _i < arguments.length; _i++) {
	        args[_i - 2] = arguments[_i];
	      }
	      var delegate = exports.intervalProvider.delegate;
	      if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
	        return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
	      }
	      return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
	    }),
	    clearInterval: /*#__PURE__*/function (_clearInterval) {
	      function clearInterval(_x3) {
	        return _clearInterval.apply(this, arguments);
	      }
	      clearInterval.toString = function () {
	        return _clearInterval.toString();
	      };
	      return clearInterval;
	    }(function (handle) {
	      var delegate = exports.intervalProvider.delegate;
	      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
	    }),
	    delegate: undefined
	  };
	})(intervalProvider);

	var __extends$8 = commonjsGlobal && commonjsGlobal.__extends || /*#__PURE__*/function () {
	  var _extendStatics = function extendStatics(d, b) {
	    _extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return _extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    _extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(AsyncAction$1, "__esModule", {
	  value: true
	});
	AsyncAction$1.AsyncAction = void 0;
	var Action_1 = Action$1;
	var intervalProvider_1 = intervalProvider;
	var arrRemove_1$5 = arrRemove$1;
	var AsyncAction = /*#__PURE__*/function (_super) {
	  __extends$8(AsyncAction, _super);
	  function AsyncAction(scheduler, work) {
	    var _this = _super.call(this, scheduler, work) || this;
	    _this.scheduler = scheduler;
	    _this.work = work;
	    _this.pending = false;
	    return _this;
	  }
	  AsyncAction.prototype.schedule = function (state, delay) {
	    var _a;
	    if (delay === void 0) {
	      delay = 0;
	    }
	    if (this.closed) {
	      return this;
	    }
	    this.state = state;
	    var id = this.id;
	    var scheduler = this.scheduler;
	    if (id != null) {
	      this.id = this.recycleAsyncId(scheduler, id, delay);
	    }
	    this.pending = true;
	    this.delay = delay;
	    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
	    return this;
	  };
	  AsyncAction.prototype.requestAsyncId = function (scheduler, _id, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }
	    return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
	  };
	  AsyncAction.prototype.recycleAsyncId = function (_scheduler, id, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }
	    if (delay != null && this.delay === delay && this.pending === false) {
	      return id;
	    }
	    if (id != null) {
	      intervalProvider_1.intervalProvider.clearInterval(id);
	    }
	    return undefined;
	  };
	  AsyncAction.prototype.execute = function (state, delay) {
	    if (this.closed) {
	      return new Error('executing a cancelled action');
	    }
	    this.pending = false;
	    var error = this._execute(state, delay);
	    if (error) {
	      return error;
	    } else if (this.pending === false && this.id != null) {
	      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
	    }
	  };
	  AsyncAction.prototype._execute = function (state, _delay) {
	    var errored = false;
	    var errorValue;
	    try {
	      this.work(state);
	    } catch (e) {
	      errored = true;
	      errorValue = e ? e : new Error('Scheduled action threw falsy error');
	    }
	    if (errored) {
	      this.unsubscribe();
	      return errorValue;
	    }
	  };
	  AsyncAction.prototype.unsubscribe = function () {
	    if (!this.closed) {
	      var _a = this,
	        id = _a.id,
	        scheduler = _a.scheduler;
	      var actions = scheduler.actions;
	      this.work = this.state = this.scheduler = null;
	      this.pending = false;
	      arrRemove_1$5.arrRemove(actions, this);
	      if (id != null) {
	        this.id = this.recycleAsyncId(scheduler, id, null);
	      }
	      this.delay = null;
	      _super.prototype.unsubscribe.call(this);
	    }
	  };
	  return AsyncAction;
	}(Action_1.Action);
	AsyncAction$1.AsyncAction = AsyncAction;

	var immediateProvider = {};

	var Immediate = {};

	Object.defineProperty(Immediate, "__esModule", {
	  value: true
	});
	Immediate.TestTools = Immediate.Immediate = void 0;
	var nextHandle = 1;
	var resolved;
	var activeHandles = {};
	function findAndClearHandle(handle) {
	  if (handle in activeHandles) {
	    delete activeHandles[handle];
	    return true;
	  }
	  return false;
	}
	Immediate.Immediate = {
	  setImmediate: function setImmediate(cb) {
	    var handle = nextHandle++;
	    activeHandles[handle] = true;
	    if (!resolved) {
	      resolved = Promise.resolve();
	    }
	    resolved.then(function () {
	      return findAndClearHandle(handle) && cb();
	    });
	    return handle;
	  },
	  clearImmediate: function clearImmediate(handle) {
	    findAndClearHandle(handle);
	  }
	};
	Immediate.TestTools = {
	  pending: function pending() {
	    return Object.keys(activeHandles).length;
	  }
	};

	(function (exports) {

	  var __read = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o),
	      r,
	      ar = [],
	      e;
	    try {
	      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    } catch (error) {
	      e = {
	        error: error
	      };
	    } finally {
	      try {
	        if (r && !r.done && (m = i["return"])) m.call(i);
	      } finally {
	        if (e) throw e.error;
	      }
	    }
	    return ar;
	  };
	  var __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	    return to;
	  };
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.immediateProvider = void 0;
	  var Immediate_1 = Immediate;
	  var _setImmediate = Immediate_1.Immediate.setImmediate,
	    _clearImmediate = Immediate_1.Immediate.clearImmediate;
	  exports.immediateProvider = {
	    setImmediate: function setImmediate() {
	      var args = [];
	      for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	      }
	      var delegate = exports.immediateProvider.delegate;
	      return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || _setImmediate).apply(void 0, __spreadArray([], __read(args)));
	    },
	    clearImmediate: function clearImmediate(handle) {
	      var delegate = exports.immediateProvider.delegate;
	      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || _clearImmediate)(handle);
	    },
	    delegate: undefined
	  };
	})(immediateProvider);

	var __extends$7 = commonjsGlobal && commonjsGlobal.__extends || /*#__PURE__*/function () {
	  var _extendStatics = function extendStatics(d, b) {
	    _extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return _extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    _extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(AsapAction$1, "__esModule", {
	  value: true
	});
	AsapAction$1.AsapAction = void 0;
	var AsyncAction_1$3 = AsyncAction$1;
	var immediateProvider_1 = immediateProvider;
	var AsapAction = /*#__PURE__*/function (_super) {
	  __extends$7(AsapAction, _super);
	  function AsapAction(scheduler, work) {
	    var _this = _super.call(this, scheduler, work) || this;
	    _this.scheduler = scheduler;
	    _this.work = work;
	    return _this;
	  }
	  AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }
	    if (delay !== null && delay > 0) {
	      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	    }
	    scheduler.actions.push(this);
	    return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));
	  };
	  AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	    var _a;
	    if (delay === void 0) {
	      delay = 0;
	    }
	    if (delay != null ? delay > 0 : this.delay > 0) {
	      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	    }
	    var actions = scheduler.actions;
	    if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
	      immediateProvider_1.immediateProvider.clearImmediate(id);
	      if (scheduler._scheduled === id) {
	        scheduler._scheduled = undefined;
	      }
	    }
	    return undefined;
	  };
	  return AsapAction;
	}(AsyncAction_1$3.AsyncAction);
	AsapAction$1.AsapAction = AsapAction;

	var AsapScheduler$1 = {};

	var AsyncScheduler$1 = {};

	var Scheduler$1 = {};

	Object.defineProperty(Scheduler$1, "__esModule", {
	  value: true
	});
	Scheduler$1.Scheduler = void 0;
	var dateTimestampProvider_1$1 = dateTimestampProvider;
	var Scheduler = /*#__PURE__*/function () {
	  function Scheduler(schedulerActionCtor, now) {
	    if (now === void 0) {
	      now = Scheduler.now;
	    }
	    this.schedulerActionCtor = schedulerActionCtor;
	    this.now = now;
	  }
	  Scheduler.prototype.schedule = function (work, delay, state) {
	    if (delay === void 0) {
	      delay = 0;
	    }
	    return new this.schedulerActionCtor(this, work).schedule(state, delay);
	  };
	  Scheduler.now = dateTimestampProvider_1$1.dateTimestampProvider.now;
	  return Scheduler;
	}();
	Scheduler$1.Scheduler = Scheduler;

	var __extends$6 = commonjsGlobal && commonjsGlobal.__extends || /*#__PURE__*/function () {
	  var _extendStatics = function extendStatics(d, b) {
	    _extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return _extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    _extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(AsyncScheduler$1, "__esModule", {
	  value: true
	});
	AsyncScheduler$1.AsyncScheduler = void 0;
	var Scheduler_1 = Scheduler$1;
	var AsyncScheduler = /*#__PURE__*/function (_super) {
	  __extends$6(AsyncScheduler, _super);
	  function AsyncScheduler(SchedulerAction, now) {
	    if (now === void 0) {
	      now = Scheduler_1.Scheduler.now;
	    }
	    var _this = _super.call(this, SchedulerAction, now) || this;
	    _this.actions = [];
	    _this._active = false;
	    return _this;
	  }
	  AsyncScheduler.prototype.flush = function (action) {
	    var actions = this.actions;
	    if (this._active) {
	      actions.push(action);
	      return;
	    }
	    var error;
	    this._active = true;
	    do {
	      if (error = action.execute(action.state, action.delay)) {
	        break;
	      }
	    } while (action = actions.shift());
	    this._active = false;
	    if (error) {
	      while (action = actions.shift()) {
	        action.unsubscribe();
	      }
	      throw error;
	    }
	  };
	  return AsyncScheduler;
	}(Scheduler_1.Scheduler);
	AsyncScheduler$1.AsyncScheduler = AsyncScheduler;

	var __extends$5 = commonjsGlobal && commonjsGlobal.__extends || /*#__PURE__*/function () {
	  var _extendStatics = function extendStatics(d, b) {
	    _extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return _extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    _extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(AsapScheduler$1, "__esModule", {
	  value: true
	});
	AsapScheduler$1.AsapScheduler = void 0;
	var AsyncScheduler_1$3 = AsyncScheduler$1;
	var AsapScheduler = /*#__PURE__*/function (_super) {
	  __extends$5(AsapScheduler, _super);
	  function AsapScheduler() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }
	  AsapScheduler.prototype.flush = function (action) {
	    this._active = true;
	    var flushId = this._scheduled;
	    this._scheduled = undefined;
	    var actions = this.actions;
	    var error;
	    action = action || actions.shift();
	    do {
	      if (error = action.execute(action.state, action.delay)) {
	        break;
	      }
	    } while ((action = actions[0]) && action.id === flushId && actions.shift());
	    this._active = false;
	    if (error) {
	      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
	        action.unsubscribe();
	      }
	      throw error;
	    }
	  };
	  return AsapScheduler;
	}(AsyncScheduler_1$3.AsyncScheduler);
	AsapScheduler$1.AsapScheduler = AsapScheduler;

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.asap = exports.asapScheduler = void 0;
	  var AsapAction_1 = AsapAction$1;
	  var AsapScheduler_1 = AsapScheduler$1;
	  exports.asapScheduler = /*#__PURE__*/new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
	  exports.asap = exports.asapScheduler;
	})(asap);

	var async = {};

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.async = exports.asyncScheduler = void 0;
	  var AsyncAction_1 = AsyncAction$1;
	  var AsyncScheduler_1 = AsyncScheduler$1;
	  exports.asyncScheduler = /*#__PURE__*/new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
	  exports.async = exports.asyncScheduler;
	})(async);

	var queue = {};

	var QueueAction$1 = {};

	var __extends$4 = commonjsGlobal && commonjsGlobal.__extends || /*#__PURE__*/function () {
	  var _extendStatics = function extendStatics(d, b) {
	    _extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return _extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    _extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(QueueAction$1, "__esModule", {
	  value: true
	});
	QueueAction$1.QueueAction = void 0;
	var AsyncAction_1$2 = AsyncAction$1;
	var QueueAction = /*#__PURE__*/function (_super) {
	  __extends$4(QueueAction, _super);
	  function QueueAction(scheduler, work) {
	    var _this = _super.call(this, scheduler, work) || this;
	    _this.scheduler = scheduler;
	    _this.work = work;
	    return _this;
	  }
	  QueueAction.prototype.schedule = function (state, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }
	    if (delay > 0) {
	      return _super.prototype.schedule.call(this, state, delay);
	    }
	    this.delay = delay;
	    this.state = state;
	    this.scheduler.flush(this);
	    return this;
	  };
	  QueueAction.prototype.execute = function (state, delay) {
	    return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
	  };
	  QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }
	    if (delay != null && delay > 0 || delay == null && this.delay > 0) {
	      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	    }
	    scheduler.flush(this);
	    return 0;
	  };
	  return QueueAction;
	}(AsyncAction_1$2.AsyncAction);
	QueueAction$1.QueueAction = QueueAction;

	var QueueScheduler$1 = {};

	var __extends$3 = commonjsGlobal && commonjsGlobal.__extends || /*#__PURE__*/function () {
	  var _extendStatics = function extendStatics(d, b) {
	    _extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return _extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    _extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(QueueScheduler$1, "__esModule", {
	  value: true
	});
	QueueScheduler$1.QueueScheduler = void 0;
	var AsyncScheduler_1$2 = AsyncScheduler$1;
	var QueueScheduler = /*#__PURE__*/function (_super) {
	  __extends$3(QueueScheduler, _super);
	  function QueueScheduler() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }
	  return QueueScheduler;
	}(AsyncScheduler_1$2.AsyncScheduler);
	QueueScheduler$1.QueueScheduler = QueueScheduler;

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.queue = exports.queueScheduler = void 0;
	  var QueueAction_1 = QueueAction$1;
	  var QueueScheduler_1 = QueueScheduler$1;
	  exports.queueScheduler = /*#__PURE__*/new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
	  exports.queue = exports.queueScheduler;
	})(queue);

	var animationFrame = {};

	var AnimationFrameAction$1 = {};

	var __extends$2 = commonjsGlobal && commonjsGlobal.__extends || /*#__PURE__*/function () {
	  var _extendStatics = function extendStatics(d, b) {
	    _extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return _extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    _extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(AnimationFrameAction$1, "__esModule", {
	  value: true
	});
	AnimationFrameAction$1.AnimationFrameAction = void 0;
	var AsyncAction_1$1 = AsyncAction$1;
	var animationFrameProvider_1 = animationFrameProvider;
	var AnimationFrameAction = /*#__PURE__*/function (_super) {
	  __extends$2(AnimationFrameAction, _super);
	  function AnimationFrameAction(scheduler, work) {
	    var _this = _super.call(this, scheduler, work) || this;
	    _this.scheduler = scheduler;
	    _this.work = work;
	    return _this;
	  }
	  AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }
	    if (delay !== null && delay > 0) {
	      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	    }
	    scheduler.actions.push(this);
	    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function () {
	      return scheduler.flush(undefined);
	    }));
	  };
	  AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	    var _a;
	    if (delay === void 0) {
	      delay = 0;
	    }
	    if (delay != null ? delay > 0 : this.delay > 0) {
	      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	    }
	    var actions = scheduler.actions;
	    if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
	      animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
	      scheduler._scheduled = undefined;
	    }
	    return undefined;
	  };
	  return AnimationFrameAction;
	}(AsyncAction_1$1.AsyncAction);
	AnimationFrameAction$1.AnimationFrameAction = AnimationFrameAction;

	var AnimationFrameScheduler$1 = {};

	var __extends$1 = commonjsGlobal && commonjsGlobal.__extends || /*#__PURE__*/function () {
	  var _extendStatics = function extendStatics(d, b) {
	    _extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return _extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    _extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(AnimationFrameScheduler$1, "__esModule", {
	  value: true
	});
	AnimationFrameScheduler$1.AnimationFrameScheduler = void 0;
	var AsyncScheduler_1$1 = AsyncScheduler$1;
	var AnimationFrameScheduler = /*#__PURE__*/function (_super) {
	  __extends$1(AnimationFrameScheduler, _super);
	  function AnimationFrameScheduler() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }
	  AnimationFrameScheduler.prototype.flush = function (action) {
	    this._active = true;
	    var flushId = this._scheduled;
	    this._scheduled = undefined;
	    var actions = this.actions;
	    var error;
	    action = action || actions.shift();
	    do {
	      if (error = action.execute(action.state, action.delay)) {
	        break;
	      }
	    } while ((action = actions[0]) && action.id === flushId && actions.shift());
	    this._active = false;
	    if (error) {
	      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
	        action.unsubscribe();
	      }
	      throw error;
	    }
	  };
	  return AnimationFrameScheduler;
	}(AsyncScheduler_1$1.AsyncScheduler);
	AnimationFrameScheduler$1.AnimationFrameScheduler = AnimationFrameScheduler;

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.animationFrame = exports.animationFrameScheduler = void 0;
	  var AnimationFrameAction_1 = AnimationFrameAction$1;
	  var AnimationFrameScheduler_1 = AnimationFrameScheduler$1;
	  exports.animationFrameScheduler = /*#__PURE__*/new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
	  exports.animationFrame = exports.animationFrameScheduler;
	})(animationFrame);

	var VirtualTimeScheduler$1 = {};

	var __extends = commonjsGlobal && commonjsGlobal.__extends || /*#__PURE__*/function () {
	  var _extendStatics = function extendStatics(d, b) {
	    _extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return _extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    _extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	Object.defineProperty(VirtualTimeScheduler$1, "__esModule", {
	  value: true
	});
	VirtualTimeScheduler$1.VirtualAction = VirtualTimeScheduler$1.VirtualTimeScheduler = void 0;
	var AsyncAction_1 = AsyncAction$1;
	var Subscription_1$4 = Subscription$1;
	var AsyncScheduler_1 = AsyncScheduler$1;
	var VirtualTimeScheduler = /*#__PURE__*/function (_super) {
	  __extends(VirtualTimeScheduler, _super);
	  function VirtualTimeScheduler(schedulerActionCtor, maxFrames) {
	    if (schedulerActionCtor === void 0) {
	      schedulerActionCtor = VirtualAction;
	    }
	    if (maxFrames === void 0) {
	      maxFrames = Infinity;
	    }
	    var _this = _super.call(this, schedulerActionCtor, function () {
	      return _this.frame;
	    }) || this;
	    _this.maxFrames = maxFrames;
	    _this.frame = 0;
	    _this.index = -1;
	    return _this;
	  }
	  VirtualTimeScheduler.prototype.flush = function () {
	    var _a = this,
	      actions = _a.actions,
	      maxFrames = _a.maxFrames;
	    var error;
	    var action;
	    while ((action = actions[0]) && action.delay <= maxFrames) {
	      actions.shift();
	      this.frame = action.delay;
	      if (error = action.execute(action.state, action.delay)) {
	        break;
	      }
	    }
	    if (error) {
	      while (action = actions.shift()) {
	        action.unsubscribe();
	      }
	      throw error;
	    }
	  };
	  VirtualTimeScheduler.frameTimeFactor = 10;
	  return VirtualTimeScheduler;
	}(AsyncScheduler_1.AsyncScheduler);
	VirtualTimeScheduler$1.VirtualTimeScheduler = VirtualTimeScheduler;
	var VirtualAction = /*#__PURE__*/function (_super) {
	  __extends(VirtualAction, _super);
	  function VirtualAction(scheduler, work, index) {
	    if (index === void 0) {
	      index = scheduler.index += 1;
	    }
	    var _this = _super.call(this, scheduler, work) || this;
	    _this.scheduler = scheduler;
	    _this.work = work;
	    _this.index = index;
	    _this.active = true;
	    _this.index = scheduler.index = index;
	    return _this;
	  }
	  VirtualAction.prototype.schedule = function (state, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }
	    if (Number.isFinite(delay)) {
	      if (!this.id) {
	        return _super.prototype.schedule.call(this, state, delay);
	      }
	      this.active = false;
	      var action = new VirtualAction(this.scheduler, this.work);
	      this.add(action);
	      return action.schedule(state, delay);
	    } else {
	      return Subscription_1$4.Subscription.EMPTY;
	    }
	  };
	  VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	    if (delay === void 0) {
	      delay = 0;
	    }
	    this.delay = scheduler.frame + delay;
	    var actions = scheduler.actions;
	    actions.push(this);
	    actions.sort(VirtualAction.sortActions);
	    return 1;
	  };
	  VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	    return undefined;
	  };
	  VirtualAction.prototype._execute = function (state, delay) {
	    if (this.active === true) {
	      return _super.prototype._execute.call(this, state, delay);
	    }
	  };
	  VirtualAction.sortActions = function (a, b) {
	    if (a.delay === b.delay) {
	      if (a.index === b.index) {
	        return 0;
	      } else if (a.index > b.index) {
	        return 1;
	      } else {
	        return -1;
	      }
	    } else if (a.delay > b.delay) {
	      return 1;
	    } else {
	      return -1;
	    }
	  };
	  return VirtualAction;
	}(AsyncAction_1.AsyncAction);
	VirtualTimeScheduler$1.VirtualAction = VirtualAction;

	var Notification = {};

	var empty = {};

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.empty = exports.EMPTY = void 0;
	  var Observable_1 = Observable$1;
	  exports.EMPTY = /*#__PURE__*/new Observable_1.Observable(function (subscriber) {
	    return subscriber.complete();
	  });
	  function empty(scheduler) {
	    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
	  }
	  exports.empty = empty;
	  function emptyScheduled(scheduler) {
	    return new Observable_1.Observable(function (subscriber) {
	      return scheduler.schedule(function () {
	        return subscriber.complete();
	      });
	    });
	  }
	})(empty);

	var of$1 = {};

	var args = {};

	var isScheduler$1 = {};

	Object.defineProperty(isScheduler$1, "__esModule", {
	  value: true
	});
	isScheduler$1.isScheduler = void 0;
	var isFunction_1$m = isFunction$1;
	function isScheduler(value) {
	  return value && isFunction_1$m.isFunction(value.schedule);
	}
	isScheduler$1.isScheduler = isScheduler;

	Object.defineProperty(args, "__esModule", {
	  value: true
	});
	args.popNumber = args.popScheduler = args.popResultSelector = void 0;
	var isFunction_1$l = isFunction$1;
	var isScheduler_1$3 = isScheduler$1;
	function last$2(arr) {
	  return arr[arr.length - 1];
	}
	function popResultSelector(args) {
	  return isFunction_1$l.isFunction(last$2(args)) ? args.pop() : undefined;
	}
	args.popResultSelector = popResultSelector;
	function popScheduler(args) {
	  return isScheduler_1$3.isScheduler(last$2(args)) ? args.pop() : undefined;
	}
	args.popScheduler = popScheduler;
	function popNumber(args, defaultValue) {
	  return typeof last$2(args) === 'number' ? args.pop() : defaultValue;
	}
	args.popNumber = popNumber;

	var from$2 = {};

	var scheduled$1 = {};

	var scheduleObservable$1 = {};

	var innerFrom$1 = {};

	var isArrayLike = {};

	Object.defineProperty(isArrayLike, "__esModule", {
	  value: true
	});
	isArrayLike.isArrayLike = void 0;
	isArrayLike.isArrayLike = function (x) {
	  return x && typeof x.length === 'number' && typeof x !== 'function';
	};

	var isPromise$1 = {};

	Object.defineProperty(isPromise$1, "__esModule", {
	  value: true
	});
	isPromise$1.isPromise = void 0;
	var isFunction_1$k = isFunction$1;
	function isPromise(value) {
	  return isFunction_1$k.isFunction(value === null || value === void 0 ? void 0 : value.then);
	}
	isPromise$1.isPromise = isPromise;

	var isInteropObservable$1 = {};

	Object.defineProperty(isInteropObservable$1, "__esModule", {
	  value: true
	});
	isInteropObservable$1.isInteropObservable = void 0;
	var observable_1$1 = observable;
	var isFunction_1$j = isFunction$1;
	function isInteropObservable(input) {
	  return isFunction_1$j.isFunction(input[observable_1$1.observable]);
	}
	isInteropObservable$1.isInteropObservable = isInteropObservable;

	var isAsyncIterable$1 = {};

	Object.defineProperty(isAsyncIterable$1, "__esModule", {
	  value: true
	});
	isAsyncIterable$1.isAsyncIterable = void 0;
	var isFunction_1$i = isFunction$1;
	function isAsyncIterable(obj) {
	  return Symbol.asyncIterator && isFunction_1$i.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
	}
	isAsyncIterable$1.isAsyncIterable = isAsyncIterable;

	var throwUnobservableError = {};

	Object.defineProperty(throwUnobservableError, "__esModule", {
	  value: true
	});
	throwUnobservableError.createInvalidObservableTypeError = void 0;
	function createInvalidObservableTypeError(input) {
	  return new TypeError("You provided " + (input !== null && _typeof(input) === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
	}
	throwUnobservableError.createInvalidObservableTypeError = createInvalidObservableTypeError;

	var isIterable$1 = {};

	var iterator = {};

	Object.defineProperty(iterator, "__esModule", {
	  value: true
	});
	iterator.iterator = iterator.getSymbolIterator = void 0;
	function getSymbolIterator() {
	  if (typeof Symbol !== 'function' || !Symbol.iterator) {
	    return '@@iterator';
	  }
	  return Symbol.iterator;
	}
	iterator.getSymbolIterator = getSymbolIterator;
	iterator.iterator = /*#__PURE__*/getSymbolIterator();

	Object.defineProperty(isIterable$1, "__esModule", {
	  value: true
	});
	isIterable$1.isIterable = void 0;
	var iterator_1$1 = iterator;
	var isFunction_1$h = isFunction$1;
	function isIterable(input) {
	  return isFunction_1$h.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1$1.iterator]);
	}
	isIterable$1.isIterable = isIterable;

	var isReadableStreamLike$1 = {};

	var __generator$2 = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
	  var _ = {
	      label: 0,
	      sent: function sent() {
	        if (t[0] & 1) throw t[1];
	        return t[1];
	      },
	      trys: [],
	      ops: []
	    },
	    f,
	    y,
	    t,
	    g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
	    return this;
	  }), g;
	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }
	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");
	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];
	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;
	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };
	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;
	        case 7:
	          op = _.ops.pop();
	          _.trys.pop();
	          continue;
	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }
	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }
	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }
	          if (t && _.label < t[2]) {
	            _.label = t[2];
	            _.ops.push(op);
	            break;
	          }
	          if (t[2]) _.ops.pop();
	          _.trys.pop();
	          continue;
	      }
	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }
	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	var __await = commonjsGlobal && commonjsGlobal.__await || function (v) {
	  return this instanceof __await ? (this.v = v, this) : new __await(v);
	};
	var __asyncGenerator = commonjsGlobal && commonjsGlobal.__asyncGenerator || function (thisArg, _arguments, generator) {
	  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	  var g = generator.apply(thisArg, _arguments || []),
	    i,
	    q = [];
	  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
	    return this;
	  }, i;
	  function verb(n) {
	    if (g[n]) i[n] = function (v) {
	      return new Promise(function (a, b) {
	        q.push([n, v, a, b]) > 1 || resume(n, v);
	      });
	    };
	  }
	  function resume(n, v) {
	    try {
	      step(g[n](v));
	    } catch (e) {
	      settle(q[0][3], e);
	    }
	  }
	  function step(r) {
	    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
	  }
	  function fulfill(value) {
	    resume("next", value);
	  }
	  function reject(value) {
	    resume("throw", value);
	  }
	  function settle(f, v) {
	    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
	  }
	};
	Object.defineProperty(isReadableStreamLike$1, "__esModule", {
	  value: true
	});
	isReadableStreamLike$1.isReadableStreamLike = isReadableStreamLike$1.readableStreamLikeToAsyncGenerator = void 0;
	var isFunction_1$g = isFunction$1;
	function readableStreamLikeToAsyncGenerator(readableStream) {
	  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
	    var reader, _a, value, done;
	    return __generator$2(this, function (_b) {
	      switch (_b.label) {
	        case 0:
	          reader = readableStream.getReader();
	          _b.label = 1;
	        case 1:
	          _b.trys.push([1,, 9, 10]);
	          _b.label = 2;
	        case 2:
	          return [4, __await(reader.read())];
	        case 3:
	          _a = _b.sent(), value = _a.value, done = _a.done;
	          if (!done) return [3, 5];
	          return [4, __await(void 0)];
	        case 4:
	          return [2, _b.sent()];
	        case 5:
	          return [4, __await(value)];
	        case 6:
	          return [4, _b.sent()];
	        case 7:
	          _b.sent();
	          return [3, 2];
	        case 8:
	          return [3, 10];
	        case 9:
	          reader.releaseLock();
	          return [7];
	        case 10:
	          return [2];
	      }
	    });
	  });
	}
	isReadableStreamLike$1.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
	function isReadableStreamLike(obj) {
	  return isFunction_1$g.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
	}
	isReadableStreamLike$1.isReadableStreamLike = isReadableStreamLike;

	var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }
	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }
	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }
	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }
	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};
	var __generator$1 = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
	  var _ = {
	      label: 0,
	      sent: function sent() {
	        if (t[0] & 1) throw t[1];
	        return t[1];
	      },
	      trys: [],
	      ops: []
	    },
	    f,
	    y,
	    t,
	    g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
	    return this;
	  }), g;
	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }
	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");
	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];
	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;
	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };
	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;
	        case 7:
	          op = _.ops.pop();
	          _.trys.pop();
	          continue;
	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }
	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }
	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }
	          if (t && _.label < t[2]) {
	            _.label = t[2];
	            _.ops.push(op);
	            break;
	          }
	          if (t[2]) _.ops.pop();
	          _.trys.pop();
	          continue;
	      }
	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }
	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	var __asyncValues = commonjsGlobal && commonjsGlobal.__asyncValues || function (o) {
	  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	  var m = o[Symbol.asyncIterator],
	    i;
	  return m ? m.call(o) : (o = typeof __values$6 === "function" ? __values$6(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
	    return this;
	  }, i);
	  function verb(n) {
	    i[n] = o[n] && function (v) {
	      return new Promise(function (resolve, reject) {
	        v = o[n](v), settle(resolve, reject, v.done, v.value);
	      });
	    };
	  }
	  function settle(resolve, reject, d, v) {
	    Promise.resolve(v).then(function (v) {
	      resolve({
	        value: v,
	        done: d
	      });
	    }, reject);
	  }
	};
	var __values$6 = commonjsGlobal && commonjsGlobal.__values || function (o) {
	  var s = typeof Symbol === "function" && Symbol.iterator,
	    m = s && o[s],
	    i = 0;
	  if (m) return m.call(o);
	  if (o && typeof o.length === "number") return {
	    next: function next() {
	      if (o && i >= o.length) o = void 0;
	      return {
	        value: o && o[i++],
	        done: !o
	      };
	    }
	  };
	  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(innerFrom$1, "__esModule", {
	  value: true
	});
	innerFrom$1.fromReadableStreamLike = innerFrom$1.fromAsyncIterable = innerFrom$1.fromIterable = innerFrom$1.fromPromise = innerFrom$1.fromArrayLike = innerFrom$1.fromInteropObservable = innerFrom$1.innerFrom = void 0;
	var isArrayLike_1$2 = isArrayLike;
	var isPromise_1$1 = isPromise$1;
	var Observable_1$k = Observable$1;
	var isInteropObservable_1$1 = isInteropObservable$1;
	var isAsyncIterable_1$1 = isAsyncIterable$1;
	var throwUnobservableError_1$1 = throwUnobservableError;
	var isIterable_1$1 = isIterable$1;
	var isReadableStreamLike_1$2 = isReadableStreamLike$1;
	var isFunction_1$f = isFunction$1;
	var reportUnhandledError_1 = reportUnhandledError$1;
	var observable_1 = observable;
	function innerFrom(input) {
	  if (input instanceof Observable_1$k.Observable) {
	    return input;
	  }
	  if (input != null) {
	    if (isInteropObservable_1$1.isInteropObservable(input)) {
	      return fromInteropObservable(input);
	    }
	    if (isArrayLike_1$2.isArrayLike(input)) {
	      return fromArrayLike(input);
	    }
	    if (isPromise_1$1.isPromise(input)) {
	      return fromPromise(input);
	    }
	    if (isAsyncIterable_1$1.isAsyncIterable(input)) {
	      return fromAsyncIterable(input);
	    }
	    if (isIterable_1$1.isIterable(input)) {
	      return fromIterable(input);
	    }
	    if (isReadableStreamLike_1$2.isReadableStreamLike(input)) {
	      return fromReadableStreamLike(input);
	    }
	  }
	  throw throwUnobservableError_1$1.createInvalidObservableTypeError(input);
	}
	innerFrom$1.innerFrom = innerFrom;
	function fromInteropObservable(obj) {
	  return new Observable_1$k.Observable(function (subscriber) {
	    var obs = obj[observable_1.observable]();
	    if (isFunction_1$f.isFunction(obs.subscribe)) {
	      return obs.subscribe(subscriber);
	    }
	    throw new TypeError('Provided object does not correctly implement Symbol.observable');
	  });
	}
	innerFrom$1.fromInteropObservable = fromInteropObservable;
	function fromArrayLike(array) {
	  return new Observable_1$k.Observable(function (subscriber) {
	    for (var i = 0; i < array.length && !subscriber.closed; i++) {
	      subscriber.next(array[i]);
	    }
	    subscriber.complete();
	  });
	}
	innerFrom$1.fromArrayLike = fromArrayLike;
	function fromPromise(promise) {
	  return new Observable_1$k.Observable(function (subscriber) {
	    promise.then(function (value) {
	      if (!subscriber.closed) {
	        subscriber.next(value);
	        subscriber.complete();
	      }
	    }, function (err) {
	      return subscriber.error(err);
	    }).then(null, reportUnhandledError_1.reportUnhandledError);
	  });
	}
	innerFrom$1.fromPromise = fromPromise;
	function fromIterable(iterable) {
	  return new Observable_1$k.Observable(function (subscriber) {
	    var e_1, _a;
	    try {
	      for (var iterable_1 = __values$6(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
	        var value = iterable_1_1.value;
	        subscriber.next(value);
	        if (subscriber.closed) {
	          return;
	        }
	      }
	    } catch (e_1_1) {
	      e_1 = {
	        error: e_1_1
	      };
	    } finally {
	      try {
	        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1["return"])) _a.call(iterable_1);
	      } finally {
	        if (e_1) throw e_1.error;
	      }
	    }
	    subscriber.complete();
	  });
	}
	innerFrom$1.fromIterable = fromIterable;
	function fromAsyncIterable(asyncIterable) {
	  return new Observable_1$k.Observable(function (subscriber) {
	    process(asyncIterable, subscriber)["catch"](function (err) {
	      return subscriber.error(err);
	    });
	  });
	}
	innerFrom$1.fromAsyncIterable = fromAsyncIterable;
	function fromReadableStreamLike(readableStream) {
	  return fromAsyncIterable(isReadableStreamLike_1$2.readableStreamLikeToAsyncGenerator(readableStream));
	}
	innerFrom$1.fromReadableStreamLike = fromReadableStreamLike;
	function process(asyncIterable, subscriber) {
	  var asyncIterable_1, asyncIterable_1_1;
	  var e_2, _a;
	  return __awaiter(this, void 0, void 0, function () {
	    var value, e_2_1;
	    return __generator$1(this, function (_b) {
	      switch (_b.label) {
	        case 0:
	          _b.trys.push([0, 5, 6, 11]);
	          asyncIterable_1 = __asyncValues(asyncIterable);
	          _b.label = 1;
	        case 1:
	          return [4, asyncIterable_1.next()];
	        case 2:
	          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
	          value = asyncIterable_1_1.value;
	          subscriber.next(value);
	          if (subscriber.closed) {
	            return [2];
	          }
	          _b.label = 3;
	        case 3:
	          return [3, 1];
	        case 4:
	          return [3, 11];
	        case 5:
	          e_2_1 = _b.sent();
	          e_2 = {
	            error: e_2_1
	          };
	          return [3, 11];
	        case 6:
	          _b.trys.push([6,, 9, 10]);
	          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1["return"]))) return [3, 8];
	          return [4, _a.call(asyncIterable_1)];
	        case 7:
	          _b.sent();
	          _b.label = 8;
	        case 8:
	          return [3, 10];
	        case 9:
	          if (e_2) throw e_2.error;
	          return [7];
	        case 10:
	          return [7];
	        case 11:
	          subscriber.complete();
	          return [2];
	      }
	    });
	  });
	}

	var observeOn$1 = {};

	var executeSchedule$1 = {};

	Object.defineProperty(executeSchedule$1, "__esModule", {
	  value: true
	});
	executeSchedule$1.executeSchedule = void 0;
	function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
	  if (delay === void 0) {
	    delay = 0;
	  }
	  if (repeat === void 0) {
	    repeat = false;
	  }
	  var scheduleSubscription = scheduler.schedule(function () {
	    work();
	    if (repeat) {
	      parentSubscription.add(this.schedule(null, delay));
	    } else {
	      this.unsubscribe();
	    }
	  }, delay);
	  parentSubscription.add(scheduleSubscription);
	  if (!repeat) {
	    return scheduleSubscription;
	  }
	}
	executeSchedule$1.executeSchedule = executeSchedule;

	Object.defineProperty(observeOn$1, "__esModule", {
	  value: true
	});
	observeOn$1.observeOn = void 0;
	var executeSchedule_1$6 = executeSchedule$1;
	var lift_1$12 = lift;
	var OperatorSubscriber_1$T = OperatorSubscriber$1;
	function observeOn(scheduler, delay) {
	  if (delay === void 0) {
	    delay = 0;
	  }
	  return lift_1$12.operate(function (source, subscriber) {
	    source.subscribe(OperatorSubscriber_1$T.createOperatorSubscriber(subscriber, function (value) {
	      return executeSchedule_1$6.executeSchedule(subscriber, scheduler, function () {
	        return subscriber.next(value);
	      }, delay);
	    }, function () {
	      return executeSchedule_1$6.executeSchedule(subscriber, scheduler, function () {
	        return subscriber.complete();
	      }, delay);
	    }, function (err) {
	      return executeSchedule_1$6.executeSchedule(subscriber, scheduler, function () {
	        return subscriber.error(err);
	      }, delay);
	    }));
	  });
	}
	observeOn$1.observeOn = observeOn;

	var subscribeOn$1 = {};

	Object.defineProperty(subscribeOn$1, "__esModule", {
	  value: true
	});
	subscribeOn$1.subscribeOn = void 0;
	var lift_1$11 = lift;
	function subscribeOn(scheduler, delay) {
	  if (delay === void 0) {
	    delay = 0;
	  }
	  return lift_1$11.operate(function (source, subscriber) {
	    subscriber.add(scheduler.schedule(function () {
	      return source.subscribe(subscriber);
	    }, delay));
	  });
	}
	subscribeOn$1.subscribeOn = subscribeOn;

	Object.defineProperty(scheduleObservable$1, "__esModule", {
	  value: true
	});
	scheduleObservable$1.scheduleObservable = void 0;
	var innerFrom_1$D = innerFrom$1;
	var observeOn_1$2 = observeOn$1;
	var subscribeOn_1$2 = subscribeOn$1;
	function scheduleObservable(input, scheduler) {
	  return innerFrom_1$D.innerFrom(input).pipe(subscribeOn_1$2.subscribeOn(scheduler), observeOn_1$2.observeOn(scheduler));
	}
	scheduleObservable$1.scheduleObservable = scheduleObservable;

	var schedulePromise$1 = {};

	Object.defineProperty(schedulePromise$1, "__esModule", {
	  value: true
	});
	schedulePromise$1.schedulePromise = void 0;
	var innerFrom_1$C = innerFrom$1;
	var observeOn_1$1 = observeOn$1;
	var subscribeOn_1$1 = subscribeOn$1;
	function schedulePromise(input, scheduler) {
	  return innerFrom_1$C.innerFrom(input).pipe(subscribeOn_1$1.subscribeOn(scheduler), observeOn_1$1.observeOn(scheduler));
	}
	schedulePromise$1.schedulePromise = schedulePromise;

	var scheduleArray$1 = {};

	Object.defineProperty(scheduleArray$1, "__esModule", {
	  value: true
	});
	scheduleArray$1.scheduleArray = void 0;
	var Observable_1$j = Observable$1;
	function scheduleArray(input, scheduler) {
	  return new Observable_1$j.Observable(function (subscriber) {
	    var i = 0;
	    return scheduler.schedule(function () {
	      if (i === input.length) {
	        subscriber.complete();
	      } else {
	        subscriber.next(input[i++]);
	        if (!subscriber.closed) {
	          this.schedule();
	        }
	      }
	    });
	  });
	}
	scheduleArray$1.scheduleArray = scheduleArray;

	var scheduleIterable$1 = {};

	Object.defineProperty(scheduleIterable$1, "__esModule", {
	  value: true
	});
	scheduleIterable$1.scheduleIterable = void 0;
	var Observable_1$i = Observable$1;
	var iterator_1 = iterator;
	var isFunction_1$e = isFunction$1;
	var executeSchedule_1$5 = executeSchedule$1;
	function scheduleIterable(input, scheduler) {
	  return new Observable_1$i.Observable(function (subscriber) {
	    var iterator;
	    executeSchedule_1$5.executeSchedule(subscriber, scheduler, function () {
	      iterator = input[iterator_1.iterator]();
	      executeSchedule_1$5.executeSchedule(subscriber, scheduler, function () {
	        var _a;
	        var value;
	        var done;
	        try {
	          _a = iterator.next(), value = _a.value, done = _a.done;
	        } catch (err) {
	          subscriber.error(err);
	          return;
	        }
	        if (done) {
	          subscriber.complete();
	        } else {
	          subscriber.next(value);
	        }
	      }, 0, true);
	    });
	    return function () {
	      return isFunction_1$e.isFunction(iterator === null || iterator === void 0 ? void 0 : iterator["return"]) && iterator["return"]();
	    };
	  });
	}
	scheduleIterable$1.scheduleIterable = scheduleIterable;

	var scheduleAsyncIterable$1 = {};

	Object.defineProperty(scheduleAsyncIterable$1, "__esModule", {
	  value: true
	});
	scheduleAsyncIterable$1.scheduleAsyncIterable = void 0;
	var Observable_1$h = Observable$1;
	var executeSchedule_1$4 = executeSchedule$1;
	function scheduleAsyncIterable(input, scheduler) {
	  if (!input) {
	    throw new Error('Iterable cannot be null');
	  }
	  return new Observable_1$h.Observable(function (subscriber) {
	    executeSchedule_1$4.executeSchedule(subscriber, scheduler, function () {
	      var iterator = input[Symbol.asyncIterator]();
	      executeSchedule_1$4.executeSchedule(subscriber, scheduler, function () {
	        iterator.next().then(function (result) {
	          if (result.done) {
	            subscriber.complete();
	          } else {
	            subscriber.next(result.value);
	          }
	        });
	      }, 0, true);
	    });
	  });
	}
	scheduleAsyncIterable$1.scheduleAsyncIterable = scheduleAsyncIterable;

	var scheduleReadableStreamLike$1 = {};

	Object.defineProperty(scheduleReadableStreamLike$1, "__esModule", {
	  value: true
	});
	scheduleReadableStreamLike$1.scheduleReadableStreamLike = void 0;
	var scheduleAsyncIterable_1$1 = scheduleAsyncIterable$1;
	var isReadableStreamLike_1$1 = isReadableStreamLike$1;
	function scheduleReadableStreamLike(input, scheduler) {
	  return scheduleAsyncIterable_1$1.scheduleAsyncIterable(isReadableStreamLike_1$1.readableStreamLikeToAsyncGenerator(input), scheduler);
	}
	scheduleReadableStreamLike$1.scheduleReadableStreamLike = scheduleReadableStreamLike;

	Object.defineProperty(scheduled$1, "__esModule", {
	  value: true
	});
	scheduled$1.scheduled = void 0;
	var scheduleObservable_1 = scheduleObservable$1;
	var schedulePromise_1 = schedulePromise$1;
	var scheduleArray_1 = scheduleArray$1;
	var scheduleIterable_1$1 = scheduleIterable$1;
	var scheduleAsyncIterable_1 = scheduleAsyncIterable$1;
	var isInteropObservable_1 = isInteropObservable$1;
	var isPromise_1 = isPromise$1;
	var isArrayLike_1$1 = isArrayLike;
	var isIterable_1 = isIterable$1;
	var isAsyncIterable_1 = isAsyncIterable$1;
	var throwUnobservableError_1 = throwUnobservableError;
	var isReadableStreamLike_1 = isReadableStreamLike$1;
	var scheduleReadableStreamLike_1 = scheduleReadableStreamLike$1;
	function scheduled(input, scheduler) {
	  if (input != null) {
	    if (isInteropObservable_1.isInteropObservable(input)) {
	      return scheduleObservable_1.scheduleObservable(input, scheduler);
	    }
	    if (isArrayLike_1$1.isArrayLike(input)) {
	      return scheduleArray_1.scheduleArray(input, scheduler);
	    }
	    if (isPromise_1.isPromise(input)) {
	      return schedulePromise_1.schedulePromise(input, scheduler);
	    }
	    if (isAsyncIterable_1.isAsyncIterable(input)) {
	      return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
	    }
	    if (isIterable_1.isIterable(input)) {
	      return scheduleIterable_1$1.scheduleIterable(input, scheduler);
	    }
	    if (isReadableStreamLike_1.isReadableStreamLike(input)) {
	      return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
	    }
	  }
	  throw throwUnobservableError_1.createInvalidObservableTypeError(input);
	}
	scheduled$1.scheduled = scheduled;

	Object.defineProperty(from$2, "__esModule", {
	  value: true
	});
	from$2.from = void 0;
	var scheduled_1 = scheduled$1;
	var innerFrom_1$B = innerFrom$1;
	function from$1(input, scheduler) {
	  return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1$B.innerFrom(input);
	}
	from$2.from = from$1;

	Object.defineProperty(of$1, "__esModule", {
	  value: true
	});
	of$1.of = void 0;
	var args_1$c = args;
	var from_1$6 = from$2;
	function of() {
	  var args = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    args[_i] = arguments[_i];
	  }
	  var scheduler = args_1$c.popScheduler(args);
	  return from_1$6.from(args, scheduler);
	}
	of$1.of = of;

	var throwError$1 = {};

	Object.defineProperty(throwError$1, "__esModule", {
	  value: true
	});
	throwError$1.throwError = void 0;
	var Observable_1$g = Observable$1;
	var isFunction_1$d = isFunction$1;
	function throwError(errorOrErrorFactory, scheduler) {
	  var errorFactory = isFunction_1$d.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function () {
	    return errorOrErrorFactory;
	  };
	  var init = function init(subscriber) {
	    return subscriber.error(errorFactory());
	  };
	  return new Observable_1$g.Observable(scheduler ? function (subscriber) {
	    return scheduler.schedule(init, 0, subscriber);
	  } : init);
	}
	throwError$1.throwError = throwError;

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.observeNotification = exports.Notification = exports.NotificationKind = void 0;
	  var empty_1 = empty;
	  var of_1 = of$1;
	  var throwError_1 = throwError$1;
	  var isFunction_1 = isFunction$1;
	  (function (NotificationKind) {
	    NotificationKind["NEXT"] = "N";
	    NotificationKind["ERROR"] = "E";
	    NotificationKind["COMPLETE"] = "C";
	  })(exports.NotificationKind || (exports.NotificationKind = {}));
	  var Notification = /*#__PURE__*/function () {
	    function Notification(kind, value, error) {
	      this.kind = kind;
	      this.value = value;
	      this.error = error;
	      this.hasValue = kind === 'N';
	    }
	    Notification.prototype.observe = function (observer) {
	      return observeNotification(this, observer);
	    };
	    Notification.prototype["do"] = function (nextHandler, errorHandler, completeHandler) {
	      var _a = this,
	        kind = _a.kind,
	        value = _a.value,
	        error = _a.error;
	      return kind === 'N' ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === 'E' ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
	    };
	    Notification.prototype.accept = function (nextOrObserver, error, complete) {
	      var _a;
	      return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this["do"](nextOrObserver, error, complete);
	    };
	    Notification.prototype.toObservable = function () {
	      var _a = this,
	        kind = _a.kind,
	        value = _a.value,
	        error = _a.error;
	      var result = kind === 'N' ? of_1.of(value) : kind === 'E' ? throwError_1.throwError(function () {
	        return error;
	      }) : kind === 'C' ? empty_1.EMPTY : 0;
	      if (!result) {
	        throw new TypeError("Unexpected notification kind " + kind);
	      }
	      return result;
	    };
	    Notification.createNext = function (value) {
	      return new Notification('N', value);
	    };
	    Notification.createError = function (err) {
	      return new Notification('E', undefined, err);
	    };
	    Notification.createComplete = function () {
	      return Notification.completeNotification;
	    };
	    Notification.completeNotification = /*#__PURE__*/new Notification('C');
	    return Notification;
	  }();
	  exports.Notification = Notification;
	  function observeNotification(notification, observer) {
	    var _a, _b, _c;
	    var _d = notification,
	      kind = _d.kind,
	      value = _d.value,
	      error = _d.error;
	    if (typeof kind !== 'string') {
	      throw new TypeError('Invalid notification, missing "kind"');
	    }
	    kind === 'N' ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === 'E' ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
	  }
	  exports.observeNotification = observeNotification;
	})(Notification);

	var isObservable$1 = {};

	Object.defineProperty(isObservable$1, "__esModule", {
	  value: true
	});
	isObservable$1.isObservable = void 0;
	var Observable_1$f = Observable$1;
	var isFunction_1$c = isFunction$1;
	function isObservable(obj) {
	  return !!obj && (obj instanceof Observable_1$f.Observable || isFunction_1$c.isFunction(obj.lift) && isFunction_1$c.isFunction(obj.subscribe));
	}
	isObservable$1.isObservable = isObservable;

	var lastValueFrom$1 = {};

	var EmptyError = {};

	Object.defineProperty(EmptyError, "__esModule", {
	  value: true
	});
	EmptyError.EmptyError = void 0;
	var createErrorClass_1$3 = createErrorClass$1;
	EmptyError.EmptyError = /*#__PURE__*/createErrorClass_1$3.createErrorClass(function (_super) {
	  return function EmptyErrorImpl() {
	    _super(this);
	    this.name = 'EmptyError';
	    this.message = 'no elements in sequence';
	  };
	});

	Object.defineProperty(lastValueFrom$1, "__esModule", {
	  value: true
	});
	lastValueFrom$1.lastValueFrom = void 0;
	var EmptyError_1$5 = EmptyError;
	function lastValueFrom(source, config) {
	  var hasConfig = _typeof(config) === 'object';
	  return new Promise(function (resolve, reject) {
	    var _hasValue = false;
	    var _value;
	    source.subscribe({
	      next: function next(value) {
	        _value = value;
	        _hasValue = true;
	      },
	      error: reject,
	      complete: function complete() {
	        if (_hasValue) {
	          resolve(_value);
	        } else if (hasConfig) {
	          resolve(config.defaultValue);
	        } else {
	          reject(new EmptyError_1$5.EmptyError());
	        }
	      }
	    });
	  });
	}
	lastValueFrom$1.lastValueFrom = lastValueFrom;

	var firstValueFrom$1 = {};

	Object.defineProperty(firstValueFrom$1, "__esModule", {
	  value: true
	});
	firstValueFrom$1.firstValueFrom = void 0;
	var EmptyError_1$4 = EmptyError;
	var Subscriber_1$1 = Subscriber;
	function firstValueFrom(source, config) {
	  var hasConfig = _typeof(config) === 'object';
	  return new Promise(function (resolve, reject) {
	    var subscriber = new Subscriber_1$1.SafeSubscriber({
	      next: function next(value) {
	        resolve(value);
	        subscriber.unsubscribe();
	      },
	      error: reject,
	      complete: function complete() {
	        if (hasConfig) {
	          resolve(config.defaultValue);
	        } else {
	          reject(new EmptyError_1$4.EmptyError());
	        }
	      }
	    });
	    source.subscribe(subscriber);
	  });
	}
	firstValueFrom$1.firstValueFrom = firstValueFrom;

	var ArgumentOutOfRangeError = {};

	Object.defineProperty(ArgumentOutOfRangeError, "__esModule", {
	  value: true
	});
	ArgumentOutOfRangeError.ArgumentOutOfRangeError = void 0;
	var createErrorClass_1$2 = createErrorClass$1;
	ArgumentOutOfRangeError.ArgumentOutOfRangeError = /*#__PURE__*/createErrorClass_1$2.createErrorClass(function (_super) {
	  return function ArgumentOutOfRangeErrorImpl() {
	    _super(this);
	    this.name = 'ArgumentOutOfRangeError';
	    this.message = 'argument out of range';
	  };
	});

	var NotFoundError = {};

	Object.defineProperty(NotFoundError, "__esModule", {
	  value: true
	});
	NotFoundError.NotFoundError = void 0;
	var createErrorClass_1$1 = createErrorClass$1;
	NotFoundError.NotFoundError = /*#__PURE__*/createErrorClass_1$1.createErrorClass(function (_super) {
	  return function NotFoundErrorImpl(message) {
	    _super(this);
	    this.name = 'NotFoundError';
	    this.message = message;
	  };
	});

	var SequenceError = {};

	Object.defineProperty(SequenceError, "__esModule", {
	  value: true
	});
	SequenceError.SequenceError = void 0;
	var createErrorClass_1 = createErrorClass$1;
	SequenceError.SequenceError = /*#__PURE__*/createErrorClass_1.createErrorClass(function (_super) {
	  return function SequenceErrorImpl(message) {
	    _super(this);
	    this.name = 'SequenceError';
	    this.message = message;
	  };
	});

	var timeout$1 = {};

	var isDate = {};

	Object.defineProperty(isDate, "__esModule", {
	  value: true
	});
	isDate.isValidDate = void 0;
	function isValidDate(value) {
	  return value instanceof Date && !isNaN(value);
	}
	isDate.isValidDate = isValidDate;

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.timeout = exports.TimeoutError = void 0;
	  var async_1 = async;
	  var isDate_1 = isDate;
	  var lift_1 = lift;
	  var innerFrom_1 = innerFrom$1;
	  var createErrorClass_1 = createErrorClass$1;
	  var OperatorSubscriber_1 = OperatorSubscriber$1;
	  var executeSchedule_1 = executeSchedule$1;
	  exports.TimeoutError = /*#__PURE__*/createErrorClass_1.createErrorClass(function (_super) {
	    return function TimeoutErrorImpl(info) {
	      if (info === void 0) {
	        info = null;
	      }
	      _super(this);
	      this.message = 'Timeout has occurred';
	      this.name = 'TimeoutError';
	      this.info = info;
	    };
	  });
	  function timeout(config, schedulerArg) {
	    var _a = isDate_1.isValidDate(config) ? {
	        first: config
	      } : typeof config === 'number' ? {
	        each: config
	      } : config,
	      first = _a.first,
	      each = _a.each,
	      _b = _a["with"],
	      _with = _b === void 0 ? timeoutErrorFactory : _b,
	      _c = _a.scheduler,
	      scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_1.asyncScheduler : _c,
	      _d = _a.meta,
	      meta = _d === void 0 ? null : _d;
	    if (first == null && each == null) {
	      throw new TypeError('No timeout provided.');
	    }
	    return lift_1.operate(function (source, subscriber) {
	      var originalSourceSubscription;
	      var timerSubscription;
	      var lastValue = null;
	      var seen = 0;
	      var startTimer = function startTimer(delay) {
	        timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function () {
	          try {
	            originalSourceSubscription.unsubscribe();
	            innerFrom_1.innerFrom(_with({
	              meta: meta,
	              lastValue: lastValue,
	              seen: seen
	            })).subscribe(subscriber);
	          } catch (err) {
	            subscriber.error(err);
	          }
	        }, delay);
	      };
	      originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	        timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
	        seen++;
	        subscriber.next(lastValue = value);
	        each > 0 && startTimer(each);
	      }, undefined, undefined, function () {
	        if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
	          timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
	        }
	        lastValue = null;
	      }));
	      !seen && startTimer(first != null ? typeof first === 'number' ? first : +first - scheduler.now() : each);
	    });
	  }
	  exports.timeout = timeout;
	  function timeoutErrorFactory(info) {
	    throw new exports.TimeoutError(info);
	  }
	})(timeout$1);

	var bindCallback$1 = {};

	var bindCallbackInternals$1 = {};

	var mapOneOrManyArgs$1 = {};

	var map$1 = {};

	Object.defineProperty(map$1, "__esModule", {
	  value: true
	});
	map$1.map = void 0;
	var lift_1$10 = lift;
	var OperatorSubscriber_1$S = OperatorSubscriber$1;
	function map(project, thisArg) {
	  return lift_1$10.operate(function (source, subscriber) {
	    var index = 0;
	    source.subscribe(OperatorSubscriber_1$S.createOperatorSubscriber(subscriber, function (value) {
	      subscriber.next(project.call(thisArg, value, index++));
	    }));
	  });
	}
	map$1.map = map;

	var __read$g = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	var __spreadArray$f = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	  return to;
	};
	Object.defineProperty(mapOneOrManyArgs$1, "__esModule", {
	  value: true
	});
	mapOneOrManyArgs$1.mapOneOrManyArgs = void 0;
	var map_1$5 = map$1;
	var isArray$2 = Array.isArray;
	function callOrApply(fn, args) {
	  return isArray$2(args) ? fn.apply(void 0, __spreadArray$f([], __read$g(args))) : fn(args);
	}
	function mapOneOrManyArgs(fn) {
	  return map_1$5.map(function (args) {
	    return callOrApply(fn, args);
	  });
	}
	mapOneOrManyArgs$1.mapOneOrManyArgs = mapOneOrManyArgs;

	var __read$f = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	var __spreadArray$e = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	  return to;
	};
	Object.defineProperty(bindCallbackInternals$1, "__esModule", {
	  value: true
	});
	bindCallbackInternals$1.bindCallbackInternals = void 0;
	var isScheduler_1$2 = isScheduler$1;
	var Observable_1$e = Observable$1;
	var subscribeOn_1 = subscribeOn$1;
	var mapOneOrManyArgs_1$6 = mapOneOrManyArgs$1;
	var observeOn_1 = observeOn$1;
	var AsyncSubject_1$1 = AsyncSubject$1;
	function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
	  if (resultSelector) {
	    if (isScheduler_1$2.isScheduler(resultSelector)) {
	      scheduler = resultSelector;
	    } else {
	      return function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	          args[_i] = arguments[_i];
	        }
	        return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1$6.mapOneOrManyArgs(resultSelector));
	      };
	    }
	  }
	  if (scheduler) {
	    return function () {
	      var args = [];
	      for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	      }
	      return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
	    };
	  }
	  return function () {
	    var _this = this;
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	      args[_i] = arguments[_i];
	    }
	    var subject = new AsyncSubject_1$1.AsyncSubject();
	    var uninitialized = true;
	    return new Observable_1$e.Observable(function (subscriber) {
	      var subs = subject.subscribe(subscriber);
	      if (uninitialized) {
	        uninitialized = false;
	        var isAsync_1 = false;
	        var isComplete_1 = false;
	        callbackFunc.apply(_this, __spreadArray$e(__spreadArray$e([], __read$f(args)), [function () {
	          var results = [];
	          for (var _i = 0; _i < arguments.length; _i++) {
	            results[_i] = arguments[_i];
	          }
	          if (isNodeStyle) {
	            var err = results.shift();
	            if (err != null) {
	              subject.error(err);
	              return;
	            }
	          }
	          subject.next(1 < results.length ? results : results[0]);
	          isComplete_1 = true;
	          if (isAsync_1) {
	            subject.complete();
	          }
	        }]));
	        if (isComplete_1) {
	          subject.complete();
	        }
	        isAsync_1 = true;
	      }
	      return subs;
	    });
	  };
	}
	bindCallbackInternals$1.bindCallbackInternals = bindCallbackInternals;

	Object.defineProperty(bindCallback$1, "__esModule", {
	  value: true
	});
	bindCallback$1.bindCallback = void 0;
	var bindCallbackInternals_1$1 = bindCallbackInternals$1;
	function bindCallback(callbackFunc, resultSelector, scheduler) {
	  return bindCallbackInternals_1$1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
	}
	bindCallback$1.bindCallback = bindCallback;

	var bindNodeCallback$1 = {};

	Object.defineProperty(bindNodeCallback$1, "__esModule", {
	  value: true
	});
	bindNodeCallback$1.bindNodeCallback = void 0;
	var bindCallbackInternals_1 = bindCallbackInternals$1;
	function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
	  return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
	}
	bindNodeCallback$1.bindNodeCallback = bindNodeCallback;

	var combineLatest$3 = {};

	var argsArgArrayOrObject$1 = {};

	Object.defineProperty(argsArgArrayOrObject$1, "__esModule", {
	  value: true
	});
	argsArgArrayOrObject$1.argsArgArrayOrObject = void 0;
	var isArray$1 = Array.isArray;
	var getPrototypeOf = Object.getPrototypeOf,
	  objectProto = Object.prototype,
	  getKeys = Object.keys;
	function argsArgArrayOrObject(args) {
	  if (args.length === 1) {
	    var first_1 = args[0];
	    if (isArray$1(first_1)) {
	      return {
	        args: first_1,
	        keys: null
	      };
	    }
	    if (isPOJO(first_1)) {
	      var keys = getKeys(first_1);
	      return {
	        args: keys.map(function (key) {
	          return first_1[key];
	        }),
	        keys: keys
	      };
	    }
	  }
	  return {
	    args: args,
	    keys: null
	  };
	}
	argsArgArrayOrObject$1.argsArgArrayOrObject = argsArgArrayOrObject;
	function isPOJO(obj) {
	  return obj && _typeof(obj) === 'object' && getPrototypeOf(obj) === objectProto;
	}

	var createObject$1 = {};

	Object.defineProperty(createObject$1, "__esModule", {
	  value: true
	});
	createObject$1.createObject = void 0;
	function createObject(keys, values) {
	  return keys.reduce(function (result, key, i) {
	    return result[key] = values[i], result;
	  }, {});
	}
	createObject$1.createObject = createObject;

	Object.defineProperty(combineLatest$3, "__esModule", {
	  value: true
	});
	combineLatest$3.combineLatestInit = combineLatest$3.combineLatest = void 0;
	var Observable_1$d = Observable$1;
	var argsArgArrayOrObject_1$1 = argsArgArrayOrObject$1;
	var from_1$5 = from$2;
	var identity_1$d = identity$1;
	var mapOneOrManyArgs_1$5 = mapOneOrManyArgs$1;
	var args_1$b = args;
	var createObject_1$1 = createObject$1;
	var OperatorSubscriber_1$R = OperatorSubscriber$1;
	var executeSchedule_1$3 = executeSchedule$1;
	function combineLatest$2() {
	  var args = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    args[_i] = arguments[_i];
	  }
	  var scheduler = args_1$b.popScheduler(args);
	  var resultSelector = args_1$b.popResultSelector(args);
	  var _a = argsArgArrayOrObject_1$1.argsArgArrayOrObject(args),
	    observables = _a.args,
	    keys = _a.keys;
	  if (observables.length === 0) {
	    return from_1$5.from([], scheduler);
	  }
	  var result = new Observable_1$d.Observable(combineLatestInit(observables, scheduler, keys ? function (values) {
	    return createObject_1$1.createObject(keys, values);
	  } : identity_1$d.identity));
	  return resultSelector ? result.pipe(mapOneOrManyArgs_1$5.mapOneOrManyArgs(resultSelector)) : result;
	}
	combineLatest$3.combineLatest = combineLatest$2;
	function combineLatestInit(observables, scheduler, valueTransform) {
	  if (valueTransform === void 0) {
	    valueTransform = identity_1$d.identity;
	  }
	  return function (subscriber) {
	    maybeSchedule(scheduler, function () {
	      var length = observables.length;
	      var values = new Array(length);
	      var active = length;
	      var remainingFirstValues = length;
	      var _loop_1 = function _loop_1(i) {
	        maybeSchedule(scheduler, function () {
	          var source = from_1$5.from(observables[i], scheduler);
	          var hasFirstValue = false;
	          source.subscribe(OperatorSubscriber_1$R.createOperatorSubscriber(subscriber, function (value) {
	            values[i] = value;
	            if (!hasFirstValue) {
	              hasFirstValue = true;
	              remainingFirstValues--;
	            }
	            if (!remainingFirstValues) {
	              subscriber.next(valueTransform(values.slice()));
	            }
	          }, function () {
	            if (! --active) {
	              subscriber.complete();
	            }
	          }));
	        }, subscriber);
	      };
	      for (var i = 0; i < length; i++) {
	        _loop_1(i);
	      }
	    }, subscriber);
	  };
	}
	combineLatest$3.combineLatestInit = combineLatestInit;
	function maybeSchedule(scheduler, execute, subscription) {
	  if (scheduler) {
	    executeSchedule_1$3.executeSchedule(subscription, scheduler, execute);
	  } else {
	    execute();
	  }
	}

	var concat$3 = {};

	var concatAll$1 = {};

	var mergeAll$1 = {};

	var mergeMap$1 = {};

	var mergeInternals$1 = {};

	Object.defineProperty(mergeInternals$1, "__esModule", {
	  value: true
	});
	mergeInternals$1.mergeInternals = void 0;
	var innerFrom_1$A = innerFrom$1;
	var executeSchedule_1$2 = executeSchedule$1;
	var OperatorSubscriber_1$Q = OperatorSubscriber$1;
	function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
	  var buffer = [];
	  var active = 0;
	  var index = 0;
	  var isComplete = false;
	  var checkComplete = function checkComplete() {
	    if (isComplete && !buffer.length && !active) {
	      subscriber.complete();
	    }
	  };
	  var outerNext = function outerNext(value) {
	    return active < concurrent ? doInnerSub(value) : buffer.push(value);
	  };
	  var doInnerSub = function doInnerSub(value) {
	    expand && subscriber.next(value);
	    active++;
	    var innerComplete = false;
	    innerFrom_1$A.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1$Q.createOperatorSubscriber(subscriber, function (innerValue) {
	      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
	      if (expand) {
	        outerNext(innerValue);
	      } else {
	        subscriber.next(innerValue);
	      }
	    }, function () {
	      innerComplete = true;
	    }, undefined, function () {
	      if (innerComplete) {
	        try {
	          active--;
	          var _loop_1 = function _loop_1() {
	            var bufferedValue = buffer.shift();
	            if (innerSubScheduler) {
	              executeSchedule_1$2.executeSchedule(subscriber, innerSubScheduler, function () {
	                return doInnerSub(bufferedValue);
	              });
	            } else {
	              doInnerSub(bufferedValue);
	            }
	          };
	          while (buffer.length && active < concurrent) {
	            _loop_1();
	          }
	          checkComplete();
	        } catch (err) {
	          subscriber.error(err);
	        }
	      }
	    }));
	  };
	  source.subscribe(OperatorSubscriber_1$Q.createOperatorSubscriber(subscriber, outerNext, function () {
	    isComplete = true;
	    checkComplete();
	  }));
	  return function () {
	    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
	  };
	}
	mergeInternals$1.mergeInternals = mergeInternals;

	Object.defineProperty(mergeMap$1, "__esModule", {
	  value: true
	});
	mergeMap$1.mergeMap = void 0;
	var map_1$4 = map$1;
	var innerFrom_1$z = innerFrom$1;
	var lift_1$$ = lift;
	var mergeInternals_1$2 = mergeInternals$1;
	var isFunction_1$b = isFunction$1;
	function mergeMap(project, resultSelector, concurrent) {
	  if (concurrent === void 0) {
	    concurrent = Infinity;
	  }
	  if (isFunction_1$b.isFunction(resultSelector)) {
	    return mergeMap(function (a, i) {
	      return map_1$4.map(function (b, ii) {
	        return resultSelector(a, b, i, ii);
	      })(innerFrom_1$z.innerFrom(project(a, i)));
	    }, concurrent);
	  } else if (typeof resultSelector === 'number') {
	    concurrent = resultSelector;
	  }
	  return lift_1$$.operate(function (source, subscriber) {
	    return mergeInternals_1$2.mergeInternals(source, subscriber, project, concurrent);
	  });
	}
	mergeMap$1.mergeMap = mergeMap;

	Object.defineProperty(mergeAll$1, "__esModule", {
	  value: true
	});
	mergeAll$1.mergeAll = void 0;
	var mergeMap_1$6 = mergeMap$1;
	var identity_1$c = identity$1;
	function mergeAll(concurrent) {
	  if (concurrent === void 0) {
	    concurrent = Infinity;
	  }
	  return mergeMap_1$6.mergeMap(identity_1$c.identity, concurrent);
	}
	mergeAll$1.mergeAll = mergeAll;

	Object.defineProperty(concatAll$1, "__esModule", {
	  value: true
	});
	concatAll$1.concatAll = void 0;
	var mergeAll_1$2 = mergeAll$1;
	function concatAll() {
	  return mergeAll_1$2.mergeAll(1);
	}
	concatAll$1.concatAll = concatAll;

	Object.defineProperty(concat$3, "__esModule", {
	  value: true
	});
	concat$3.concat = void 0;
	var concatAll_1$1 = concatAll$1;
	var args_1$a = args;
	var from_1$4 = from$2;
	function concat$2() {
	  var args = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    args[_i] = arguments[_i];
	  }
	  return concatAll_1$1.concatAll()(from_1$4.from(args, args_1$a.popScheduler(args)));
	}
	concat$3.concat = concat$2;

	var connectable$1 = {};

	var defer$1 = {};

	Object.defineProperty(defer$1, "__esModule", {
	  value: true
	});
	defer$1.defer = void 0;
	var Observable_1$c = Observable$1;
	var innerFrom_1$y = innerFrom$1;
	function defer(observableFactory) {
	  return new Observable_1$c.Observable(function (subscriber) {
	    innerFrom_1$y.innerFrom(observableFactory()).subscribe(subscriber);
	  });
	}
	defer$1.defer = defer;

	Object.defineProperty(connectable$1, "__esModule", {
	  value: true
	});
	connectable$1.connectable = void 0;
	var Subject_1$b = Subject$1;
	var Observable_1$b = Observable$1;
	var defer_1$2 = defer$1;
	var DEFAULT_CONFIG$1 = {
	  connector: function connector() {
	    return new Subject_1$b.Subject();
	  },
	  resetOnDisconnect: true
	};
	function connectable(source, config) {
	  if (config === void 0) {
	    config = DEFAULT_CONFIG$1;
	  }
	  var connection = null;
	  var connector = config.connector,
	    _a = config.resetOnDisconnect,
	    resetOnDisconnect = _a === void 0 ? true : _a;
	  var subject = connector();
	  var result = new Observable_1$b.Observable(function (subscriber) {
	    return subject.subscribe(subscriber);
	  });
	  result.connect = function () {
	    if (!connection || connection.closed) {
	      connection = defer_1$2.defer(function () {
	        return source;
	      }).subscribe(subject);
	      if (resetOnDisconnect) {
	        connection.add(function () {
	          return subject = connector();
	        });
	      }
	    }
	    return connection;
	  };
	  return result;
	}
	connectable$1.connectable = connectable;

	var forkJoin$1 = {};

	Object.defineProperty(forkJoin$1, "__esModule", {
	  value: true
	});
	forkJoin$1.forkJoin = void 0;
	var Observable_1$a = Observable$1;
	var argsArgArrayOrObject_1 = argsArgArrayOrObject$1;
	var innerFrom_1$x = innerFrom$1;
	var args_1$9 = args;
	var OperatorSubscriber_1$P = OperatorSubscriber$1;
	var mapOneOrManyArgs_1$4 = mapOneOrManyArgs$1;
	var createObject_1 = createObject$1;
	function forkJoin() {
	  var args = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    args[_i] = arguments[_i];
	  }
	  var resultSelector = args_1$9.popResultSelector(args);
	  var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args),
	    sources = _a.args,
	    keys = _a.keys;
	  var result = new Observable_1$a.Observable(function (subscriber) {
	    var length = sources.length;
	    if (!length) {
	      subscriber.complete();
	      return;
	    }
	    var values = new Array(length);
	    var remainingCompletions = length;
	    var remainingEmissions = length;
	    var _loop_1 = function _loop_1(sourceIndex) {
	      var hasValue = false;
	      innerFrom_1$x.innerFrom(sources[sourceIndex]).subscribe(OperatorSubscriber_1$P.createOperatorSubscriber(subscriber, function (value) {
	        if (!hasValue) {
	          hasValue = true;
	          remainingEmissions--;
	        }
	        values[sourceIndex] = value;
	      }, function () {
	        return remainingCompletions--;
	      }, undefined, function () {
	        if (!remainingCompletions || !hasValue) {
	          if (!remainingEmissions) {
	            subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
	          }
	          subscriber.complete();
	        }
	      }));
	    };
	    for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
	      _loop_1(sourceIndex);
	    }
	  });
	  return resultSelector ? result.pipe(mapOneOrManyArgs_1$4.mapOneOrManyArgs(resultSelector)) : result;
	}
	forkJoin$1.forkJoin = forkJoin;

	var fromEvent$1 = {};

	var __read$e = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	Object.defineProperty(fromEvent$1, "__esModule", {
	  value: true
	});
	fromEvent$1.fromEvent = void 0;
	var innerFrom_1$w = innerFrom$1;
	var Observable_1$9 = Observable$1;
	var mergeMap_1$5 = mergeMap$1;
	var isArrayLike_1 = isArrayLike;
	var isFunction_1$a = isFunction$1;
	var mapOneOrManyArgs_1$3 = mapOneOrManyArgs$1;
	var nodeEventEmitterMethods = ['addListener', 'removeListener'];
	var eventTargetMethods = ['addEventListener', 'removeEventListener'];
	var jqueryMethods = ['on', 'off'];
	function fromEvent(target, eventName, options, resultSelector) {
	  if (isFunction_1$a.isFunction(options)) {
	    resultSelector = options;
	    options = undefined;
	  }
	  if (resultSelector) {
	    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs_1$3.mapOneOrManyArgs(resultSelector));
	  }
	  var _a = __read$e(isEventTarget(target) ? eventTargetMethods.map(function (methodName) {
	      return function (handler) {
	        return target[methodName](eventName, handler, options);
	      };
	    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2),
	    add = _a[0],
	    remove = _a[1];
	  if (!add) {
	    if (isArrayLike_1.isArrayLike(target)) {
	      return mergeMap_1$5.mergeMap(function (subTarget) {
	        return fromEvent(subTarget, eventName, options);
	      })(innerFrom_1$w.innerFrom(target));
	    }
	  }
	  if (!add) {
	    throw new TypeError('Invalid event target');
	  }
	  return new Observable_1$9.Observable(function (subscriber) {
	    var handler = function handler() {
	      var args = [];
	      for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	      }
	      return subscriber.next(1 < args.length ? args : args[0]);
	    };
	    add(handler);
	    return function () {
	      return remove(handler);
	    };
	  });
	}
	fromEvent$1.fromEvent = fromEvent;
	function toCommonHandlerRegistry(target, eventName) {
	  return function (methodName) {
	    return function (handler) {
	      return target[methodName](eventName, handler);
	    };
	  };
	}
	function isNodeStyleEventEmitter(target) {
	  return isFunction_1$a.isFunction(target.addListener) && isFunction_1$a.isFunction(target.removeListener);
	}
	function isJQueryStyleEventEmitter(target) {
	  return isFunction_1$a.isFunction(target.on) && isFunction_1$a.isFunction(target.off);
	}
	function isEventTarget(target) {
	  return isFunction_1$a.isFunction(target.addEventListener) && isFunction_1$a.isFunction(target.removeEventListener);
	}

	var fromEventPattern$1 = {};

	Object.defineProperty(fromEventPattern$1, "__esModule", {
	  value: true
	});
	fromEventPattern$1.fromEventPattern = void 0;
	var Observable_1$8 = Observable$1;
	var isFunction_1$9 = isFunction$1;
	var mapOneOrManyArgs_1$2 = mapOneOrManyArgs$1;
	function fromEventPattern(addHandler, removeHandler, resultSelector) {
	  if (resultSelector) {
	    return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1$2.mapOneOrManyArgs(resultSelector));
	  }
	  return new Observable_1$8.Observable(function (subscriber) {
	    var handler = function handler() {
	      var e = [];
	      for (var _i = 0; _i < arguments.length; _i++) {
	        e[_i] = arguments[_i];
	      }
	      return subscriber.next(e.length === 1 ? e[0] : e);
	    };
	    var retValue = addHandler(handler);
	    return isFunction_1$9.isFunction(removeHandler) ? function () {
	      return removeHandler(handler, retValue);
	    } : undefined;
	  });
	}
	fromEventPattern$1.fromEventPattern = fromEventPattern;

	var generate$1 = {};

	var __generator = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
	  var _ = {
	      label: 0,
	      sent: function sent() {
	        if (t[0] & 1) throw t[1];
	        return t[1];
	      },
	      trys: [],
	      ops: []
	    },
	    f,
	    y,
	    t,
	    g;
	  return g = {
	    next: verb(0),
	    "throw": verb(1),
	    "return": verb(2)
	  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
	    return this;
	  }), g;
	  function verb(n) {
	    return function (v) {
	      return step([n, v]);
	    };
	  }
	  function step(op) {
	    if (f) throw new TypeError("Generator is already executing.");
	    while (_) try {
	      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	      if (y = 0, t) op = [op[0] & 2, t.value];
	      switch (op[0]) {
	        case 0:
	        case 1:
	          t = op;
	          break;
	        case 4:
	          _.label++;
	          return {
	            value: op[1],
	            done: false
	          };
	        case 5:
	          _.label++;
	          y = op[1];
	          op = [0];
	          continue;
	        case 7:
	          op = _.ops.pop();
	          _.trys.pop();
	          continue;
	        default:
	          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
	            _ = 0;
	            continue;
	          }
	          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
	            _.label = op[1];
	            break;
	          }
	          if (op[0] === 6 && _.label < t[1]) {
	            _.label = t[1];
	            t = op;
	            break;
	          }
	          if (t && _.label < t[2]) {
	            _.label = t[2];
	            _.ops.push(op);
	            break;
	          }
	          if (t[2]) _.ops.pop();
	          _.trys.pop();
	          continue;
	      }
	      op = body.call(thisArg, _);
	    } catch (e) {
	      op = [6, e];
	      y = 0;
	    } finally {
	      f = t = 0;
	    }
	    if (op[0] & 5) throw op[1];
	    return {
	      value: op[0] ? op[1] : void 0,
	      done: true
	    };
	  }
	};
	Object.defineProperty(generate$1, "__esModule", {
	  value: true
	});
	generate$1.generate = void 0;
	var identity_1$b = identity$1;
	var isScheduler_1$1 = isScheduler$1;
	var defer_1$1 = defer$1;
	var scheduleIterable_1 = scheduleIterable$1;
	function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
	  var _a, _b;
	  var resultSelector;
	  var initialState;
	  if (arguments.length === 1) {
	    _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1$b.identity : _b, scheduler = _a.scheduler;
	  } else {
	    initialState = initialStateOrOptions;
	    if (!resultSelectorOrScheduler || isScheduler_1$1.isScheduler(resultSelectorOrScheduler)) {
	      resultSelector = identity_1$b.identity;
	      scheduler = resultSelectorOrScheduler;
	    } else {
	      resultSelector = resultSelectorOrScheduler;
	    }
	  }
	  function gen() {
	    var state;
	    return __generator(this, function (_a) {
	      switch (_a.label) {
	        case 0:
	          state = initialState;
	          _a.label = 1;
	        case 1:
	          if (!(!condition || condition(state))) return [3, 4];
	          return [4, resultSelector(state)];
	        case 2:
	          _a.sent();
	          _a.label = 3;
	        case 3:
	          state = iterate(state);
	          return [3, 1];
	        case 4:
	          return [2];
	      }
	    });
	  }
	  return defer_1$1.defer(scheduler ? function () {
	    return scheduleIterable_1.scheduleIterable(gen(), scheduler);
	  } : gen);
	}
	generate$1.generate = generate;

	var iif$1 = {};

	Object.defineProperty(iif$1, "__esModule", {
	  value: true
	});
	iif$1.iif = void 0;
	var defer_1 = defer$1;
	function iif(condition, trueResult, falseResult) {
	  return defer_1.defer(function () {
	    return condition() ? trueResult : falseResult;
	  });
	}
	iif$1.iif = iif;

	var interval$1 = {};

	var timer$1 = {};

	Object.defineProperty(timer$1, "__esModule", {
	  value: true
	});
	timer$1.timer = void 0;
	var Observable_1$7 = Observable$1;
	var async_1$a = async;
	var isScheduler_1 = isScheduler$1;
	var isDate_1$1 = isDate;
	function timer(dueTime, intervalOrScheduler, scheduler) {
	  if (dueTime === void 0) {
	    dueTime = 0;
	  }
	  if (scheduler === void 0) {
	    scheduler = async_1$a.async;
	  }
	  var intervalDuration = -1;
	  if (intervalOrScheduler != null) {
	    if (isScheduler_1.isScheduler(intervalOrScheduler)) {
	      scheduler = intervalOrScheduler;
	    } else {
	      intervalDuration = intervalOrScheduler;
	    }
	  }
	  return new Observable_1$7.Observable(function (subscriber) {
	    var due = isDate_1$1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
	    if (due < 0) {
	      due = 0;
	    }
	    var n = 0;
	    return scheduler.schedule(function () {
	      if (!subscriber.closed) {
	        subscriber.next(n++);
	        if (0 <= intervalDuration) {
	          this.schedule(undefined, intervalDuration);
	        } else {
	          subscriber.complete();
	        }
	      }
	    }, due);
	  });
	}
	timer$1.timer = timer;

	Object.defineProperty(interval$1, "__esModule", {
	  value: true
	});
	interval$1.interval = void 0;
	var async_1$9 = async;
	var timer_1$5 = timer$1;
	function interval(period, scheduler) {
	  if (period === void 0) {
	    period = 0;
	  }
	  if (scheduler === void 0) {
	    scheduler = async_1$9.asyncScheduler;
	  }
	  if (period < 0) {
	    period = 0;
	  }
	  return timer_1$5.timer(period, period, scheduler);
	}
	interval$1.interval = interval;

	var merge$3 = {};

	Object.defineProperty(merge$3, "__esModule", {
	  value: true
	});
	merge$3.merge = void 0;
	var mergeAll_1$1 = mergeAll$1;
	var innerFrom_1$v = innerFrom$1;
	var empty_1$6 = empty;
	var args_1$8 = args;
	var from_1$3 = from$2;
	function merge$2() {
	  var args = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    args[_i] = arguments[_i];
	  }
	  var scheduler = args_1$8.popScheduler(args);
	  var concurrent = args_1$8.popNumber(args, Infinity);
	  var sources = args;
	  return !sources.length ? empty_1$6.EMPTY : sources.length === 1 ? innerFrom_1$v.innerFrom(sources[0]) : mergeAll_1$1.mergeAll(concurrent)(from_1$3.from(sources, scheduler));
	}
	merge$3.merge = merge$2;

	var never = {};

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.never = exports.NEVER = void 0;
	  var Observable_1 = Observable$1;
	  var noop_1 = noop$1;
	  exports.NEVER = /*#__PURE__*/new Observable_1.Observable(noop_1.noop);
	  function never() {
	    return exports.NEVER;
	  }
	  exports.never = never;
	})(never);

	var onErrorResumeNext$1 = {};

	var argsOrArgArray$1 = {};

	Object.defineProperty(argsOrArgArray$1, "__esModule", {
	  value: true
	});
	argsOrArgArray$1.argsOrArgArray = void 0;
	var isArray = Array.isArray;
	function argsOrArgArray(args) {
	  return args.length === 1 && isArray(args[0]) ? args[0] : args;
	}
	argsOrArgArray$1.argsOrArgArray = argsOrArgArray;

	Object.defineProperty(onErrorResumeNext$1, "__esModule", {
	  value: true
	});
	onErrorResumeNext$1.onErrorResumeNext = void 0;
	var Observable_1$6 = Observable$1;
	var argsOrArgArray_1$5 = argsOrArgArray$1;
	var OperatorSubscriber_1$O = OperatorSubscriber$1;
	var noop_1$c = noop$1;
	var innerFrom_1$u = innerFrom$1;
	function onErrorResumeNext() {
	  var sources = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    sources[_i] = arguments[_i];
	  }
	  var nextSources = argsOrArgArray_1$5.argsOrArgArray(sources);
	  return new Observable_1$6.Observable(function (subscriber) {
	    var sourceIndex = 0;
	    var subscribeNext = function subscribeNext() {
	      if (sourceIndex < nextSources.length) {
	        var nextSource = void 0;
	        try {
	          nextSource = innerFrom_1$u.innerFrom(nextSources[sourceIndex++]);
	        } catch (err) {
	          subscribeNext();
	          return;
	        }
	        var innerSubscriber = new OperatorSubscriber_1$O.OperatorSubscriber(subscriber, undefined, noop_1$c.noop, noop_1$c.noop);
	        nextSource.subscribe(innerSubscriber);
	        innerSubscriber.add(subscribeNext);
	      } else {
	        subscriber.complete();
	      }
	    };
	    subscribeNext();
	  });
	}
	onErrorResumeNext$1.onErrorResumeNext = onErrorResumeNext;

	var pairs$1 = {};

	Object.defineProperty(pairs$1, "__esModule", {
	  value: true
	});
	pairs$1.pairs = void 0;
	var from_1$2 = from$2;
	function pairs(obj, scheduler) {
	  return from_1$2.from(Object.entries(obj), scheduler);
	}
	pairs$1.pairs = pairs;

	var partition$1 = {};

	var not$1 = {};

	Object.defineProperty(not$1, "__esModule", {
	  value: true
	});
	not$1.not = void 0;
	function not(pred, thisArg) {
	  return function (value, index) {
	    return !pred.call(thisArg, value, index);
	  };
	}
	not$1.not = not;

	var filter$1 = {};

	Object.defineProperty(filter$1, "__esModule", {
	  value: true
	});
	filter$1.filter = void 0;
	var lift_1$_ = lift;
	var OperatorSubscriber_1$N = OperatorSubscriber$1;
	function filter(predicate, thisArg) {
	  return lift_1$_.operate(function (source, subscriber) {
	    var index = 0;
	    source.subscribe(OperatorSubscriber_1$N.createOperatorSubscriber(subscriber, function (value) {
	      return predicate.call(thisArg, value, index++) && subscriber.next(value);
	    }));
	  });
	}
	filter$1.filter = filter;

	Object.defineProperty(partition$1, "__esModule", {
	  value: true
	});
	partition$1.partition = void 0;
	var not_1 = not$1;
	var filter_1$4 = filter$1;
	var innerFrom_1$t = innerFrom$1;
	function partition(source, predicate, thisArg) {
	  return [filter_1$4.filter(predicate, thisArg)(innerFrom_1$t.innerFrom(source)), filter_1$4.filter(not_1.not(predicate, thisArg))(innerFrom_1$t.innerFrom(source))];
	}
	partition$1.partition = partition;

	var race$1 = {};

	Object.defineProperty(race$1, "__esModule", {
	  value: true
	});
	race$1.raceInit = race$1.race = void 0;
	var Observable_1$5 = Observable$1;
	var innerFrom_1$s = innerFrom$1;
	var argsOrArgArray_1$4 = argsOrArgArray$1;
	var OperatorSubscriber_1$M = OperatorSubscriber$1;
	function race() {
	  var sources = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    sources[_i] = arguments[_i];
	  }
	  sources = argsOrArgArray_1$4.argsOrArgArray(sources);
	  return sources.length === 1 ? innerFrom_1$s.innerFrom(sources[0]) : new Observable_1$5.Observable(raceInit(sources));
	}
	race$1.race = race;
	function raceInit(sources) {
	  return function (subscriber) {
	    var subscriptions = [];
	    var _loop_1 = function _loop_1(i) {
	      subscriptions.push(innerFrom_1$s.innerFrom(sources[i]).subscribe(OperatorSubscriber_1$M.createOperatorSubscriber(subscriber, function (value) {
	        if (subscriptions) {
	          for (var s = 0; s < subscriptions.length; s++) {
	            s !== i && subscriptions[s].unsubscribe();
	          }
	          subscriptions = null;
	        }
	        subscriber.next(value);
	      })));
	    };
	    for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
	      _loop_1(i);
	    }
	  };
	}
	race$1.raceInit = raceInit;

	var range$1 = {};

	Object.defineProperty(range$1, "__esModule", {
	  value: true
	});
	range$1.range = void 0;
	var Observable_1$4 = Observable$1;
	var empty_1$5 = empty;
	function range(start, count, scheduler) {
	  if (count == null) {
	    count = start;
	    start = 0;
	  }
	  if (count <= 0) {
	    return empty_1$5.EMPTY;
	  }
	  var end = count + start;
	  return new Observable_1$4.Observable(scheduler ? function (subscriber) {
	    var n = start;
	    return scheduler.schedule(function () {
	      if (n < end) {
	        subscriber.next(n++);
	        this.schedule();
	      } else {
	        subscriber.complete();
	      }
	    });
	  } : function (subscriber) {
	    var n = start;
	    while (n < end && !subscriber.closed) {
	      subscriber.next(n++);
	    }
	    subscriber.complete();
	  });
	}
	range$1.range = range;

	var using$1 = {};

	Object.defineProperty(using$1, "__esModule", {
	  value: true
	});
	using$1.using = void 0;
	var Observable_1$3 = Observable$1;
	var innerFrom_1$r = innerFrom$1;
	var empty_1$4 = empty;
	function using(resourceFactory, observableFactory) {
	  return new Observable_1$3.Observable(function (subscriber) {
	    var resource = resourceFactory();
	    var result = observableFactory(resource);
	    var source = result ? innerFrom_1$r.innerFrom(result) : empty_1$4.EMPTY;
	    source.subscribe(subscriber);
	    return function () {
	      if (resource) {
	        resource.unsubscribe();
	      }
	    };
	  });
	}
	using$1.using = using;

	var zip$3 = {};

	var __read$d = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	var __spreadArray$d = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	  return to;
	};
	Object.defineProperty(zip$3, "__esModule", {
	  value: true
	});
	zip$3.zip = void 0;
	var Observable_1$2 = Observable$1;
	var innerFrom_1$q = innerFrom$1;
	var argsOrArgArray_1$3 = argsOrArgArray$1;
	var empty_1$3 = empty;
	var OperatorSubscriber_1$L = OperatorSubscriber$1;
	var args_1$7 = args;
	function zip$2() {
	  var args = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    args[_i] = arguments[_i];
	  }
	  var resultSelector = args_1$7.popResultSelector(args);
	  var sources = argsOrArgArray_1$3.argsOrArgArray(args);
	  return sources.length ? new Observable_1$2.Observable(function (subscriber) {
	    var buffers = sources.map(function () {
	      return [];
	    });
	    var completed = sources.map(function () {
	      return false;
	    });
	    subscriber.add(function () {
	      buffers = completed = null;
	    });
	    var _loop_1 = function _loop_1(sourceIndex) {
	      innerFrom_1$q.innerFrom(sources[sourceIndex]).subscribe(OperatorSubscriber_1$L.createOperatorSubscriber(subscriber, function (value) {
	        buffers[sourceIndex].push(value);
	        if (buffers.every(function (buffer) {
	          return buffer.length;
	        })) {
	          var result = buffers.map(function (buffer) {
	            return buffer.shift();
	          });
	          subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray$d([], __read$d(result))) : result);
	          if (buffers.some(function (buffer, i) {
	            return !buffer.length && completed[i];
	          })) {
	            subscriber.complete();
	          }
	        }
	      }, function () {
	        completed[sourceIndex] = true;
	        !buffers[sourceIndex].length && subscriber.complete();
	      }));
	    };
	    for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
	      _loop_1(sourceIndex);
	    }
	    return function () {
	      buffers = completed = null;
	    };
	  }) : empty_1$3.EMPTY;
	}
	zip$3.zip = zip$2;

	var types = {};

	Object.defineProperty(types, "__esModule", {
	  value: true
	});

	var audit$1 = {};

	Object.defineProperty(audit$1, "__esModule", {
	  value: true
	});
	audit$1.audit = void 0;
	var lift_1$Z = lift;
	var innerFrom_1$p = innerFrom$1;
	var OperatorSubscriber_1$K = OperatorSubscriber$1;
	function audit(durationSelector) {
	  return lift_1$Z.operate(function (source, subscriber) {
	    var hasValue = false;
	    var lastValue = null;
	    var durationSubscriber = null;
	    var isComplete = false;
	    var endDuration = function endDuration() {
	      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
	      durationSubscriber = null;
	      if (hasValue) {
	        hasValue = false;
	        var value = lastValue;
	        lastValue = null;
	        subscriber.next(value);
	      }
	      isComplete && subscriber.complete();
	    };
	    var cleanupDuration = function cleanupDuration() {
	      durationSubscriber = null;
	      isComplete && subscriber.complete();
	    };
	    source.subscribe(OperatorSubscriber_1$K.createOperatorSubscriber(subscriber, function (value) {
	      hasValue = true;
	      lastValue = value;
	      if (!durationSubscriber) {
	        innerFrom_1$p.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1$K.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
	      }
	    }, function () {
	      isComplete = true;
	      (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
	    }));
	  });
	}
	audit$1.audit = audit;

	var auditTime$1 = {};

	Object.defineProperty(auditTime$1, "__esModule", {
	  value: true
	});
	auditTime$1.auditTime = void 0;
	var async_1$8 = async;
	var audit_1 = audit$1;
	var timer_1$4 = timer$1;
	function auditTime(duration, scheduler) {
	  if (scheduler === void 0) {
	    scheduler = async_1$8.asyncScheduler;
	  }
	  return audit_1.audit(function () {
	    return timer_1$4.timer(duration, scheduler);
	  });
	}
	auditTime$1.auditTime = auditTime;

	var buffer$1 = {};

	Object.defineProperty(buffer$1, "__esModule", {
	  value: true
	});
	buffer$1.buffer = void 0;
	var lift_1$Y = lift;
	var noop_1$b = noop$1;
	var OperatorSubscriber_1$J = OperatorSubscriber$1;
	var innerFrom_1$o = innerFrom$1;
	function buffer(closingNotifier) {
	  return lift_1$Y.operate(function (source, subscriber) {
	    var currentBuffer = [];
	    source.subscribe(OperatorSubscriber_1$J.createOperatorSubscriber(subscriber, function (value) {
	      return currentBuffer.push(value);
	    }, function () {
	      subscriber.next(currentBuffer);
	      subscriber.complete();
	    }));
	    innerFrom_1$o.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1$J.createOperatorSubscriber(subscriber, function () {
	      var b = currentBuffer;
	      currentBuffer = [];
	      subscriber.next(b);
	    }, noop_1$b.noop));
	    return function () {
	      currentBuffer = null;
	    };
	  });
	}
	buffer$1.buffer = buffer;

	var bufferCount$1 = {};

	var __values$5 = commonjsGlobal && commonjsGlobal.__values || function (o) {
	  var s = typeof Symbol === "function" && Symbol.iterator,
	    m = s && o[s],
	    i = 0;
	  if (m) return m.call(o);
	  if (o && typeof o.length === "number") return {
	    next: function next() {
	      if (o && i >= o.length) o = void 0;
	      return {
	        value: o && o[i++],
	        done: !o
	      };
	    }
	  };
	  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(bufferCount$1, "__esModule", {
	  value: true
	});
	bufferCount$1.bufferCount = void 0;
	var lift_1$X = lift;
	var OperatorSubscriber_1$I = OperatorSubscriber$1;
	var arrRemove_1$4 = arrRemove$1;
	function bufferCount(bufferSize, startBufferEvery) {
	  if (startBufferEvery === void 0) {
	    startBufferEvery = null;
	  }
	  startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
	  return lift_1$X.operate(function (source, subscriber) {
	    var buffers = [];
	    var count = 0;
	    source.subscribe(OperatorSubscriber_1$I.createOperatorSubscriber(subscriber, function (value) {
	      var e_1, _a, e_2, _b;
	      var toEmit = null;
	      if (count++ % startBufferEvery === 0) {
	        buffers.push([]);
	      }
	      try {
	        for (var buffers_1 = __values$5(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
	          var buffer = buffers_1_1.value;
	          buffer.push(value);
	          if (bufferSize <= buffer.length) {
	            toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
	            toEmit.push(buffer);
	          }
	        }
	      } catch (e_1_1) {
	        e_1 = {
	          error: e_1_1
	        };
	      } finally {
	        try {
	          if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1["return"])) _a.call(buffers_1);
	        } finally {
	          if (e_1) throw e_1.error;
	        }
	      }
	      if (toEmit) {
	        try {
	          for (var toEmit_1 = __values$5(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
	            var buffer = toEmit_1_1.value;
	            arrRemove_1$4.arrRemove(buffers, buffer);
	            subscriber.next(buffer);
	          }
	        } catch (e_2_1) {
	          e_2 = {
	            error: e_2_1
	          };
	        } finally {
	          try {
	            if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1["return"])) _b.call(toEmit_1);
	          } finally {
	            if (e_2) throw e_2.error;
	          }
	        }
	      }
	    }, function () {
	      var e_3, _a;
	      try {
	        for (var buffers_2 = __values$5(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
	          var buffer = buffers_2_1.value;
	          subscriber.next(buffer);
	        }
	      } catch (e_3_1) {
	        e_3 = {
	          error: e_3_1
	        };
	      } finally {
	        try {
	          if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2["return"])) _a.call(buffers_2);
	        } finally {
	          if (e_3) throw e_3.error;
	        }
	      }
	      subscriber.complete();
	    }, undefined, function () {
	      buffers = null;
	    }));
	  });
	}
	bufferCount$1.bufferCount = bufferCount;

	var bufferTime$1 = {};

	var __values$4 = commonjsGlobal && commonjsGlobal.__values || function (o) {
	  var s = typeof Symbol === "function" && Symbol.iterator,
	    m = s && o[s],
	    i = 0;
	  if (m) return m.call(o);
	  if (o && typeof o.length === "number") return {
	    next: function next() {
	      if (o && i >= o.length) o = void 0;
	      return {
	        value: o && o[i++],
	        done: !o
	      };
	    }
	  };
	  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(bufferTime$1, "__esModule", {
	  value: true
	});
	bufferTime$1.bufferTime = void 0;
	var Subscription_1$3 = Subscription$1;
	var lift_1$W = lift;
	var OperatorSubscriber_1$H = OperatorSubscriber$1;
	var arrRemove_1$3 = arrRemove$1;
	var async_1$7 = async;
	var args_1$6 = args;
	var executeSchedule_1$1 = executeSchedule$1;
	function bufferTime(bufferTimeSpan) {
	  var _a, _b;
	  var otherArgs = [];
	  for (var _i = 1; _i < arguments.length; _i++) {
	    otherArgs[_i - 1] = arguments[_i];
	  }
	  var scheduler = (_a = args_1$6.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1$7.asyncScheduler;
	  var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
	  var maxBufferSize = otherArgs[1] || Infinity;
	  return lift_1$W.operate(function (source, subscriber) {
	    var bufferRecords = [];
	    var restartOnEmit = false;
	    var emit = function emit(record) {
	      var buffer = record.buffer,
	        subs = record.subs;
	      subs.unsubscribe();
	      arrRemove_1$3.arrRemove(bufferRecords, record);
	      subscriber.next(buffer);
	      restartOnEmit && startBuffer();
	    };
	    var startBuffer = function startBuffer() {
	      if (bufferRecords) {
	        var subs = new Subscription_1$3.Subscription();
	        subscriber.add(subs);
	        var buffer = [];
	        var record_1 = {
	          buffer: buffer,
	          subs: subs
	        };
	        bufferRecords.push(record_1);
	        executeSchedule_1$1.executeSchedule(subs, scheduler, function () {
	          return emit(record_1);
	        }, bufferTimeSpan);
	      }
	    };
	    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
	      executeSchedule_1$1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
	    } else {
	      restartOnEmit = true;
	    }
	    startBuffer();
	    var bufferTimeSubscriber = OperatorSubscriber_1$H.createOperatorSubscriber(subscriber, function (value) {
	      var e_1, _a;
	      var recordsCopy = bufferRecords.slice();
	      try {
	        for (var recordsCopy_1 = __values$4(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
	          var record = recordsCopy_1_1.value;
	          var buffer = record.buffer;
	          buffer.push(value);
	          maxBufferSize <= buffer.length && emit(record);
	        }
	      } catch (e_1_1) {
	        e_1 = {
	          error: e_1_1
	        };
	      } finally {
	        try {
	          if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a = recordsCopy_1["return"])) _a.call(recordsCopy_1);
	        } finally {
	          if (e_1) throw e_1.error;
	        }
	      }
	    }, function () {
	      while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
	        subscriber.next(bufferRecords.shift().buffer);
	      }
	      bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
	      subscriber.complete();
	      subscriber.unsubscribe();
	    }, undefined, function () {
	      return bufferRecords = null;
	    });
	    source.subscribe(bufferTimeSubscriber);
	  });
	}
	bufferTime$1.bufferTime = bufferTime;

	var bufferToggle$1 = {};

	var __values$3 = commonjsGlobal && commonjsGlobal.__values || function (o) {
	  var s = typeof Symbol === "function" && Symbol.iterator,
	    m = s && o[s],
	    i = 0;
	  if (m) return m.call(o);
	  if (o && typeof o.length === "number") return {
	    next: function next() {
	      if (o && i >= o.length) o = void 0;
	      return {
	        value: o && o[i++],
	        done: !o
	      };
	    }
	  };
	  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(bufferToggle$1, "__esModule", {
	  value: true
	});
	bufferToggle$1.bufferToggle = void 0;
	var Subscription_1$2 = Subscription$1;
	var lift_1$V = lift;
	var innerFrom_1$n = innerFrom$1;
	var OperatorSubscriber_1$G = OperatorSubscriber$1;
	var noop_1$a = noop$1;
	var arrRemove_1$2 = arrRemove$1;
	function bufferToggle(openings, closingSelector) {
	  return lift_1$V.operate(function (source, subscriber) {
	    var buffers = [];
	    innerFrom_1$n.innerFrom(openings).subscribe(OperatorSubscriber_1$G.createOperatorSubscriber(subscriber, function (openValue) {
	      var buffer = [];
	      buffers.push(buffer);
	      var closingSubscription = new Subscription_1$2.Subscription();
	      var emitBuffer = function emitBuffer() {
	        arrRemove_1$2.arrRemove(buffers, buffer);
	        subscriber.next(buffer);
	        closingSubscription.unsubscribe();
	      };
	      closingSubscription.add(innerFrom_1$n.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1$G.createOperatorSubscriber(subscriber, emitBuffer, noop_1$a.noop)));
	    }, noop_1$a.noop));
	    source.subscribe(OperatorSubscriber_1$G.createOperatorSubscriber(subscriber, function (value) {
	      var e_1, _a;
	      try {
	        for (var buffers_1 = __values$3(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
	          var buffer = buffers_1_1.value;
	          buffer.push(value);
	        }
	      } catch (e_1_1) {
	        e_1 = {
	          error: e_1_1
	        };
	      } finally {
	        try {
	          if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1["return"])) _a.call(buffers_1);
	        } finally {
	          if (e_1) throw e_1.error;
	        }
	      }
	    }, function () {
	      while (buffers.length > 0) {
	        subscriber.next(buffers.shift());
	      }
	      subscriber.complete();
	    }));
	  });
	}
	bufferToggle$1.bufferToggle = bufferToggle;

	var bufferWhen$1 = {};

	Object.defineProperty(bufferWhen$1, "__esModule", {
	  value: true
	});
	bufferWhen$1.bufferWhen = void 0;
	var lift_1$U = lift;
	var noop_1$9 = noop$1;
	var OperatorSubscriber_1$F = OperatorSubscriber$1;
	var innerFrom_1$m = innerFrom$1;
	function bufferWhen(closingSelector) {
	  return lift_1$U.operate(function (source, subscriber) {
	    var buffer = null;
	    var closingSubscriber = null;
	    var openBuffer = function openBuffer() {
	      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
	      var b = buffer;
	      buffer = [];
	      b && subscriber.next(b);
	      innerFrom_1$m.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1$F.createOperatorSubscriber(subscriber, openBuffer, noop_1$9.noop));
	    };
	    openBuffer();
	    source.subscribe(OperatorSubscriber_1$F.createOperatorSubscriber(subscriber, function (value) {
	      return buffer === null || buffer === void 0 ? void 0 : buffer.push(value);
	    }, function () {
	      buffer && subscriber.next(buffer);
	      subscriber.complete();
	    }, undefined, function () {
	      return buffer = closingSubscriber = null;
	    }));
	  });
	}
	bufferWhen$1.bufferWhen = bufferWhen;

	var catchError$1 = {};

	Object.defineProperty(catchError$1, "__esModule", {
	  value: true
	});
	catchError$1.catchError = void 0;
	var innerFrom_1$l = innerFrom$1;
	var OperatorSubscriber_1$E = OperatorSubscriber$1;
	var lift_1$T = lift;
	function catchError(selector) {
	  return lift_1$T.operate(function (source, subscriber) {
	    var innerSub = null;
	    var syncUnsub = false;
	    var handledResult;
	    innerSub = source.subscribe(OperatorSubscriber_1$E.createOperatorSubscriber(subscriber, undefined, undefined, function (err) {
	      handledResult = innerFrom_1$l.innerFrom(selector(err, catchError(selector)(source)));
	      if (innerSub) {
	        innerSub.unsubscribe();
	        innerSub = null;
	        handledResult.subscribe(subscriber);
	      } else {
	        syncUnsub = true;
	      }
	    }));
	    if (syncUnsub) {
	      innerSub.unsubscribe();
	      innerSub = null;
	      handledResult.subscribe(subscriber);
	    }
	  });
	}
	catchError$1.catchError = catchError;

	var combineAll = {};

	var combineLatestAll$1 = {};

	var joinAllInternals$1 = {};

	var toArray$1 = {};

	var reduce$1 = {};

	var scanInternals$1 = {};

	Object.defineProperty(scanInternals$1, "__esModule", {
	  value: true
	});
	scanInternals$1.scanInternals = void 0;
	var OperatorSubscriber_1$D = OperatorSubscriber$1;
	function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
	  return function (source, subscriber) {
	    var hasState = hasSeed;
	    var state = seed;
	    var index = 0;
	    source.subscribe(OperatorSubscriber_1$D.createOperatorSubscriber(subscriber, function (value) {
	      var i = index++;
	      state = hasState ? accumulator(state, value, i) : (hasState = true, value);
	      emitOnNext && subscriber.next(state);
	    }, emitBeforeComplete && function () {
	      hasState && subscriber.next(state);
	      subscriber.complete();
	    }));
	  };
	}
	scanInternals$1.scanInternals = scanInternals;

	Object.defineProperty(reduce$1, "__esModule", {
	  value: true
	});
	reduce$1.reduce = void 0;
	var scanInternals_1$1 = scanInternals$1;
	var lift_1$S = lift;
	function reduce(accumulator, seed) {
	  return lift_1$S.operate(scanInternals_1$1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
	}
	reduce$1.reduce = reduce;

	Object.defineProperty(toArray$1, "__esModule", {
	  value: true
	});
	toArray$1.toArray = void 0;
	var reduce_1$3 = reduce$1;
	var lift_1$R = lift;
	var arrReducer = function arrReducer(arr, value) {
	  return arr.push(value), arr;
	};
	function toArray() {
	  return lift_1$R.operate(function (source, subscriber) {
	    reduce_1$3.reduce(arrReducer, [])(source).subscribe(subscriber);
	  });
	}
	toArray$1.toArray = toArray;

	Object.defineProperty(joinAllInternals$1, "__esModule", {
	  value: true
	});
	joinAllInternals$1.joinAllInternals = void 0;
	var identity_1$a = identity$1;
	var mapOneOrManyArgs_1$1 = mapOneOrManyArgs$1;
	var pipe_1$1 = pipe$1;
	var mergeMap_1$4 = mergeMap$1;
	var toArray_1 = toArray$1;
	function joinAllInternals(joinFn, project) {
	  return pipe_1$1.pipe(toArray_1.toArray(), mergeMap_1$4.mergeMap(function (sources) {
	    return joinFn(sources);
	  }), project ? mapOneOrManyArgs_1$1.mapOneOrManyArgs(project) : identity_1$a.identity);
	}
	joinAllInternals$1.joinAllInternals = joinAllInternals;

	Object.defineProperty(combineLatestAll$1, "__esModule", {
	  value: true
	});
	combineLatestAll$1.combineLatestAll = void 0;
	var combineLatest_1$2 = combineLatest$3;
	var joinAllInternals_1$1 = joinAllInternals$1;
	function combineLatestAll(project) {
	  return joinAllInternals_1$1.joinAllInternals(combineLatest_1$2.combineLatest, project);
	}
	combineLatestAll$1.combineLatestAll = combineLatestAll;

	Object.defineProperty(combineAll, "__esModule", {
	  value: true
	});
	combineAll.combineAll = void 0;
	var combineLatestAll_1 = combineLatestAll$1;
	combineAll.combineAll = combineLatestAll_1.combineLatestAll;

	var combineLatestWith$1 = {};

	var combineLatest$1 = {};

	var __read$c = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	var __spreadArray$c = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	  return to;
	};
	Object.defineProperty(combineLatest$1, "__esModule", {
	  value: true
	});
	combineLatest$1.combineLatest = void 0;
	var combineLatest_1$1 = combineLatest$3;
	var lift_1$Q = lift;
	var argsOrArgArray_1$2 = argsOrArgArray$1;
	var mapOneOrManyArgs_1 = mapOneOrManyArgs$1;
	var pipe_1 = pipe$1;
	var args_1$5 = args;
	function combineLatest() {
	  var args = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    args[_i] = arguments[_i];
	  }
	  var resultSelector = args_1$5.popResultSelector(args);
	  return resultSelector ? pipe_1.pipe(combineLatest.apply(void 0, __spreadArray$c([], __read$c(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1$Q.operate(function (source, subscriber) {
	    combineLatest_1$1.combineLatestInit(__spreadArray$c([source], __read$c(argsOrArgArray_1$2.argsOrArgArray(args))))(subscriber);
	  });
	}
	combineLatest$1.combineLatest = combineLatest;

	var __read$b = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	var __spreadArray$b = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	  return to;
	};
	Object.defineProperty(combineLatestWith$1, "__esModule", {
	  value: true
	});
	combineLatestWith$1.combineLatestWith = void 0;
	var combineLatest_1 = combineLatest$1;
	function combineLatestWith() {
	  var otherSources = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    otherSources[_i] = arguments[_i];
	  }
	  return combineLatest_1.combineLatest.apply(void 0, __spreadArray$b([], __read$b(otherSources)));
	}
	combineLatestWith$1.combineLatestWith = combineLatestWith;

	var concatMap$1 = {};

	Object.defineProperty(concatMap$1, "__esModule", {
	  value: true
	});
	concatMap$1.concatMap = void 0;
	var mergeMap_1$3 = mergeMap$1;
	var isFunction_1$8 = isFunction$1;
	function concatMap(project, resultSelector) {
	  return isFunction_1$8.isFunction(resultSelector) ? mergeMap_1$3.mergeMap(project, resultSelector, 1) : mergeMap_1$3.mergeMap(project, 1);
	}
	concatMap$1.concatMap = concatMap;

	var concatMapTo$1 = {};

	Object.defineProperty(concatMapTo$1, "__esModule", {
	  value: true
	});
	concatMapTo$1.concatMapTo = void 0;
	var concatMap_1 = concatMap$1;
	var isFunction_1$7 = isFunction$1;
	function concatMapTo(innerObservable, resultSelector) {
	  return isFunction_1$7.isFunction(resultSelector) ? concatMap_1.concatMap(function () {
	    return innerObservable;
	  }, resultSelector) : concatMap_1.concatMap(function () {
	    return innerObservable;
	  });
	}
	concatMapTo$1.concatMapTo = concatMapTo;

	var concatWith$1 = {};

	var concat$1 = {};

	var __read$a = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	var __spreadArray$a = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	  return to;
	};
	Object.defineProperty(concat$1, "__esModule", {
	  value: true
	});
	concat$1.concat = void 0;
	var lift_1$P = lift;
	var concatAll_1 = concatAll$1;
	var args_1$4 = args;
	var from_1$1 = from$2;
	function concat() {
	  var args = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    args[_i] = arguments[_i];
	  }
	  var scheduler = args_1$4.popScheduler(args);
	  return lift_1$P.operate(function (source, subscriber) {
	    concatAll_1.concatAll()(from_1$1.from(__spreadArray$a([source], __read$a(args)), scheduler)).subscribe(subscriber);
	  });
	}
	concat$1.concat = concat;

	var __read$9 = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	var __spreadArray$9 = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	  return to;
	};
	Object.defineProperty(concatWith$1, "__esModule", {
	  value: true
	});
	concatWith$1.concatWith = void 0;
	var concat_1$3 = concat$1;
	function concatWith() {
	  var otherSources = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    otherSources[_i] = arguments[_i];
	  }
	  return concat_1$3.concat.apply(void 0, __spreadArray$9([], __read$9(otherSources)));
	}
	concatWith$1.concatWith = concatWith;

	var connect$1 = {};

	var fromSubscribable$1 = {};

	Object.defineProperty(fromSubscribable$1, "__esModule", {
	  value: true
	});
	fromSubscribable$1.fromSubscribable = void 0;
	var Observable_1$1 = Observable$1;
	function fromSubscribable(subscribable) {
	  return new Observable_1$1.Observable(function (subscriber) {
	    return subscribable.subscribe(subscriber);
	  });
	}
	fromSubscribable$1.fromSubscribable = fromSubscribable;

	Object.defineProperty(connect$1, "__esModule", {
	  value: true
	});
	connect$1.connect = void 0;
	var Subject_1$a = Subject$1;
	var innerFrom_1$k = innerFrom$1;
	var lift_1$O = lift;
	var fromSubscribable_1 = fromSubscribable$1;
	var DEFAULT_CONFIG = {
	  connector: function connector() {
	    return new Subject_1$a.Subject();
	  }
	};
	function connect(selector, config) {
	  if (config === void 0) {
	    config = DEFAULT_CONFIG;
	  }
	  var connector = config.connector;
	  return lift_1$O.operate(function (source, subscriber) {
	    var subject = connector();
	    innerFrom_1$k.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
	    subscriber.add(source.subscribe(subject));
	  });
	}
	connect$1.connect = connect;

	var count$1 = {};

	Object.defineProperty(count$1, "__esModule", {
	  value: true
	});
	count$1.count = void 0;
	var reduce_1$2 = reduce$1;
	function count(predicate) {
	  return reduce_1$2.reduce(function (total, value, i) {
	    return !predicate || predicate(value, i) ? total + 1 : total;
	  }, 0);
	}
	count$1.count = count;

	var debounce$1 = {};

	Object.defineProperty(debounce$1, "__esModule", {
	  value: true
	});
	debounce$1.debounce = void 0;
	var lift_1$N = lift;
	var noop_1$8 = noop$1;
	var OperatorSubscriber_1$C = OperatorSubscriber$1;
	var innerFrom_1$j = innerFrom$1;
	function debounce(durationSelector) {
	  return lift_1$N.operate(function (source, subscriber) {
	    var hasValue = false;
	    var lastValue = null;
	    var durationSubscriber = null;
	    var emit = function emit() {
	      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
	      durationSubscriber = null;
	      if (hasValue) {
	        hasValue = false;
	        var value = lastValue;
	        lastValue = null;
	        subscriber.next(value);
	      }
	    };
	    source.subscribe(OperatorSubscriber_1$C.createOperatorSubscriber(subscriber, function (value) {
	      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
	      hasValue = true;
	      lastValue = value;
	      durationSubscriber = OperatorSubscriber_1$C.createOperatorSubscriber(subscriber, emit, noop_1$8.noop);
	      innerFrom_1$j.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
	    }, function () {
	      emit();
	      subscriber.complete();
	    }, undefined, function () {
	      lastValue = durationSubscriber = null;
	    }));
	  });
	}
	debounce$1.debounce = debounce;

	var debounceTime$1 = {};

	Object.defineProperty(debounceTime$1, "__esModule", {
	  value: true
	});
	debounceTime$1.debounceTime = void 0;
	var async_1$6 = async;
	var lift_1$M = lift;
	var OperatorSubscriber_1$B = OperatorSubscriber$1;
	function debounceTime(dueTime, scheduler) {
	  if (scheduler === void 0) {
	    scheduler = async_1$6.asyncScheduler;
	  }
	  return lift_1$M.operate(function (source, subscriber) {
	    var activeTask = null;
	    var lastValue = null;
	    var lastTime = null;
	    var emit = function emit() {
	      if (activeTask) {
	        activeTask.unsubscribe();
	        activeTask = null;
	        var value = lastValue;
	        lastValue = null;
	        subscriber.next(value);
	      }
	    };
	    function emitWhenIdle() {
	      var targetTime = lastTime + dueTime;
	      var now = scheduler.now();
	      if (now < targetTime) {
	        activeTask = this.schedule(undefined, targetTime - now);
	        subscriber.add(activeTask);
	        return;
	      }
	      emit();
	    }
	    source.subscribe(OperatorSubscriber_1$B.createOperatorSubscriber(subscriber, function (value) {
	      lastValue = value;
	      lastTime = scheduler.now();
	      if (!activeTask) {
	        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
	        subscriber.add(activeTask);
	      }
	    }, function () {
	      emit();
	      subscriber.complete();
	    }, undefined, function () {
	      lastValue = activeTask = null;
	    }));
	  });
	}
	debounceTime$1.debounceTime = debounceTime;

	var defaultIfEmpty$1 = {};

	Object.defineProperty(defaultIfEmpty$1, "__esModule", {
	  value: true
	});
	defaultIfEmpty$1.defaultIfEmpty = void 0;
	var lift_1$L = lift;
	var OperatorSubscriber_1$A = OperatorSubscriber$1;
	function defaultIfEmpty(defaultValue) {
	  return lift_1$L.operate(function (source, subscriber) {
	    var hasValue = false;
	    source.subscribe(OperatorSubscriber_1$A.createOperatorSubscriber(subscriber, function (value) {
	      hasValue = true;
	      subscriber.next(value);
	    }, function () {
	      if (!hasValue) {
	        subscriber.next(defaultValue);
	      }
	      subscriber.complete();
	    }));
	  });
	}
	defaultIfEmpty$1.defaultIfEmpty = defaultIfEmpty;

	var delay$1 = {};

	var delayWhen$1 = {};

	var take$1 = {};

	Object.defineProperty(take$1, "__esModule", {
	  value: true
	});
	take$1.take = void 0;
	var empty_1$2 = empty;
	var lift_1$K = lift;
	var OperatorSubscriber_1$z = OperatorSubscriber$1;
	function take(count) {
	  return count <= 0 ? function () {
	    return empty_1$2.EMPTY;
	  } : lift_1$K.operate(function (source, subscriber) {
	    var seen = 0;
	    source.subscribe(OperatorSubscriber_1$z.createOperatorSubscriber(subscriber, function (value) {
	      if (++seen <= count) {
	        subscriber.next(value);
	        if (count <= seen) {
	          subscriber.complete();
	        }
	      }
	    }));
	  });
	}
	take$1.take = take;

	var ignoreElements$1 = {};

	Object.defineProperty(ignoreElements$1, "__esModule", {
	  value: true
	});
	ignoreElements$1.ignoreElements = void 0;
	var lift_1$J = lift;
	var OperatorSubscriber_1$y = OperatorSubscriber$1;
	var noop_1$7 = noop$1;
	function ignoreElements() {
	  return lift_1$J.operate(function (source, subscriber) {
	    source.subscribe(OperatorSubscriber_1$y.createOperatorSubscriber(subscriber, noop_1$7.noop));
	  });
	}
	ignoreElements$1.ignoreElements = ignoreElements;

	var mapTo$1 = {};

	Object.defineProperty(mapTo$1, "__esModule", {
	  value: true
	});
	mapTo$1.mapTo = void 0;
	var map_1$3 = map$1;
	function mapTo(value) {
	  return map_1$3.map(function () {
	    return value;
	  });
	}
	mapTo$1.mapTo = mapTo;

	Object.defineProperty(delayWhen$1, "__esModule", {
	  value: true
	});
	delayWhen$1.delayWhen = void 0;
	var concat_1$2 = concat$3;
	var take_1$2 = take$1;
	var ignoreElements_1 = ignoreElements$1;
	var mapTo_1 = mapTo$1;
	var mergeMap_1$2 = mergeMap$1;
	var innerFrom_1$i = innerFrom$1;
	function delayWhen(delayDurationSelector, subscriptionDelay) {
	  if (subscriptionDelay) {
	    return function (source) {
	      return concat_1$2.concat(subscriptionDelay.pipe(take_1$2.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
	    };
	  }
	  return mergeMap_1$2.mergeMap(function (value, index) {
	    return innerFrom_1$i.innerFrom(delayDurationSelector(value, index)).pipe(take_1$2.take(1), mapTo_1.mapTo(value));
	  });
	}
	delayWhen$1.delayWhen = delayWhen;

	Object.defineProperty(delay$1, "__esModule", {
	  value: true
	});
	delay$1.delay = void 0;
	var async_1$5 = async;
	var delayWhen_1 = delayWhen$1;
	var timer_1$3 = timer$1;
	function delay(due, scheduler) {
	  if (scheduler === void 0) {
	    scheduler = async_1$5.asyncScheduler;
	  }
	  var duration = timer_1$3.timer(due, scheduler);
	  return delayWhen_1.delayWhen(function () {
	    return duration;
	  });
	}
	delay$1.delay = delay;

	var dematerialize$1 = {};

	Object.defineProperty(dematerialize$1, "__esModule", {
	  value: true
	});
	dematerialize$1.dematerialize = void 0;
	var Notification_1$1 = Notification;
	var lift_1$I = lift;
	var OperatorSubscriber_1$x = OperatorSubscriber$1;
	function dematerialize() {
	  return lift_1$I.operate(function (source, subscriber) {
	    source.subscribe(OperatorSubscriber_1$x.createOperatorSubscriber(subscriber, function (notification) {
	      return Notification_1$1.observeNotification(notification, subscriber);
	    }));
	  });
	}
	dematerialize$1.dematerialize = dematerialize;

	var distinct$1 = {};

	Object.defineProperty(distinct$1, "__esModule", {
	  value: true
	});
	distinct$1.distinct = void 0;
	var lift_1$H = lift;
	var OperatorSubscriber_1$w = OperatorSubscriber$1;
	var noop_1$6 = noop$1;
	var innerFrom_1$h = innerFrom$1;
	function distinct(keySelector, flushes) {
	  return lift_1$H.operate(function (source, subscriber) {
	    var distinctKeys = new Set();
	    source.subscribe(OperatorSubscriber_1$w.createOperatorSubscriber(subscriber, function (value) {
	      var key = keySelector ? keySelector(value) : value;
	      if (!distinctKeys.has(key)) {
	        distinctKeys.add(key);
	        subscriber.next(value);
	      }
	    }));
	    flushes && innerFrom_1$h.innerFrom(flushes).subscribe(OperatorSubscriber_1$w.createOperatorSubscriber(subscriber, function () {
	      return distinctKeys.clear();
	    }, noop_1$6.noop));
	  });
	}
	distinct$1.distinct = distinct;

	var distinctUntilChanged$1 = {};

	Object.defineProperty(distinctUntilChanged$1, "__esModule", {
	  value: true
	});
	distinctUntilChanged$1.distinctUntilChanged = void 0;
	var identity_1$9 = identity$1;
	var lift_1$G = lift;
	var OperatorSubscriber_1$v = OperatorSubscriber$1;
	function distinctUntilChanged(comparator, keySelector) {
	  if (keySelector === void 0) {
	    keySelector = identity_1$9.identity;
	  }
	  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
	  return lift_1$G.operate(function (source, subscriber) {
	    var previousKey;
	    var first = true;
	    source.subscribe(OperatorSubscriber_1$v.createOperatorSubscriber(subscriber, function (value) {
	      var currentKey = keySelector(value);
	      if (first || !comparator(previousKey, currentKey)) {
	        first = false;
	        previousKey = currentKey;
	        subscriber.next(value);
	      }
	    }));
	  });
	}
	distinctUntilChanged$1.distinctUntilChanged = distinctUntilChanged;
	function defaultCompare(a, b) {
	  return a === b;
	}

	var distinctUntilKeyChanged$1 = {};

	Object.defineProperty(distinctUntilKeyChanged$1, "__esModule", {
	  value: true
	});
	distinctUntilKeyChanged$1.distinctUntilKeyChanged = void 0;
	var distinctUntilChanged_1 = distinctUntilChanged$1;
	function distinctUntilKeyChanged(key, compare) {
	  return distinctUntilChanged_1.distinctUntilChanged(function (x, y) {
	    return compare ? compare(x[key], y[key]) : x[key] === y[key];
	  });
	}
	distinctUntilKeyChanged$1.distinctUntilKeyChanged = distinctUntilKeyChanged;

	var elementAt$1 = {};

	var throwIfEmpty$1 = {};

	Object.defineProperty(throwIfEmpty$1, "__esModule", {
	  value: true
	});
	throwIfEmpty$1.throwIfEmpty = void 0;
	var EmptyError_1$3 = EmptyError;
	var lift_1$F = lift;
	var OperatorSubscriber_1$u = OperatorSubscriber$1;
	function throwIfEmpty(errorFactory) {
	  if (errorFactory === void 0) {
	    errorFactory = defaultErrorFactory;
	  }
	  return lift_1$F.operate(function (source, subscriber) {
	    var hasValue = false;
	    source.subscribe(OperatorSubscriber_1$u.createOperatorSubscriber(subscriber, function (value) {
	      hasValue = true;
	      subscriber.next(value);
	    }, function () {
	      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
	    }));
	  });
	}
	throwIfEmpty$1.throwIfEmpty = throwIfEmpty;
	function defaultErrorFactory() {
	  return new EmptyError_1$3.EmptyError();
	}

	Object.defineProperty(elementAt$1, "__esModule", {
	  value: true
	});
	elementAt$1.elementAt = void 0;
	var ArgumentOutOfRangeError_1 = ArgumentOutOfRangeError;
	var filter_1$3 = filter$1;
	var throwIfEmpty_1$2 = throwIfEmpty$1;
	var defaultIfEmpty_1$2 = defaultIfEmpty$1;
	var take_1$1 = take$1;
	function elementAt(index, defaultValue) {
	  if (index < 0) {
	    throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
	  }
	  var hasDefaultValue = arguments.length >= 2;
	  return function (source) {
	    return source.pipe(filter_1$3.filter(function (v, i) {
	      return i === index;
	    }), take_1$1.take(1), hasDefaultValue ? defaultIfEmpty_1$2.defaultIfEmpty(defaultValue) : throwIfEmpty_1$2.throwIfEmpty(function () {
	      return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
	    }));
	  };
	}
	elementAt$1.elementAt = elementAt;

	var endWith$1 = {};

	var __read$8 = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	var __spreadArray$8 = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	  return to;
	};
	Object.defineProperty(endWith$1, "__esModule", {
	  value: true
	});
	endWith$1.endWith = void 0;
	var concat_1$1 = concat$3;
	var of_1 = of$1;
	function endWith() {
	  var values = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    values[_i] = arguments[_i];
	  }
	  return function (source) {
	    return concat_1$1.concat(source, of_1.of.apply(void 0, __spreadArray$8([], __read$8(values))));
	  };
	}
	endWith$1.endWith = endWith;

	var every$1 = {};

	Object.defineProperty(every$1, "__esModule", {
	  value: true
	});
	every$1.every = void 0;
	var lift_1$E = lift;
	var OperatorSubscriber_1$t = OperatorSubscriber$1;
	function every(predicate, thisArg) {
	  return lift_1$E.operate(function (source, subscriber) {
	    var index = 0;
	    source.subscribe(OperatorSubscriber_1$t.createOperatorSubscriber(subscriber, function (value) {
	      if (!predicate.call(thisArg, value, index++, source)) {
	        subscriber.next(false);
	        subscriber.complete();
	      }
	    }, function () {
	      subscriber.next(true);
	      subscriber.complete();
	    }));
	  });
	}
	every$1.every = every;

	var exhaust = {};

	var exhaustAll$1 = {};

	var exhaustMap$1 = {};

	Object.defineProperty(exhaustMap$1, "__esModule", {
	  value: true
	});
	exhaustMap$1.exhaustMap = void 0;
	var map_1$2 = map$1;
	var innerFrom_1$g = innerFrom$1;
	var lift_1$D = lift;
	var OperatorSubscriber_1$s = OperatorSubscriber$1;
	function exhaustMap(project, resultSelector) {
	  if (resultSelector) {
	    return function (source) {
	      return source.pipe(exhaustMap(function (a, i) {
	        return innerFrom_1$g.innerFrom(project(a, i)).pipe(map_1$2.map(function (b, ii) {
	          return resultSelector(a, b, i, ii);
	        }));
	      }));
	    };
	  }
	  return lift_1$D.operate(function (source, subscriber) {
	    var index = 0;
	    var innerSub = null;
	    var isComplete = false;
	    source.subscribe(OperatorSubscriber_1$s.createOperatorSubscriber(subscriber, function (outerValue) {
	      if (!innerSub) {
	        innerSub = OperatorSubscriber_1$s.createOperatorSubscriber(subscriber, undefined, function () {
	          innerSub = null;
	          isComplete && subscriber.complete();
	        });
	        innerFrom_1$g.innerFrom(project(outerValue, index++)).subscribe(innerSub);
	      }
	    }, function () {
	      isComplete = true;
	      !innerSub && subscriber.complete();
	    }));
	  });
	}
	exhaustMap$1.exhaustMap = exhaustMap;

	Object.defineProperty(exhaustAll$1, "__esModule", {
	  value: true
	});
	exhaustAll$1.exhaustAll = void 0;
	var exhaustMap_1 = exhaustMap$1;
	var identity_1$8 = identity$1;
	function exhaustAll() {
	  return exhaustMap_1.exhaustMap(identity_1$8.identity);
	}
	exhaustAll$1.exhaustAll = exhaustAll;

	Object.defineProperty(exhaust, "__esModule", {
	  value: true
	});
	exhaust.exhaust = void 0;
	var exhaustAll_1 = exhaustAll$1;
	exhaust.exhaust = exhaustAll_1.exhaustAll;

	var expand$1 = {};

	Object.defineProperty(expand$1, "__esModule", {
	  value: true
	});
	expand$1.expand = void 0;
	var lift_1$C = lift;
	var mergeInternals_1$1 = mergeInternals$1;
	function expand(project, concurrent, scheduler) {
	  if (concurrent === void 0) {
	    concurrent = Infinity;
	  }
	  concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
	  return lift_1$C.operate(function (source, subscriber) {
	    return mergeInternals_1$1.mergeInternals(source, subscriber, project, concurrent, undefined, true, scheduler);
	  });
	}
	expand$1.expand = expand;

	var finalize$1 = {};

	Object.defineProperty(finalize$1, "__esModule", {
	  value: true
	});
	finalize$1.finalize = void 0;
	var lift_1$B = lift;
	function finalize(callback) {
	  return lift_1$B.operate(function (source, subscriber) {
	    try {
	      source.subscribe(subscriber);
	    } finally {
	      subscriber.add(callback);
	    }
	  });
	}
	finalize$1.finalize = finalize;

	var find$1 = {};

	Object.defineProperty(find$1, "__esModule", {
	  value: true
	});
	find$1.createFind = find$1.find = void 0;
	var lift_1$A = lift;
	var OperatorSubscriber_1$r = OperatorSubscriber$1;
	function find(predicate, thisArg) {
	  return lift_1$A.operate(createFind(predicate, thisArg, 'value'));
	}
	find$1.find = find;
	function createFind(predicate, thisArg, emit) {
	  var findIndex = emit === 'index';
	  return function (source, subscriber) {
	    var index = 0;
	    source.subscribe(OperatorSubscriber_1$r.createOperatorSubscriber(subscriber, function (value) {
	      var i = index++;
	      if (predicate.call(thisArg, value, i, source)) {
	        subscriber.next(findIndex ? i : value);
	        subscriber.complete();
	      }
	    }, function () {
	      subscriber.next(findIndex ? -1 : undefined);
	      subscriber.complete();
	    }));
	  };
	}
	find$1.createFind = createFind;

	var findIndex$1 = {};

	Object.defineProperty(findIndex$1, "__esModule", {
	  value: true
	});
	findIndex$1.findIndex = void 0;
	var lift_1$z = lift;
	var find_1 = find$1;
	function findIndex(predicate, thisArg) {
	  return lift_1$z.operate(find_1.createFind(predicate, thisArg, 'index'));
	}
	findIndex$1.findIndex = findIndex;

	var first$1 = {};

	Object.defineProperty(first$1, "__esModule", {
	  value: true
	});
	first$1.first = void 0;
	var EmptyError_1$2 = EmptyError;
	var filter_1$2 = filter$1;
	var take_1 = take$1;
	var defaultIfEmpty_1$1 = defaultIfEmpty$1;
	var throwIfEmpty_1$1 = throwIfEmpty$1;
	var identity_1$7 = identity$1;
	function first(predicate, defaultValue) {
	  var hasDefaultValue = arguments.length >= 2;
	  return function (source) {
	    return source.pipe(predicate ? filter_1$2.filter(function (v, i) {
	      return predicate(v, i, source);
	    }) : identity_1$7.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1$1.defaultIfEmpty(defaultValue) : throwIfEmpty_1$1.throwIfEmpty(function () {
	      return new EmptyError_1$2.EmptyError();
	    }));
	  };
	}
	first$1.first = first;

	var groupBy$1 = {};

	Object.defineProperty(groupBy$1, "__esModule", {
	  value: true
	});
	groupBy$1.groupBy = void 0;
	var Observable_1 = Observable$1;
	var innerFrom_1$f = innerFrom$1;
	var Subject_1$9 = Subject$1;
	var lift_1$y = lift;
	var OperatorSubscriber_1$q = OperatorSubscriber$1;
	function groupBy(keySelector, elementOrOptions, duration, connector) {
	  return lift_1$y.operate(function (source, subscriber) {
	    var element;
	    if (!elementOrOptions || typeof elementOrOptions === 'function') {
	      element = elementOrOptions;
	    } else {
	      duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
	    }
	    var groups = new Map();
	    var notify = function notify(cb) {
	      groups.forEach(cb);
	      cb(subscriber);
	    };
	    var handleError = function handleError(err) {
	      return notify(function (consumer) {
	        return consumer.error(err);
	      });
	    };
	    var activeGroups = 0;
	    var teardownAttempted = false;
	    var groupBySourceSubscriber = new OperatorSubscriber_1$q.OperatorSubscriber(subscriber, function (value) {
	      try {
	        var key_1 = keySelector(value);
	        var group_1 = groups.get(key_1);
	        if (!group_1) {
	          groups.set(key_1, group_1 = connector ? connector() : new Subject_1$9.Subject());
	          var grouped = createGroupedObservable(key_1, group_1);
	          subscriber.next(grouped);
	          if (duration) {
	            var durationSubscriber_1 = OperatorSubscriber_1$q.createOperatorSubscriber(group_1, function () {
	              group_1.complete();
	              durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
	            }, undefined, undefined, function () {
	              return groups["delete"](key_1);
	            });
	            groupBySourceSubscriber.add(innerFrom_1$f.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
	          }
	        }
	        group_1.next(element ? element(value) : value);
	      } catch (err) {
	        handleError(err);
	      }
	    }, function () {
	      return notify(function (consumer) {
	        return consumer.complete();
	      });
	    }, handleError, function () {
	      return groups.clear();
	    }, function () {
	      teardownAttempted = true;
	      return activeGroups === 0;
	    });
	    source.subscribe(groupBySourceSubscriber);
	    function createGroupedObservable(key, groupSubject) {
	      var result = new Observable_1.Observable(function (groupSubscriber) {
	        activeGroups++;
	        var innerSub = groupSubject.subscribe(groupSubscriber);
	        return function () {
	          innerSub.unsubscribe();
	          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
	        };
	      });
	      result.key = key;
	      return result;
	    }
	  });
	}
	groupBy$1.groupBy = groupBy;

	var isEmpty$1 = {};

	Object.defineProperty(isEmpty$1, "__esModule", {
	  value: true
	});
	isEmpty$1.isEmpty = void 0;
	var lift_1$x = lift;
	var OperatorSubscriber_1$p = OperatorSubscriber$1;
	function isEmpty() {
	  return lift_1$x.operate(function (source, subscriber) {
	    source.subscribe(OperatorSubscriber_1$p.createOperatorSubscriber(subscriber, function () {
	      subscriber.next(false);
	      subscriber.complete();
	    }, function () {
	      subscriber.next(true);
	      subscriber.complete();
	    }));
	  });
	}
	isEmpty$1.isEmpty = isEmpty;

	var last$1 = {};

	var takeLast$1 = {};

	var __values$2 = commonjsGlobal && commonjsGlobal.__values || function (o) {
	  var s = typeof Symbol === "function" && Symbol.iterator,
	    m = s && o[s],
	    i = 0;
	  if (m) return m.call(o);
	  if (o && typeof o.length === "number") return {
	    next: function next() {
	      if (o && i >= o.length) o = void 0;
	      return {
	        value: o && o[i++],
	        done: !o
	      };
	    }
	  };
	  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(takeLast$1, "__esModule", {
	  value: true
	});
	takeLast$1.takeLast = void 0;
	var empty_1$1 = empty;
	var lift_1$w = lift;
	var OperatorSubscriber_1$o = OperatorSubscriber$1;
	function takeLast(count) {
	  return count <= 0 ? function () {
	    return empty_1$1.EMPTY;
	  } : lift_1$w.operate(function (source, subscriber) {
	    var buffer = [];
	    source.subscribe(OperatorSubscriber_1$o.createOperatorSubscriber(subscriber, function (value) {
	      buffer.push(value);
	      count < buffer.length && buffer.shift();
	    }, function () {
	      var e_1, _a;
	      try {
	        for (var buffer_1 = __values$2(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
	          var value = buffer_1_1.value;
	          subscriber.next(value);
	        }
	      } catch (e_1_1) {
	        e_1 = {
	          error: e_1_1
	        };
	      } finally {
	        try {
	          if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1["return"])) _a.call(buffer_1);
	        } finally {
	          if (e_1) throw e_1.error;
	        }
	      }
	      subscriber.complete();
	    }, undefined, function () {
	      buffer = null;
	    }));
	  });
	}
	takeLast$1.takeLast = takeLast;

	Object.defineProperty(last$1, "__esModule", {
	  value: true
	});
	last$1.last = void 0;
	var EmptyError_1$1 = EmptyError;
	var filter_1$1 = filter$1;
	var takeLast_1 = takeLast$1;
	var throwIfEmpty_1 = throwIfEmpty$1;
	var defaultIfEmpty_1 = defaultIfEmpty$1;
	var identity_1$6 = identity$1;
	function last(predicate, defaultValue) {
	  var hasDefaultValue = arguments.length >= 2;
	  return function (source) {
	    return source.pipe(predicate ? filter_1$1.filter(function (v, i) {
	      return predicate(v, i, source);
	    }) : identity_1$6.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () {
	      return new EmptyError_1$1.EmptyError();
	    }));
	  };
	}
	last$1.last = last;

	var materialize$1 = {};

	Object.defineProperty(materialize$1, "__esModule", {
	  value: true
	});
	materialize$1.materialize = void 0;
	var Notification_1 = Notification;
	var lift_1$v = lift;
	var OperatorSubscriber_1$n = OperatorSubscriber$1;
	function materialize() {
	  return lift_1$v.operate(function (source, subscriber) {
	    source.subscribe(OperatorSubscriber_1$n.createOperatorSubscriber(subscriber, function (value) {
	      subscriber.next(Notification_1.Notification.createNext(value));
	    }, function () {
	      subscriber.next(Notification_1.Notification.createComplete());
	      subscriber.complete();
	    }, function (err) {
	      subscriber.next(Notification_1.Notification.createError(err));
	      subscriber.complete();
	    }));
	  });
	}
	materialize$1.materialize = materialize;

	var max$1 = {};

	Object.defineProperty(max$1, "__esModule", {
	  value: true
	});
	max$1.max = void 0;
	var reduce_1$1 = reduce$1;
	var isFunction_1$6 = isFunction$1;
	function max(comparer) {
	  return reduce_1$1.reduce(isFunction_1$6.isFunction(comparer) ? function (x, y) {
	    return comparer(x, y) > 0 ? x : y;
	  } : function (x, y) {
	    return x > y ? x : y;
	  });
	}
	max$1.max = max;

	var flatMap = {};

	Object.defineProperty(flatMap, "__esModule", {
	  value: true
	});
	flatMap.flatMap = void 0;
	var mergeMap_1$1 = mergeMap$1;
	flatMap.flatMap = mergeMap_1$1.mergeMap;

	var mergeMapTo$1 = {};

	Object.defineProperty(mergeMapTo$1, "__esModule", {
	  value: true
	});
	mergeMapTo$1.mergeMapTo = void 0;
	var mergeMap_1 = mergeMap$1;
	var isFunction_1$5 = isFunction$1;
	function mergeMapTo(innerObservable, resultSelector, concurrent) {
	  if (concurrent === void 0) {
	    concurrent = Infinity;
	  }
	  if (isFunction_1$5.isFunction(resultSelector)) {
	    return mergeMap_1.mergeMap(function () {
	      return innerObservable;
	    }, resultSelector, concurrent);
	  }
	  if (typeof resultSelector === 'number') {
	    concurrent = resultSelector;
	  }
	  return mergeMap_1.mergeMap(function () {
	    return innerObservable;
	  }, concurrent);
	}
	mergeMapTo$1.mergeMapTo = mergeMapTo;

	var mergeScan$1 = {};

	Object.defineProperty(mergeScan$1, "__esModule", {
	  value: true
	});
	mergeScan$1.mergeScan = void 0;
	var lift_1$u = lift;
	var mergeInternals_1 = mergeInternals$1;
	function mergeScan(accumulator, seed, concurrent) {
	  if (concurrent === void 0) {
	    concurrent = Infinity;
	  }
	  return lift_1$u.operate(function (source, subscriber) {
	    var state = seed;
	    return mergeInternals_1.mergeInternals(source, subscriber, function (value, index) {
	      return accumulator(state, value, index);
	    }, concurrent, function (value) {
	      state = value;
	    }, false, undefined, function () {
	      return state = null;
	    });
	  });
	}
	mergeScan$1.mergeScan = mergeScan;

	var mergeWith$1 = {};

	var merge$1 = {};

	var __read$7 = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	var __spreadArray$7 = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	  return to;
	};
	Object.defineProperty(merge$1, "__esModule", {
	  value: true
	});
	merge$1.merge = void 0;
	var lift_1$t = lift;
	var argsOrArgArray_1$1 = argsOrArgArray$1;
	var mergeAll_1 = mergeAll$1;
	var args_1$3 = args;
	var from_1 = from$2;
	function merge() {
	  var args = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    args[_i] = arguments[_i];
	  }
	  var scheduler = args_1$3.popScheduler(args);
	  var concurrent = args_1$3.popNumber(args, Infinity);
	  args = argsOrArgArray_1$1.argsOrArgArray(args);
	  return lift_1$t.operate(function (source, subscriber) {
	    mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray$7([source], __read$7(args)), scheduler)).subscribe(subscriber);
	  });
	}
	merge$1.merge = merge;

	var __read$6 = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	var __spreadArray$6 = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	  return to;
	};
	Object.defineProperty(mergeWith$1, "__esModule", {
	  value: true
	});
	mergeWith$1.mergeWith = void 0;
	var merge_1 = merge$1;
	function mergeWith() {
	  var otherSources = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    otherSources[_i] = arguments[_i];
	  }
	  return merge_1.merge.apply(void 0, __spreadArray$6([], __read$6(otherSources)));
	}
	mergeWith$1.mergeWith = mergeWith;

	var min$1 = {};

	Object.defineProperty(min$1, "__esModule", {
	  value: true
	});
	min$1.min = void 0;
	var reduce_1 = reduce$1;
	var isFunction_1$4 = isFunction$1;
	function min(comparer) {
	  return reduce_1.reduce(isFunction_1$4.isFunction(comparer) ? function (x, y) {
	    return comparer(x, y) < 0 ? x : y;
	  } : function (x, y) {
	    return x < y ? x : y;
	  });
	}
	min$1.min = min;

	var multicast$1 = {};

	Object.defineProperty(multicast$1, "__esModule", {
	  value: true
	});
	multicast$1.multicast = void 0;
	var ConnectableObservable_1$2 = ConnectableObservable$1;
	var isFunction_1$3 = isFunction$1;
	var connect_1$1 = connect$1;
	function multicast(subjectOrSubjectFactory, selector) {
	  var subjectFactory = isFunction_1$3.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function () {
	    return subjectOrSubjectFactory;
	  };
	  if (isFunction_1$3.isFunction(selector)) {
	    return connect_1$1.connect(selector, {
	      connector: subjectFactory
	    });
	  }
	  return function (source) {
	    return new ConnectableObservable_1$2.ConnectableObservable(source, subjectFactory);
	  };
	}
	multicast$1.multicast = multicast;

	var onErrorResumeNextWith$1 = {};

	var __read$5 = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	var __spreadArray$5 = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	  return to;
	};
	Object.defineProperty(onErrorResumeNextWith$1, "__esModule", {
	  value: true
	});
	onErrorResumeNextWith$1.onErrorResumeNext = onErrorResumeNextWith$1.onErrorResumeNextWith = void 0;
	var argsOrArgArray_1 = argsOrArgArray$1;
	var onErrorResumeNext_1 = onErrorResumeNext$1;
	function onErrorResumeNextWith() {
	  var sources = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    sources[_i] = arguments[_i];
	  }
	  var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
	  return function (source) {
	    return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray$5([source], __read$5(nextSources)));
	  };
	}
	onErrorResumeNextWith$1.onErrorResumeNextWith = onErrorResumeNextWith;
	onErrorResumeNextWith$1.onErrorResumeNext = onErrorResumeNextWith;

	var pairwise$1 = {};

	Object.defineProperty(pairwise$1, "__esModule", {
	  value: true
	});
	pairwise$1.pairwise = void 0;
	var lift_1$s = lift;
	var OperatorSubscriber_1$m = OperatorSubscriber$1;
	function pairwise() {
	  return lift_1$s.operate(function (source, subscriber) {
	    var prev;
	    var hasPrev = false;
	    source.subscribe(OperatorSubscriber_1$m.createOperatorSubscriber(subscriber, function (value) {
	      var p = prev;
	      prev = value;
	      hasPrev && subscriber.next([p, value]);
	      hasPrev = true;
	    }));
	  });
	}
	pairwise$1.pairwise = pairwise;

	var pluck$1 = {};

	Object.defineProperty(pluck$1, "__esModule", {
	  value: true
	});
	pluck$1.pluck = void 0;
	var map_1$1 = map$1;
	function pluck() {
	  var properties = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    properties[_i] = arguments[_i];
	  }
	  var length = properties.length;
	  if (length === 0) {
	    throw new Error('list of properties cannot be empty.');
	  }
	  return map_1$1.map(function (x) {
	    var currentProp = x;
	    for (var i = 0; i < length; i++) {
	      var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
	      if (typeof p !== 'undefined') {
	        currentProp = p;
	      } else {
	        return undefined;
	      }
	    }
	    return currentProp;
	  });
	}
	pluck$1.pluck = pluck;

	var publish$1 = {};

	Object.defineProperty(publish$1, "__esModule", {
	  value: true
	});
	publish$1.publish = void 0;
	var Subject_1$8 = Subject$1;
	var multicast_1$1 = multicast$1;
	var connect_1 = connect$1;
	function publish(selector) {
	  return selector ? function (source) {
	    return connect_1.connect(selector)(source);
	  } : function (source) {
	    return multicast_1$1.multicast(new Subject_1$8.Subject())(source);
	  };
	}
	publish$1.publish = publish;

	var publishBehavior$1 = {};

	Object.defineProperty(publishBehavior$1, "__esModule", {
	  value: true
	});
	publishBehavior$1.publishBehavior = void 0;
	var BehaviorSubject_1 = BehaviorSubject$1;
	var ConnectableObservable_1$1 = ConnectableObservable$1;
	function publishBehavior(initialValue) {
	  return function (source) {
	    var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
	    return new ConnectableObservable_1$1.ConnectableObservable(source, function () {
	      return subject;
	    });
	  };
	}
	publishBehavior$1.publishBehavior = publishBehavior;

	var publishLast$1 = {};

	Object.defineProperty(publishLast$1, "__esModule", {
	  value: true
	});
	publishLast$1.publishLast = void 0;
	var AsyncSubject_1 = AsyncSubject$1;
	var ConnectableObservable_1 = ConnectableObservable$1;
	function publishLast() {
	  return function (source) {
	    var subject = new AsyncSubject_1.AsyncSubject();
	    return new ConnectableObservable_1.ConnectableObservable(source, function () {
	      return subject;
	    });
	  };
	}
	publishLast$1.publishLast = publishLast;

	var publishReplay$1 = {};

	Object.defineProperty(publishReplay$1, "__esModule", {
	  value: true
	});
	publishReplay$1.publishReplay = void 0;
	var ReplaySubject_1$1 = ReplaySubject$1;
	var multicast_1 = multicast$1;
	var isFunction_1$2 = isFunction$1;
	function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
	  if (selectorOrScheduler && !isFunction_1$2.isFunction(selectorOrScheduler)) {
	    timestampProvider = selectorOrScheduler;
	  }
	  var selector = isFunction_1$2.isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;
	  return function (source) {
	    return multicast_1.multicast(new ReplaySubject_1$1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source);
	  };
	}
	publishReplay$1.publishReplay = publishReplay;

	var raceWith$1 = {};

	var __read$4 = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	var __spreadArray$4 = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	  return to;
	};
	Object.defineProperty(raceWith$1, "__esModule", {
	  value: true
	});
	raceWith$1.raceWith = void 0;
	var race_1 = race$1;
	var lift_1$r = lift;
	var identity_1$5 = identity$1;
	function raceWith() {
	  var otherSources = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    otherSources[_i] = arguments[_i];
	  }
	  return !otherSources.length ? identity_1$5.identity : lift_1$r.operate(function (source, subscriber) {
	    race_1.raceInit(__spreadArray$4([source], __read$4(otherSources)))(subscriber);
	  });
	}
	raceWith$1.raceWith = raceWith;

	var repeat$1 = {};

	Object.defineProperty(repeat$1, "__esModule", {
	  value: true
	});
	repeat$1.repeat = void 0;
	var empty_1 = empty;
	var lift_1$q = lift;
	var OperatorSubscriber_1$l = OperatorSubscriber$1;
	var innerFrom_1$e = innerFrom$1;
	var timer_1$2 = timer$1;
	function repeat(countOrConfig) {
	  var _a;
	  var count = Infinity;
	  var delay;
	  if (countOrConfig != null) {
	    if (_typeof(countOrConfig) === 'object') {
	      _a = countOrConfig.count, count = _a === void 0 ? Infinity : _a, delay = countOrConfig.delay;
	    } else {
	      count = countOrConfig;
	    }
	  }
	  return count <= 0 ? function () {
	    return empty_1.EMPTY;
	  } : lift_1$q.operate(function (source, subscriber) {
	    var soFar = 0;
	    var sourceSub;
	    var resubscribe = function resubscribe() {
	      sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
	      sourceSub = null;
	      if (delay != null) {
	        var notifier = typeof delay === 'number' ? timer_1$2.timer(delay) : innerFrom_1$e.innerFrom(delay(soFar));
	        var notifierSubscriber_1 = OperatorSubscriber_1$l.createOperatorSubscriber(subscriber, function () {
	          notifierSubscriber_1.unsubscribe();
	          subscribeToSource();
	        });
	        notifier.subscribe(notifierSubscriber_1);
	      } else {
	        subscribeToSource();
	      }
	    };
	    var subscribeToSource = function subscribeToSource() {
	      var syncUnsub = false;
	      sourceSub = source.subscribe(OperatorSubscriber_1$l.createOperatorSubscriber(subscriber, undefined, function () {
	        if (++soFar < count) {
	          if (sourceSub) {
	            resubscribe();
	          } else {
	            syncUnsub = true;
	          }
	        } else {
	          subscriber.complete();
	        }
	      }));
	      if (syncUnsub) {
	        resubscribe();
	      }
	    };
	    subscribeToSource();
	  });
	}
	repeat$1.repeat = repeat;

	var repeatWhen$1 = {};

	Object.defineProperty(repeatWhen$1, "__esModule", {
	  value: true
	});
	repeatWhen$1.repeatWhen = void 0;
	var innerFrom_1$d = innerFrom$1;
	var Subject_1$7 = Subject$1;
	var lift_1$p = lift;
	var OperatorSubscriber_1$k = OperatorSubscriber$1;
	function repeatWhen(notifier) {
	  return lift_1$p.operate(function (source, subscriber) {
	    var innerSub;
	    var syncResub = false;
	    var completions$;
	    var isNotifierComplete = false;
	    var isMainComplete = false;
	    var checkComplete = function checkComplete() {
	      return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
	    };
	    var getCompletionSubject = function getCompletionSubject() {
	      if (!completions$) {
	        completions$ = new Subject_1$7.Subject();
	        innerFrom_1$d.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1$k.createOperatorSubscriber(subscriber, function () {
	          if (innerSub) {
	            subscribeForRepeatWhen();
	          } else {
	            syncResub = true;
	          }
	        }, function () {
	          isNotifierComplete = true;
	          checkComplete();
	        }));
	      }
	      return completions$;
	    };
	    var subscribeForRepeatWhen = function subscribeForRepeatWhen() {
	      isMainComplete = false;
	      innerSub = source.subscribe(OperatorSubscriber_1$k.createOperatorSubscriber(subscriber, undefined, function () {
	        isMainComplete = true;
	        !checkComplete() && getCompletionSubject().next();
	      }));
	      if (syncResub) {
	        innerSub.unsubscribe();
	        innerSub = null;
	        syncResub = false;
	        subscribeForRepeatWhen();
	      }
	    };
	    subscribeForRepeatWhen();
	  });
	}
	repeatWhen$1.repeatWhen = repeatWhen;

	var retry$1 = {};

	Object.defineProperty(retry$1, "__esModule", {
	  value: true
	});
	retry$1.retry = void 0;
	var lift_1$o = lift;
	var OperatorSubscriber_1$j = OperatorSubscriber$1;
	var identity_1$4 = identity$1;
	var timer_1$1 = timer$1;
	var innerFrom_1$c = innerFrom$1;
	function retry(configOrCount) {
	  if (configOrCount === void 0) {
	    configOrCount = Infinity;
	  }
	  var config;
	  if (configOrCount && _typeof(configOrCount) === 'object') {
	    config = configOrCount;
	  } else {
	    config = {
	      count: configOrCount
	    };
	  }
	  var _a = config.count,
	    count = _a === void 0 ? Infinity : _a,
	    delay = config.delay,
	    _b = config.resetOnSuccess,
	    resetOnSuccess = _b === void 0 ? false : _b;
	  return count <= 0 ? identity_1$4.identity : lift_1$o.operate(function (source, subscriber) {
	    var soFar = 0;
	    var innerSub;
	    var subscribeForRetry = function subscribeForRetry() {
	      var syncUnsub = false;
	      innerSub = source.subscribe(OperatorSubscriber_1$j.createOperatorSubscriber(subscriber, function (value) {
	        if (resetOnSuccess) {
	          soFar = 0;
	        }
	        subscriber.next(value);
	      }, undefined, function (err) {
	        if (soFar++ < count) {
	          var resub_1 = function resub_1() {
	            if (innerSub) {
	              innerSub.unsubscribe();
	              innerSub = null;
	              subscribeForRetry();
	            } else {
	              syncUnsub = true;
	            }
	          };
	          if (delay != null) {
	            var notifier = typeof delay === 'number' ? timer_1$1.timer(delay) : innerFrom_1$c.innerFrom(delay(err, soFar));
	            var notifierSubscriber_1 = OperatorSubscriber_1$j.createOperatorSubscriber(subscriber, function () {
	              notifierSubscriber_1.unsubscribe();
	              resub_1();
	            }, function () {
	              subscriber.complete();
	            });
	            notifier.subscribe(notifierSubscriber_1);
	          } else {
	            resub_1();
	          }
	        } else {
	          subscriber.error(err);
	        }
	      }));
	      if (syncUnsub) {
	        innerSub.unsubscribe();
	        innerSub = null;
	        subscribeForRetry();
	      }
	    };
	    subscribeForRetry();
	  });
	}
	retry$1.retry = retry;

	var retryWhen$1 = {};

	Object.defineProperty(retryWhen$1, "__esModule", {
	  value: true
	});
	retryWhen$1.retryWhen = void 0;
	var innerFrom_1$b = innerFrom$1;
	var Subject_1$6 = Subject$1;
	var lift_1$n = lift;
	var OperatorSubscriber_1$i = OperatorSubscriber$1;
	function retryWhen(notifier) {
	  return lift_1$n.operate(function (source, subscriber) {
	    var innerSub;
	    var syncResub = false;
	    var errors$;
	    var subscribeForRetryWhen = function subscribeForRetryWhen() {
	      innerSub = source.subscribe(OperatorSubscriber_1$i.createOperatorSubscriber(subscriber, undefined, undefined, function (err) {
	        if (!errors$) {
	          errors$ = new Subject_1$6.Subject();
	          innerFrom_1$b.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1$i.createOperatorSubscriber(subscriber, function () {
	            return innerSub ? subscribeForRetryWhen() : syncResub = true;
	          }));
	        }
	        if (errors$) {
	          errors$.next(err);
	        }
	      }));
	      if (syncResub) {
	        innerSub.unsubscribe();
	        innerSub = null;
	        syncResub = false;
	        subscribeForRetryWhen();
	      }
	    };
	    subscribeForRetryWhen();
	  });
	}
	retryWhen$1.retryWhen = retryWhen;

	var sample$1 = {};

	Object.defineProperty(sample$1, "__esModule", {
	  value: true
	});
	sample$1.sample = void 0;
	var innerFrom_1$a = innerFrom$1;
	var lift_1$m = lift;
	var noop_1$5 = noop$1;
	var OperatorSubscriber_1$h = OperatorSubscriber$1;
	function sample(notifier) {
	  return lift_1$m.operate(function (source, subscriber) {
	    var hasValue = false;
	    var lastValue = null;
	    source.subscribe(OperatorSubscriber_1$h.createOperatorSubscriber(subscriber, function (value) {
	      hasValue = true;
	      lastValue = value;
	    }));
	    innerFrom_1$a.innerFrom(notifier).subscribe(OperatorSubscriber_1$h.createOperatorSubscriber(subscriber, function () {
	      if (hasValue) {
	        hasValue = false;
	        var value = lastValue;
	        lastValue = null;
	        subscriber.next(value);
	      }
	    }, noop_1$5.noop));
	  });
	}
	sample$1.sample = sample;

	var sampleTime$1 = {};

	Object.defineProperty(sampleTime$1, "__esModule", {
	  value: true
	});
	sampleTime$1.sampleTime = void 0;
	var async_1$4 = async;
	var sample_1 = sample$1;
	var interval_1 = interval$1;
	function sampleTime(period, scheduler) {
	  if (scheduler === void 0) {
	    scheduler = async_1$4.asyncScheduler;
	  }
	  return sample_1.sample(interval_1.interval(period, scheduler));
	}
	sampleTime$1.sampleTime = sampleTime;

	var scan$1 = {};

	Object.defineProperty(scan$1, "__esModule", {
	  value: true
	});
	scan$1.scan = void 0;
	var lift_1$l = lift;
	var scanInternals_1 = scanInternals$1;
	function scan(accumulator, seed) {
	  return lift_1$l.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
	}
	scan$1.scan = scan;

	var sequenceEqual$1 = {};

	Object.defineProperty(sequenceEqual$1, "__esModule", {
	  value: true
	});
	sequenceEqual$1.sequenceEqual = void 0;
	var lift_1$k = lift;
	var OperatorSubscriber_1$g = OperatorSubscriber$1;
	var innerFrom_1$9 = innerFrom$1;
	function sequenceEqual(compareTo, comparator) {
	  if (comparator === void 0) {
	    comparator = function comparator(a, b) {
	      return a === b;
	    };
	  }
	  return lift_1$k.operate(function (source, subscriber) {
	    var aState = createState();
	    var bState = createState();
	    var emit = function emit(isEqual) {
	      subscriber.next(isEqual);
	      subscriber.complete();
	    };
	    var createSubscriber = function createSubscriber(selfState, otherState) {
	      var sequenceEqualSubscriber = OperatorSubscriber_1$g.createOperatorSubscriber(subscriber, function (a) {
	        var buffer = otherState.buffer,
	          complete = otherState.complete;
	        if (buffer.length === 0) {
	          complete ? emit(false) : selfState.buffer.push(a);
	        } else {
	          !comparator(a, buffer.shift()) && emit(false);
	        }
	      }, function () {
	        selfState.complete = true;
	        var complete = otherState.complete,
	          buffer = otherState.buffer;
	        complete && emit(buffer.length === 0);
	        sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
	      });
	      return sequenceEqualSubscriber;
	    };
	    source.subscribe(createSubscriber(aState, bState));
	    innerFrom_1$9.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
	  });
	}
	sequenceEqual$1.sequenceEqual = sequenceEqual;
	function createState() {
	  return {
	    buffer: [],
	    complete: false
	  };
	}

	var share$1 = {};

	var __read$3 = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	var __spreadArray$3 = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	  return to;
	};
	Object.defineProperty(share$1, "__esModule", {
	  value: true
	});
	share$1.share = void 0;
	var innerFrom_1$8 = innerFrom$1;
	var Subject_1$5 = Subject$1;
	var Subscriber_1 = Subscriber;
	var lift_1$j = lift;
	function share(options) {
	  if (options === void 0) {
	    options = {};
	  }
	  var _a = options.connector,
	    connector = _a === void 0 ? function () {
	      return new Subject_1$5.Subject();
	    } : _a,
	    _b = options.resetOnError,
	    resetOnError = _b === void 0 ? true : _b,
	    _c = options.resetOnComplete,
	    resetOnComplete = _c === void 0 ? true : _c,
	    _d = options.resetOnRefCountZero,
	    resetOnRefCountZero = _d === void 0 ? true : _d;
	  return function (wrapperSource) {
	    var connection;
	    var resetConnection;
	    var subject;
	    var refCount = 0;
	    var hasCompleted = false;
	    var hasErrored = false;
	    var cancelReset = function cancelReset() {
	      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
	      resetConnection = undefined;
	    };
	    var reset = function reset() {
	      cancelReset();
	      connection = subject = undefined;
	      hasCompleted = hasErrored = false;
	    };
	    var resetAndUnsubscribe = function resetAndUnsubscribe() {
	      var conn = connection;
	      reset();
	      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
	    };
	    return lift_1$j.operate(function (source, subscriber) {
	      refCount++;
	      if (!hasErrored && !hasCompleted) {
	        cancelReset();
	      }
	      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
	      subscriber.add(function () {
	        refCount--;
	        if (refCount === 0 && !hasErrored && !hasCompleted) {
	          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
	        }
	      });
	      dest.subscribe(subscriber);
	      if (!connection && refCount > 0) {
	        connection = new Subscriber_1.SafeSubscriber({
	          next: function next(value) {
	            return dest.next(value);
	          },
	          error: function error(err) {
	            hasErrored = true;
	            cancelReset();
	            resetConnection = handleReset(reset, resetOnError, err);
	            dest.error(err);
	          },
	          complete: function complete() {
	            hasCompleted = true;
	            cancelReset();
	            resetConnection = handleReset(reset, resetOnComplete);
	            dest.complete();
	          }
	        });
	        innerFrom_1$8.innerFrom(source).subscribe(connection);
	      }
	    })(wrapperSource);
	  };
	}
	share$1.share = share;
	function handleReset(reset, on) {
	  var args = [];
	  for (var _i = 2; _i < arguments.length; _i++) {
	    args[_i - 2] = arguments[_i];
	  }
	  if (on === true) {
	    reset();
	    return;
	  }
	  if (on === false) {
	    return;
	  }
	  var onSubscriber = new Subscriber_1.SafeSubscriber({
	    next: function next() {
	      onSubscriber.unsubscribe();
	      reset();
	    }
	  });
	  return innerFrom_1$8.innerFrom(on.apply(void 0, __spreadArray$3([], __read$3(args)))).subscribe(onSubscriber);
	}

	var shareReplay$1 = {};

	Object.defineProperty(shareReplay$1, "__esModule", {
	  value: true
	});
	shareReplay$1.shareReplay = void 0;
	var ReplaySubject_1 = ReplaySubject$1;
	var share_1 = share$1;
	function shareReplay(configOrBufferSize, windowTime, scheduler) {
	  var _a, _b, _c;
	  var bufferSize;
	  var refCount = false;
	  if (configOrBufferSize && _typeof(configOrBufferSize) === 'object') {
	    _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
	  } else {
	    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
	  }
	  return share_1.share({
	    connector: function connector() {
	      return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
	    },
	    resetOnError: true,
	    resetOnComplete: false,
	    resetOnRefCountZero: refCount
	  });
	}
	shareReplay$1.shareReplay = shareReplay;

	var single$1 = {};

	Object.defineProperty(single$1, "__esModule", {
	  value: true
	});
	single$1.single = void 0;
	var EmptyError_1 = EmptyError;
	var SequenceError_1 = SequenceError;
	var NotFoundError_1 = NotFoundError;
	var lift_1$i = lift;
	var OperatorSubscriber_1$f = OperatorSubscriber$1;
	function single(predicate) {
	  return lift_1$i.operate(function (source, subscriber) {
	    var hasValue = false;
	    var singleValue;
	    var seenValue = false;
	    var index = 0;
	    source.subscribe(OperatorSubscriber_1$f.createOperatorSubscriber(subscriber, function (value) {
	      seenValue = true;
	      if (!predicate || predicate(value, index++, source)) {
	        hasValue && subscriber.error(new SequenceError_1.SequenceError('Too many matching values'));
	        hasValue = true;
	        singleValue = value;
	      }
	    }, function () {
	      if (hasValue) {
	        subscriber.next(singleValue);
	        subscriber.complete();
	      } else {
	        subscriber.error(seenValue ? new NotFoundError_1.NotFoundError('No matching values') : new EmptyError_1.EmptyError());
	      }
	    }));
	  });
	}
	single$1.single = single;

	var skip$1 = {};

	Object.defineProperty(skip$1, "__esModule", {
	  value: true
	});
	skip$1.skip = void 0;
	var filter_1 = filter$1;
	function skip(count) {
	  return filter_1.filter(function (_, index) {
	    return count <= index;
	  });
	}
	skip$1.skip = skip;

	var skipLast$1 = {};

	Object.defineProperty(skipLast$1, "__esModule", {
	  value: true
	});
	skipLast$1.skipLast = void 0;
	var identity_1$3 = identity$1;
	var lift_1$h = lift;
	var OperatorSubscriber_1$e = OperatorSubscriber$1;
	function skipLast(skipCount) {
	  return skipCount <= 0 ? identity_1$3.identity : lift_1$h.operate(function (source, subscriber) {
	    var ring = new Array(skipCount);
	    var seen = 0;
	    source.subscribe(OperatorSubscriber_1$e.createOperatorSubscriber(subscriber, function (value) {
	      var valueIndex = seen++;
	      if (valueIndex < skipCount) {
	        ring[valueIndex] = value;
	      } else {
	        var index = valueIndex % skipCount;
	        var oldValue = ring[index];
	        ring[index] = value;
	        subscriber.next(oldValue);
	      }
	    }));
	    return function () {
	      ring = null;
	    };
	  });
	}
	skipLast$1.skipLast = skipLast;

	var skipUntil$1 = {};

	Object.defineProperty(skipUntil$1, "__esModule", {
	  value: true
	});
	skipUntil$1.skipUntil = void 0;
	var lift_1$g = lift;
	var OperatorSubscriber_1$d = OperatorSubscriber$1;
	var innerFrom_1$7 = innerFrom$1;
	var noop_1$4 = noop$1;
	function skipUntil(notifier) {
	  return lift_1$g.operate(function (source, subscriber) {
	    var taking = false;
	    var skipSubscriber = OperatorSubscriber_1$d.createOperatorSubscriber(subscriber, function () {
	      skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
	      taking = true;
	    }, noop_1$4.noop);
	    innerFrom_1$7.innerFrom(notifier).subscribe(skipSubscriber);
	    source.subscribe(OperatorSubscriber_1$d.createOperatorSubscriber(subscriber, function (value) {
	      return taking && subscriber.next(value);
	    }));
	  });
	}
	skipUntil$1.skipUntil = skipUntil;

	var skipWhile$1 = {};

	Object.defineProperty(skipWhile$1, "__esModule", {
	  value: true
	});
	skipWhile$1.skipWhile = void 0;
	var lift_1$f = lift;
	var OperatorSubscriber_1$c = OperatorSubscriber$1;
	function skipWhile(predicate) {
	  return lift_1$f.operate(function (source, subscriber) {
	    var taking = false;
	    var index = 0;
	    source.subscribe(OperatorSubscriber_1$c.createOperatorSubscriber(subscriber, function (value) {
	      return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
	    }));
	  });
	}
	skipWhile$1.skipWhile = skipWhile;

	var startWith$1 = {};

	Object.defineProperty(startWith$1, "__esModule", {
	  value: true
	});
	startWith$1.startWith = void 0;
	var concat_1 = concat$3;
	var args_1$2 = args;
	var lift_1$e = lift;
	function startWith() {
	  var values = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    values[_i] = arguments[_i];
	  }
	  var scheduler = args_1$2.popScheduler(values);
	  return lift_1$e.operate(function (source, subscriber) {
	    (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
	  });
	}
	startWith$1.startWith = startWith;

	var switchAll$1 = {};

	var switchMap$1 = {};

	Object.defineProperty(switchMap$1, "__esModule", {
	  value: true
	});
	switchMap$1.switchMap = void 0;
	var innerFrom_1$6 = innerFrom$1;
	var lift_1$d = lift;
	var OperatorSubscriber_1$b = OperatorSubscriber$1;
	function switchMap(project, resultSelector) {
	  return lift_1$d.operate(function (source, subscriber) {
	    var innerSubscriber = null;
	    var index = 0;
	    var isComplete = false;
	    var checkComplete = function checkComplete() {
	      return isComplete && !innerSubscriber && subscriber.complete();
	    };
	    source.subscribe(OperatorSubscriber_1$b.createOperatorSubscriber(subscriber, function (value) {
	      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
	      var innerIndex = 0;
	      var outerIndex = index++;
	      innerFrom_1$6.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1$b.createOperatorSubscriber(subscriber, function (innerValue) {
	        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
	      }, function () {
	        innerSubscriber = null;
	        checkComplete();
	      }));
	    }, function () {
	      isComplete = true;
	      checkComplete();
	    }));
	  });
	}
	switchMap$1.switchMap = switchMap;

	Object.defineProperty(switchAll$1, "__esModule", {
	  value: true
	});
	switchAll$1.switchAll = void 0;
	var switchMap_1$2 = switchMap$1;
	var identity_1$2 = identity$1;
	function switchAll() {
	  return switchMap_1$2.switchMap(identity_1$2.identity);
	}
	switchAll$1.switchAll = switchAll;

	var switchMapTo$1 = {};

	Object.defineProperty(switchMapTo$1, "__esModule", {
	  value: true
	});
	switchMapTo$1.switchMapTo = void 0;
	var switchMap_1$1 = switchMap$1;
	var isFunction_1$1 = isFunction$1;
	function switchMapTo(innerObservable, resultSelector) {
	  return isFunction_1$1.isFunction(resultSelector) ? switchMap_1$1.switchMap(function () {
	    return innerObservable;
	  }, resultSelector) : switchMap_1$1.switchMap(function () {
	    return innerObservable;
	  });
	}
	switchMapTo$1.switchMapTo = switchMapTo;

	var switchScan$1 = {};

	Object.defineProperty(switchScan$1, "__esModule", {
	  value: true
	});
	switchScan$1.switchScan = void 0;
	var switchMap_1 = switchMap$1;
	var lift_1$c = lift;
	function switchScan(accumulator, seed) {
	  return lift_1$c.operate(function (source, subscriber) {
	    var state = seed;
	    switchMap_1.switchMap(function (value, index) {
	      return accumulator(state, value, index);
	    }, function (_, innerValue) {
	      return state = innerValue, innerValue;
	    })(source).subscribe(subscriber);
	    return function () {
	      state = null;
	    };
	  });
	}
	switchScan$1.switchScan = switchScan;

	var takeUntil$1 = {};

	Object.defineProperty(takeUntil$1, "__esModule", {
	  value: true
	});
	takeUntil$1.takeUntil = void 0;
	var lift_1$b = lift;
	var OperatorSubscriber_1$a = OperatorSubscriber$1;
	var innerFrom_1$5 = innerFrom$1;
	var noop_1$3 = noop$1;
	function takeUntil(notifier) {
	  return lift_1$b.operate(function (source, subscriber) {
	    innerFrom_1$5.innerFrom(notifier).subscribe(OperatorSubscriber_1$a.createOperatorSubscriber(subscriber, function () {
	      return subscriber.complete();
	    }, noop_1$3.noop));
	    !subscriber.closed && source.subscribe(subscriber);
	  });
	}
	takeUntil$1.takeUntil = takeUntil;

	var takeWhile$1 = {};

	Object.defineProperty(takeWhile$1, "__esModule", {
	  value: true
	});
	takeWhile$1.takeWhile = void 0;
	var lift_1$a = lift;
	var OperatorSubscriber_1$9 = OperatorSubscriber$1;
	function takeWhile(predicate, inclusive) {
	  if (inclusive === void 0) {
	    inclusive = false;
	  }
	  return lift_1$a.operate(function (source, subscriber) {
	    var index = 0;
	    source.subscribe(OperatorSubscriber_1$9.createOperatorSubscriber(subscriber, function (value) {
	      var result = predicate(value, index++);
	      (result || inclusive) && subscriber.next(value);
	      !result && subscriber.complete();
	    }));
	  });
	}
	takeWhile$1.takeWhile = takeWhile;

	var tap$1 = {};

	Object.defineProperty(tap$1, "__esModule", {
	  value: true
	});
	tap$1.tap = void 0;
	var isFunction_1 = isFunction$1;
	var lift_1$9 = lift;
	var OperatorSubscriber_1$8 = OperatorSubscriber$1;
	var identity_1$1 = identity$1;
	function tap(observerOrNext, error, complete) {
	  var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete ? {
	    next: observerOrNext,
	    error: error,
	    complete: complete
	  } : observerOrNext;
	  return tapObserver ? lift_1$9.operate(function (source, subscriber) {
	    var _a;
	    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
	    var isUnsub = true;
	    source.subscribe(OperatorSubscriber_1$8.createOperatorSubscriber(subscriber, function (value) {
	      var _a;
	      (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);
	      subscriber.next(value);
	    }, function () {
	      var _a;
	      isUnsub = false;
	      (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
	      subscriber.complete();
	    }, function (err) {
	      var _a;
	      isUnsub = false;
	      (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);
	      subscriber.error(err);
	    }, function () {
	      var _a, _b;
	      if (isUnsub) {
	        (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
	      }
	      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
	    }));
	  }) : identity_1$1.identity;
	}
	tap$1.tap = tap;

	var throttle$1 = {};

	Object.defineProperty(throttle$1, "__esModule", {
	  value: true
	});
	throttle$1.throttle = void 0;
	var lift_1$8 = lift;
	var OperatorSubscriber_1$7 = OperatorSubscriber$1;
	var innerFrom_1$4 = innerFrom$1;
	function throttle(durationSelector, config) {
	  return lift_1$8.operate(function (source, subscriber) {
	    var _a = config !== null && config !== void 0 ? config : {},
	      _b = _a.leading,
	      leading = _b === void 0 ? true : _b,
	      _c = _a.trailing,
	      trailing = _c === void 0 ? false : _c;
	    var hasValue = false;
	    var sendValue = null;
	    var throttled = null;
	    var isComplete = false;
	    var endThrottling = function endThrottling() {
	      throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
	      throttled = null;
	      if (trailing) {
	        send();
	        isComplete && subscriber.complete();
	      }
	    };
	    var cleanupThrottling = function cleanupThrottling() {
	      throttled = null;
	      isComplete && subscriber.complete();
	    };
	    var startThrottle = function startThrottle(value) {
	      return throttled = innerFrom_1$4.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1$7.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
	    };
	    var send = function send() {
	      if (hasValue) {
	        hasValue = false;
	        var value = sendValue;
	        sendValue = null;
	        subscriber.next(value);
	        !isComplete && startThrottle(value);
	      }
	    };
	    source.subscribe(OperatorSubscriber_1$7.createOperatorSubscriber(subscriber, function (value) {
	      hasValue = true;
	      sendValue = value;
	      !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
	    }, function () {
	      isComplete = true;
	      !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
	    }));
	  });
	}
	throttle$1.throttle = throttle;

	var throttleTime$1 = {};

	Object.defineProperty(throttleTime$1, "__esModule", {
	  value: true
	});
	throttleTime$1.throttleTime = void 0;
	var async_1$3 = async;
	var throttle_1 = throttle$1;
	var timer_1 = timer$1;
	function throttleTime(duration, scheduler, config) {
	  if (scheduler === void 0) {
	    scheduler = async_1$3.asyncScheduler;
	  }
	  var duration$ = timer_1.timer(duration, scheduler);
	  return throttle_1.throttle(function () {
	    return duration$;
	  }, config);
	}
	throttleTime$1.throttleTime = throttleTime;

	var timeInterval$1 = {};

	Object.defineProperty(timeInterval$1, "__esModule", {
	  value: true
	});
	timeInterval$1.TimeInterval = timeInterval$1.timeInterval = void 0;
	var async_1$2 = async;
	var lift_1$7 = lift;
	var OperatorSubscriber_1$6 = OperatorSubscriber$1;
	function timeInterval(scheduler) {
	  if (scheduler === void 0) {
	    scheduler = async_1$2.asyncScheduler;
	  }
	  return lift_1$7.operate(function (source, subscriber) {
	    var last = scheduler.now();
	    source.subscribe(OperatorSubscriber_1$6.createOperatorSubscriber(subscriber, function (value) {
	      var now = scheduler.now();
	      var interval = now - last;
	      last = now;
	      subscriber.next(new TimeInterval(value, interval));
	    }));
	  });
	}
	timeInterval$1.timeInterval = timeInterval;
	var TimeInterval = /*#__PURE__*/function () {
	  function TimeInterval(value, interval) {
	    this.value = value;
	    this.interval = interval;
	  }
	  return TimeInterval;
	}();
	timeInterval$1.TimeInterval = TimeInterval;

	var timeoutWith$1 = {};

	Object.defineProperty(timeoutWith$1, "__esModule", {
	  value: true
	});
	timeoutWith$1.timeoutWith = void 0;
	var async_1$1 = async;
	var isDate_1 = isDate;
	var timeout_1 = timeout$1;
	function timeoutWith(due, withObservable, scheduler) {
	  var first;
	  var each;
	  var _with;
	  scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1$1.async;
	  if (isDate_1.isValidDate(due)) {
	    first = due;
	  } else if (typeof due === 'number') {
	    each = due;
	  }
	  if (withObservable) {
	    _with = function _with() {
	      return withObservable;
	    };
	  } else {
	    throw new TypeError('No observable provided to switch to');
	  }
	  if (first == null && each == null) {
	    throw new TypeError('No timeout provided.');
	  }
	  return timeout_1.timeout({
	    first: first,
	    each: each,
	    scheduler: scheduler,
	    "with": _with
	  });
	}
	timeoutWith$1.timeoutWith = timeoutWith;

	var timestamp$1 = {};

	Object.defineProperty(timestamp$1, "__esModule", {
	  value: true
	});
	timestamp$1.timestamp = void 0;
	var dateTimestampProvider_1 = dateTimestampProvider;
	var map_1 = map$1;
	function timestamp(timestampProvider) {
	  if (timestampProvider === void 0) {
	    timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
	  }
	  return map_1.map(function (value) {
	    return {
	      value: value,
	      timestamp: timestampProvider.now()
	    };
	  });
	}
	timestamp$1.timestamp = timestamp;

	var window$2 = {};

	Object.defineProperty(window$2, "__esModule", {
	  value: true
	});
	window$2.window = void 0;
	var Subject_1$4 = Subject$1;
	var lift_1$6 = lift;
	var OperatorSubscriber_1$5 = OperatorSubscriber$1;
	var noop_1$2 = noop$1;
	var innerFrom_1$3 = innerFrom$1;
	function window$1(windowBoundaries) {
	  return lift_1$6.operate(function (source, subscriber) {
	    var windowSubject = new Subject_1$4.Subject();
	    subscriber.next(windowSubject.asObservable());
	    var errorHandler = function errorHandler(err) {
	      windowSubject.error(err);
	      subscriber.error(err);
	    };
	    source.subscribe(OperatorSubscriber_1$5.createOperatorSubscriber(subscriber, function (value) {
	      return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
	    }, function () {
	      windowSubject.complete();
	      subscriber.complete();
	    }, errorHandler));
	    innerFrom_1$3.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1$5.createOperatorSubscriber(subscriber, function () {
	      windowSubject.complete();
	      subscriber.next(windowSubject = new Subject_1$4.Subject());
	    }, noop_1$2.noop, errorHandler));
	    return function () {
	      windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
	      windowSubject = null;
	    };
	  });
	}
	window$2.window = window$1;

	var windowCount$1 = {};

	var __values$1 = commonjsGlobal && commonjsGlobal.__values || function (o) {
	  var s = typeof Symbol === "function" && Symbol.iterator,
	    m = s && o[s],
	    i = 0;
	  if (m) return m.call(o);
	  if (o && typeof o.length === "number") return {
	    next: function next() {
	      if (o && i >= o.length) o = void 0;
	      return {
	        value: o && o[i++],
	        done: !o
	      };
	    }
	  };
	  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(windowCount$1, "__esModule", {
	  value: true
	});
	windowCount$1.windowCount = void 0;
	var Subject_1$3 = Subject$1;
	var lift_1$5 = lift;
	var OperatorSubscriber_1$4 = OperatorSubscriber$1;
	function windowCount(windowSize, startWindowEvery) {
	  if (startWindowEvery === void 0) {
	    startWindowEvery = 0;
	  }
	  var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
	  return lift_1$5.operate(function (source, subscriber) {
	    var windows = [new Subject_1$3.Subject()];
	    var count = 0;
	    subscriber.next(windows[0].asObservable());
	    source.subscribe(OperatorSubscriber_1$4.createOperatorSubscriber(subscriber, function (value) {
	      var e_1, _a;
	      try {
	        for (var windows_1 = __values$1(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
	          var window_1 = windows_1_1.value;
	          window_1.next(value);
	        }
	      } catch (e_1_1) {
	        e_1 = {
	          error: e_1_1
	        };
	      } finally {
	        try {
	          if (windows_1_1 && !windows_1_1.done && (_a = windows_1["return"])) _a.call(windows_1);
	        } finally {
	          if (e_1) throw e_1.error;
	        }
	      }
	      var c = count - windowSize + 1;
	      if (c >= 0 && c % startEvery === 0) {
	        windows.shift().complete();
	      }
	      if (++count % startEvery === 0) {
	        var window_2 = new Subject_1$3.Subject();
	        windows.push(window_2);
	        subscriber.next(window_2.asObservable());
	      }
	    }, function () {
	      while (windows.length > 0) {
	        windows.shift().complete();
	      }
	      subscriber.complete();
	    }, function (err) {
	      while (windows.length > 0) {
	        windows.shift().error(err);
	      }
	      subscriber.error(err);
	    }, function () {
	      windows = null;
	    }));
	  });
	}
	windowCount$1.windowCount = windowCount;

	var windowTime$1 = {};

	Object.defineProperty(windowTime$1, "__esModule", {
	  value: true
	});
	windowTime$1.windowTime = void 0;
	var Subject_1$2 = Subject$1;
	var async_1 = async;
	var Subscription_1$1 = Subscription$1;
	var lift_1$4 = lift;
	var OperatorSubscriber_1$3 = OperatorSubscriber$1;
	var arrRemove_1$1 = arrRemove$1;
	var args_1$1 = args;
	var executeSchedule_1 = executeSchedule$1;
	function windowTime(windowTimeSpan) {
	  var _a, _b;
	  var otherArgs = [];
	  for (var _i = 1; _i < arguments.length; _i++) {
	    otherArgs[_i - 1] = arguments[_i];
	  }
	  var scheduler = (_a = args_1$1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
	  var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
	  var maxWindowSize = otherArgs[1] || Infinity;
	  return lift_1$4.operate(function (source, subscriber) {
	    var windowRecords = [];
	    var restartOnClose = false;
	    var closeWindow = function closeWindow(record) {
	      var window = record.window,
	        subs = record.subs;
	      window.complete();
	      subs.unsubscribe();
	      arrRemove_1$1.arrRemove(windowRecords, record);
	      restartOnClose && startWindow();
	    };
	    var startWindow = function startWindow() {
	      if (windowRecords) {
	        var subs = new Subscription_1$1.Subscription();
	        subscriber.add(subs);
	        var window_1 = new Subject_1$2.Subject();
	        var record_1 = {
	          window: window_1,
	          subs: subs,
	          seen: 0
	        };
	        windowRecords.push(record_1);
	        subscriber.next(window_1.asObservable());
	        executeSchedule_1.executeSchedule(subs, scheduler, function () {
	          return closeWindow(record_1);
	        }, windowTimeSpan);
	      }
	    };
	    if (windowCreationInterval !== null && windowCreationInterval >= 0) {
	      executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
	    } else {
	      restartOnClose = true;
	    }
	    startWindow();
	    var loop = function loop(cb) {
	      return windowRecords.slice().forEach(cb);
	    };
	    var terminate = function terminate(cb) {
	      loop(function (_a) {
	        var window = _a.window;
	        return cb(window);
	      });
	      cb(subscriber);
	      subscriber.unsubscribe();
	    };
	    source.subscribe(OperatorSubscriber_1$3.createOperatorSubscriber(subscriber, function (value) {
	      loop(function (record) {
	        record.window.next(value);
	        maxWindowSize <= ++record.seen && closeWindow(record);
	      });
	    }, function () {
	      return terminate(function (consumer) {
	        return consumer.complete();
	      });
	    }, function (err) {
	      return terminate(function (consumer) {
	        return consumer.error(err);
	      });
	    }));
	    return function () {
	      windowRecords = null;
	    };
	  });
	}
	windowTime$1.windowTime = windowTime;

	var windowToggle$1 = {};

	var __values = commonjsGlobal && commonjsGlobal.__values || function (o) {
	  var s = typeof Symbol === "function" && Symbol.iterator,
	    m = s && o[s],
	    i = 0;
	  if (m) return m.call(o);
	  if (o && typeof o.length === "number") return {
	    next: function next() {
	      if (o && i >= o.length) o = void 0;
	      return {
	        value: o && o[i++],
	        done: !o
	      };
	    }
	  };
	  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(windowToggle$1, "__esModule", {
	  value: true
	});
	windowToggle$1.windowToggle = void 0;
	var Subject_1$1 = Subject$1;
	var Subscription_1 = Subscription$1;
	var lift_1$3 = lift;
	var innerFrom_1$2 = innerFrom$1;
	var OperatorSubscriber_1$2 = OperatorSubscriber$1;
	var noop_1$1 = noop$1;
	var arrRemove_1 = arrRemove$1;
	function windowToggle(openings, closingSelector) {
	  return lift_1$3.operate(function (source, subscriber) {
	    var windows = [];
	    var handleError = function handleError(err) {
	      while (0 < windows.length) {
	        windows.shift().error(err);
	      }
	      subscriber.error(err);
	    };
	    innerFrom_1$2.innerFrom(openings).subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(subscriber, function (openValue) {
	      var window = new Subject_1$1.Subject();
	      windows.push(window);
	      var closingSubscription = new Subscription_1.Subscription();
	      var closeWindow = function closeWindow() {
	        arrRemove_1.arrRemove(windows, window);
	        window.complete();
	        closingSubscription.unsubscribe();
	      };
	      var closingNotifier;
	      try {
	        closingNotifier = innerFrom_1$2.innerFrom(closingSelector(openValue));
	      } catch (err) {
	        handleError(err);
	        return;
	      }
	      subscriber.next(window.asObservable());
	      closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(subscriber, closeWindow, noop_1$1.noop, handleError)));
	    }, noop_1$1.noop));
	    source.subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(subscriber, function (value) {
	      var e_1, _a;
	      var windowsCopy = windows.slice();
	      try {
	        for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
	          var window_1 = windowsCopy_1_1.value;
	          window_1.next(value);
	        }
	      } catch (e_1_1) {
	        e_1 = {
	          error: e_1_1
	        };
	      } finally {
	        try {
	          if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1["return"])) _a.call(windowsCopy_1);
	        } finally {
	          if (e_1) throw e_1.error;
	        }
	      }
	    }, function () {
	      while (0 < windows.length) {
	        windows.shift().complete();
	      }
	      subscriber.complete();
	    }, handleError, function () {
	      while (0 < windows.length) {
	        windows.shift().unsubscribe();
	      }
	    }));
	  });
	}
	windowToggle$1.windowToggle = windowToggle;

	var windowWhen$1 = {};

	Object.defineProperty(windowWhen$1, "__esModule", {
	  value: true
	});
	windowWhen$1.windowWhen = void 0;
	var Subject_1 = Subject$1;
	var lift_1$2 = lift;
	var OperatorSubscriber_1$1 = OperatorSubscriber$1;
	var innerFrom_1$1 = innerFrom$1;
	function windowWhen(closingSelector) {
	  return lift_1$2.operate(function (source, subscriber) {
	    var window;
	    var closingSubscriber;
	    var handleError = function handleError(err) {
	      window.error(err);
	      subscriber.error(err);
	    };
	    var openWindow = function openWindow() {
	      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
	      window === null || window === void 0 ? void 0 : window.complete();
	      window = new Subject_1.Subject();
	      subscriber.next(window.asObservable());
	      var closingNotifier;
	      try {
	        closingNotifier = innerFrom_1$1.innerFrom(closingSelector());
	      } catch (err) {
	        handleError(err);
	        return;
	      }
	      closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1$1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
	    };
	    openWindow();
	    source.subscribe(OperatorSubscriber_1$1.createOperatorSubscriber(subscriber, function (value) {
	      return window.next(value);
	    }, function () {
	      window.complete();
	      subscriber.complete();
	    }, handleError, function () {
	      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
	      window = null;
	    }));
	  });
	}
	windowWhen$1.windowWhen = windowWhen;

	var withLatestFrom$1 = {};

	var __read$2 = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	var __spreadArray$2 = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	  return to;
	};
	Object.defineProperty(withLatestFrom$1, "__esModule", {
	  value: true
	});
	withLatestFrom$1.withLatestFrom = void 0;
	var lift_1$1 = lift;
	var OperatorSubscriber_1 = OperatorSubscriber$1;
	var innerFrom_1 = innerFrom$1;
	var identity_1 = identity$1;
	var noop_1 = noop$1;
	var args_1 = args;
	function withLatestFrom() {
	  var inputs = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    inputs[_i] = arguments[_i];
	  }
	  var project = args_1.popResultSelector(inputs);
	  return lift_1$1.operate(function (source, subscriber) {
	    var len = inputs.length;
	    var otherValues = new Array(len);
	    var hasValue = inputs.map(function () {
	      return false;
	    });
	    var ready = false;
	    var _loop_1 = function _loop_1(i) {
	      innerFrom_1.innerFrom(inputs[i]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	        otherValues[i] = value;
	        if (!ready && !hasValue[i]) {
	          hasValue[i] = true;
	          (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
	        }
	      }, noop_1.noop));
	    };
	    for (var i = 0; i < len; i++) {
	      _loop_1(i);
	    }
	    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	      if (ready) {
	        var values = __spreadArray$2([value], __read$2(otherValues));
	        subscriber.next(project ? project.apply(void 0, __spreadArray$2([], __read$2(values))) : values);
	      }
	    }));
	  });
	}
	withLatestFrom$1.withLatestFrom = withLatestFrom;

	var zipAll$1 = {};

	Object.defineProperty(zipAll$1, "__esModule", {
	  value: true
	});
	zipAll$1.zipAll = void 0;
	var zip_1$2 = zip$3;
	var joinAllInternals_1 = joinAllInternals$1;
	function zipAll(project) {
	  return joinAllInternals_1.joinAllInternals(zip_1$2.zip, project);
	}
	zipAll$1.zipAll = zipAll;

	var zipWith$1 = {};

	var zip$1 = {};

	var __read$1 = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	var __spreadArray$1 = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	  return to;
	};
	Object.defineProperty(zip$1, "__esModule", {
	  value: true
	});
	zip$1.zip = void 0;
	var zip_1$1 = zip$3;
	var lift_1 = lift;
	function zip() {
	  var sources = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    sources[_i] = arguments[_i];
	  }
	  return lift_1.operate(function (source, subscriber) {
	    zip_1$1.zip.apply(void 0, __spreadArray$1([source], __read$1(sources))).subscribe(subscriber);
	  });
	}
	zip$1.zip = zip;

	var __read = commonjsGlobal && commonjsGlobal.__read || function (o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	    r,
	    ar = [],
	    e;
	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }
	  return ar;
	};
	var __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function (to, from) {
	  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
	  return to;
	};
	Object.defineProperty(zipWith$1, "__esModule", {
	  value: true
	});
	zipWith$1.zipWith = void 0;
	var zip_1 = zip$1;
	function zipWith() {
	  var otherInputs = [];
	  for (var _i = 0; _i < arguments.length; _i++) {
	    otherInputs[_i] = arguments[_i];
	  }
	  return zip_1.zip.apply(void 0, __spreadArray([], __read(otherInputs)));
	}
	zipWith$1.zipWith = zipWith;

	(function (exports) {

	  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, {
	      enumerable: true,
	      get: function get() {
	        return m[k];
	      }
	    });
	  } : function (o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	  });
	  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	  };
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
	  exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
	  exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
	  exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
	  var Observable_1 = Observable$1;
	  Object.defineProperty(exports, "Observable", {
	    enumerable: true,
	    get: function get() {
	      return Observable_1.Observable;
	    }
	  });
	  var ConnectableObservable_1 = ConnectableObservable$1;
	  Object.defineProperty(exports, "ConnectableObservable", {
	    enumerable: true,
	    get: function get() {
	      return ConnectableObservable_1.ConnectableObservable;
	    }
	  });
	  var observable_1 = observable;
	  Object.defineProperty(exports, "observable", {
	    enumerable: true,
	    get: function get() {
	      return observable_1.observable;
	    }
	  });
	  var animationFrames_1 = animationFrames$1;
	  Object.defineProperty(exports, "animationFrames", {
	    enumerable: true,
	    get: function get() {
	      return animationFrames_1.animationFrames;
	    }
	  });
	  var Subject_1 = Subject$1;
	  Object.defineProperty(exports, "Subject", {
	    enumerable: true,
	    get: function get() {
	      return Subject_1.Subject;
	    }
	  });
	  var BehaviorSubject_1 = BehaviorSubject$1;
	  Object.defineProperty(exports, "BehaviorSubject", {
	    enumerable: true,
	    get: function get() {
	      return BehaviorSubject_1.BehaviorSubject;
	    }
	  });
	  var ReplaySubject_1 = ReplaySubject$1;
	  Object.defineProperty(exports, "ReplaySubject", {
	    enumerable: true,
	    get: function get() {
	      return ReplaySubject_1.ReplaySubject;
	    }
	  });
	  var AsyncSubject_1 = AsyncSubject$1;
	  Object.defineProperty(exports, "AsyncSubject", {
	    enumerable: true,
	    get: function get() {
	      return AsyncSubject_1.AsyncSubject;
	    }
	  });
	  var asap_1 = asap;
	  Object.defineProperty(exports, "asap", {
	    enumerable: true,
	    get: function get() {
	      return asap_1.asap;
	    }
	  });
	  Object.defineProperty(exports, "asapScheduler", {
	    enumerable: true,
	    get: function get() {
	      return asap_1.asapScheduler;
	    }
	  });
	  var async_1 = async;
	  Object.defineProperty(exports, "async", {
	    enumerable: true,
	    get: function get() {
	      return async_1.async;
	    }
	  });
	  Object.defineProperty(exports, "asyncScheduler", {
	    enumerable: true,
	    get: function get() {
	      return async_1.asyncScheduler;
	    }
	  });
	  var queue_1 = queue;
	  Object.defineProperty(exports, "queue", {
	    enumerable: true,
	    get: function get() {
	      return queue_1.queue;
	    }
	  });
	  Object.defineProperty(exports, "queueScheduler", {
	    enumerable: true,
	    get: function get() {
	      return queue_1.queueScheduler;
	    }
	  });
	  var animationFrame_1 = animationFrame;
	  Object.defineProperty(exports, "animationFrame", {
	    enumerable: true,
	    get: function get() {
	      return animationFrame_1.animationFrame;
	    }
	  });
	  Object.defineProperty(exports, "animationFrameScheduler", {
	    enumerable: true,
	    get: function get() {
	      return animationFrame_1.animationFrameScheduler;
	    }
	  });
	  var VirtualTimeScheduler_1 = VirtualTimeScheduler$1;
	  Object.defineProperty(exports, "VirtualTimeScheduler", {
	    enumerable: true,
	    get: function get() {
	      return VirtualTimeScheduler_1.VirtualTimeScheduler;
	    }
	  });
	  Object.defineProperty(exports, "VirtualAction", {
	    enumerable: true,
	    get: function get() {
	      return VirtualTimeScheduler_1.VirtualAction;
	    }
	  });
	  var Scheduler_1 = Scheduler$1;
	  Object.defineProperty(exports, "Scheduler", {
	    enumerable: true,
	    get: function get() {
	      return Scheduler_1.Scheduler;
	    }
	  });
	  var Subscription_1 = Subscription$1;
	  Object.defineProperty(exports, "Subscription", {
	    enumerable: true,
	    get: function get() {
	      return Subscription_1.Subscription;
	    }
	  });
	  var Subscriber_1 = Subscriber;
	  Object.defineProperty(exports, "Subscriber", {
	    enumerable: true,
	    get: function get() {
	      return Subscriber_1.Subscriber;
	    }
	  });
	  var Notification_1 = Notification;
	  Object.defineProperty(exports, "Notification", {
	    enumerable: true,
	    get: function get() {
	      return Notification_1.Notification;
	    }
	  });
	  Object.defineProperty(exports, "NotificationKind", {
	    enumerable: true,
	    get: function get() {
	      return Notification_1.NotificationKind;
	    }
	  });
	  var pipe_1 = pipe$1;
	  Object.defineProperty(exports, "pipe", {
	    enumerable: true,
	    get: function get() {
	      return pipe_1.pipe;
	    }
	  });
	  var noop_1 = noop$1;
	  Object.defineProperty(exports, "noop", {
	    enumerable: true,
	    get: function get() {
	      return noop_1.noop;
	    }
	  });
	  var identity_1 = identity$1;
	  Object.defineProperty(exports, "identity", {
	    enumerable: true,
	    get: function get() {
	      return identity_1.identity;
	    }
	  });
	  var isObservable_1 = isObservable$1;
	  Object.defineProperty(exports, "isObservable", {
	    enumerable: true,
	    get: function get() {
	      return isObservable_1.isObservable;
	    }
	  });
	  var lastValueFrom_1 = lastValueFrom$1;
	  Object.defineProperty(exports, "lastValueFrom", {
	    enumerable: true,
	    get: function get() {
	      return lastValueFrom_1.lastValueFrom;
	    }
	  });
	  var firstValueFrom_1 = firstValueFrom$1;
	  Object.defineProperty(exports, "firstValueFrom", {
	    enumerable: true,
	    get: function get() {
	      return firstValueFrom_1.firstValueFrom;
	    }
	  });
	  var ArgumentOutOfRangeError_1 = ArgumentOutOfRangeError;
	  Object.defineProperty(exports, "ArgumentOutOfRangeError", {
	    enumerable: true,
	    get: function get() {
	      return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
	    }
	  });
	  var EmptyError_1 = EmptyError;
	  Object.defineProperty(exports, "EmptyError", {
	    enumerable: true,
	    get: function get() {
	      return EmptyError_1.EmptyError;
	    }
	  });
	  var NotFoundError_1 = NotFoundError;
	  Object.defineProperty(exports, "NotFoundError", {
	    enumerable: true,
	    get: function get() {
	      return NotFoundError_1.NotFoundError;
	    }
	  });
	  var ObjectUnsubscribedError_1 = ObjectUnsubscribedError;
	  Object.defineProperty(exports, "ObjectUnsubscribedError", {
	    enumerable: true,
	    get: function get() {
	      return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
	    }
	  });
	  var SequenceError_1 = SequenceError;
	  Object.defineProperty(exports, "SequenceError", {
	    enumerable: true,
	    get: function get() {
	      return SequenceError_1.SequenceError;
	    }
	  });
	  var timeout_1 = timeout$1;
	  Object.defineProperty(exports, "TimeoutError", {
	    enumerable: true,
	    get: function get() {
	      return timeout_1.TimeoutError;
	    }
	  });
	  var UnsubscriptionError_1 = UnsubscriptionError;
	  Object.defineProperty(exports, "UnsubscriptionError", {
	    enumerable: true,
	    get: function get() {
	      return UnsubscriptionError_1.UnsubscriptionError;
	    }
	  });
	  var bindCallback_1 = bindCallback$1;
	  Object.defineProperty(exports, "bindCallback", {
	    enumerable: true,
	    get: function get() {
	      return bindCallback_1.bindCallback;
	    }
	  });
	  var bindNodeCallback_1 = bindNodeCallback$1;
	  Object.defineProperty(exports, "bindNodeCallback", {
	    enumerable: true,
	    get: function get() {
	      return bindNodeCallback_1.bindNodeCallback;
	    }
	  });
	  var combineLatest_1 = combineLatest$3;
	  Object.defineProperty(exports, "combineLatest", {
	    enumerable: true,
	    get: function get() {
	      return combineLatest_1.combineLatest;
	    }
	  });
	  var concat_1 = concat$3;
	  Object.defineProperty(exports, "concat", {
	    enumerable: true,
	    get: function get() {
	      return concat_1.concat;
	    }
	  });
	  var connectable_1 = connectable$1;
	  Object.defineProperty(exports, "connectable", {
	    enumerable: true,
	    get: function get() {
	      return connectable_1.connectable;
	    }
	  });
	  var defer_1 = defer$1;
	  Object.defineProperty(exports, "defer", {
	    enumerable: true,
	    get: function get() {
	      return defer_1.defer;
	    }
	  });
	  var empty_1 = empty;
	  Object.defineProperty(exports, "empty", {
	    enumerable: true,
	    get: function get() {
	      return empty_1.empty;
	    }
	  });
	  var forkJoin_1 = forkJoin$1;
	  Object.defineProperty(exports, "forkJoin", {
	    enumerable: true,
	    get: function get() {
	      return forkJoin_1.forkJoin;
	    }
	  });
	  var from_1 = from$2;
	  Object.defineProperty(exports, "from", {
	    enumerable: true,
	    get: function get() {
	      return from_1.from;
	    }
	  });
	  var fromEvent_1 = fromEvent$1;
	  Object.defineProperty(exports, "fromEvent", {
	    enumerable: true,
	    get: function get() {
	      return fromEvent_1.fromEvent;
	    }
	  });
	  var fromEventPattern_1 = fromEventPattern$1;
	  Object.defineProperty(exports, "fromEventPattern", {
	    enumerable: true,
	    get: function get() {
	      return fromEventPattern_1.fromEventPattern;
	    }
	  });
	  var generate_1 = generate$1;
	  Object.defineProperty(exports, "generate", {
	    enumerable: true,
	    get: function get() {
	      return generate_1.generate;
	    }
	  });
	  var iif_1 = iif$1;
	  Object.defineProperty(exports, "iif", {
	    enumerable: true,
	    get: function get() {
	      return iif_1.iif;
	    }
	  });
	  var interval_1 = interval$1;
	  Object.defineProperty(exports, "interval", {
	    enumerable: true,
	    get: function get() {
	      return interval_1.interval;
	    }
	  });
	  var merge_1 = merge$3;
	  Object.defineProperty(exports, "merge", {
	    enumerable: true,
	    get: function get() {
	      return merge_1.merge;
	    }
	  });
	  var never_1 = never;
	  Object.defineProperty(exports, "never", {
	    enumerable: true,
	    get: function get() {
	      return never_1.never;
	    }
	  });
	  var of_1 = of$1;
	  Object.defineProperty(exports, "of", {
	    enumerable: true,
	    get: function get() {
	      return of_1.of;
	    }
	  });
	  var onErrorResumeNext_1 = onErrorResumeNext$1;
	  Object.defineProperty(exports, "onErrorResumeNext", {
	    enumerable: true,
	    get: function get() {
	      return onErrorResumeNext_1.onErrorResumeNext;
	    }
	  });
	  var pairs_1 = pairs$1;
	  Object.defineProperty(exports, "pairs", {
	    enumerable: true,
	    get: function get() {
	      return pairs_1.pairs;
	    }
	  });
	  var partition_1 = partition$1;
	  Object.defineProperty(exports, "partition", {
	    enumerable: true,
	    get: function get() {
	      return partition_1.partition;
	    }
	  });
	  var race_1 = race$1;
	  Object.defineProperty(exports, "race", {
	    enumerable: true,
	    get: function get() {
	      return race_1.race;
	    }
	  });
	  var range_1 = range$1;
	  Object.defineProperty(exports, "range", {
	    enumerable: true,
	    get: function get() {
	      return range_1.range;
	    }
	  });
	  var throwError_1 = throwError$1;
	  Object.defineProperty(exports, "throwError", {
	    enumerable: true,
	    get: function get() {
	      return throwError_1.throwError;
	    }
	  });
	  var timer_1 = timer$1;
	  Object.defineProperty(exports, "timer", {
	    enumerable: true,
	    get: function get() {
	      return timer_1.timer;
	    }
	  });
	  var using_1 = using$1;
	  Object.defineProperty(exports, "using", {
	    enumerable: true,
	    get: function get() {
	      return using_1.using;
	    }
	  });
	  var zip_1 = zip$3;
	  Object.defineProperty(exports, "zip", {
	    enumerable: true,
	    get: function get() {
	      return zip_1.zip;
	    }
	  });
	  var scheduled_1 = scheduled$1;
	  Object.defineProperty(exports, "scheduled", {
	    enumerable: true,
	    get: function get() {
	      return scheduled_1.scheduled;
	    }
	  });
	  var empty_2 = empty;
	  Object.defineProperty(exports, "EMPTY", {
	    enumerable: true,
	    get: function get() {
	      return empty_2.EMPTY;
	    }
	  });
	  var never_2 = never;
	  Object.defineProperty(exports, "NEVER", {
	    enumerable: true,
	    get: function get() {
	      return never_2.NEVER;
	    }
	  });
	  __exportStar(types, exports);
	  var config_1 = config;
	  Object.defineProperty(exports, "config", {
	    enumerable: true,
	    get: function get() {
	      return config_1.config;
	    }
	  });
	  var audit_1 = audit$1;
	  Object.defineProperty(exports, "audit", {
	    enumerable: true,
	    get: function get() {
	      return audit_1.audit;
	    }
	  });
	  var auditTime_1 = auditTime$1;
	  Object.defineProperty(exports, "auditTime", {
	    enumerable: true,
	    get: function get() {
	      return auditTime_1.auditTime;
	    }
	  });
	  var buffer_1 = buffer$1;
	  Object.defineProperty(exports, "buffer", {
	    enumerable: true,
	    get: function get() {
	      return buffer_1.buffer;
	    }
	  });
	  var bufferCount_1 = bufferCount$1;
	  Object.defineProperty(exports, "bufferCount", {
	    enumerable: true,
	    get: function get() {
	      return bufferCount_1.bufferCount;
	    }
	  });
	  var bufferTime_1 = bufferTime$1;
	  Object.defineProperty(exports, "bufferTime", {
	    enumerable: true,
	    get: function get() {
	      return bufferTime_1.bufferTime;
	    }
	  });
	  var bufferToggle_1 = bufferToggle$1;
	  Object.defineProperty(exports, "bufferToggle", {
	    enumerable: true,
	    get: function get() {
	      return bufferToggle_1.bufferToggle;
	    }
	  });
	  var bufferWhen_1 = bufferWhen$1;
	  Object.defineProperty(exports, "bufferWhen", {
	    enumerable: true,
	    get: function get() {
	      return bufferWhen_1.bufferWhen;
	    }
	  });
	  var catchError_1 = catchError$1;
	  Object.defineProperty(exports, "catchError", {
	    enumerable: true,
	    get: function get() {
	      return catchError_1.catchError;
	    }
	  });
	  var combineAll_1 = combineAll;
	  Object.defineProperty(exports, "combineAll", {
	    enumerable: true,
	    get: function get() {
	      return combineAll_1.combineAll;
	    }
	  });
	  var combineLatestAll_1 = combineLatestAll$1;
	  Object.defineProperty(exports, "combineLatestAll", {
	    enumerable: true,
	    get: function get() {
	      return combineLatestAll_1.combineLatestAll;
	    }
	  });
	  var combineLatestWith_1 = combineLatestWith$1;
	  Object.defineProperty(exports, "combineLatestWith", {
	    enumerable: true,
	    get: function get() {
	      return combineLatestWith_1.combineLatestWith;
	    }
	  });
	  var concatAll_1 = concatAll$1;
	  Object.defineProperty(exports, "concatAll", {
	    enumerable: true,
	    get: function get() {
	      return concatAll_1.concatAll;
	    }
	  });
	  var concatMap_1 = concatMap$1;
	  Object.defineProperty(exports, "concatMap", {
	    enumerable: true,
	    get: function get() {
	      return concatMap_1.concatMap;
	    }
	  });
	  var concatMapTo_1 = concatMapTo$1;
	  Object.defineProperty(exports, "concatMapTo", {
	    enumerable: true,
	    get: function get() {
	      return concatMapTo_1.concatMapTo;
	    }
	  });
	  var concatWith_1 = concatWith$1;
	  Object.defineProperty(exports, "concatWith", {
	    enumerable: true,
	    get: function get() {
	      return concatWith_1.concatWith;
	    }
	  });
	  var connect_1 = connect$1;
	  Object.defineProperty(exports, "connect", {
	    enumerable: true,
	    get: function get() {
	      return connect_1.connect;
	    }
	  });
	  var count_1 = count$1;
	  Object.defineProperty(exports, "count", {
	    enumerable: true,
	    get: function get() {
	      return count_1.count;
	    }
	  });
	  var debounce_1 = debounce$1;
	  Object.defineProperty(exports, "debounce", {
	    enumerable: true,
	    get: function get() {
	      return debounce_1.debounce;
	    }
	  });
	  var debounceTime_1 = debounceTime$1;
	  Object.defineProperty(exports, "debounceTime", {
	    enumerable: true,
	    get: function get() {
	      return debounceTime_1.debounceTime;
	    }
	  });
	  var defaultIfEmpty_1 = defaultIfEmpty$1;
	  Object.defineProperty(exports, "defaultIfEmpty", {
	    enumerable: true,
	    get: function get() {
	      return defaultIfEmpty_1.defaultIfEmpty;
	    }
	  });
	  var delay_1 = delay$1;
	  Object.defineProperty(exports, "delay", {
	    enumerable: true,
	    get: function get() {
	      return delay_1.delay;
	    }
	  });
	  var delayWhen_1 = delayWhen$1;
	  Object.defineProperty(exports, "delayWhen", {
	    enumerable: true,
	    get: function get() {
	      return delayWhen_1.delayWhen;
	    }
	  });
	  var dematerialize_1 = dematerialize$1;
	  Object.defineProperty(exports, "dematerialize", {
	    enumerable: true,
	    get: function get() {
	      return dematerialize_1.dematerialize;
	    }
	  });
	  var distinct_1 = distinct$1;
	  Object.defineProperty(exports, "distinct", {
	    enumerable: true,
	    get: function get() {
	      return distinct_1.distinct;
	    }
	  });
	  var distinctUntilChanged_1 = distinctUntilChanged$1;
	  Object.defineProperty(exports, "distinctUntilChanged", {
	    enumerable: true,
	    get: function get() {
	      return distinctUntilChanged_1.distinctUntilChanged;
	    }
	  });
	  var distinctUntilKeyChanged_1 = distinctUntilKeyChanged$1;
	  Object.defineProperty(exports, "distinctUntilKeyChanged", {
	    enumerable: true,
	    get: function get() {
	      return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
	    }
	  });
	  var elementAt_1 = elementAt$1;
	  Object.defineProperty(exports, "elementAt", {
	    enumerable: true,
	    get: function get() {
	      return elementAt_1.elementAt;
	    }
	  });
	  var endWith_1 = endWith$1;
	  Object.defineProperty(exports, "endWith", {
	    enumerable: true,
	    get: function get() {
	      return endWith_1.endWith;
	    }
	  });
	  var every_1 = every$1;
	  Object.defineProperty(exports, "every", {
	    enumerable: true,
	    get: function get() {
	      return every_1.every;
	    }
	  });
	  var exhaust_1 = exhaust;
	  Object.defineProperty(exports, "exhaust", {
	    enumerable: true,
	    get: function get() {
	      return exhaust_1.exhaust;
	    }
	  });
	  var exhaustAll_1 = exhaustAll$1;
	  Object.defineProperty(exports, "exhaustAll", {
	    enumerable: true,
	    get: function get() {
	      return exhaustAll_1.exhaustAll;
	    }
	  });
	  var exhaustMap_1 = exhaustMap$1;
	  Object.defineProperty(exports, "exhaustMap", {
	    enumerable: true,
	    get: function get() {
	      return exhaustMap_1.exhaustMap;
	    }
	  });
	  var expand_1 = expand$1;
	  Object.defineProperty(exports, "expand", {
	    enumerable: true,
	    get: function get() {
	      return expand_1.expand;
	    }
	  });
	  var filter_1 = filter$1;
	  Object.defineProperty(exports, "filter", {
	    enumerable: true,
	    get: function get() {
	      return filter_1.filter;
	    }
	  });
	  var finalize_1 = finalize$1;
	  Object.defineProperty(exports, "finalize", {
	    enumerable: true,
	    get: function get() {
	      return finalize_1.finalize;
	    }
	  });
	  var find_1 = find$1;
	  Object.defineProperty(exports, "find", {
	    enumerable: true,
	    get: function get() {
	      return find_1.find;
	    }
	  });
	  var findIndex_1 = findIndex$1;
	  Object.defineProperty(exports, "findIndex", {
	    enumerable: true,
	    get: function get() {
	      return findIndex_1.findIndex;
	    }
	  });
	  var first_1 = first$1;
	  Object.defineProperty(exports, "first", {
	    enumerable: true,
	    get: function get() {
	      return first_1.first;
	    }
	  });
	  var groupBy_1 = groupBy$1;
	  Object.defineProperty(exports, "groupBy", {
	    enumerable: true,
	    get: function get() {
	      return groupBy_1.groupBy;
	    }
	  });
	  var ignoreElements_1 = ignoreElements$1;
	  Object.defineProperty(exports, "ignoreElements", {
	    enumerable: true,
	    get: function get() {
	      return ignoreElements_1.ignoreElements;
	    }
	  });
	  var isEmpty_1 = isEmpty$1;
	  Object.defineProperty(exports, "isEmpty", {
	    enumerable: true,
	    get: function get() {
	      return isEmpty_1.isEmpty;
	    }
	  });
	  var last_1 = last$1;
	  Object.defineProperty(exports, "last", {
	    enumerable: true,
	    get: function get() {
	      return last_1.last;
	    }
	  });
	  var map_1 = map$1;
	  Object.defineProperty(exports, "map", {
	    enumerable: true,
	    get: function get() {
	      return map_1.map;
	    }
	  });
	  var mapTo_1 = mapTo$1;
	  Object.defineProperty(exports, "mapTo", {
	    enumerable: true,
	    get: function get() {
	      return mapTo_1.mapTo;
	    }
	  });
	  var materialize_1 = materialize$1;
	  Object.defineProperty(exports, "materialize", {
	    enumerable: true,
	    get: function get() {
	      return materialize_1.materialize;
	    }
	  });
	  var max_1 = max$1;
	  Object.defineProperty(exports, "max", {
	    enumerable: true,
	    get: function get() {
	      return max_1.max;
	    }
	  });
	  var mergeAll_1 = mergeAll$1;
	  Object.defineProperty(exports, "mergeAll", {
	    enumerable: true,
	    get: function get() {
	      return mergeAll_1.mergeAll;
	    }
	  });
	  var flatMap_1 = flatMap;
	  Object.defineProperty(exports, "flatMap", {
	    enumerable: true,
	    get: function get() {
	      return flatMap_1.flatMap;
	    }
	  });
	  var mergeMap_1 = mergeMap$1;
	  Object.defineProperty(exports, "mergeMap", {
	    enumerable: true,
	    get: function get() {
	      return mergeMap_1.mergeMap;
	    }
	  });
	  var mergeMapTo_1 = mergeMapTo$1;
	  Object.defineProperty(exports, "mergeMapTo", {
	    enumerable: true,
	    get: function get() {
	      return mergeMapTo_1.mergeMapTo;
	    }
	  });
	  var mergeScan_1 = mergeScan$1;
	  Object.defineProperty(exports, "mergeScan", {
	    enumerable: true,
	    get: function get() {
	      return mergeScan_1.mergeScan;
	    }
	  });
	  var mergeWith_1 = mergeWith$1;
	  Object.defineProperty(exports, "mergeWith", {
	    enumerable: true,
	    get: function get() {
	      return mergeWith_1.mergeWith;
	    }
	  });
	  var min_1 = min$1;
	  Object.defineProperty(exports, "min", {
	    enumerable: true,
	    get: function get() {
	      return min_1.min;
	    }
	  });
	  var multicast_1 = multicast$1;
	  Object.defineProperty(exports, "multicast", {
	    enumerable: true,
	    get: function get() {
	      return multicast_1.multicast;
	    }
	  });
	  var observeOn_1 = observeOn$1;
	  Object.defineProperty(exports, "observeOn", {
	    enumerable: true,
	    get: function get() {
	      return observeOn_1.observeOn;
	    }
	  });
	  var onErrorResumeNextWith_1 = onErrorResumeNextWith$1;
	  Object.defineProperty(exports, "onErrorResumeNextWith", {
	    enumerable: true,
	    get: function get() {
	      return onErrorResumeNextWith_1.onErrorResumeNextWith;
	    }
	  });
	  var pairwise_1 = pairwise$1;
	  Object.defineProperty(exports, "pairwise", {
	    enumerable: true,
	    get: function get() {
	      return pairwise_1.pairwise;
	    }
	  });
	  var pluck_1 = pluck$1;
	  Object.defineProperty(exports, "pluck", {
	    enumerable: true,
	    get: function get() {
	      return pluck_1.pluck;
	    }
	  });
	  var publish_1 = publish$1;
	  Object.defineProperty(exports, "publish", {
	    enumerable: true,
	    get: function get() {
	      return publish_1.publish;
	    }
	  });
	  var publishBehavior_1 = publishBehavior$1;
	  Object.defineProperty(exports, "publishBehavior", {
	    enumerable: true,
	    get: function get() {
	      return publishBehavior_1.publishBehavior;
	    }
	  });
	  var publishLast_1 = publishLast$1;
	  Object.defineProperty(exports, "publishLast", {
	    enumerable: true,
	    get: function get() {
	      return publishLast_1.publishLast;
	    }
	  });
	  var publishReplay_1 = publishReplay$1;
	  Object.defineProperty(exports, "publishReplay", {
	    enumerable: true,
	    get: function get() {
	      return publishReplay_1.publishReplay;
	    }
	  });
	  var raceWith_1 = raceWith$1;
	  Object.defineProperty(exports, "raceWith", {
	    enumerable: true,
	    get: function get() {
	      return raceWith_1.raceWith;
	    }
	  });
	  var reduce_1 = reduce$1;
	  Object.defineProperty(exports, "reduce", {
	    enumerable: true,
	    get: function get() {
	      return reduce_1.reduce;
	    }
	  });
	  var repeat_1 = repeat$1;
	  Object.defineProperty(exports, "repeat", {
	    enumerable: true,
	    get: function get() {
	      return repeat_1.repeat;
	    }
	  });
	  var repeatWhen_1 = repeatWhen$1;
	  Object.defineProperty(exports, "repeatWhen", {
	    enumerable: true,
	    get: function get() {
	      return repeatWhen_1.repeatWhen;
	    }
	  });
	  var retry_1 = retry$1;
	  Object.defineProperty(exports, "retry", {
	    enumerable: true,
	    get: function get() {
	      return retry_1.retry;
	    }
	  });
	  var retryWhen_1 = retryWhen$1;
	  Object.defineProperty(exports, "retryWhen", {
	    enumerable: true,
	    get: function get() {
	      return retryWhen_1.retryWhen;
	    }
	  });
	  var refCount_1 = refCount$1;
	  Object.defineProperty(exports, "refCount", {
	    enumerable: true,
	    get: function get() {
	      return refCount_1.refCount;
	    }
	  });
	  var sample_1 = sample$1;
	  Object.defineProperty(exports, "sample", {
	    enumerable: true,
	    get: function get() {
	      return sample_1.sample;
	    }
	  });
	  var sampleTime_1 = sampleTime$1;
	  Object.defineProperty(exports, "sampleTime", {
	    enumerable: true,
	    get: function get() {
	      return sampleTime_1.sampleTime;
	    }
	  });
	  var scan_1 = scan$1;
	  Object.defineProperty(exports, "scan", {
	    enumerable: true,
	    get: function get() {
	      return scan_1.scan;
	    }
	  });
	  var sequenceEqual_1 = sequenceEqual$1;
	  Object.defineProperty(exports, "sequenceEqual", {
	    enumerable: true,
	    get: function get() {
	      return sequenceEqual_1.sequenceEqual;
	    }
	  });
	  var share_1 = share$1;
	  Object.defineProperty(exports, "share", {
	    enumerable: true,
	    get: function get() {
	      return share_1.share;
	    }
	  });
	  var shareReplay_1 = shareReplay$1;
	  Object.defineProperty(exports, "shareReplay", {
	    enumerable: true,
	    get: function get() {
	      return shareReplay_1.shareReplay;
	    }
	  });
	  var single_1 = single$1;
	  Object.defineProperty(exports, "single", {
	    enumerable: true,
	    get: function get() {
	      return single_1.single;
	    }
	  });
	  var skip_1 = skip$1;
	  Object.defineProperty(exports, "skip", {
	    enumerable: true,
	    get: function get() {
	      return skip_1.skip;
	    }
	  });
	  var skipLast_1 = skipLast$1;
	  Object.defineProperty(exports, "skipLast", {
	    enumerable: true,
	    get: function get() {
	      return skipLast_1.skipLast;
	    }
	  });
	  var skipUntil_1 = skipUntil$1;
	  Object.defineProperty(exports, "skipUntil", {
	    enumerable: true,
	    get: function get() {
	      return skipUntil_1.skipUntil;
	    }
	  });
	  var skipWhile_1 = skipWhile$1;
	  Object.defineProperty(exports, "skipWhile", {
	    enumerable: true,
	    get: function get() {
	      return skipWhile_1.skipWhile;
	    }
	  });
	  var startWith_1 = startWith$1;
	  Object.defineProperty(exports, "startWith", {
	    enumerable: true,
	    get: function get() {
	      return startWith_1.startWith;
	    }
	  });
	  var subscribeOn_1 = subscribeOn$1;
	  Object.defineProperty(exports, "subscribeOn", {
	    enumerable: true,
	    get: function get() {
	      return subscribeOn_1.subscribeOn;
	    }
	  });
	  var switchAll_1 = switchAll$1;
	  Object.defineProperty(exports, "switchAll", {
	    enumerable: true,
	    get: function get() {
	      return switchAll_1.switchAll;
	    }
	  });
	  var switchMap_1 = switchMap$1;
	  Object.defineProperty(exports, "switchMap", {
	    enumerable: true,
	    get: function get() {
	      return switchMap_1.switchMap;
	    }
	  });
	  var switchMapTo_1 = switchMapTo$1;
	  Object.defineProperty(exports, "switchMapTo", {
	    enumerable: true,
	    get: function get() {
	      return switchMapTo_1.switchMapTo;
	    }
	  });
	  var switchScan_1 = switchScan$1;
	  Object.defineProperty(exports, "switchScan", {
	    enumerable: true,
	    get: function get() {
	      return switchScan_1.switchScan;
	    }
	  });
	  var take_1 = take$1;
	  Object.defineProperty(exports, "take", {
	    enumerable: true,
	    get: function get() {
	      return take_1.take;
	    }
	  });
	  var takeLast_1 = takeLast$1;
	  Object.defineProperty(exports, "takeLast", {
	    enumerable: true,
	    get: function get() {
	      return takeLast_1.takeLast;
	    }
	  });
	  var takeUntil_1 = takeUntil$1;
	  Object.defineProperty(exports, "takeUntil", {
	    enumerable: true,
	    get: function get() {
	      return takeUntil_1.takeUntil;
	    }
	  });
	  var takeWhile_1 = takeWhile$1;
	  Object.defineProperty(exports, "takeWhile", {
	    enumerable: true,
	    get: function get() {
	      return takeWhile_1.takeWhile;
	    }
	  });
	  var tap_1 = tap$1;
	  Object.defineProperty(exports, "tap", {
	    enumerable: true,
	    get: function get() {
	      return tap_1.tap;
	    }
	  });
	  var throttle_1 = throttle$1;
	  Object.defineProperty(exports, "throttle", {
	    enumerable: true,
	    get: function get() {
	      return throttle_1.throttle;
	    }
	  });
	  var throttleTime_1 = throttleTime$1;
	  Object.defineProperty(exports, "throttleTime", {
	    enumerable: true,
	    get: function get() {
	      return throttleTime_1.throttleTime;
	    }
	  });
	  var throwIfEmpty_1 = throwIfEmpty$1;
	  Object.defineProperty(exports, "throwIfEmpty", {
	    enumerable: true,
	    get: function get() {
	      return throwIfEmpty_1.throwIfEmpty;
	    }
	  });
	  var timeInterval_1 = timeInterval$1;
	  Object.defineProperty(exports, "timeInterval", {
	    enumerable: true,
	    get: function get() {
	      return timeInterval_1.timeInterval;
	    }
	  });
	  var timeout_2 = timeout$1;
	  Object.defineProperty(exports, "timeout", {
	    enumerable: true,
	    get: function get() {
	      return timeout_2.timeout;
	    }
	  });
	  var timeoutWith_1 = timeoutWith$1;
	  Object.defineProperty(exports, "timeoutWith", {
	    enumerable: true,
	    get: function get() {
	      return timeoutWith_1.timeoutWith;
	    }
	  });
	  var timestamp_1 = timestamp$1;
	  Object.defineProperty(exports, "timestamp", {
	    enumerable: true,
	    get: function get() {
	      return timestamp_1.timestamp;
	    }
	  });
	  var toArray_1 = toArray$1;
	  Object.defineProperty(exports, "toArray", {
	    enumerable: true,
	    get: function get() {
	      return toArray_1.toArray;
	    }
	  });
	  var window_1 = window$2;
	  Object.defineProperty(exports, "window", {
	    enumerable: true,
	    get: function get() {
	      return window_1.window;
	    }
	  });
	  var windowCount_1 = windowCount$1;
	  Object.defineProperty(exports, "windowCount", {
	    enumerable: true,
	    get: function get() {
	      return windowCount_1.windowCount;
	    }
	  });
	  var windowTime_1 = windowTime$1;
	  Object.defineProperty(exports, "windowTime", {
	    enumerable: true,
	    get: function get() {
	      return windowTime_1.windowTime;
	    }
	  });
	  var windowToggle_1 = windowToggle$1;
	  Object.defineProperty(exports, "windowToggle", {
	    enumerable: true,
	    get: function get() {
	      return windowToggle_1.windowToggle;
	    }
	  });
	  var windowWhen_1 = windowWhen$1;
	  Object.defineProperty(exports, "windowWhen", {
	    enumerable: true,
	    get: function get() {
	      return windowWhen_1.windowWhen;
	    }
	  });
	  var withLatestFrom_1 = withLatestFrom$1;
	  Object.defineProperty(exports, "withLatestFrom", {
	    enumerable: true,
	    get: function get() {
	      return withLatestFrom_1.withLatestFrom;
	    }
	  });
	  var zipAll_1 = zipAll$1;
	  Object.defineProperty(exports, "zipAll", {
	    enumerable: true,
	    get: function get() {
	      return zipAll_1.zipAll;
	    }
	  });
	  var zipWith_1 = zipWith$1;
	  Object.defineProperty(exports, "zipWith", {
	    enumerable: true,
	    get: function get() {
	      return zipWith_1.zipWith;
	    }
	  });
	})(cjs);

	Object.defineProperty(aborting, "__esModule", {
	  value: true
	});
	var checkAbortSignal_1 = aborting.checkAbortSignal = checkAbortSignal;
	aborting.abortBreakPoint = abortBreakPoint;
	aborting.makeAbortError = makeAbortError;
	aborting.observeAbortSignal = observeAbortSignal;
	var isAbortException_1 = aborting.isAbortException = isAbortException;
	var rxjs_1 = cjs;
	var AbortError = /*#__PURE__*/function (_Error) {
	  _inherits(AbortError, _Error);
	  var _super = /*#__PURE__*/_createSuper(AbortError);
	  function AbortError() {
	    _classCallCheck(this, AbortError);
	    return _super.apply(this, arguments);
	  }
	  return _createClass(AbortError);
	}( /*#__PURE__*/_wrapNativeSuper(Error));
	function checkAbortSignal(signal) {
	  if (!signal) {
	    return;
	  }
	  if (!(signal instanceof AbortSignal)) {
	    throw new TypeError('must pass an AbortSignal');
	  }
	  if (signal.aborted) {
	    throw makeAbortError();
	  }
	}
	function timeout(ms) {
	  return new Promise(function (resolve) {
	    return setTimeout(resolve, ms);
	  });
	}
	function abortBreakPoint(_x) {
	  return _abortBreakPoint.apply(this, arguments);
	}
	function _abortBreakPoint() {
	  _abortBreakPoint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(signal) {
	    return _regeneratorRuntime().wrap(function _callee$(_context) {
	      while (1) switch (_context.prev = _context.next) {
	        case 0:
	          _context.next = 2;
	          return timeout(1);
	        case 2:
	          checkAbortSignal(signal);
	        case 3:
	        case "end":
	          return _context.stop();
	      }
	    }, _callee);
	  }));
	  return _abortBreakPoint.apply(this, arguments);
	}
	function makeAbortError() {
	  if (typeof DOMException !== 'undefined') {
	    return new DOMException('aborted', 'AbortError');
	  }
	  var e = new AbortError('aborted');
	  e.code = 'ERR_ABORTED';
	  return e;
	}
	function observeAbortSignal(signal) {
	  if (!signal) {
	    return new rxjs_1.Observable();
	  }
	  return (0, rxjs_1.fromEvent)(signal, 'abort');
	}
	function isAbortException(exception) {
	  return exception instanceof Error && (exception.name === 'AbortError' || exception.code === 'ERR_ABORTED' || !!/\b(aborted|aborterror)\b/i.test(exception.message));
	}

	var jsonpath$1 = {exports: {}};

	(function (module, exports) {
	  (function (f) {
	    {
	      module.exports = /*#__PURE__*/f();
	    }
	  })(function () {
	    return function e(t, n, r) {
	      function s(o, u) {
	        if (!n[o]) {
	          if (!t[o]) {
	            var a = typeof commonjsRequire == "function" && commonjsRequire;
	            if (!u && a) return a(o, !0);
	            if (i) return i(o, !0);
	            var f = new Error("Cannot find module '" + o + "'");
	            throw f.code = "MODULE_NOT_FOUND", f;
	          }
	          var l = n[o] = {
	            exports: {}
	          };
	          t[o][0].call(l.exports, function (e) {
	            var n = t[o][1][e];
	            return s(n ? n : e);
	          }, l, l.exports, e, t, n, r);
	        }
	        return n[o].exports;
	      }
	      var i = typeof commonjsRequire == "function" && commonjsRequire;
	      for (var o = 0; o < r.length; o++) s(r[o]);
	      return s;
	    }({
	      "./aesprim": [function (require, module, exports) {
	        /*
	          Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
	          Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
	          Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
	          Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
	          Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
	          Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
	          Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
	          Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
	          Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
	          Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>
	        
	          Redistribution and use in source and binary forms, with or without
	          modification, are permitted provided that the following conditions are met:
	        
	            * Redistributions of source code must retain the above copyright
	              notice, this list of conditions and the following disclaimer.
	            * Redistributions in binary form must reproduce the above copyright
	              notice, this list of conditions and the following disclaimer in the
	              documentation and/or other materials provided with the distribution.
	        
	          THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	          AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	          IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	          ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	          DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	          (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	          LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	          ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	          (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	          THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	        */

	        /*jslint bitwise:true plusplus:true */
	        /*global esprima:true, define:true, exports:true, window: true,
	        throwErrorTolerant: true,
	        throwError: true, generateStatement: true, peek: true,
	        parseAssignmentExpression: true, parseBlock: true, parseExpression: true,
	        parseFunctionDeclaration: true, parseFunctionExpression: true,
	        parseFunctionSourceElements: true, parseVariableIdentifier: true,
	        parseLeftHandSideExpression: true,
	        parseUnaryExpression: true,
	        parseStatement: true, parseSourceElement: true */

	        (function (root, factory) {

	          // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
	          // Rhino, and plain browser loading.

	          /* istanbul ignore next */
	          if (typeof exports !== 'undefined') {
	            factory(exports);
	          } else {
	            factory(root.esprima = {});
	          }
	        })(this, function (exports) {

	          var Token, TokenName, FnExprTokens, Syntax, PropertyKind, Messages, Regex, SyntaxTreeDelegate, source, strict, index, lineNumber, lineStart, length, delegate, lookahead, state, extra;
	          Token = {
	            BooleanLiteral: 1,
	            EOF: 2,
	            Identifier: 3,
	            Keyword: 4,
	            NullLiteral: 5,
	            NumericLiteral: 6,
	            Punctuator: 7,
	            StringLiteral: 8,
	            RegularExpression: 9
	          };
	          TokenName = {};
	          TokenName[Token.BooleanLiteral] = 'Boolean';
	          TokenName[Token.EOF] = '<end>';
	          TokenName[Token.Identifier] = 'Identifier';
	          TokenName[Token.Keyword] = 'Keyword';
	          TokenName[Token.NullLiteral] = 'Null';
	          TokenName[Token.NumericLiteral] = 'Numeric';
	          TokenName[Token.Punctuator] = 'Punctuator';
	          TokenName[Token.StringLiteral] = 'String';
	          TokenName[Token.RegularExpression] = 'RegularExpression';

	          // A function following one of those tokens is an expression.
	          FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new', 'return', 'case', 'delete', 'throw', 'void',
	          // assignment operators
	          '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ',',
	          // binary/unary operators
	          '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!=='];
	          Syntax = {
	            AssignmentExpression: 'AssignmentExpression',
	            ArrayExpression: 'ArrayExpression',
	            BlockStatement: 'BlockStatement',
	            BinaryExpression: 'BinaryExpression',
	            BreakStatement: 'BreakStatement',
	            CallExpression: 'CallExpression',
	            CatchClause: 'CatchClause',
	            ConditionalExpression: 'ConditionalExpression',
	            ContinueStatement: 'ContinueStatement',
	            DoWhileStatement: 'DoWhileStatement',
	            DebuggerStatement: 'DebuggerStatement',
	            EmptyStatement: 'EmptyStatement',
	            ExpressionStatement: 'ExpressionStatement',
	            ForStatement: 'ForStatement',
	            ForInStatement: 'ForInStatement',
	            FunctionDeclaration: 'FunctionDeclaration',
	            FunctionExpression: 'FunctionExpression',
	            Identifier: 'Identifier',
	            IfStatement: 'IfStatement',
	            Literal: 'Literal',
	            LabeledStatement: 'LabeledStatement',
	            LogicalExpression: 'LogicalExpression',
	            MemberExpression: 'MemberExpression',
	            NewExpression: 'NewExpression',
	            ObjectExpression: 'ObjectExpression',
	            Program: 'Program',
	            Property: 'Property',
	            ReturnStatement: 'ReturnStatement',
	            SequenceExpression: 'SequenceExpression',
	            SwitchStatement: 'SwitchStatement',
	            SwitchCase: 'SwitchCase',
	            ThisExpression: 'ThisExpression',
	            ThrowStatement: 'ThrowStatement',
	            TryStatement: 'TryStatement',
	            UnaryExpression: 'UnaryExpression',
	            UpdateExpression: 'UpdateExpression',
	            VariableDeclaration: 'VariableDeclaration',
	            VariableDeclarator: 'VariableDeclarator',
	            WhileStatement: 'WhileStatement',
	            WithStatement: 'WithStatement'
	          };
	          PropertyKind = {
	            Data: 1,
	            Get: 2,
	            Set: 4
	          };

	          // Error messages should be identical to V8.
	          Messages = {
	            UnexpectedToken: 'Unexpected token %0',
	            UnexpectedNumber: 'Unexpected number',
	            UnexpectedString: 'Unexpected string',
	            UnexpectedIdentifier: 'Unexpected identifier',
	            UnexpectedReserved: 'Unexpected reserved word',
	            UnexpectedEOS: 'Unexpected end of input',
	            NewlineAfterThrow: 'Illegal newline after throw',
	            InvalidRegExp: 'Invalid regular expression',
	            UnterminatedRegExp: 'Invalid regular expression: missing /',
	            InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	            InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	            MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	            NoCatchOrFinally: 'Missing catch or finally after try',
	            UnknownLabel: 'Undefined label \'%0\'',
	            Redeclaration: '%0 \'%1\' has already been declared',
	            IllegalContinue: 'Illegal continue statement',
	            IllegalBreak: 'Illegal break statement',
	            IllegalReturn: 'Illegal return statement',
	            StrictModeWith: 'Strict mode code may not include a with statement',
	            StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	            StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	            StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	            StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	            StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	            StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	            StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	            StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',
	            AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',
	            AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',
	            StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	            StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	            StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	            StrictReservedWord: 'Use of future reserved word in strict mode'
	          };

	          // See also tools/generate-unicode-regex.py.
	          Regex = {
	            NonAsciiIdentifierStart: new RegExp("[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]"),
	            NonAsciiIdentifierPart: new RegExp("[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]")
	          };

	          // Ensure the condition is true, otherwise throw an error.
	          // This is only to have a better contract semantic, i.e. another safety net
	          // to catch a logic error. The condition shall be fulfilled in normal case.
	          // Do NOT use this to enforce a certain condition on any user input.

	          function assert(condition, message) {
	            /* istanbul ignore if */
	            if (!condition) {
	              throw new Error('ASSERT: ' + message);
	            }
	          }
	          function isDecimalDigit(ch) {
	            return ch >= 48 && ch <= 57; // 0..9
	          }

	          function isHexDigit(ch) {
	            return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
	          }
	          function isOctalDigit(ch) {
	            return '01234567'.indexOf(ch) >= 0;
	          }

	          // 7.2 White Space

	          function isWhiteSpace(ch) {
	            return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0;
	          }

	          // 7.3 Line Terminators

	          function isLineTerminator(ch) {
	            return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
	          }

	          // 7.6 Identifier Names and Identifiers

	          function isIdentifierStart(ch) {
	            return ch == 0x40 || ch === 0x24 || ch === 0x5F ||
	            // $ (dollar) and _ (underscore)
	            ch >= 0x41 && ch <= 0x5A ||
	            // A..Z
	            ch >= 0x61 && ch <= 0x7A ||
	            // a..z
	            ch === 0x5C ||
	            // \ (backslash)
	            ch >= 0x80 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));
	          }
	          function isIdentifierPart(ch) {
	            return ch === 0x24 || ch === 0x5F ||
	            // $ (dollar) and _ (underscore)
	            ch >= 0x41 && ch <= 0x5A ||
	            // A..Z
	            ch >= 0x61 && ch <= 0x7A ||
	            // a..z
	            ch >= 0x30 && ch <= 0x39 ||
	            // 0..9
	            ch === 0x5C ||
	            // \ (backslash)
	            ch >= 0x80 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));
	          }

	          // 7.6.1.2 Future Reserved Words

	          function isFutureReservedWord(id) {
	            switch (id) {
	              case 'class':
	              case 'enum':
	              case 'export':
	              case 'extends':
	              case 'import':
	              case 'super':
	                return true;
	              default:
	                return false;
	            }
	          }
	          function isStrictModeReservedWord(id) {
	            switch (id) {
	              case 'implements':
	              case 'interface':
	              case 'package':
	              case 'private':
	              case 'protected':
	              case 'public':
	              case 'static':
	              case 'yield':
	              case 'let':
	                return true;
	              default:
	                return false;
	            }
	          }
	          function isRestrictedWord(id) {
	            return id === 'eval' || id === 'arguments';
	          }

	          // 7.6.1.1 Keywords

	          function isKeyword(id) {
	            if (strict && isStrictModeReservedWord(id)) {
	              return true;
	            }

	            // 'const' is specialized as Keyword in V8.
	            // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.
	            // Some others are from future reserved words.

	            switch (id.length) {
	              case 2:
	                return id === 'if' || id === 'in' || id === 'do';
	              case 3:
	                return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';
	              case 4:
	                return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
	              case 5:
	                return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
	              case 6:
	                return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
	              case 7:
	                return id === 'default' || id === 'finally' || id === 'extends';
	              case 8:
	                return id === 'function' || id === 'continue' || id === 'debugger';
	              case 10:
	                return id === 'instanceof';
	              default:
	                return false;
	            }
	          }

	          // 7.4 Comments

	          function addComment(type, value, start, end, loc) {
	            var comment;
	            assert(typeof start === 'number', 'Comment must have valid position');

	            // Because the way the actual token is scanned, often the comments
	            // (if any) are skipped twice during the lexical analysis.
	            // Thus, we need to skip adding a comment if the comment array already
	            // handled it.
	            if (state.lastCommentStart >= start) {
	              return;
	            }
	            state.lastCommentStart = start;
	            comment = {
	              type: type,
	              value: value
	            };
	            if (extra.range) {
	              comment.range = [start, end];
	            }
	            if (extra.loc) {
	              comment.loc = loc;
	            }
	            extra.comments.push(comment);
	            if (extra.attachComment) {
	              extra.leadingComments.push(comment);
	              extra.trailingComments.push(comment);
	            }
	          }
	          function skipSingleLineComment(offset) {
	            var start, loc, ch, comment;
	            start = index - offset;
	            loc = {
	              start: {
	                line: lineNumber,
	                column: index - lineStart - offset
	              }
	            };
	            while (index < length) {
	              ch = source.charCodeAt(index);
	              ++index;
	              if (isLineTerminator(ch)) {
	                if (extra.comments) {
	                  comment = source.slice(start + offset, index - 1);
	                  loc.end = {
	                    line: lineNumber,
	                    column: index - lineStart - 1
	                  };
	                  addComment('Line', comment, start, index - 1, loc);
	                }
	                if (ch === 13 && source.charCodeAt(index) === 10) {
	                  ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	                return;
	              }
	            }
	            if (extra.comments) {
	              comment = source.slice(start + offset, index);
	              loc.end = {
	                line: lineNumber,
	                column: index - lineStart
	              };
	              addComment('Line', comment, start, index, loc);
	            }
	          }
	          function skipMultiLineComment() {
	            var start, loc, ch, comment;
	            if (extra.comments) {
	              start = index - 2;
	              loc = {
	                start: {
	                  line: lineNumber,
	                  column: index - lineStart - 2
	                }
	              };
	            }
	            while (index < length) {
	              ch = source.charCodeAt(index);
	              if (isLineTerminator(ch)) {
	                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
	                  ++index;
	                }
	                ++lineNumber;
	                ++index;
	                lineStart = index;
	                if (index >= length) {
	                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	              } else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (source.charCodeAt(index + 1) === 0x2F) {
	                  ++index;
	                  ++index;
	                  if (extra.comments) {
	                    comment = source.slice(start + 2, index - 2);
	                    loc.end = {
	                      line: lineNumber,
	                      column: index - lineStart
	                    };
	                    addComment('Block', comment, start, index, loc);
	                  }
	                  return;
	                }
	                ++index;
	              } else {
	                ++index;
	              }
	            }
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	          }
	          function skipComment() {
	            var ch, start;
	            start = index === 0;
	            while (index < length) {
	              ch = source.charCodeAt(index);
	              if (isWhiteSpace(ch)) {
	                ++index;
	              } else if (isLineTerminator(ch)) {
	                ++index;
	                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
	                  ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	                start = true;
	              } else if (ch === 0x2F) {
	                // U+002F is '/'
	                ch = source.charCodeAt(index + 1);
	                if (ch === 0x2F) {
	                  ++index;
	                  ++index;
	                  skipSingleLineComment(2);
	                  start = true;
	                } else if (ch === 0x2A) {
	                  // U+002A is '*'
	                  ++index;
	                  ++index;
	                  skipMultiLineComment();
	                } else {
	                  break;
	                }
	              } else if (start && ch === 0x2D) {
	                // U+002D is '-'
	                // U+003E is '>'
	                if (source.charCodeAt(index + 1) === 0x2D && source.charCodeAt(index + 2) === 0x3E) {
	                  // '-->' is a single-line comment
	                  index += 3;
	                  skipSingleLineComment(3);
	                } else {
	                  break;
	                }
	              } else if (ch === 0x3C) {
	                // U+003C is '<'
	                if (source.slice(index + 1, index + 4) === '!--') {
	                  ++index; // `<`
	                  ++index; // `!`
	                  ++index; // `-`
	                  ++index; // `-`
	                  skipSingleLineComment(4);
	                } else {
	                  break;
	                }
	              } else {
	                break;
	              }
	            }
	          }
	          function scanHexEscape(prefix) {
	            var i,
	              len,
	              ch,
	              code = 0;
	            len = prefix === 'u' ? 4 : 2;
	            for (i = 0; i < len; ++i) {
	              if (index < length && isHexDigit(source[index])) {
	                ch = source[index++];
	                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	              } else {
	                return '';
	              }
	            }
	            return String.fromCharCode(code);
	          }
	          function getEscapedIdentifier() {
	            var ch, id;
	            ch = source.charCodeAt(index++);
	            id = String.fromCharCode(ch);

	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (ch === 0x5C) {
	              if (source.charCodeAt(index) !== 0x75) {
	                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	              }
	              ++index;
	              ch = scanHexEscape('u');
	              if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
	                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	              }
	              id = ch;
	            }
	            while (index < length) {
	              ch = source.charCodeAt(index);
	              if (!isIdentifierPart(ch)) {
	                break;
	              }
	              ++index;
	              id += String.fromCharCode(ch);

	              // '\u' (U+005C, U+0075) denotes an escaped character.
	              if (ch === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (source.charCodeAt(index) !== 0x75) {
	                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	                ++index;
	                ch = scanHexEscape('u');
	                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
	                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	                id += ch;
	              }
	            }
	            return id;
	          }
	          function getIdentifier() {
	            var start, ch;
	            start = index++;
	            while (index < length) {
	              ch = source.charCodeAt(index);
	              if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                index = start;
	                return getEscapedIdentifier();
	              }
	              if (isIdentifierPart(ch)) {
	                ++index;
	              } else {
	                break;
	              }
	            }
	            return source.slice(start, index);
	          }
	          function scanIdentifier() {
	            var start, id, type;
	            start = index;

	            // Backslash (U+005C) starts an escaped character.
	            id = source.charCodeAt(index) === 0x5C ? getEscapedIdentifier() : getIdentifier();

	            // There is no keyword or literal with only one character.
	            // Thus, it must be an identifier.
	            if (id.length === 1) {
	              type = Token.Identifier;
	            } else if (isKeyword(id)) {
	              type = Token.Keyword;
	            } else if (id === 'null') {
	              type = Token.NullLiteral;
	            } else if (id === 'true' || id === 'false') {
	              type = Token.BooleanLiteral;
	            } else {
	              type = Token.Identifier;
	            }
	            return {
	              type: type,
	              value: id,
	              lineNumber: lineNumber,
	              lineStart: lineStart,
	              start: start,
	              end: index
	            };
	          }

	          // 7.7 Punctuators

	          function scanPunctuator() {
	            var start = index,
	              code = source.charCodeAt(index),
	              code2,
	              ch1 = source[index],
	              ch2,
	              ch3,
	              ch4;
	            switch (code) {
	              // Check for most common single-character punctuators.
	              case 0x2E: // . dot
	              case 0x28: // ( open bracket
	              case 0x29: // ) close bracket
	              case 0x3B: // ; semicolon
	              case 0x2C: // , comma
	              case 0x7B: // { open curly brace
	              case 0x7D: // } close curly brace
	              case 0x5B: // [
	              case 0x5D: // ]
	              case 0x3A: // :
	              case 0x3F: // ?
	              case 0x7E:
	                // ~
	                ++index;
	                if (extra.tokenize) {
	                  if (code === 0x28) {
	                    extra.openParenToken = extra.tokens.length;
	                  } else if (code === 0x7B) {
	                    extra.openCurlyToken = extra.tokens.length;
	                  }
	                }
	                return {
	                  type: Token.Punctuator,
	                  value: String.fromCharCode(code),
	                  lineNumber: lineNumber,
	                  lineStart: lineStart,
	                  start: start,
	                  end: index
	                };
	              default:
	                code2 = source.charCodeAt(index + 1);

	                // '=' (U+003D) marks an assignment or comparison operator.
	                if (code2 === 0x3D) {
	                  switch (code) {
	                    case 0x2B: // +
	                    case 0x2D: // -
	                    case 0x2F: // /
	                    case 0x3C: // <
	                    case 0x3E: // >
	                    case 0x5E: // ^
	                    case 0x7C: // |
	                    case 0x25: // %
	                    case 0x26: // &
	                    case 0x2A:
	                      // *
	                      index += 2;
	                      return {
	                        type: Token.Punctuator,
	                        value: String.fromCharCode(code) + String.fromCharCode(code2),
	                        lineNumber: lineNumber,
	                        lineStart: lineStart,
	                        start: start,
	                        end: index
	                      };
	                    case 0x21: // !
	                    case 0x3D:
	                      // =
	                      index += 2;

	                      // !== and ===
	                      if (source.charCodeAt(index) === 0x3D) {
	                        ++index;
	                      }
	                      return {
	                        type: Token.Punctuator,
	                        value: source.slice(start, index),
	                        lineNumber: lineNumber,
	                        lineStart: lineStart,
	                        start: start,
	                        end: index
	                      };
	                  }
	                }
	            }

	            // 4-character punctuator: >>>=

	            ch4 = source.substr(index, 4);
	            if (ch4 === '>>>=') {
	              index += 4;
	              return {
	                type: Token.Punctuator,
	                value: ch4,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	              };
	            }

	            // 3-character punctuators: === !== >>> <<= >>=

	            ch3 = ch4.substr(0, 3);
	            if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
	              index += 3;
	              return {
	                type: Token.Punctuator,
	                value: ch3,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	              };
	            }

	            // Other 2-character punctuators: ++ -- << >> && ||
	            ch2 = ch3.substr(0, 2);
	            if (ch1 === ch2[1] && '+-<>&|'.indexOf(ch1) >= 0 || ch2 === '=>') {
	              index += 2;
	              return {
	                type: Token.Punctuator,
	                value: ch2,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	              };
	            }

	            // 1-character punctuators: < > = ! + - * % & | ^ /
	            if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
	              ++index;
	              return {
	                type: Token.Punctuator,
	                value: ch1,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	              };
	            }
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	          }

	          // 7.8.3 Numeric Literals

	          function scanHexLiteral(start) {
	            var number = '';
	            while (index < length) {
	              if (!isHexDigit(source[index])) {
	                break;
	              }
	              number += source[index++];
	            }
	            if (number.length === 0) {
	              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	            }
	            if (isIdentifierStart(source.charCodeAt(index))) {
	              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	            }
	            return {
	              type: Token.NumericLiteral,
	              value: parseInt('0x' + number, 16),
	              lineNumber: lineNumber,
	              lineStart: lineStart,
	              start: start,
	              end: index
	            };
	          }
	          function scanOctalLiteral(start) {
	            var number = '0' + source[index++];
	            while (index < length) {
	              if (!isOctalDigit(source[index])) {
	                break;
	              }
	              number += source[index++];
	            }
	            if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
	              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	            }
	            return {
	              type: Token.NumericLiteral,
	              value: parseInt(number, 8),
	              octal: true,
	              lineNumber: lineNumber,
	              lineStart: lineStart,
	              start: start,
	              end: index
	            };
	          }
	          function scanNumericLiteral() {
	            var number, start, ch;
	            ch = source[index];
	            assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');
	            start = index;
	            number = '';
	            if (ch !== '.') {
	              number = source[index++];
	              ch = source[index];

	              // Hex number starts with '0x'.
	              // Octal number starts with '0'.
	              if (number === '0') {
	                if (ch === 'x' || ch === 'X') {
	                  ++index;
	                  return scanHexLiteral(start);
	                }
	                if (isOctalDigit(ch)) {
	                  return scanOctalLiteral(start);
	                }

	                // decimal number starts with '0' such as '09' is illegal.
	                if (ch && isDecimalDigit(ch.charCodeAt(0))) {
	                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	              }
	              while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	              }
	              ch = source[index];
	            }
	            if (ch === '.') {
	              number += source[index++];
	              while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	              }
	              ch = source[index];
	            }
	            if (ch === 'e' || ch === 'E') {
	              number += source[index++];
	              ch = source[index];
	              if (ch === '+' || ch === '-') {
	                number += source[index++];
	              }
	              if (isDecimalDigit(source.charCodeAt(index))) {
	                while (isDecimalDigit(source.charCodeAt(index))) {
	                  number += source[index++];
	                }
	              } else {
	                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	              }
	            }
	            if (isIdentifierStart(source.charCodeAt(index))) {
	              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	            }
	            return {
	              type: Token.NumericLiteral,
	              value: parseFloat(number),
	              lineNumber: lineNumber,
	              lineStart: lineStart,
	              start: start,
	              end: index
	            };
	          }

	          // 7.8.4 String Literals

	          function scanStringLiteral() {
	            var str = '',
	              quote,
	              start,
	              ch,
	              code,
	              unescaped,
	              restore,
	              octal = false,
	              startLineNumber,
	              startLineStart;
	            startLineNumber = lineNumber;
	            startLineStart = lineStart;
	            quote = source[index];
	            assert(quote === '\'' || quote === '"', 'String literal must starts with a quote');
	            start = index;
	            ++index;
	            while (index < length) {
	              ch = source[index++];
	              if (ch === quote) {
	                quote = '';
	                break;
	              } else if (ch === '\\') {
	                ch = source[index++];
	                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
	                  switch (ch) {
	                    case 'u':
	                    case 'x':
	                      restore = index;
	                      unescaped = scanHexEscape(ch);
	                      if (unescaped) {
	                        str += unescaped;
	                      } else {
	                        index = restore;
	                        str += ch;
	                      }
	                      break;
	                    case 'n':
	                      str += '\n';
	                      break;
	                    case 'r':
	                      str += '\r';
	                      break;
	                    case 't':
	                      str += '\t';
	                      break;
	                    case 'b':
	                      str += '\b';
	                      break;
	                    case 'f':
	                      str += '\f';
	                      break;
	                    case 'v':
	                      str += '\x0B';
	                      break;
	                    default:
	                      if (isOctalDigit(ch)) {
	                        code = '01234567'.indexOf(ch);

	                        // \0 is not octal escape sequence
	                        if (code !== 0) {
	                          octal = true;
	                        }
	                        if (index < length && isOctalDigit(source[index])) {
	                          octal = true;
	                          code = code * 8 + '01234567'.indexOf(source[index++]);

	                          // 3 digits are only allowed when string starts
	                          // with 0, 1, 2, 3
	                          if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {
	                            code = code * 8 + '01234567'.indexOf(source[index++]);
	                          }
	                        }
	                        str += String.fromCharCode(code);
	                      } else {
	                        str += ch;
	                      }
	                      break;
	                  }
	                } else {
	                  ++lineNumber;
	                  if (ch === '\r' && source[index] === '\n') {
	                    ++index;
	                  }
	                  lineStart = index;
	                }
	              } else if (isLineTerminator(ch.charCodeAt(0))) {
	                break;
	              } else {
	                str += ch;
	              }
	            }
	            if (quote !== '') {
	              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	            }
	            return {
	              type: Token.StringLiteral,
	              value: str,
	              octal: octal,
	              startLineNumber: startLineNumber,
	              startLineStart: startLineStart,
	              lineNumber: lineNumber,
	              lineStart: lineStart,
	              start: start,
	              end: index
	            };
	          }
	          function testRegExp(pattern, flags) {
	            var value;
	            try {
	              value = new RegExp(pattern, flags);
	            } catch (e) {
	              throwError({}, Messages.InvalidRegExp);
	            }
	            return value;
	          }
	          function scanRegExpBody() {
	            var ch, str, classMarker, terminated, body;
	            ch = source[index];
	            assert(ch === '/', 'Regular expression literal must start with a slash');
	            str = source[index++];
	            classMarker = false;
	            terminated = false;
	            while (index < length) {
	              ch = source[index++];
	              str += ch;
	              if (ch === '\\') {
	                ch = source[index++];
	                // ECMA-262 7.8.5
	                if (isLineTerminator(ch.charCodeAt(0))) {
	                  throwError({}, Messages.UnterminatedRegExp);
	                }
	                str += ch;
	              } else if (isLineTerminator(ch.charCodeAt(0))) {
	                throwError({}, Messages.UnterminatedRegExp);
	              } else if (classMarker) {
	                if (ch === ']') {
	                  classMarker = false;
	                }
	              } else {
	                if (ch === '/') {
	                  terminated = true;
	                  break;
	                } else if (ch === '[') {
	                  classMarker = true;
	                }
	              }
	            }
	            if (!terminated) {
	              throwError({}, Messages.UnterminatedRegExp);
	            }

	            // Exclude leading and trailing slash.
	            body = str.substr(1, str.length - 2);
	            return {
	              value: body,
	              literal: str
	            };
	          }
	          function scanRegExpFlags() {
	            var ch, str, flags, restore;
	            str = '';
	            flags = '';
	            while (index < length) {
	              ch = source[index];
	              if (!isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	              }
	              ++index;
	              if (ch === '\\' && index < length) {
	                ch = source[index];
	                if (ch === 'u') {
	                  ++index;
	                  restore = index;
	                  ch = scanHexEscape('u');
	                  if (ch) {
	                    flags += ch;
	                    for (str += "\\u"; restore < index; ++restore) {
	                      str += source[restore];
	                    }
	                  } else {
	                    index = restore;
	                    flags += 'u';
	                    str += "\\u";
	                  }
	                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
	                } else {
	                  str += '\\';
	                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	              } else {
	                flags += ch;
	                str += ch;
	              }
	            }
	            return {
	              value: flags,
	              literal: str
	            };
	          }
	          function scanRegExp() {
	            var start, body, flags, value;
	            lookahead = null;
	            skipComment();
	            start = index;
	            body = scanRegExpBody();
	            flags = scanRegExpFlags();
	            value = testRegExp(body.value, flags.value);
	            if (extra.tokenize) {
	              return {
	                type: Token.RegularExpression,
	                value: value,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	              };
	            }
	            return {
	              literal: body.literal + flags.literal,
	              value: value,
	              start: start,
	              end: index
	            };
	          }
	          function collectRegex() {
	            var pos, loc, regex, token;
	            skipComment();
	            pos = index;
	            loc = {
	              start: {
	                line: lineNumber,
	                column: index - lineStart
	              }
	            };
	            regex = scanRegExp();
	            loc.end = {
	              line: lineNumber,
	              column: index - lineStart
	            };

	            /* istanbul ignore next */
	            if (!extra.tokenize) {
	              // Pop the previous token, which is likely '/' or '/='
	              if (extra.tokens.length > 0) {
	                token = extra.tokens[extra.tokens.length - 1];
	                if (token.range[0] === pos && token.type === 'Punctuator') {
	                  if (token.value === '/' || token.value === '/=') {
	                    extra.tokens.pop();
	                  }
	                }
	              }
	              extra.tokens.push({
	                type: 'RegularExpression',
	                value: regex.literal,
	                range: [pos, index],
	                loc: loc
	              });
	            }
	            return regex;
	          }
	          function isIdentifierName(token) {
	            return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;
	          }
	          function advanceSlash() {
	            var prevToken, checkToken;
	            // Using the following algorithm:
	            // https://github.com/mozilla/sweet.js/wiki/design
	            prevToken = extra.tokens[extra.tokens.length - 1];
	            if (!prevToken) {
	              // Nothing before that: it cannot be a division.
	              return collectRegex();
	            }
	            if (prevToken.type === 'Punctuator') {
	              if (prevToken.value === ']') {
	                return scanPunctuator();
	              }
	              if (prevToken.value === ')') {
	                checkToken = extra.tokens[extra.openParenToken - 1];
	                if (checkToken && checkToken.type === 'Keyword' && (checkToken.value === 'if' || checkToken.value === 'while' || checkToken.value === 'for' || checkToken.value === 'with')) {
	                  return collectRegex();
	                }
	                return scanPunctuator();
	              }
	              if (prevToken.value === '}') {
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                if (extra.tokens[extra.openCurlyToken - 3] && extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
	                  // Anonymous function.
	                  checkToken = extra.tokens[extra.openCurlyToken - 4];
	                  if (!checkToken) {
	                    return scanPunctuator();
	                  }
	                } else if (extra.tokens[extra.openCurlyToken - 4] && extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
	                  // Named function.
	                  checkToken = extra.tokens[extra.openCurlyToken - 5];
	                  if (!checkToken) {
	                    return collectRegex();
	                  }
	                } else {
	                  return scanPunctuator();
	                }
	                // checkToken determines whether the function is
	                // a declaration or an expression.
	                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
	                  // It is an expression.
	                  return scanPunctuator();
	                }
	                // It is a declaration.
	                return collectRegex();
	              }
	              return collectRegex();
	            }
	            if (prevToken.type === 'Keyword') {
	              return collectRegex();
	            }
	            return scanPunctuator();
	          }
	          function advance() {
	            var ch;
	            skipComment();
	            if (index >= length) {
	              return {
	                type: Token.EOF,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: index,
	                end: index
	              };
	            }
	            ch = source.charCodeAt(index);
	            if (isIdentifierStart(ch)) {
	              return scanIdentifier();
	            }

	            // Very common: ( and ) and ;
	            if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
	              return scanPunctuator();
	            }

	            // String literal starts with single quote (U+0027) or double quote (U+0022).
	            if (ch === 0x27 || ch === 0x22) {
	              return scanStringLiteral();
	            }

	            // Dot (.) U+002E can also start a floating-point number, hence the need
	            // to check the next character.
	            if (ch === 0x2E) {
	              if (isDecimalDigit(source.charCodeAt(index + 1))) {
	                return scanNumericLiteral();
	              }
	              return scanPunctuator();
	            }
	            if (isDecimalDigit(ch)) {
	              return scanNumericLiteral();
	            }

	            // Slash (/) U+002F can also start a regex.
	            if (extra.tokenize && ch === 0x2F) {
	              return advanceSlash();
	            }
	            return scanPunctuator();
	          }
	          function collectToken() {
	            var loc, token, value;
	            skipComment();
	            loc = {
	              start: {
	                line: lineNumber,
	                column: index - lineStart
	              }
	            };
	            token = advance();
	            loc.end = {
	              line: lineNumber,
	              column: index - lineStart
	            };
	            if (token.type !== Token.EOF) {
	              value = source.slice(token.start, token.end);
	              extra.tokens.push({
	                type: TokenName[token.type],
	                value: value,
	                range: [token.start, token.end],
	                loc: loc
	              });
	            }
	            return token;
	          }
	          function lex() {
	            var token;
	            token = lookahead;
	            index = token.end;
	            lineNumber = token.lineNumber;
	            lineStart = token.lineStart;
	            lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();
	            index = token.end;
	            lineNumber = token.lineNumber;
	            lineStart = token.lineStart;
	            return token;
	          }
	          function peek() {
	            var pos, line, start;
	            pos = index;
	            line = lineNumber;
	            start = lineStart;
	            lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();
	            index = pos;
	            lineNumber = line;
	            lineStart = start;
	          }
	          function Position(line, column) {
	            this.line = line;
	            this.column = column;
	          }
	          function SourceLocation(startLine, startColumn, line, column) {
	            this.start = new Position(startLine, startColumn);
	            this.end = new Position(line, column);
	          }
	          SyntaxTreeDelegate = {
	            name: 'SyntaxTree',
	            processComment: function processComment(node) {
	              var lastChild, trailingComments;
	              if (node.type === Syntax.Program) {
	                if (node.body.length > 0) {
	                  return;
	                }
	              }
	              if (extra.trailingComments.length > 0) {
	                if (extra.trailingComments[0].range[0] >= node.range[1]) {
	                  trailingComments = extra.trailingComments;
	                  extra.trailingComments = [];
	                } else {
	                  extra.trailingComments.length = 0;
	                }
	              } else {
	                if (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {
	                  trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
	                  delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
	                }
	              }

	              // Eating the stack.
	              while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {
	                lastChild = extra.bottomRightStack.pop();
	              }
	              if (lastChild) {
	                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
	                  node.leadingComments = lastChild.leadingComments;
	                  delete lastChild.leadingComments;
	                }
	              } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
	                node.leadingComments = extra.leadingComments;
	                extra.leadingComments = [];
	              }
	              if (trailingComments) {
	                node.trailingComments = trailingComments;
	              }
	              extra.bottomRightStack.push(node);
	            },
	            markEnd: function markEnd(node, startToken) {
	              if (extra.range) {
	                node.range = [startToken.start, index];
	              }
	              if (extra.loc) {
	                node.loc = new SourceLocation(startToken.startLineNumber === undefined ? startToken.lineNumber : startToken.startLineNumber, startToken.start - (startToken.startLineStart === undefined ? startToken.lineStart : startToken.startLineStart), lineNumber, index - lineStart);
	                this.postProcess(node);
	              }
	              if (extra.attachComment) {
	                this.processComment(node);
	              }
	              return node;
	            },
	            postProcess: function postProcess(node) {
	              if (extra.source) {
	                node.loc.source = extra.source;
	              }
	              return node;
	            },
	            createArrayExpression: function createArrayExpression(elements) {
	              return {
	                type: Syntax.ArrayExpression,
	                elements: elements
	              };
	            },
	            createAssignmentExpression: function createAssignmentExpression(operator, left, right) {
	              return {
	                type: Syntax.AssignmentExpression,
	                operator: operator,
	                left: left,
	                right: right
	              };
	            },
	            createBinaryExpression: function createBinaryExpression(operator, left, right) {
	              var type = operator === '||' || operator === '&&' ? Syntax.LogicalExpression : Syntax.BinaryExpression;
	              return {
	                type: type,
	                operator: operator,
	                left: left,
	                right: right
	              };
	            },
	            createBlockStatement: function createBlockStatement(body) {
	              return {
	                type: Syntax.BlockStatement,
	                body: body
	              };
	            },
	            createBreakStatement: function createBreakStatement(label) {
	              return {
	                type: Syntax.BreakStatement,
	                label: label
	              };
	            },
	            createCallExpression: function createCallExpression(callee, args) {
	              return {
	                type: Syntax.CallExpression,
	                callee: callee,
	                'arguments': args
	              };
	            },
	            createCatchClause: function createCatchClause(param, body) {
	              return {
	                type: Syntax.CatchClause,
	                param: param,
	                body: body
	              };
	            },
	            createConditionalExpression: function createConditionalExpression(test, consequent, alternate) {
	              return {
	                type: Syntax.ConditionalExpression,
	                test: test,
	                consequent: consequent,
	                alternate: alternate
	              };
	            },
	            createContinueStatement: function createContinueStatement(label) {
	              return {
	                type: Syntax.ContinueStatement,
	                label: label
	              };
	            },
	            createDebuggerStatement: function createDebuggerStatement() {
	              return {
	                type: Syntax.DebuggerStatement
	              };
	            },
	            createDoWhileStatement: function createDoWhileStatement(body, test) {
	              return {
	                type: Syntax.DoWhileStatement,
	                body: body,
	                test: test
	              };
	            },
	            createEmptyStatement: function createEmptyStatement() {
	              return {
	                type: Syntax.EmptyStatement
	              };
	            },
	            createExpressionStatement: function createExpressionStatement(expression) {
	              return {
	                type: Syntax.ExpressionStatement,
	                expression: expression
	              };
	            },
	            createForStatement: function createForStatement(init, test, update, body) {
	              return {
	                type: Syntax.ForStatement,
	                init: init,
	                test: test,
	                update: update,
	                body: body
	              };
	            },
	            createForInStatement: function createForInStatement(left, right, body) {
	              return {
	                type: Syntax.ForInStatement,
	                left: left,
	                right: right,
	                body: body,
	                each: false
	              };
	            },
	            createFunctionDeclaration: function createFunctionDeclaration(id, params, defaults, body) {
	              return {
	                type: Syntax.FunctionDeclaration,
	                id: id,
	                params: params,
	                defaults: defaults,
	                body: body,
	                rest: null,
	                generator: false,
	                expression: false
	              };
	            },
	            createFunctionExpression: function createFunctionExpression(id, params, defaults, body) {
	              return {
	                type: Syntax.FunctionExpression,
	                id: id,
	                params: params,
	                defaults: defaults,
	                body: body,
	                rest: null,
	                generator: false,
	                expression: false
	              };
	            },
	            createIdentifier: function createIdentifier(name) {
	              return {
	                type: Syntax.Identifier,
	                name: name
	              };
	            },
	            createIfStatement: function createIfStatement(test, consequent, alternate) {
	              return {
	                type: Syntax.IfStatement,
	                test: test,
	                consequent: consequent,
	                alternate: alternate
	              };
	            },
	            createLabeledStatement: function createLabeledStatement(label, body) {
	              return {
	                type: Syntax.LabeledStatement,
	                label: label,
	                body: body
	              };
	            },
	            createLiteral: function createLiteral(token) {
	              return {
	                type: Syntax.Literal,
	                value: token.value,
	                raw: source.slice(token.start, token.end)
	              };
	            },
	            createMemberExpression: function createMemberExpression(accessor, object, property) {
	              return {
	                type: Syntax.MemberExpression,
	                computed: accessor === '[',
	                object: object,
	                property: property
	              };
	            },
	            createNewExpression: function createNewExpression(callee, args) {
	              return {
	                type: Syntax.NewExpression,
	                callee: callee,
	                'arguments': args
	              };
	            },
	            createObjectExpression: function createObjectExpression(properties) {
	              return {
	                type: Syntax.ObjectExpression,
	                properties: properties
	              };
	            },
	            createPostfixExpression: function createPostfixExpression(operator, argument) {
	              return {
	                type: Syntax.UpdateExpression,
	                operator: operator,
	                argument: argument,
	                prefix: false
	              };
	            },
	            createProgram: function createProgram(body) {
	              return {
	                type: Syntax.Program,
	                body: body
	              };
	            },
	            createProperty: function createProperty(kind, key, value) {
	              return {
	                type: Syntax.Property,
	                key: key,
	                value: value,
	                kind: kind
	              };
	            },
	            createReturnStatement: function createReturnStatement(argument) {
	              return {
	                type: Syntax.ReturnStatement,
	                argument: argument
	              };
	            },
	            createSequenceExpression: function createSequenceExpression(expressions) {
	              return {
	                type: Syntax.SequenceExpression,
	                expressions: expressions
	              };
	            },
	            createSwitchCase: function createSwitchCase(test, consequent) {
	              return {
	                type: Syntax.SwitchCase,
	                test: test,
	                consequent: consequent
	              };
	            },
	            createSwitchStatement: function createSwitchStatement(discriminant, cases) {
	              return {
	                type: Syntax.SwitchStatement,
	                discriminant: discriminant,
	                cases: cases
	              };
	            },
	            createThisExpression: function createThisExpression() {
	              return {
	                type: Syntax.ThisExpression
	              };
	            },
	            createThrowStatement: function createThrowStatement(argument) {
	              return {
	                type: Syntax.ThrowStatement,
	                argument: argument
	              };
	            },
	            createTryStatement: function createTryStatement(block, guardedHandlers, handlers, finalizer) {
	              return {
	                type: Syntax.TryStatement,
	                block: block,
	                guardedHandlers: guardedHandlers,
	                handlers: handlers,
	                finalizer: finalizer
	              };
	            },
	            createUnaryExpression: function createUnaryExpression(operator, argument) {
	              if (operator === '++' || operator === '--') {
	                return {
	                  type: Syntax.UpdateExpression,
	                  operator: operator,
	                  argument: argument,
	                  prefix: true
	                };
	              }
	              return {
	                type: Syntax.UnaryExpression,
	                operator: operator,
	                argument: argument,
	                prefix: true
	              };
	            },
	            createVariableDeclaration: function createVariableDeclaration(declarations, kind) {
	              return {
	                type: Syntax.VariableDeclaration,
	                declarations: declarations,
	                kind: kind
	              };
	            },
	            createVariableDeclarator: function createVariableDeclarator(id, init) {
	              return {
	                type: Syntax.VariableDeclarator,
	                id: id,
	                init: init
	              };
	            },
	            createWhileStatement: function createWhileStatement(test, body) {
	              return {
	                type: Syntax.WhileStatement,
	                test: test,
	                body: body
	              };
	            },
	            createWithStatement: function createWithStatement(object, body) {
	              return {
	                type: Syntax.WithStatement,
	                object: object,
	                body: body
	              };
	            }
	          };

	          // Return true if there is a line terminator before the next token.

	          function peekLineTerminator() {
	            var pos, line, start, found;
	            pos = index;
	            line = lineNumber;
	            start = lineStart;
	            skipComment();
	            found = lineNumber !== line;
	            index = pos;
	            lineNumber = line;
	            lineStart = start;
	            return found;
	          }

	          // Throw an exception

	          function throwError(token, messageFormat) {
	            var error,
	              args = Array.prototype.slice.call(arguments, 2),
	              msg = messageFormat.replace(/%(\d)/g, function (whole, index) {
	                assert(index < args.length, 'Message reference must be in range');
	                return args[index];
	              });
	            if (typeof token.lineNumber === 'number') {
	              error = new Error('Line ' + token.lineNumber + ': ' + msg);
	              error.index = token.start;
	              error.lineNumber = token.lineNumber;
	              error.column = token.start - lineStart + 1;
	            } else {
	              error = new Error('Line ' + lineNumber + ': ' + msg);
	              error.index = index;
	              error.lineNumber = lineNumber;
	              error.column = index - lineStart + 1;
	            }
	            error.description = msg;
	            throw error;
	          }
	          function throwErrorTolerant() {
	            try {
	              throwError.apply(null, arguments);
	            } catch (e) {
	              if (extra.errors) {
	                extra.errors.push(e);
	              } else {
	                throw e;
	              }
	            }
	          }

	          // Throw an exception because of the token.

	          function throwUnexpected(token) {
	            if (token.type === Token.EOF) {
	              throwError(token, Messages.UnexpectedEOS);
	            }
	            if (token.type === Token.NumericLiteral) {
	              throwError(token, Messages.UnexpectedNumber);
	            }
	            if (token.type === Token.StringLiteral) {
	              throwError(token, Messages.UnexpectedString);
	            }
	            if (token.type === Token.Identifier) {
	              throwError(token, Messages.UnexpectedIdentifier);
	            }
	            if (token.type === Token.Keyword) {
	              if (isFutureReservedWord(token.value)) {
	                throwError(token, Messages.UnexpectedReserved);
	              } else if (strict && isStrictModeReservedWord(token.value)) {
	                throwErrorTolerant(token, Messages.StrictReservedWord);
	                return;
	              }
	              throwError(token, Messages.UnexpectedToken, token.value);
	            }

	            // BooleanLiteral, NullLiteral, or Punctuator.
	            throwError(token, Messages.UnexpectedToken, token.value);
	          }

	          // Expect the next token to match the specified punctuator.
	          // If not, an exception will be thrown.

	          function expect(value) {
	            var token = lex();
	            if (token.type !== Token.Punctuator || token.value !== value) {
	              throwUnexpected(token);
	            }
	          }

	          // Expect the next token to match the specified keyword.
	          // If not, an exception will be thrown.

	          function expectKeyword(keyword) {
	            var token = lex();
	            if (token.type !== Token.Keyword || token.value !== keyword) {
	              throwUnexpected(token);
	            }
	          }

	          // Return true if the next token matches the specified punctuator.

	          function match(value) {
	            return lookahead.type === Token.Punctuator && lookahead.value === value;
	          }

	          // Return true if the next token matches the specified keyword

	          function matchKeyword(keyword) {
	            return lookahead.type === Token.Keyword && lookahead.value === keyword;
	          }

	          // Return true if the next token is an assignment operator

	          function matchAssign() {
	            var op;
	            if (lookahead.type !== Token.Punctuator) {
	              return false;
	            }
	            op = lookahead.value;
	            return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';
	          }
	          function consumeSemicolon() {
	            var line;

	            // Catch the very common case first: immediately a semicolon (U+003B).
	            if (source.charCodeAt(index) === 0x3B || match(';')) {
	              lex();
	              return;
	            }
	            line = lineNumber;
	            skipComment();
	            if (lineNumber !== line) {
	              return;
	            }
	            if (lookahead.type !== Token.EOF && !match('}')) {
	              throwUnexpected(lookahead);
	            }
	          }

	          // Return true if provided expression is LeftHandSideExpression

	          function isLeftHandSide(expr) {
	            return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
	          }

	          // 11.1.4 Array Initialiser

	          function parseArrayInitialiser() {
	            var elements = [],
	              startToken;
	            startToken = lookahead;
	            expect('[');
	            while (!match(']')) {
	              if (match(',')) {
	                lex();
	                elements.push(null);
	              } else {
	                elements.push(parseAssignmentExpression());
	                if (!match(']')) {
	                  expect(',');
	                }
	              }
	            }
	            lex();
	            return delegate.markEnd(delegate.createArrayExpression(elements), startToken);
	          }

	          // 11.1.5 Object Initialiser

	          function parsePropertyFunction(param, first) {
	            var previousStrict, body, startToken;
	            previousStrict = strict;
	            startToken = lookahead;
	            body = parseFunctionSourceElements();
	            if (first && strict && isRestrictedWord(param[0].name)) {
	              throwErrorTolerant(first, Messages.StrictParamName);
	            }
	            strict = previousStrict;
	            return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body), startToken);
	          }
	          function parseObjectPropertyKey() {
	            var token, startToken;
	            startToken = lookahead;
	            token = lex();

	            // Note: This function is called only from parseObjectProperty(), where
	            // EOF and Punctuator tokens are already filtered out.

	            if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
	              if (strict && token.octal) {
	                throwErrorTolerant(token, Messages.StrictOctalLiteral);
	              }
	              return delegate.markEnd(delegate.createLiteral(token), startToken);
	            }
	            return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
	          }
	          function parseObjectProperty() {
	            var token, key, id, value, param, startToken;
	            token = lookahead;
	            startToken = lookahead;
	            if (token.type === Token.Identifier) {
	              id = parseObjectPropertyKey();

	              // Property Assignment: Getter and Setter.

	              if (token.value === 'get' && !match(':')) {
	                key = parseObjectPropertyKey();
	                expect('(');
	                expect(')');
	                value = parsePropertyFunction([]);
	                return delegate.markEnd(delegate.createProperty('get', key, value), startToken);
	              }
	              if (token.value === 'set' && !match(':')) {
	                key = parseObjectPropertyKey();
	                expect('(');
	                token = lookahead;
	                if (token.type !== Token.Identifier) {
	                  expect(')');
	                  throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
	                  value = parsePropertyFunction([]);
	                } else {
	                  param = [parseVariableIdentifier()];
	                  expect(')');
	                  value = parsePropertyFunction(param, token);
	                }
	                return delegate.markEnd(delegate.createProperty('set', key, value), startToken);
	              }
	              expect(':');
	              value = parseAssignmentExpression();
	              return delegate.markEnd(delegate.createProperty('init', id, value), startToken);
	            }
	            if (token.type === Token.EOF || token.type === Token.Punctuator) {
	              throwUnexpected(token);
	            } else {
	              key = parseObjectPropertyKey();
	              expect(':');
	              value = parseAssignmentExpression();
	              return delegate.markEnd(delegate.createProperty('init', key, value), startToken);
	            }
	          }
	          function parseObjectInitialiser() {
	            var properties = [],
	              property,
	              name,
	              key,
	              kind,
	              map = {},
	              toString = String,
	              startToken;
	            startToken = lookahead;
	            expect('{');
	            while (!match('}')) {
	              property = parseObjectProperty();
	              if (property.key.type === Syntax.Identifier) {
	                name = property.key.name;
	              } else {
	                name = toString(property.key.value);
	              }
	              kind = property.kind === 'init' ? PropertyKind.Data : property.kind === 'get' ? PropertyKind.Get : PropertyKind.Set;
	              key = '$' + name;
	              if (Object.prototype.hasOwnProperty.call(map, key)) {
	                if (map[key] === PropertyKind.Data) {
	                  if (strict && kind === PropertyKind.Data) {
	                    throwErrorTolerant({}, Messages.StrictDuplicateProperty);
	                  } else if (kind !== PropertyKind.Data) {
	                    throwErrorTolerant({}, Messages.AccessorDataProperty);
	                  }
	                } else {
	                  if (kind === PropertyKind.Data) {
	                    throwErrorTolerant({}, Messages.AccessorDataProperty);
	                  } else if (map[key] & kind) {
	                    throwErrorTolerant({}, Messages.AccessorGetSet);
	                  }
	                }
	                map[key] |= kind;
	              } else {
	                map[key] = kind;
	              }
	              properties.push(property);
	              if (!match('}')) {
	                expect(',');
	              }
	            }
	            expect('}');
	            return delegate.markEnd(delegate.createObjectExpression(properties), startToken);
	          }

	          // 11.1.6 The Grouping Operator

	          function parseGroupExpression() {
	            var expr;
	            expect('(');
	            expr = parseExpression();
	            expect(')');
	            return expr;
	          }

	          // 11.1 Primary Expressions

	          function parsePrimaryExpression() {
	            var type, token, expr, startToken;
	            if (match('(')) {
	              return parseGroupExpression();
	            }
	            if (match('[')) {
	              return parseArrayInitialiser();
	            }
	            if (match('{')) {
	              return parseObjectInitialiser();
	            }
	            type = lookahead.type;
	            startToken = lookahead;
	            if (type === Token.Identifier) {
	              expr = delegate.createIdentifier(lex().value);
	            } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
	              if (strict && lookahead.octal) {
	                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
	              }
	              expr = delegate.createLiteral(lex());
	            } else if (type === Token.Keyword) {
	              if (matchKeyword('function')) {
	                return parseFunctionExpression();
	              }
	              if (matchKeyword('this')) {
	                lex();
	                expr = delegate.createThisExpression();
	              } else {
	                throwUnexpected(lex());
	              }
	            } else if (type === Token.BooleanLiteral) {
	              token = lex();
	              token.value = token.value === 'true';
	              expr = delegate.createLiteral(token);
	            } else if (type === Token.NullLiteral) {
	              token = lex();
	              token.value = null;
	              expr = delegate.createLiteral(token);
	            } else if (match('/') || match('/=')) {
	              if (typeof extra.tokens !== 'undefined') {
	                expr = delegate.createLiteral(collectRegex());
	              } else {
	                expr = delegate.createLiteral(scanRegExp());
	              }
	              peek();
	            } else {
	              throwUnexpected(lex());
	            }
	            return delegate.markEnd(expr, startToken);
	          }

	          // 11.2 Left-Hand-Side Expressions

	          function parseArguments() {
	            var args = [];
	            expect('(');
	            if (!match(')')) {
	              while (index < length) {
	                args.push(parseAssignmentExpression());
	                if (match(')')) {
	                  break;
	                }
	                expect(',');
	              }
	            }
	            expect(')');
	            return args;
	          }
	          function parseNonComputedProperty() {
	            var token, startToken;
	            startToken = lookahead;
	            token = lex();
	            if (!isIdentifierName(token)) {
	              throwUnexpected(token);
	            }
	            return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
	          }
	          function parseNonComputedMember() {
	            expect('.');
	            return parseNonComputedProperty();
	          }
	          function parseComputedMember() {
	            var expr;
	            expect('[');
	            expr = parseExpression();
	            expect(']');
	            return expr;
	          }
	          function parseNewExpression() {
	            var callee, args, startToken;
	            startToken = lookahead;
	            expectKeyword('new');
	            callee = parseLeftHandSideExpression();
	            args = match('(') ? parseArguments() : [];
	            return delegate.markEnd(delegate.createNewExpression(callee, args), startToken);
	          }
	          function parseLeftHandSideExpressionAllowCall() {
	            var previousAllowIn, expr, args, property, startToken;
	            startToken = lookahead;
	            previousAllowIn = state.allowIn;
	            state.allowIn = true;
	            expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
	            state.allowIn = previousAllowIn;
	            for (;;) {
	              if (match('.')) {
	                property = parseNonComputedMember();
	                expr = delegate.createMemberExpression('.', expr, property);
	              } else if (match('(')) {
	                args = parseArguments();
	                expr = delegate.createCallExpression(expr, args);
	              } else if (match('[')) {
	                property = parseComputedMember();
	                expr = delegate.createMemberExpression('[', expr, property);
	              } else {
	                break;
	              }
	              delegate.markEnd(expr, startToken);
	            }
	            return expr;
	          }
	          function parseLeftHandSideExpression() {
	            var previousAllowIn, expr, property, startToken;
	            startToken = lookahead;
	            previousAllowIn = state.allowIn;
	            expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
	            state.allowIn = previousAllowIn;
	            while (match('.') || match('[')) {
	              if (match('[')) {
	                property = parseComputedMember();
	                expr = delegate.createMemberExpression('[', expr, property);
	              } else {
	                property = parseNonComputedMember();
	                expr = delegate.createMemberExpression('.', expr, property);
	              }
	              delegate.markEnd(expr, startToken);
	            }
	            return expr;
	          }

	          // 11.3 Postfix Expressions

	          function parsePostfixExpression() {
	            var expr,
	              token,
	              startToken = lookahead;
	            expr = parseLeftHandSideExpressionAllowCall();
	            if (lookahead.type === Token.Punctuator) {
	              if ((match('++') || match('--')) && !peekLineTerminator()) {
	                // 11.3.1, 11.3.2
	                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                  throwErrorTolerant({}, Messages.StrictLHSPostfix);
	                }
	                if (!isLeftHandSide(expr)) {
	                  throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
	                }
	                token = lex();
	                expr = delegate.markEnd(delegate.createPostfixExpression(token.value, expr), startToken);
	              }
	            }
	            return expr;
	          }

	          // 11.4 Unary Operators

	          function parseUnaryExpression() {
	            var token, expr, startToken;
	            if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
	              expr = parsePostfixExpression();
	            } else if (match('++') || match('--')) {
	              startToken = lookahead;
	              token = lex();
	              expr = parseUnaryExpression();
	              // 11.4.4, 11.4.5
	              if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                throwErrorTolerant({}, Messages.StrictLHSPrefix);
	              }
	              if (!isLeftHandSide(expr)) {
	                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
	              }
	              expr = delegate.createUnaryExpression(token.value, expr);
	              expr = delegate.markEnd(expr, startToken);
	            } else if (match('+') || match('-') || match('~') || match('!')) {
	              startToken = lookahead;
	              token = lex();
	              expr = parseUnaryExpression();
	              expr = delegate.createUnaryExpression(token.value, expr);
	              expr = delegate.markEnd(expr, startToken);
	            } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
	              startToken = lookahead;
	              token = lex();
	              expr = parseUnaryExpression();
	              expr = delegate.createUnaryExpression(token.value, expr);
	              expr = delegate.markEnd(expr, startToken);
	              if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
	                throwErrorTolerant({}, Messages.StrictDelete);
	              }
	            } else {
	              expr = parsePostfixExpression();
	            }
	            return expr;
	          }
	          function binaryPrecedence(token, allowIn) {
	            var prec = 0;
	            if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
	              return 0;
	            }
	            switch (token.value) {
	              case '||':
	                prec = 1;
	                break;
	              case '&&':
	                prec = 2;
	                break;
	              case '|':
	                prec = 3;
	                break;
	              case '^':
	                prec = 4;
	                break;
	              case '&':
	                prec = 5;
	                break;
	              case '==':
	              case '!=':
	              case '===':
	              case '!==':
	                prec = 6;
	                break;
	              case '<':
	              case '>':
	              case '<=':
	              case '>=':
	              case 'instanceof':
	                prec = 7;
	                break;
	              case 'in':
	                prec = allowIn ? 7 : 0;
	                break;
	              case '<<':
	              case '>>':
	              case '>>>':
	                prec = 8;
	                break;
	              case '+':
	              case '-':
	                prec = 9;
	                break;
	              case '*':
	              case '/':
	              case '%':
	                prec = 11;
	                break;
	            }
	            return prec;
	          }

	          // 11.5 Multiplicative Operators
	          // 11.6 Additive Operators
	          // 11.7 Bitwise Shift Operators
	          // 11.8 Relational Operators
	          // 11.9 Equality Operators
	          // 11.10 Binary Bitwise Operators
	          // 11.11 Binary Logical Operators

	          function parseBinaryExpression() {
	            var marker, markers, expr, token, prec, stack, right, operator, left, i;
	            marker = lookahead;
	            left = parseUnaryExpression();
	            token = lookahead;
	            prec = binaryPrecedence(token, state.allowIn);
	            if (prec === 0) {
	              return left;
	            }
	            token.prec = prec;
	            lex();
	            markers = [marker, lookahead];
	            right = parseUnaryExpression();
	            stack = [left, token, right];
	            while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {
	              // Reduce: make a binary expression from the three topmost entries.
	              while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
	                right = stack.pop();
	                operator = stack.pop().value;
	                left = stack.pop();
	                expr = delegate.createBinaryExpression(operator, left, right);
	                markers.pop();
	                marker = markers[markers.length - 1];
	                delegate.markEnd(expr, marker);
	                stack.push(expr);
	              }

	              // Shift.
	              token = lex();
	              token.prec = prec;
	              stack.push(token);
	              markers.push(lookahead);
	              expr = parseUnaryExpression();
	              stack.push(expr);
	            }

	            // Final reduce to clean-up the stack.
	            i = stack.length - 1;
	            expr = stack[i];
	            markers.pop();
	            while (i > 1) {
	              expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
	              i -= 2;
	              marker = markers.pop();
	              delegate.markEnd(expr, marker);
	            }
	            return expr;
	          }

	          // 11.12 Conditional Operator

	          function parseConditionalExpression() {
	            var expr, previousAllowIn, consequent, alternate, startToken;
	            startToken = lookahead;
	            expr = parseBinaryExpression();
	            if (match('?')) {
	              lex();
	              previousAllowIn = state.allowIn;
	              state.allowIn = true;
	              consequent = parseAssignmentExpression();
	              state.allowIn = previousAllowIn;
	              expect(':');
	              alternate = parseAssignmentExpression();
	              expr = delegate.createConditionalExpression(expr, consequent, alternate);
	              delegate.markEnd(expr, startToken);
	            }
	            return expr;
	          }

	          // 11.13 Assignment Operators

	          function parseAssignmentExpression() {
	            var token, left, right, node, startToken;
	            token = lookahead;
	            startToken = lookahead;
	            node = left = parseConditionalExpression();
	            if (matchAssign()) {
	              // LeftHandSideExpression
	              if (!isLeftHandSide(left)) {
	                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
	              }

	              // 11.13.1
	              if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {
	                throwErrorTolerant(token, Messages.StrictLHSAssignment);
	              }
	              token = lex();
	              right = parseAssignmentExpression();
	              node = delegate.markEnd(delegate.createAssignmentExpression(token.value, left, right), startToken);
	            }
	            return node;
	          }

	          // 11.14 Comma Operator

	          function parseExpression() {
	            var expr,
	              startToken = lookahead;
	            expr = parseAssignmentExpression();
	            if (match(',')) {
	              expr = delegate.createSequenceExpression([expr]);
	              while (index < length) {
	                if (!match(',')) {
	                  break;
	                }
	                lex();
	                expr.expressions.push(parseAssignmentExpression());
	              }
	              delegate.markEnd(expr, startToken);
	            }
	            return expr;
	          }

	          // 12.1 Block

	          function parseStatementList() {
	            var list = [],
	              statement;
	            while (index < length) {
	              if (match('}')) {
	                break;
	              }
	              statement = parseSourceElement();
	              if (typeof statement === 'undefined') {
	                break;
	              }
	              list.push(statement);
	            }
	            return list;
	          }
	          function parseBlock() {
	            var block, startToken;
	            startToken = lookahead;
	            expect('{');
	            block = parseStatementList();
	            expect('}');
	            return delegate.markEnd(delegate.createBlockStatement(block), startToken);
	          }

	          // 12.2 Variable Statement

	          function parseVariableIdentifier() {
	            var token, startToken;
	            startToken = lookahead;
	            token = lex();
	            if (token.type !== Token.Identifier) {
	              throwUnexpected(token);
	            }
	            return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
	          }
	          function parseVariableDeclaration(kind) {
	            var init = null,
	              id,
	              startToken;
	            startToken = lookahead;
	            id = parseVariableIdentifier();

	            // 12.2.1
	            if (strict && isRestrictedWord(id.name)) {
	              throwErrorTolerant({}, Messages.StrictVarName);
	            }
	            if (kind === 'const') {
	              expect('=');
	              init = parseAssignmentExpression();
	            } else if (match('=')) {
	              lex();
	              init = parseAssignmentExpression();
	            }
	            return delegate.markEnd(delegate.createVariableDeclarator(id, init), startToken);
	          }
	          function parseVariableDeclarationList(kind) {
	            var list = [];
	            do {
	              list.push(parseVariableDeclaration(kind));
	              if (!match(',')) {
	                break;
	              }
	              lex();
	            } while (index < length);
	            return list;
	          }
	          function parseVariableStatement() {
	            var declarations;
	            expectKeyword('var');
	            declarations = parseVariableDeclarationList();
	            consumeSemicolon();
	            return delegate.createVariableDeclaration(declarations, 'var');
	          }

	          // kind may be `const` or `let`
	          // Both are experimental and not in the specification yet.
	          // see http://wiki.ecmascript.org/doku.php?id=harmony:const
	          // and http://wiki.ecmascript.org/doku.php?id=harmony:let
	          function parseConstLetDeclaration(kind) {
	            var declarations, startToken;
	            startToken = lookahead;
	            expectKeyword(kind);
	            declarations = parseVariableDeclarationList(kind);
	            consumeSemicolon();
	            return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind), startToken);
	          }

	          // 12.3 Empty Statement

	          function parseEmptyStatement() {
	            expect(';');
	            return delegate.createEmptyStatement();
	          }

	          // 12.4 Expression Statement

	          function parseExpressionStatement() {
	            var expr = parseExpression();
	            consumeSemicolon();
	            return delegate.createExpressionStatement(expr);
	          }

	          // 12.5 If statement

	          function parseIfStatement() {
	            var test, consequent, alternate;
	            expectKeyword('if');
	            expect('(');
	            test = parseExpression();
	            expect(')');
	            consequent = parseStatement();
	            if (matchKeyword('else')) {
	              lex();
	              alternate = parseStatement();
	            } else {
	              alternate = null;
	            }
	            return delegate.createIfStatement(test, consequent, alternate);
	          }

	          // 12.6 Iteration Statements

	          function parseDoWhileStatement() {
	            var body, test, oldInIteration;
	            expectKeyword('do');
	            oldInIteration = state.inIteration;
	            state.inIteration = true;
	            body = parseStatement();
	            state.inIteration = oldInIteration;
	            expectKeyword('while');
	            expect('(');
	            test = parseExpression();
	            expect(')');
	            if (match(';')) {
	              lex();
	            }
	            return delegate.createDoWhileStatement(body, test);
	          }
	          function parseWhileStatement() {
	            var test, body, oldInIteration;
	            expectKeyword('while');
	            expect('(');
	            test = parseExpression();
	            expect(')');
	            oldInIteration = state.inIteration;
	            state.inIteration = true;
	            body = parseStatement();
	            state.inIteration = oldInIteration;
	            return delegate.createWhileStatement(test, body);
	          }
	          function parseForVariableDeclaration() {
	            var token, declarations, startToken;
	            startToken = lookahead;
	            token = lex();
	            declarations = parseVariableDeclarationList();
	            return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value), startToken);
	          }
	          function parseForStatement() {
	            var init, test, update, left, right, body, oldInIteration;
	            init = test = update = null;
	            expectKeyword('for');
	            expect('(');
	            if (match(';')) {
	              lex();
	            } else {
	              if (matchKeyword('var') || matchKeyword('let')) {
	                state.allowIn = false;
	                init = parseForVariableDeclaration();
	                state.allowIn = true;
	                if (init.declarations.length === 1 && matchKeyword('in')) {
	                  lex();
	                  left = init;
	                  right = parseExpression();
	                  init = null;
	                }
	              } else {
	                state.allowIn = false;
	                init = parseExpression();
	                state.allowIn = true;
	                if (matchKeyword('in')) {
	                  // LeftHandSideExpression
	                  if (!isLeftHandSide(init)) {
	                    throwErrorTolerant({}, Messages.InvalidLHSInForIn);
	                  }
	                  lex();
	                  left = init;
	                  right = parseExpression();
	                  init = null;
	                }
	              }
	              if (typeof left === 'undefined') {
	                expect(';');
	              }
	            }
	            if (typeof left === 'undefined') {
	              if (!match(';')) {
	                test = parseExpression();
	              }
	              expect(';');
	              if (!match(')')) {
	                update = parseExpression();
	              }
	            }
	            expect(')');
	            oldInIteration = state.inIteration;
	            state.inIteration = true;
	            body = parseStatement();
	            state.inIteration = oldInIteration;
	            return typeof left === 'undefined' ? delegate.createForStatement(init, test, update, body) : delegate.createForInStatement(left, right, body);
	          }

	          // 12.7 The continue statement

	          function parseContinueStatement() {
	            var label = null,
	              key;
	            expectKeyword('continue');

	            // Optimize the most common form: 'continue;'.
	            if (source.charCodeAt(index) === 0x3B) {
	              lex();
	              if (!state.inIteration) {
	                throwError({}, Messages.IllegalContinue);
	              }
	              return delegate.createContinueStatement(null);
	            }
	            if (peekLineTerminator()) {
	              if (!state.inIteration) {
	                throwError({}, Messages.IllegalContinue);
	              }
	              return delegate.createContinueStatement(null);
	            }
	            if (lookahead.type === Token.Identifier) {
	              label = parseVariableIdentifier();
	              key = '$' + label.name;
	              if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError({}, Messages.UnknownLabel, label.name);
	              }
	            }
	            consumeSemicolon();
	            if (label === null && !state.inIteration) {
	              throwError({}, Messages.IllegalContinue);
	            }
	            return delegate.createContinueStatement(label);
	          }

	          // 12.8 The break statement

	          function parseBreakStatement() {
	            var label = null,
	              key;
	            expectKeyword('break');

	            // Catch the very common case first: immediately a semicolon (U+003B).
	            if (source.charCodeAt(index) === 0x3B) {
	              lex();
	              if (!(state.inIteration || state.inSwitch)) {
	                throwError({}, Messages.IllegalBreak);
	              }
	              return delegate.createBreakStatement(null);
	            }
	            if (peekLineTerminator()) {
	              if (!(state.inIteration || state.inSwitch)) {
	                throwError({}, Messages.IllegalBreak);
	              }
	              return delegate.createBreakStatement(null);
	            }
	            if (lookahead.type === Token.Identifier) {
	              label = parseVariableIdentifier();
	              key = '$' + label.name;
	              if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError({}, Messages.UnknownLabel, label.name);
	              }
	            }
	            consumeSemicolon();
	            if (label === null && !(state.inIteration || state.inSwitch)) {
	              throwError({}, Messages.IllegalBreak);
	            }
	            return delegate.createBreakStatement(label);
	          }

	          // 12.9 The return statement

	          function parseReturnStatement() {
	            var argument = null;
	            expectKeyword('return');
	            if (!state.inFunctionBody) {
	              throwErrorTolerant({}, Messages.IllegalReturn);
	            }

	            // 'return' followed by a space and an identifier is very common.
	            if (source.charCodeAt(index) === 0x20) {
	              if (isIdentifierStart(source.charCodeAt(index + 1))) {
	                argument = parseExpression();
	                consumeSemicolon();
	                return delegate.createReturnStatement(argument);
	              }
	            }
	            if (peekLineTerminator()) {
	              return delegate.createReturnStatement(null);
	            }
	            if (!match(';')) {
	              if (!match('}') && lookahead.type !== Token.EOF) {
	                argument = parseExpression();
	              }
	            }
	            consumeSemicolon();
	            return delegate.createReturnStatement(argument);
	          }

	          // 12.10 The with statement

	          function parseWithStatement() {
	            var object, body;
	            if (strict) {
	              // TODO(ikarienator): Should we update the test cases instead?
	              skipComment();
	              throwErrorTolerant({}, Messages.StrictModeWith);
	            }
	            expectKeyword('with');
	            expect('(');
	            object = parseExpression();
	            expect(')');
	            body = parseStatement();
	            return delegate.createWithStatement(object, body);
	          }

	          // 12.10 The swith statement

	          function parseSwitchCase() {
	            var test,
	              consequent = [],
	              statement,
	              startToken;
	            startToken = lookahead;
	            if (matchKeyword('default')) {
	              lex();
	              test = null;
	            } else {
	              expectKeyword('case');
	              test = parseExpression();
	            }
	            expect(':');
	            while (index < length) {
	              if (match('}') || matchKeyword('default') || matchKeyword('case')) {
	                break;
	              }
	              statement = parseStatement();
	              consequent.push(statement);
	            }
	            return delegate.markEnd(delegate.createSwitchCase(test, consequent), startToken);
	          }
	          function parseSwitchStatement() {
	            var discriminant, cases, clause, oldInSwitch, defaultFound;
	            expectKeyword('switch');
	            expect('(');
	            discriminant = parseExpression();
	            expect(')');
	            expect('{');
	            cases = [];
	            if (match('}')) {
	              lex();
	              return delegate.createSwitchStatement(discriminant, cases);
	            }
	            oldInSwitch = state.inSwitch;
	            state.inSwitch = true;
	            defaultFound = false;
	            while (index < length) {
	              if (match('}')) {
	                break;
	              }
	              clause = parseSwitchCase();
	              if (clause.test === null) {
	                if (defaultFound) {
	                  throwError({}, Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	              }
	              cases.push(clause);
	            }
	            state.inSwitch = oldInSwitch;
	            expect('}');
	            return delegate.createSwitchStatement(discriminant, cases);
	          }

	          // 12.13 The throw statement

	          function parseThrowStatement() {
	            var argument;
	            expectKeyword('throw');
	            if (peekLineTerminator()) {
	              throwError({}, Messages.NewlineAfterThrow);
	            }
	            argument = parseExpression();
	            consumeSemicolon();
	            return delegate.createThrowStatement(argument);
	          }

	          // 12.14 The try statement

	          function parseCatchClause() {
	            var param, body, startToken;
	            startToken = lookahead;
	            expectKeyword('catch');
	            expect('(');
	            if (match(')')) {
	              throwUnexpected(lookahead);
	            }
	            param = parseVariableIdentifier();
	            // 12.14.1
	            if (strict && isRestrictedWord(param.name)) {
	              throwErrorTolerant({}, Messages.StrictCatchVariable);
	            }
	            expect(')');
	            body = parseBlock();
	            return delegate.markEnd(delegate.createCatchClause(param, body), startToken);
	          }
	          function parseTryStatement() {
	            var block,
	              handlers = [],
	              finalizer = null;
	            expectKeyword('try');
	            block = parseBlock();
	            if (matchKeyword('catch')) {
	              handlers.push(parseCatchClause());
	            }
	            if (matchKeyword('finally')) {
	              lex();
	              finalizer = parseBlock();
	            }
	            if (handlers.length === 0 && !finalizer) {
	              throwError({}, Messages.NoCatchOrFinally);
	            }
	            return delegate.createTryStatement(block, [], handlers, finalizer);
	          }

	          // 12.15 The debugger statement

	          function parseDebuggerStatement() {
	            expectKeyword('debugger');
	            consumeSemicolon();
	            return delegate.createDebuggerStatement();
	          }

	          // 12 Statements

	          function parseStatement() {
	            var type = lookahead.type,
	              expr,
	              labeledBody,
	              key,
	              startToken;
	            if (type === Token.EOF) {
	              throwUnexpected(lookahead);
	            }
	            if (type === Token.Punctuator && lookahead.value === '{') {
	              return parseBlock();
	            }
	            startToken = lookahead;
	            if (type === Token.Punctuator) {
	              switch (lookahead.value) {
	                case ';':
	                  return delegate.markEnd(parseEmptyStatement(), startToken);
	                case '(':
	                  return delegate.markEnd(parseExpressionStatement(), startToken);
	              }
	            }
	            if (type === Token.Keyword) {
	              switch (lookahead.value) {
	                case 'break':
	                  return delegate.markEnd(parseBreakStatement(), startToken);
	                case 'continue':
	                  return delegate.markEnd(parseContinueStatement(), startToken);
	                case 'debugger':
	                  return delegate.markEnd(parseDebuggerStatement(), startToken);
	                case 'do':
	                  return delegate.markEnd(parseDoWhileStatement(), startToken);
	                case 'for':
	                  return delegate.markEnd(parseForStatement(), startToken);
	                case 'function':
	                  return delegate.markEnd(parseFunctionDeclaration(), startToken);
	                case 'if':
	                  return delegate.markEnd(parseIfStatement(), startToken);
	                case 'return':
	                  return delegate.markEnd(parseReturnStatement(), startToken);
	                case 'switch':
	                  return delegate.markEnd(parseSwitchStatement(), startToken);
	                case 'throw':
	                  return delegate.markEnd(parseThrowStatement(), startToken);
	                case 'try':
	                  return delegate.markEnd(parseTryStatement(), startToken);
	                case 'var':
	                  return delegate.markEnd(parseVariableStatement(), startToken);
	                case 'while':
	                  return delegate.markEnd(parseWhileStatement(), startToken);
	                case 'with':
	                  return delegate.markEnd(parseWithStatement(), startToken);
	              }
	            }
	            expr = parseExpression();

	            // 12.12 Labelled Statements
	            if (expr.type === Syntax.Identifier && match(':')) {
	              lex();
	              key = '$' + expr.name;
	              if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError({}, Messages.Redeclaration, 'Label', expr.name);
	              }
	              state.labelSet[key] = true;
	              labeledBody = parseStatement();
	              delete state.labelSet[key];
	              return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody), startToken);
	            }
	            consumeSemicolon();
	            return delegate.markEnd(delegate.createExpressionStatement(expr), startToken);
	          }

	          // 13 Function Definition

	          function parseFunctionSourceElements() {
	            var sourceElement,
	              sourceElements = [],
	              token,
	              directive,
	              firstRestricted,
	              oldLabelSet,
	              oldInIteration,
	              oldInSwitch,
	              oldInFunctionBody,
	              startToken;
	            startToken = lookahead;
	            expect('{');
	            while (index < length) {
	              if (lookahead.type !== Token.StringLiteral) {
	                break;
	              }
	              token = lookahead;
	              sourceElement = parseSourceElement();
	              sourceElements.push(sourceElement);
	              if (sourceElement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	              }
	              directive = source.slice(token.start + 1, token.end - 1);
	              if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
	                }
	              } else {
	                if (!firstRestricted && token.octal) {
	                  firstRestricted = token;
	                }
	              }
	            }
	            oldLabelSet = state.labelSet;
	            oldInIteration = state.inIteration;
	            oldInSwitch = state.inSwitch;
	            oldInFunctionBody = state.inFunctionBody;
	            state.labelSet = {};
	            state.inIteration = false;
	            state.inSwitch = false;
	            state.inFunctionBody = true;
	            while (index < length) {
	              if (match('}')) {
	                break;
	              }
	              sourceElement = parseSourceElement();
	              if (typeof sourceElement === 'undefined') {
	                break;
	              }
	              sourceElements.push(sourceElement);
	            }
	            expect('}');
	            state.labelSet = oldLabelSet;
	            state.inIteration = oldInIteration;
	            state.inSwitch = oldInSwitch;
	            state.inFunctionBody = oldInFunctionBody;
	            return delegate.markEnd(delegate.createBlockStatement(sourceElements), startToken);
	          }
	          function parseParams(firstRestricted) {
	            var param,
	              params = [],
	              token,
	              stricted,
	              paramSet,
	              key,
	              message;
	            expect('(');
	            if (!match(')')) {
	              paramSet = {};
	              while (index < length) {
	                token = lookahead;
	                param = parseVariableIdentifier();
	                key = '$' + token.value;
	                if (strict) {
	                  if (isRestrictedWord(token.value)) {
	                    stricted = token;
	                    message = Messages.StrictParamName;
	                  }
	                  if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
	                    stricted = token;
	                    message = Messages.StrictParamDupe;
	                  }
	                } else if (!firstRestricted) {
	                  if (isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictParamName;
	                  } else if (isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictReservedWord;
	                  } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
	                    firstRestricted = token;
	                    message = Messages.StrictParamDupe;
	                  }
	                }
	                params.push(param);
	                paramSet[key] = true;
	                if (match(')')) {
	                  break;
	                }
	                expect(',');
	              }
	            }
	            expect(')');
	            return {
	              params: params,
	              stricted: stricted,
	              firstRestricted: firstRestricted,
	              message: message
	            };
	          }
	          function parseFunctionDeclaration() {
	            var id,
	              params = [],
	              body,
	              token,
	              stricted,
	              tmp,
	              firstRestricted,
	              message,
	              previousStrict,
	              startToken;
	            startToken = lookahead;
	            expectKeyword('function');
	            token = lookahead;
	            id = parseVariableIdentifier();
	            if (strict) {
	              if (isRestrictedWord(token.value)) {
	                throwErrorTolerant(token, Messages.StrictFunctionName);
	              }
	            } else {
	              if (isRestrictedWord(token.value)) {
	                firstRestricted = token;
	                message = Messages.StrictFunctionName;
	              } else if (isStrictModeReservedWord(token.value)) {
	                firstRestricted = token;
	                message = Messages.StrictReservedWord;
	              }
	            }
	            tmp = parseParams(firstRestricted);
	            params = tmp.params;
	            stricted = tmp.stricted;
	            firstRestricted = tmp.firstRestricted;
	            if (tmp.message) {
	              message = tmp.message;
	            }
	            previousStrict = strict;
	            body = parseFunctionSourceElements();
	            if (strict && firstRestricted) {
	              throwError(firstRestricted, message);
	            }
	            if (strict && stricted) {
	              throwErrorTolerant(stricted, message);
	            }
	            strict = previousStrict;
	            return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body), startToken);
	          }
	          function parseFunctionExpression() {
	            var token,
	              id = null,
	              stricted,
	              firstRestricted,
	              message,
	              tmp,
	              params = [],
	              body,
	              previousStrict,
	              startToken;
	            startToken = lookahead;
	            expectKeyword('function');
	            if (!match('(')) {
	              token = lookahead;
	              id = parseVariableIdentifier();
	              if (strict) {
	                if (isRestrictedWord(token.value)) {
	                  throwErrorTolerant(token, Messages.StrictFunctionName);
	                }
	              } else {
	                if (isRestrictedWord(token.value)) {
	                  firstRestricted = token;
	                  message = Messages.StrictFunctionName;
	                } else if (isStrictModeReservedWord(token.value)) {
	                  firstRestricted = token;
	                  message = Messages.StrictReservedWord;
	                }
	              }
	            }
	            tmp = parseParams(firstRestricted);
	            params = tmp.params;
	            stricted = tmp.stricted;
	            firstRestricted = tmp.firstRestricted;
	            if (tmp.message) {
	              message = tmp.message;
	            }
	            previousStrict = strict;
	            body = parseFunctionSourceElements();
	            if (strict && firstRestricted) {
	              throwError(firstRestricted, message);
	            }
	            if (strict && stricted) {
	              throwErrorTolerant(stricted, message);
	            }
	            strict = previousStrict;
	            return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body), startToken);
	          }

	          // 14 Program

	          function parseSourceElement() {
	            if (lookahead.type === Token.Keyword) {
	              switch (lookahead.value) {
	                case 'const':
	                case 'let':
	                  return parseConstLetDeclaration(lookahead.value);
	                case 'function':
	                  return parseFunctionDeclaration();
	                default:
	                  return parseStatement();
	              }
	            }
	            if (lookahead.type !== Token.EOF) {
	              return parseStatement();
	            }
	          }
	          function parseSourceElements() {
	            var sourceElement,
	              sourceElements = [],
	              token,
	              directive,
	              firstRestricted;
	            while (index < length) {
	              token = lookahead;
	              if (token.type !== Token.StringLiteral) {
	                break;
	              }
	              sourceElement = parseSourceElement();
	              sourceElements.push(sourceElement);
	              if (sourceElement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	              }
	              directive = source.slice(token.start + 1, token.end - 1);
	              if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
	                }
	              } else {
	                if (!firstRestricted && token.octal) {
	                  firstRestricted = token;
	                }
	              }
	            }
	            while (index < length) {
	              sourceElement = parseSourceElement();
	              /* istanbul ignore if */
	              if (typeof sourceElement === 'undefined') {
	                break;
	              }
	              sourceElements.push(sourceElement);
	            }
	            return sourceElements;
	          }
	          function parseProgram() {
	            var body, startToken;
	            skipComment();
	            peek();
	            startToken = lookahead;
	            strict = false;
	            body = parseSourceElements();
	            return delegate.markEnd(delegate.createProgram(body), startToken);
	          }
	          function filterTokenLocation() {
	            var i,
	              entry,
	              token,
	              tokens = [];
	            for (i = 0; i < extra.tokens.length; ++i) {
	              entry = extra.tokens[i];
	              token = {
	                type: entry.type,
	                value: entry.value
	              };
	              if (extra.range) {
	                token.range = entry.range;
	              }
	              if (extra.loc) {
	                token.loc = entry.loc;
	              }
	              tokens.push(token);
	            }
	            extra.tokens = tokens;
	          }
	          function tokenize(code, options) {
	            var toString, token, tokens;
	            toString = String;
	            if (typeof code !== 'string' && !(code instanceof String)) {
	              code = toString(code);
	            }
	            delegate = SyntaxTreeDelegate;
	            source = code;
	            index = 0;
	            lineNumber = source.length > 0 ? 1 : 0;
	            lineStart = 0;
	            length = source.length;
	            lookahead = null;
	            state = {
	              allowIn: true,
	              labelSet: {},
	              inFunctionBody: false,
	              inIteration: false,
	              inSwitch: false,
	              lastCommentStart: -1
	            };
	            extra = {};

	            // Options matching.
	            options = options || {};

	            // Of course we collect tokens here.
	            options.tokens = true;
	            extra.tokens = [];
	            extra.tokenize = true;
	            // The following two fields are necessary to compute the Regex tokens.
	            extra.openParenToken = -1;
	            extra.openCurlyToken = -1;
	            extra.range = typeof options.range === 'boolean' && options.range;
	            extra.loc = typeof options.loc === 'boolean' && options.loc;
	            if (typeof options.comment === 'boolean' && options.comment) {
	              extra.comments = [];
	            }
	            if (typeof options.tolerant === 'boolean' && options.tolerant) {
	              extra.errors = [];
	            }
	            try {
	              peek();
	              if (lookahead.type === Token.EOF) {
	                return extra.tokens;
	              }
	              token = lex();
	              while (lookahead.type !== Token.EOF) {
	                try {
	                  token = lex();
	                } catch (lexError) {
	                  token = lookahead;
	                  if (extra.errors) {
	                    extra.errors.push(lexError);
	                    // We have to break on the first error
	                    // to avoid infinite loops.
	                    break;
	                  } else {
	                    throw lexError;
	                  }
	                }
	              }
	              filterTokenLocation();
	              tokens = extra.tokens;
	              if (typeof extra.comments !== 'undefined') {
	                tokens.comments = extra.comments;
	              }
	              if (typeof extra.errors !== 'undefined') {
	                tokens.errors = extra.errors;
	              }
	            } catch (e) {
	              throw e;
	            } finally {
	              extra = {};
	            }
	            return tokens;
	          }
	          function parse(code, options) {
	            var program, toString;
	            toString = String;
	            if (typeof code !== 'string' && !(code instanceof String)) {
	              code = toString(code);
	            }
	            delegate = SyntaxTreeDelegate;
	            source = code;
	            index = 0;
	            lineNumber = source.length > 0 ? 1 : 0;
	            lineStart = 0;
	            length = source.length;
	            lookahead = null;
	            state = {
	              allowIn: true,
	              labelSet: {},
	              inFunctionBody: false,
	              inIteration: false,
	              inSwitch: false,
	              lastCommentStart: -1
	            };
	            extra = {};
	            if (typeof options !== 'undefined') {
	              extra.range = typeof options.range === 'boolean' && options.range;
	              extra.loc = typeof options.loc === 'boolean' && options.loc;
	              extra.attachComment = typeof options.attachComment === 'boolean' && options.attachComment;
	              if (extra.loc && options.source !== null && options.source !== undefined) {
	                extra.source = toString(options.source);
	              }
	              if (typeof options.tokens === 'boolean' && options.tokens) {
	                extra.tokens = [];
	              }
	              if (typeof options.comment === 'boolean' && options.comment) {
	                extra.comments = [];
	              }
	              if (typeof options.tolerant === 'boolean' && options.tolerant) {
	                extra.errors = [];
	              }
	              if (extra.attachComment) {
	                extra.range = true;
	                extra.comments = [];
	                extra.bottomRightStack = [];
	                extra.trailingComments = [];
	                extra.leadingComments = [];
	              }
	            }
	            try {
	              program = parseProgram();
	              if (typeof extra.comments !== 'undefined') {
	                program.comments = extra.comments;
	              }
	              if (typeof extra.tokens !== 'undefined') {
	                filterTokenLocation();
	                program.tokens = extra.tokens;
	              }
	              if (typeof extra.errors !== 'undefined') {
	                program.errors = extra.errors;
	              }
	            } catch (e) {
	              throw e;
	            } finally {
	              extra = {};
	            }
	            return program;
	          }

	          // Sync with *.json manifests.
	          exports.version = '1.2.2';
	          exports.tokenize = tokenize;
	          exports.parse = parse;

	          // Deep copy.
	          /* istanbul ignore next */
	          exports.Syntax = function () {
	            var name,
	              types = {};
	            if (typeof Object.create === 'function') {
	              types = Object.create(null);
	            }
	            for (name in Syntax) {
	              if (Syntax.hasOwnProperty(name)) {
	                types[name] = Syntax[name];
	              }
	            }
	            if (typeof Object.freeze === 'function') {
	              Object.freeze(types);
	            }
	            return types;
	          }();
	        });
	        /* vim: set sw=4 ts=4 et tw=80 : */
	      }, {}],
	      1: [function (require, module, exports) {
	        (function (process) {
	          /* parser generated by jison 0.4.13 */
	          /*
	            Returns a Parser object of the following structure:
	          
	            Parser: {
	              yy: {}
	            }
	          
	            Parser.prototype: {
	              yy: {},
	              trace: function(),
	              symbols_: {associative list: name ==> number},
	              terminals_: {associative list: number ==> name},
	              productions_: [...],
	              performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
	              table: [...],
	              defaultActions: {...},
	              parseError: function(str, hash),
	              parse: function(input),
	          
	              lexer: {
	                  EOF: 1,
	                  parseError: function(str, hash),
	                  setInput: function(input),
	                  input: function(),
	                  unput: function(str),
	                  more: function(),
	                  less: function(n),
	                  pastInput: function(),
	                  upcomingInput: function(),
	                  showPosition: function(),
	                  test_match: function(regex_match_array, rule_index),
	                  next: function(),
	                  lex: function(),
	                  begin: function(condition),
	                  popState: function(),
	                  _currentRules: function(),
	                  topState: function(),
	                  pushState: function(condition),
	          
	                  options: {
	                      ranges: boolean           (optional: true ==> token location info will include a .range[] member)
	                      flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
	                      backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
	                  },
	          
	                  performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
	                  rules: [...],
	                  conditions: {associative list: name ==> set},
	              }
	            }
	          
	          
	            token location info (@$, _$, etc.): {
	              first_line: n,
	              last_line: n,
	              first_column: n,
	              last_column: n,
	              range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
	            }
	          
	          
	            the parseError function receives a 'hash' object with these members for lexer and parser errors: {
	              text:        (matched text)
	              token:       (the produced terminal token, if any)
	              line:        (yylineno)
	            }
	            while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
	              loc:         (yylloc)
	              expected:    (string describing the set of expected tokens)
	              recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
	            }
	          */
	          var parser = function () {
	            var parser = {
	              trace: function trace() {},
	              yy: {},
	              symbols_: {
	                "error": 2,
	                "JSON_PATH": 3,
	                "DOLLAR": 4,
	                "PATH_COMPONENTS": 5,
	                "LEADING_CHILD_MEMBER_EXPRESSION": 6,
	                "PATH_COMPONENT": 7,
	                "MEMBER_COMPONENT": 8,
	                "SUBSCRIPT_COMPONENT": 9,
	                "CHILD_MEMBER_COMPONENT": 10,
	                "DESCENDANT_MEMBER_COMPONENT": 11,
	                "DOT": 12,
	                "MEMBER_EXPRESSION": 13,
	                "DOT_DOT": 14,
	                "STAR": 15,
	                "IDENTIFIER": 16,
	                "SCRIPT_EXPRESSION": 17,
	                "INTEGER": 18,
	                "END": 19,
	                "CHILD_SUBSCRIPT_COMPONENT": 20,
	                "DESCENDANT_SUBSCRIPT_COMPONENT": 21,
	                "[": 22,
	                "SUBSCRIPT": 23,
	                "]": 24,
	                "SUBSCRIPT_EXPRESSION": 25,
	                "SUBSCRIPT_EXPRESSION_LIST": 26,
	                "SUBSCRIPT_EXPRESSION_LISTABLE": 27,
	                ",": 28,
	                "STRING_LITERAL": 29,
	                "ARRAY_SLICE": 30,
	                "FILTER_EXPRESSION": 31,
	                "QQ_STRING": 32,
	                "Q_STRING": 33,
	                "$accept": 0,
	                "$end": 1
	              },
	              terminals_: {
	                2: "error",
	                4: "DOLLAR",
	                12: "DOT",
	                14: "DOT_DOT",
	                15: "STAR",
	                16: "IDENTIFIER",
	                17: "SCRIPT_EXPRESSION",
	                18: "INTEGER",
	                19: "END",
	                22: "[",
	                24: "]",
	                28: ",",
	                30: "ARRAY_SLICE",
	                31: "FILTER_EXPRESSION",
	                32: "QQ_STRING",
	                33: "Q_STRING"
	              },
	              productions_: [0, [3, 1], [3, 2], [3, 1], [3, 2], [5, 1], [5, 2], [7, 1], [7, 1], [8, 1], [8, 1], [10, 2], [6, 1], [11, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [9, 1], [9, 1], [20, 3], [21, 4], [23, 1], [23, 1], [26, 1], [26, 3], [27, 1], [27, 1], [27, 1], [25, 1], [25, 1], [25, 1], [29, 1], [29, 1]],
	              performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */
	              /**/) {
	                /* this == yyval */
	                if (!yy.ast) {
	                  yy.ast = _ast;
	                  _ast.initialize();
	                }
	                var $0 = $$.length - 1;
	                switch (yystate) {
	                  case 1:
	                    yy.ast.set({
	                      expression: {
	                        type: "root",
	                        value: $$[$0]
	                      }
	                    });
	                    yy.ast.unshift();
	                    return yy.ast["yield"]();
	                  case 2:
	                    yy.ast.set({
	                      expression: {
	                        type: "root",
	                        value: $$[$0 - 1]
	                      }
	                    });
	                    yy.ast.unshift();
	                    return yy.ast["yield"]();
	                  case 3:
	                    yy.ast.unshift();
	                    return yy.ast["yield"]();
	                  case 4:
	                    yy.ast.set({
	                      operation: "member",
	                      scope: "child",
	                      expression: {
	                        type: "identifier",
	                        value: $$[$0 - 1]
	                      }
	                    });
	                    yy.ast.unshift();
	                    return yy.ast["yield"]();
	                  case 5:
	                    break;
	                  case 6:
	                    break;
	                  case 7:
	                    yy.ast.set({
	                      operation: "member"
	                    });
	                    yy.ast.push();
	                    break;
	                  case 8:
	                    yy.ast.set({
	                      operation: "subscript"
	                    });
	                    yy.ast.push();
	                    break;
	                  case 9:
	                    yy.ast.set({
	                      scope: "child"
	                    });
	                    break;
	                  case 10:
	                    yy.ast.set({
	                      scope: "descendant"
	                    });
	                    break;
	                  case 11:
	                    break;
	                  case 12:
	                    yy.ast.set({
	                      scope: "child",
	                      operation: "member"
	                    });
	                    break;
	                  case 13:
	                    break;
	                  case 14:
	                    yy.ast.set({
	                      expression: {
	                        type: "wildcard",
	                        value: $$[$0]
	                      }
	                    });
	                    break;
	                  case 15:
	                    yy.ast.set({
	                      expression: {
	                        type: "identifier",
	                        value: $$[$0]
	                      }
	                    });
	                    break;
	                  case 16:
	                    yy.ast.set({
	                      expression: {
	                        type: "script_expression",
	                        value: $$[$0]
	                      }
	                    });
	                    break;
	                  case 17:
	                    yy.ast.set({
	                      expression: {
	                        type: "numeric_literal",
	                        value: parseInt($$[$0])
	                      }
	                    });
	                    break;
	                  case 18:
	                    break;
	                  case 19:
	                    yy.ast.set({
	                      scope: "child"
	                    });
	                    break;
	                  case 20:
	                    yy.ast.set({
	                      scope: "descendant"
	                    });
	                    break;
	                  case 21:
	                    break;
	                  case 22:
	                    break;
	                  case 23:
	                    break;
	                  case 24:
	                    $$[$0].length > 1 ? yy.ast.set({
	                      expression: {
	                        type: "union",
	                        value: $$[$0]
	                      }
	                    }) : this.$ = $$[$0];
	                    break;
	                  case 25:
	                    this.$ = [$$[$0]];
	                    break;
	                  case 26:
	                    this.$ = $$[$0 - 2].concat($$[$0]);
	                    break;
	                  case 27:
	                    this.$ = {
	                      expression: {
	                        type: "numeric_literal",
	                        value: parseInt($$[$0])
	                      }
	                    };
	                    yy.ast.set(this.$);
	                    break;
	                  case 28:
	                    this.$ = {
	                      expression: {
	                        type: "string_literal",
	                        value: $$[$0]
	                      }
	                    };
	                    yy.ast.set(this.$);
	                    break;
	                  case 29:
	                    this.$ = {
	                      expression: {
	                        type: "slice",
	                        value: $$[$0]
	                      }
	                    };
	                    yy.ast.set(this.$);
	                    break;
	                  case 30:
	                    this.$ = {
	                      expression: {
	                        type: "wildcard",
	                        value: $$[$0]
	                      }
	                    };
	                    yy.ast.set(this.$);
	                    break;
	                  case 31:
	                    this.$ = {
	                      expression: {
	                        type: "script_expression",
	                        value: $$[$0]
	                      }
	                    };
	                    yy.ast.set(this.$);
	                    break;
	                  case 32:
	                    this.$ = {
	                      expression: {
	                        type: "filter_expression",
	                        value: $$[$0]
	                      }
	                    };
	                    yy.ast.set(this.$);
	                    break;
	                  case 33:
	                    this.$ = $$[$0];
	                    break;
	                  case 34:
	                    this.$ = $$[$0];
	                    break;
	                }
	              },
	              table: [{
	                3: 1,
	                4: [1, 2],
	                6: 3,
	                13: 4,
	                15: [1, 5],
	                16: [1, 6],
	                17: [1, 7],
	                18: [1, 8],
	                19: [1, 9]
	              }, {
	                1: [3]
	              }, {
	                1: [2, 1],
	                5: 10,
	                7: 11,
	                8: 12,
	                9: 13,
	                10: 14,
	                11: 15,
	                12: [1, 18],
	                14: [1, 19],
	                20: 16,
	                21: 17,
	                22: [1, 20]
	              }, {
	                1: [2, 3],
	                5: 21,
	                7: 11,
	                8: 12,
	                9: 13,
	                10: 14,
	                11: 15,
	                12: [1, 18],
	                14: [1, 19],
	                20: 16,
	                21: 17,
	                22: [1, 20]
	              }, {
	                1: [2, 12],
	                12: [2, 12],
	                14: [2, 12],
	                22: [2, 12]
	              }, {
	                1: [2, 14],
	                12: [2, 14],
	                14: [2, 14],
	                22: [2, 14]
	              }, {
	                1: [2, 15],
	                12: [2, 15],
	                14: [2, 15],
	                22: [2, 15]
	              }, {
	                1: [2, 16],
	                12: [2, 16],
	                14: [2, 16],
	                22: [2, 16]
	              }, {
	                1: [2, 17],
	                12: [2, 17],
	                14: [2, 17],
	                22: [2, 17]
	              }, {
	                1: [2, 18],
	                12: [2, 18],
	                14: [2, 18],
	                22: [2, 18]
	              }, {
	                1: [2, 2],
	                7: 22,
	                8: 12,
	                9: 13,
	                10: 14,
	                11: 15,
	                12: [1, 18],
	                14: [1, 19],
	                20: 16,
	                21: 17,
	                22: [1, 20]
	              }, {
	                1: [2, 5],
	                12: [2, 5],
	                14: [2, 5],
	                22: [2, 5]
	              }, {
	                1: [2, 7],
	                12: [2, 7],
	                14: [2, 7],
	                22: [2, 7]
	              }, {
	                1: [2, 8],
	                12: [2, 8],
	                14: [2, 8],
	                22: [2, 8]
	              }, {
	                1: [2, 9],
	                12: [2, 9],
	                14: [2, 9],
	                22: [2, 9]
	              }, {
	                1: [2, 10],
	                12: [2, 10],
	                14: [2, 10],
	                22: [2, 10]
	              }, {
	                1: [2, 19],
	                12: [2, 19],
	                14: [2, 19],
	                22: [2, 19]
	              }, {
	                1: [2, 20],
	                12: [2, 20],
	                14: [2, 20],
	                22: [2, 20]
	              }, {
	                13: 23,
	                15: [1, 5],
	                16: [1, 6],
	                17: [1, 7],
	                18: [1, 8],
	                19: [1, 9]
	              }, {
	                13: 24,
	                15: [1, 5],
	                16: [1, 6],
	                17: [1, 7],
	                18: [1, 8],
	                19: [1, 9],
	                22: [1, 25]
	              }, {
	                15: [1, 29],
	                17: [1, 30],
	                18: [1, 33],
	                23: 26,
	                25: 27,
	                26: 28,
	                27: 32,
	                29: 34,
	                30: [1, 35],
	                31: [1, 31],
	                32: [1, 36],
	                33: [1, 37]
	              }, {
	                1: [2, 4],
	                7: 22,
	                8: 12,
	                9: 13,
	                10: 14,
	                11: 15,
	                12: [1, 18],
	                14: [1, 19],
	                20: 16,
	                21: 17,
	                22: [1, 20]
	              }, {
	                1: [2, 6],
	                12: [2, 6],
	                14: [2, 6],
	                22: [2, 6]
	              }, {
	                1: [2, 11],
	                12: [2, 11],
	                14: [2, 11],
	                22: [2, 11]
	              }, {
	                1: [2, 13],
	                12: [2, 13],
	                14: [2, 13],
	                22: [2, 13]
	              }, {
	                15: [1, 29],
	                17: [1, 30],
	                18: [1, 33],
	                23: 38,
	                25: 27,
	                26: 28,
	                27: 32,
	                29: 34,
	                30: [1, 35],
	                31: [1, 31],
	                32: [1, 36],
	                33: [1, 37]
	              }, {
	                24: [1, 39]
	              }, {
	                24: [2, 23]
	              }, {
	                24: [2, 24],
	                28: [1, 40]
	              }, {
	                24: [2, 30]
	              }, {
	                24: [2, 31]
	              }, {
	                24: [2, 32]
	              }, {
	                24: [2, 25],
	                28: [2, 25]
	              }, {
	                24: [2, 27],
	                28: [2, 27]
	              }, {
	                24: [2, 28],
	                28: [2, 28]
	              }, {
	                24: [2, 29],
	                28: [2, 29]
	              }, {
	                24: [2, 33],
	                28: [2, 33]
	              }, {
	                24: [2, 34],
	                28: [2, 34]
	              }, {
	                24: [1, 41]
	              }, {
	                1: [2, 21],
	                12: [2, 21],
	                14: [2, 21],
	                22: [2, 21]
	              }, {
	                18: [1, 33],
	                27: 42,
	                29: 34,
	                30: [1, 35],
	                32: [1, 36],
	                33: [1, 37]
	              }, {
	                1: [2, 22],
	                12: [2, 22],
	                14: [2, 22],
	                22: [2, 22]
	              }, {
	                24: [2, 26],
	                28: [2, 26]
	              }],
	              defaultActions: {
	                27: [2, 23],
	                29: [2, 30],
	                30: [2, 31],
	                31: [2, 32]
	              },
	              parseError: function parseError(str, hash) {
	                if (hash.recoverable) {
	                  this.trace(str);
	                } else {
	                  throw new Error(str);
	                }
	              },
	              parse: function parse(input) {
	                var self = this,
	                  stack = [0],
	                  vstack = [null],
	                  lstack = [],
	                  table = this.table,
	                  yytext = '',
	                  yylineno = 0,
	                  yyleng = 0,
	                  TERROR = 2,
	                  EOF = 1;
	                var args = lstack.slice.call(arguments, 1);
	                this.lexer.setInput(input);
	                this.lexer.yy = this.yy;
	                this.yy.lexer = this.lexer;
	                this.yy.parser = this;
	                if (typeof this.lexer.yylloc == 'undefined') {
	                  this.lexer.yylloc = {};
	                }
	                var yyloc = this.lexer.yylloc;
	                lstack.push(yyloc);
	                var ranges = this.lexer.options && this.lexer.options.ranges;
	                if (typeof this.yy.parseError === 'function') {
	                  this.parseError = this.yy.parseError;
	                } else {
	                  this.parseError = Object.getPrototypeOf(this).parseError;
	                }
	                function lex() {
	                  var token;
	                  token = self.lexer.lex() || EOF;
	                  if (typeof token !== 'number') {
	                    token = self.symbols_[token] || token;
	                  }
	                  return token;
	                }
	                var symbol,
	                  state,
	                  action,
	                  r,
	                  yyval = {},
	                  p,
	                  len,
	                  newState,
	                  expected;
	                while (true) {
	                  state = stack[stack.length - 1];
	                  if (this.defaultActions[state]) {
	                    action = this.defaultActions[state];
	                  } else {
	                    if (symbol === null || typeof symbol == 'undefined') {
	                      symbol = lex();
	                    }
	                    action = table[state] && table[state][symbol];
	                  }
	                  if (typeof action === 'undefined' || !action.length || !action[0]) {
	                    var errStr = '';
	                    expected = [];
	                    for (p in table[state]) {
	                      if (this.terminals_[p] && p > TERROR) {
	                        expected.push('\'' + this.terminals_[p] + '\'');
	                      }
	                    }
	                    if (this.lexer.showPosition) {
	                      errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + this.lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
	                    } else {
	                      errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
	                    }
	                    this.parseError(errStr, {
	                      text: this.lexer.match,
	                      token: this.terminals_[symbol] || symbol,
	                      line: this.lexer.yylineno,
	                      loc: yyloc,
	                      expected: expected
	                    });
	                  }
	                  if (action[0] instanceof Array && action.length > 1) {
	                    throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
	                  }
	                  switch (action[0]) {
	                    case 1:
	                      stack.push(symbol);
	                      vstack.push(this.lexer.yytext);
	                      lstack.push(this.lexer.yylloc);
	                      stack.push(action[1]);
	                      symbol = null;
	                      {
	                        yyleng = this.lexer.yyleng;
	                        yytext = this.lexer.yytext;
	                        yylineno = this.lexer.yylineno;
	                        yyloc = this.lexer.yylloc;
	                      }
	                      break;
	                    case 2:
	                      len = this.productions_[action[1]][1];
	                      yyval.$ = vstack[vstack.length - len];
	                      yyval._$ = {
	                        first_line: lstack[lstack.length - (len || 1)].first_line,
	                        last_line: lstack[lstack.length - 1].last_line,
	                        first_column: lstack[lstack.length - (len || 1)].first_column,
	                        last_column: lstack[lstack.length - 1].last_column
	                      };
	                      if (ranges) {
	                        yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
	                      }
	                      r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack].concat(args));
	                      if (typeof r !== 'undefined') {
	                        return r;
	                      }
	                      if (len) {
	                        stack = stack.slice(0, -1 * len * 2);
	                        vstack = vstack.slice(0, -1 * len);
	                        lstack = lstack.slice(0, -1 * len);
	                      }
	                      stack.push(this.productions_[action[1]][0]);
	                      vstack.push(yyval.$);
	                      lstack.push(yyval._$);
	                      newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
	                      stack.push(newState);
	                      break;
	                    case 3:
	                      return true;
	                  }
	                }
	                return true;
	              }
	            };
	            var _ast = {
	              initialize: function initialize() {
	                this._nodes = [];
	                this._node = {};
	                this._stash = [];
	              },
	              set: function set(props) {
	                for (var k in props) this._node[k] = props[k];
	                return this._node;
	              },
	              node: function node(obj) {
	                if (arguments.length) this._node = obj;
	                return this._node;
	              },
	              push: function push() {
	                this._nodes.push(this._node);
	                this._node = {};
	              },
	              unshift: function unshift() {
	                this._nodes.unshift(this._node);
	                this._node = {};
	              },
	              "yield": function _yield() {
	                var _nodes = this._nodes;
	                this.initialize();
	                return _nodes;
	              }
	            };
	            /* generated by jison-lex 0.2.1 */
	            var lexer = function () {
	              var lexer = {
	                EOF: 1,
	                parseError: function parseError(str, hash) {
	                  if (this.yy.parser) {
	                    this.yy.parser.parseError(str, hash);
	                  } else {
	                    throw new Error(str);
	                  }
	                },
	                // resets the lexer, sets new input
	                setInput: function setInput(input) {
	                  this._input = input;
	                  this._more = this._backtrack = this.done = false;
	                  this.yylineno = this.yyleng = 0;
	                  this.yytext = this.matched = this.match = '';
	                  this.conditionStack = ['INITIAL'];
	                  this.yylloc = {
	                    first_line: 1,
	                    first_column: 0,
	                    last_line: 1,
	                    last_column: 0
	                  };
	                  if (this.options.ranges) {
	                    this.yylloc.range = [0, 0];
	                  }
	                  this.offset = 0;
	                  return this;
	                },
	                // consumes and returns one char from the input
	                input: function input() {
	                  var ch = this._input[0];
	                  this.yytext += ch;
	                  this.yyleng++;
	                  this.offset++;
	                  this.match += ch;
	                  this.matched += ch;
	                  var lines = ch.match(/(?:\r\n?|\n).*/g);
	                  if (lines) {
	                    this.yylineno++;
	                    this.yylloc.last_line++;
	                  } else {
	                    this.yylloc.last_column++;
	                  }
	                  if (this.options.ranges) {
	                    this.yylloc.range[1]++;
	                  }
	                  this._input = this._input.slice(1);
	                  return ch;
	                },
	                // unshifts one char (or a string) into the input
	                unput: function unput(ch) {
	                  var len = ch.length;
	                  var lines = ch.split(/(?:\r\n?|\n)/g);
	                  this._input = ch + this._input;
	                  this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
	                  //this.yyleng -= len;
	                  this.offset -= len;
	                  var oldLines = this.match.split(/(?:\r\n?|\n)/g);
	                  this.match = this.match.substr(0, this.match.length - 1);
	                  this.matched = this.matched.substr(0, this.matched.length - 1);
	                  if (lines.length - 1) {
	                    this.yylineno -= lines.length - 1;
	                  }
	                  var r = this.yylloc.range;
	                  this.yylloc = {
	                    first_line: this.yylloc.first_line,
	                    last_line: this.yylineno + 1,
	                    first_column: this.yylloc.first_column,
	                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
	                  };
	                  if (this.options.ranges) {
	                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
	                  }
	                  this.yyleng = this.yytext.length;
	                  return this;
	                },
	                // When called from action, caches matched text and appends it on next action
	                more: function more() {
	                  this._more = true;
	                  return this;
	                },
	                // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
	                reject: function reject() {
	                  if (this.options.backtrack_lexer) {
	                    this._backtrack = true;
	                  } else {
	                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
	                      text: "",
	                      token: null,
	                      line: this.yylineno
	                    });
	                  }
	                  return this;
	                },
	                // retain first n characters of the match
	                less: function less(n) {
	                  this.unput(this.match.slice(n));
	                },
	                // displays already matched input, i.e. for error messages
	                pastInput: function pastInput() {
	                  var past = this.matched.substr(0, this.matched.length - this.match.length);
	                  return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
	                },
	                // displays upcoming input, i.e. for error messages
	                upcomingInput: function upcomingInput() {
	                  var next = this.match;
	                  if (next.length < 20) {
	                    next += this._input.substr(0, 20 - next.length);
	                  }
	                  return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
	                },
	                // displays the character position where the lexing error occurred, i.e. for error messages
	                showPosition: function showPosition() {
	                  var pre = this.pastInput();
	                  var c = new Array(pre.length + 1).join("-");
	                  return pre + this.upcomingInput() + "\n" + c + "^";
	                },
	                // test the lexed token: return FALSE when not a match, otherwise return token
	                test_match: function test_match(match, indexed_rule) {
	                  var token, lines, backup;
	                  if (this.options.backtrack_lexer) {
	                    // save context
	                    backup = {
	                      yylineno: this.yylineno,
	                      yylloc: {
	                        first_line: this.yylloc.first_line,
	                        last_line: this.last_line,
	                        first_column: this.yylloc.first_column,
	                        last_column: this.yylloc.last_column
	                      },
	                      yytext: this.yytext,
	                      match: this.match,
	                      matches: this.matches,
	                      matched: this.matched,
	                      yyleng: this.yyleng,
	                      offset: this.offset,
	                      _more: this._more,
	                      _input: this._input,
	                      yy: this.yy,
	                      conditionStack: this.conditionStack.slice(0),
	                      done: this.done
	                    };
	                    if (this.options.ranges) {
	                      backup.yylloc.range = this.yylloc.range.slice(0);
	                    }
	                  }
	                  lines = match[0].match(/(?:\r\n?|\n).*/g);
	                  if (lines) {
	                    this.yylineno += lines.length;
	                  }
	                  this.yylloc = {
	                    first_line: this.yylloc.last_line,
	                    last_line: this.yylineno + 1,
	                    first_column: this.yylloc.last_column,
	                    last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
	                  };
	                  this.yytext += match[0];
	                  this.match += match[0];
	                  this.matches = match;
	                  this.yyleng = this.yytext.length;
	                  if (this.options.ranges) {
	                    this.yylloc.range = [this.offset, this.offset += this.yyleng];
	                  }
	                  this._more = false;
	                  this._backtrack = false;
	                  this._input = this._input.slice(match[0].length);
	                  this.matched += match[0];
	                  token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
	                  if (this.done && this._input) {
	                    this.done = false;
	                  }
	                  if (token) {
	                    return token;
	                  } else if (this._backtrack) {
	                    // recover context
	                    for (var k in backup) {
	                      this[k] = backup[k];
	                    }
	                    return false; // rule action called reject() implying the next rule should be tested instead.
	                  }

	                  return false;
	                },
	                // return next match in input
	                next: function next() {
	                  if (this.done) {
	                    return this.EOF;
	                  }
	                  if (!this._input) {
	                    this.done = true;
	                  }
	                  var token, match, tempMatch, index;
	                  if (!this._more) {
	                    this.yytext = '';
	                    this.match = '';
	                  }
	                  var rules = this._currentRules();
	                  for (var i = 0; i < rules.length; i++) {
	                    tempMatch = this._input.match(this.rules[rules[i]]);
	                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
	                      match = tempMatch;
	                      index = i;
	                      if (this.options.backtrack_lexer) {
	                        token = this.test_match(tempMatch, rules[i]);
	                        if (token !== false) {
	                          return token;
	                        } else if (this._backtrack) {
	                          match = false;
	                          continue; // rule action called reject() implying a rule MISmatch.
	                        } else {
	                          // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
	                          return false;
	                        }
	                      } else if (!this.options.flex) {
	                        break;
	                      }
	                    }
	                  }
	                  if (match) {
	                    token = this.test_match(match, rules[index]);
	                    if (token !== false) {
	                      return token;
	                    }
	                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
	                    return false;
	                  }
	                  if (this._input === "") {
	                    return this.EOF;
	                  } else {
	                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
	                      text: "",
	                      token: null,
	                      line: this.yylineno
	                    });
	                  }
	                },
	                // return next match that has a token
	                lex: function lex() {
	                  var r = this.next();
	                  if (r) {
	                    return r;
	                  } else {
	                    return this.lex();
	                  }
	                },
	                // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
	                begin: function begin(condition) {
	                  this.conditionStack.push(condition);
	                },
	                // pop the previously active lexer condition state off the condition stack
	                popState: function popState() {
	                  var n = this.conditionStack.length - 1;
	                  if (n > 0) {
	                    return this.conditionStack.pop();
	                  } else {
	                    return this.conditionStack[0];
	                  }
	                },
	                // produce the lexer rule set which is active for the currently active lexer condition state
	                _currentRules: function _currentRules() {
	                  if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
	                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
	                  } else {
	                    return this.conditions["INITIAL"].rules;
	                  }
	                },
	                // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
	                topState: function topState(n) {
	                  n = this.conditionStack.length - 1 - Math.abs(n || 0);
	                  if (n >= 0) {
	                    return this.conditionStack[n];
	                  } else {
	                    return "INITIAL";
	                  }
	                },
	                // alias for begin(condition)
	                pushState: function pushState(condition) {
	                  this.begin(condition);
	                },
	                // return the number of states currently on the stack
	                stateStackSize: function stateStackSize() {
	                  return this.conditionStack.length;
	                },
	                options: {},
	                performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START
	                /**/) {
	                  switch ($avoiding_name_collisions) {
	                    case 0:
	                      return 4;
	                    case 1:
	                      return 14;
	                    case 2:
	                      return 12;
	                    case 3:
	                      return 15;
	                    case 4:
	                      return 16;
	                    case 5:
	                      return 22;
	                    case 6:
	                      return 24;
	                    case 7:
	                      return 28;
	                    case 8:
	                      return 30;
	                    case 9:
	                      return 18;
	                    case 10:
	                      yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);
	                      return 32;
	                    case 11:
	                      yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);
	                      return 33;
	                    case 12:
	                      return 17;
	                    case 13:
	                      return 31;
	                  }
	                },
	                rules: [/^(?:\$)/, /^(?:\.\.)/, /^(?:\.)/, /^(?:\*)/, /^(?:[a-zA-Z_]+[a-zA-Z0-9_]*)/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?:((-?(?:0|[1-9][0-9]*)))?\:((-?(?:0|[1-9][0-9]*)))?(\:((-?(?:0|[1-9][0-9]*)))?)?)/, /^(?:(-?(?:0|[1-9][0-9]*)))/, /^(?:"(?:\\["bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/, /^(?:'(?:\\['bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^'\\])*')/, /^(?:\(.+?\)(?=\]))/, /^(?:\?\(.+?\)(?=\]))/],
	                conditions: {
	                  "INITIAL": {
	                    "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
	                    "inclusive": true
	                  }
	                }
	              };
	              return lexer;
	            }();
	            parser.lexer = lexer;
	            function Parser() {
	              this.yy = {};
	            }
	            Parser.prototype = parser;
	            parser.Parser = Parser;
	            return new Parser();
	          }();
	          if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
	            exports.parser = parser;
	            exports.Parser = parser.Parser;
	            exports.parse = function () {
	              return parser.parse.apply(parser, arguments);
	            };
	            exports.main = function commonjsMain(args) {
	              if (!args[1]) {
	                console.log('Usage: ' + args[0] + ' FILE');
	                process.exit(1);
	              }
	              var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
	              return exports.parser.parse(source);
	            };
	            if (typeof module !== 'undefined' && require.main === module) {
	              exports.main(process.argv.slice(1));
	            }
	          }
	        }).call(this, require('_process'));
	      }, {
	        "_process": 14,
	        "fs": 12,
	        "path": 13
	      }],
	      2: [function (require, module, exports) {
	        module.exports = {
	          identifier: "[a-zA-Z_]+[a-zA-Z0-9_]*",
	          integer: "-?(?:0|[1-9][0-9]*)",
	          qq_string: "\"(?:\\\\[\"bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^\"\\\\])*\"",
	          q_string: "'(?:\\\\['bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^'\\\\])*'"
	        };
	      }, {}],
	      3: [function (require, module, exports) {
	        var dict = require('./dict');
	        var fs = require('fs');
	        var grammar = {
	          lex: {
	            macros: {
	              esc: "\\\\",
	              "int": dict.integer
	            },
	            rules: [["\\$", "return 'DOLLAR'"], ["\\.\\.", "return 'DOT_DOT'"], ["\\.", "return 'DOT'"], ["\\*", "return 'STAR'"], [dict.identifier, "return 'IDENTIFIER'"], ["\\[", "return '['"], ["\\]", "return ']'"], [",", "return ','"], ["({int})?\\:({int})?(\\:({int})?)?", "return 'ARRAY_SLICE'"], ["{int}", "return 'INTEGER'"], [dict.qq_string, "yytext = yytext.substr(1,yyleng-2); return 'QQ_STRING';"], [dict.q_string, "yytext = yytext.substr(1,yyleng-2); return 'Q_STRING';"], ["\\(.+?\\)(?=\\])", "return 'SCRIPT_EXPRESSION'"], ["\\?\\(.+?\\)(?=\\])", "return 'FILTER_EXPRESSION'"]]
	          },
	          start: "JSON_PATH",
	          bnf: {
	            JSON_PATH: [['DOLLAR', 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'], ['DOLLAR PATH_COMPONENTS', 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'], ['LEADING_CHILD_MEMBER_EXPRESSION', 'yy.ast.unshift(); return yy.ast.yield()'], ['LEADING_CHILD_MEMBER_EXPRESSION PATH_COMPONENTS', 'yy.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: $1 }}); yy.ast.unshift(); return yy.ast.yield()']],
	            PATH_COMPONENTS: [['PATH_COMPONENT', ''], ['PATH_COMPONENTS PATH_COMPONENT', '']],
	            PATH_COMPONENT: [['MEMBER_COMPONENT', 'yy.ast.set({ operation: "member" }); yy.ast.push()'], ['SUBSCRIPT_COMPONENT', 'yy.ast.set({ operation: "subscript" }); yy.ast.push() ']],
	            MEMBER_COMPONENT: [['CHILD_MEMBER_COMPONENT', 'yy.ast.set({ scope: "child" })'], ['DESCENDANT_MEMBER_COMPONENT', 'yy.ast.set({ scope: "descendant" })']],
	            CHILD_MEMBER_COMPONENT: [['DOT MEMBER_EXPRESSION', '']],
	            LEADING_CHILD_MEMBER_EXPRESSION: [['MEMBER_EXPRESSION', 'yy.ast.set({ scope: "child", operation: "member" })']],
	            DESCENDANT_MEMBER_COMPONENT: [['DOT_DOT MEMBER_EXPRESSION', '']],
	            MEMBER_EXPRESSION: [['STAR', 'yy.ast.set({ expression: { type: "wildcard", value: $1 } })'], ['IDENTIFIER', 'yy.ast.set({ expression: { type: "identifier", value: $1 } })'], ['SCRIPT_EXPRESSION', 'yy.ast.set({ expression: { type: "script_expression", value: $1 } })'], ['INTEGER', 'yy.ast.set({ expression: { type: "numeric_literal", value: parseInt($1) } })'], ['END', '']],
	            SUBSCRIPT_COMPONENT: [['CHILD_SUBSCRIPT_COMPONENT', 'yy.ast.set({ scope: "child" })'], ['DESCENDANT_SUBSCRIPT_COMPONENT', 'yy.ast.set({ scope: "descendant" })']],
	            CHILD_SUBSCRIPT_COMPONENT: [['[ SUBSCRIPT ]', '']],
	            DESCENDANT_SUBSCRIPT_COMPONENT: [['DOT_DOT [ SUBSCRIPT ]', '']],
	            SUBSCRIPT: [['SUBSCRIPT_EXPRESSION', ''], ['SUBSCRIPT_EXPRESSION_LIST', '$1.length > 1? yy.ast.set({ expression: { type: "union", value: $1 } }) : $$ = $1']],
	            SUBSCRIPT_EXPRESSION_LIST: [['SUBSCRIPT_EXPRESSION_LISTABLE', '$$ = [$1]'], ['SUBSCRIPT_EXPRESSION_LIST , SUBSCRIPT_EXPRESSION_LISTABLE', '$$ = $1.concat($3)']],
	            SUBSCRIPT_EXPRESSION_LISTABLE: [['INTEGER', '$$ = { expression: { type: "numeric_literal", value: parseInt($1) } }; yy.ast.set($$)'], ['STRING_LITERAL', '$$ = { expression: { type: "string_literal", value: $1 } }; yy.ast.set($$)'], ['ARRAY_SLICE', '$$ = { expression: { type: "slice", value: $1 } }; yy.ast.set($$)']],
	            SUBSCRIPT_EXPRESSION: [['STAR', '$$ = { expression: { type: "wildcard", value: $1 } }; yy.ast.set($$)'], ['SCRIPT_EXPRESSION', '$$ = { expression: { type: "script_expression", value: $1 } }; yy.ast.set($$)'], ['FILTER_EXPRESSION', '$$ = { expression: { type: "filter_expression", value: $1 } }; yy.ast.set($$)']],
	            STRING_LITERAL: [['QQ_STRING', "$$ = $1"], ['Q_STRING', "$$ = $1"]]
	          }
	        };
	        if (fs.readFileSync) {
	          grammar.moduleInclude = fs.readFileSync(require.resolve("../include/module.js"));
	          grammar.actionInclude = fs.readFileSync(require.resolve("../include/action.js"));
	        }
	        module.exports = grammar;
	      }, {
	        "./dict": 2,
	        "fs": 12
	      }],
	      4: [function (require, module, exports) {
	        var aesprim = require('./aesprim');
	        var slice = require('./slice');
	        var _evaluate = require('static-eval');
	        var _uniq = require('underscore').uniq;
	        var Handlers = function Handlers() {
	          return this.initialize.apply(this, arguments);
	        };
	        Handlers.prototype.initialize = function () {
	          this.traverse = traverser(true);
	          this.descend = traverser();
	        };
	        Handlers.prototype.keys = Object.keys;
	        Handlers.prototype.resolve = function (component) {
	          var key = [component.operation, component.scope, component.expression.type].join('-');
	          var method = this._fns[key];
	          if (!method) throw new Error("couldn't resolve key: " + key);
	          return method.bind(this);
	        };
	        Handlers.prototype.register = function (key, handler) {
	          if (!handler instanceof Function) {
	            throw new Error("handler must be a function");
	          }
	          this._fns[key] = handler;
	        };
	        Handlers.prototype._fns = {
	          'member-child-identifier': function memberChildIdentifier(component, partial) {
	            var key = component.expression.value;
	            var value = partial.value;
	            if (value instanceof Object && key in value) {
	              return [{
	                value: value[key],
	                path: partial.path.concat(key)
	              }];
	            }
	          },
	          'member-descendant-identifier': _traverse(function (key, value, ref) {
	            return key == ref;
	          }),
	          'subscript-child-numeric_literal': _descend(function (key, value, ref) {
	            return key === ref;
	          }),
	          'member-child-numeric_literal': _descend(function (key, value, ref) {
	            return String(key) === String(ref);
	          }),
	          'subscript-descendant-numeric_literal': _traverse(function (key, value, ref) {
	            return key === ref;
	          }),
	          'member-child-wildcard': _descend(function () {
	            return true;
	          }),
	          'member-descendant-wildcard': _traverse(function () {
	            return true;
	          }),
	          'subscript-descendant-wildcard': _traverse(function () {
	            return true;
	          }),
	          'subscript-child-wildcard': _descend(function () {
	            return true;
	          }),
	          'subscript-child-slice': function subscriptChildSlice(component, partial) {
	            if (is_array(partial.value)) {
	              var args = component.expression.value.split(':').map(_parse_nullable_int);
	              var values = partial.value.map(function (v, i) {
	                return {
	                  value: v,
	                  path: partial.path.concat(i)
	                };
	              });
	              return slice.apply(null, [values].concat(args));
	            }
	          },
	          'subscript-child-union': function subscriptChildUnion(component, partial) {
	            var results = [];
	            component.expression.value.forEach(function (component) {
	              var _component = {
	                operation: 'subscript',
	                scope: 'child',
	                expression: component.expression
	              };
	              var handler = this.resolve(_component);
	              var _results = handler(_component, partial);
	              if (_results) {
	                results = results.concat(_results);
	              }
	            }, this);
	            return unique(results);
	          },
	          'subscript-descendant-union': function subscriptDescendantUnion(component, partial, count) {
	            var jp = require('..');
	            var self = this;
	            var results = [];
	            var nodes = jp.nodes(partial, '$..*').slice(1);
	            nodes.forEach(function (node) {
	              if (results.length >= count) return;
	              component.expression.value.forEach(function (component) {
	                var _component = {
	                  operation: 'subscript',
	                  scope: 'child',
	                  expression: component.expression
	                };
	                var handler = self.resolve(_component);
	                var _results = handler(_component, node);
	                results = results.concat(_results);
	              });
	            });
	            return unique(results);
	          },
	          'subscript-child-filter_expression': function subscriptChildFilter_expression(component, partial, count) {
	            // slice out the expression from ?(expression)
	            var src = component.expression.value.slice(2, -1);
	            var ast = aesprim.parse(src).body[0].expression;
	            var passable = function passable(key, value) {
	              return evaluate(ast, {
	                '@': value
	              });
	            };
	            return this.descend(partial, null, passable, count);
	          },
	          'subscript-descendant-filter_expression': function subscriptDescendantFilter_expression(component, partial, count) {
	            // slice out the expression from ?(expression)
	            var src = component.expression.value.slice(2, -1);
	            var ast = aesprim.parse(src).body[0].expression;
	            var passable = function passable(key, value) {
	              return evaluate(ast, {
	                '@': value
	              });
	            };
	            return this.traverse(partial, null, passable, count);
	          },
	          'subscript-child-script_expression': function subscriptChildScript_expression(component, partial) {
	            var exp = component.expression.value.slice(1, -1);
	            return eval_recurse(partial, exp, '$[{{value}}]');
	          },
	          'member-child-script_expression': function memberChildScript_expression(component, partial) {
	            var exp = component.expression.value.slice(1, -1);
	            return eval_recurse(partial, exp, '$.{{value}}');
	          },
	          'member-descendant-script_expression': function memberDescendantScript_expression(component, partial) {
	            var exp = component.expression.value.slice(1, -1);
	            return eval_recurse(partial, exp, '$..value');
	          }
	        };
	        Handlers.prototype._fns['subscript-child-string_literal'] = Handlers.prototype._fns['member-child-identifier'];
	        Handlers.prototype._fns['member-descendant-numeric_literal'] = Handlers.prototype._fns['subscript-descendant-string_literal'] = Handlers.prototype._fns['member-descendant-identifier'];
	        function eval_recurse(partial, src, template) {
	          var jp = require('./index');
	          var ast = aesprim.parse(src).body[0].expression;
	          var value = evaluate(ast, {
	            '@': partial.value
	          });
	          var path = template.replace(/\{\{\s*value\s*\}\}/g, value);
	          var results = jp.nodes(partial.value, path);
	          results.forEach(function (r) {
	            r.path = partial.path.concat(r.path.slice(1));
	          });
	          return results;
	        }
	        function is_array(val) {
	          return Array.isArray(val);
	        }
	        function is_object(val) {
	          // is this a non-array, non-null object?
	          return val && !(val instanceof Array) && val instanceof Object;
	        }
	        function traverser(recurse) {
	          return function (partial, ref, passable, count) {
	            var value = partial.value;
	            var path = partial.path;
	            var results = [];
	            var descend = function (value, path) {
	              if (is_array(value)) {
	                value.forEach(function (element, index) {
	                  if (results.length >= count) {
	                    return;
	                  }
	                  if (passable(index, element, ref)) {
	                    results.push({
	                      path: path.concat(index),
	                      value: element
	                    });
	                  }
	                });
	                value.forEach(function (element, index) {
	                  if (results.length >= count) {
	                    return;
	                  }
	                  if (recurse) {
	                    descend(element, path.concat(index));
	                  }
	                });
	              } else if (is_object(value)) {
	                this.keys(value).forEach(function (k) {
	                  if (results.length >= count) {
	                    return;
	                  }
	                  if (passable(k, value[k], ref)) {
	                    results.push({
	                      path: path.concat(k),
	                      value: value[k]
	                    });
	                  }
	                });
	                this.keys(value).forEach(function (k) {
	                  if (results.length >= count) {
	                    return;
	                  }
	                  if (recurse) {
	                    descend(value[k], path.concat(k));
	                  }
	                });
	              }
	            }.bind(this);
	            descend(value, path);
	            return results;
	          };
	        }
	        function _descend(passable) {
	          return function (component, partial, count) {
	            return this.descend(partial, component.expression.value, passable, count);
	          };
	        }
	        function _traverse(passable) {
	          return function (component, partial, count) {
	            return this.traverse(partial, component.expression.value, passable, count);
	          };
	        }
	        function evaluate() {
	          try {
	            return _evaluate.apply(this, arguments);
	          } catch (e) {}
	        }
	        function unique(results) {
	          results = results.filter(function (d) {
	            return d;
	          });
	          return _uniq(results, function (r) {
	            return r.path.map(function (c) {
	              return String(c).replace('-', '--');
	            }).join('-');
	          });
	        }
	        function _parse_nullable_int(val) {
	          var sval = String(val);
	          return sval.match(/^-?[0-9]+$/) ? parseInt(sval) : null;
	        }
	        module.exports = Handlers;
	      }, {
	        "..": "jsonpath",
	        "./aesprim": "./aesprim",
	        "./index": 5,
	        "./slice": 7,
	        "static-eval": 15,
	        "underscore": 12
	      }],
	      5: [function (require, module, exports) {
	        var assert = require('assert');
	        var dict = require('./dict');
	        var Parser = require('./parser');
	        var Handlers = require('./handlers');
	        var JSONPath = function JSONPath() {
	          this.initialize.apply(this, arguments);
	        };
	        JSONPath.prototype.initialize = function () {
	          this.parser = new Parser();
	          this.handlers = new Handlers();
	        };
	        JSONPath.prototype.parse = function (string) {
	          assert.ok(_is_string(string), "we need a path");
	          return this.parser.parse(string);
	        };
	        JSONPath.prototype.parent = function (obj, string) {
	          assert.ok(obj instanceof Object, "obj needs to be an object");
	          assert.ok(string, "we need a path");
	          var node = this.nodes(obj, string)[0];
	          node.path.pop(); /* jshint unused:false */
	          return this.value(obj, node.path);
	        };
	        JSONPath.prototype.apply = function (obj, string, fn) {
	          assert.ok(obj instanceof Object, "obj needs to be an object");
	          assert.ok(string, "we need a path");
	          assert.equal(_typeof(fn), "function", "fn needs to be function");
	          var nodes = this.nodes(obj, string).sort(function (a, b) {
	            // sort nodes so we apply from the bottom up
	            return b.path.length - a.path.length;
	          });
	          nodes.forEach(function (node) {
	            var key = node.path.pop();
	            var parent = this.value(obj, this.stringify(node.path));
	            var val = node.value = fn.call(obj, parent[key]);
	            parent[key] = val;
	          }, this);
	          return nodes;
	        };
	        JSONPath.prototype.value = function (obj, path, value) {
	          assert.ok(obj instanceof Object, "obj needs to be an object");
	          assert.ok(path, "we need a path");
	          if (arguments.length >= 3) {
	            var node = this.nodes(obj, path).shift();
	            if (!node) return this._vivify(obj, path, value);
	            var key = node.path.slice(-1).shift();
	            var parent = this.parent(obj, this.stringify(node.path));
	            parent[key] = value;
	          }
	          return this.query(obj, this.stringify(path), 1).shift();
	        };
	        JSONPath.prototype._vivify = function (obj, string, value) {
	          var self = this;
	          assert.ok(obj instanceof Object, "obj needs to be an object");
	          assert.ok(string, "we need a path");
	          var path = this.parser.parse(string).map(function (component) {
	            return component.expression.value;
	          });
	          var setValue = function setValue(path, value) {
	            var key = path.pop();
	            var node = self.value(obj, path);
	            if (!node) {
	              setValue(path.concat(), typeof key === 'string' ? {} : []);
	              node = self.value(obj, path);
	            }
	            node[key] = value;
	          };
	          setValue(path, value);
	          return this.query(obj, string)[0];
	        };
	        JSONPath.prototype.query = function (obj, string, count) {
	          assert.ok(obj instanceof Object, "obj needs to be an object");
	          assert.ok(_is_string(string), "we need a path");
	          var results = this.nodes(obj, string, count).map(function (r) {
	            return r.value;
	          });
	          return results;
	        };
	        JSONPath.prototype.paths = function (obj, string, count) {
	          assert.ok(obj instanceof Object, "obj needs to be an object");
	          assert.ok(string, "we need a path");
	          var results = this.nodes(obj, string, count).map(function (r) {
	            return r.path;
	          });
	          return results;
	        };
	        JSONPath.prototype.nodes = function (obj, string, count) {
	          assert.ok(obj instanceof Object, "obj needs to be an object");
	          assert.ok(string, "we need a path");
	          if (count === 0) return [];
	          var path = this.parser.parse(string);
	          var handlers = this.handlers;
	          var partials = [{
	            path: ['$'],
	            value: obj
	          }];
	          var matches = [];
	          if (path.length && path[0].expression.type == 'root') path.shift();
	          if (!path.length) return partials;
	          path.forEach(function (component, index) {
	            if (matches.length >= count) return;
	            var handler = handlers.resolve(component);
	            var _partials = [];
	            partials.forEach(function (p) {
	              if (matches.length >= count) return;
	              var results = handler(component, p, count);
	              if (index == path.length - 1) {
	                // if we're through the components we're done
	                matches = matches.concat(results || []);
	              } else {
	                // otherwise accumulate and carry on through
	                _partials = _partials.concat(results || []);
	              }
	            });
	            partials = _partials;
	          });
	          return count ? matches.slice(0, count) : matches;
	        };
	        JSONPath.prototype.stringify = function (path) {
	          assert.ok(path, "we need a path");
	          var string = '$';
	          var templates = {
	            'descendant-member': '..{{value}}',
	            'child-member': '.{{value}}',
	            'descendant-subscript': '..[{{value}}]',
	            'child-subscript': '[{{value}}]'
	          };
	          path = this._normalize(path);
	          path.forEach(function (component) {
	            if (component.expression.type == 'root') return;
	            var key = [component.scope, component.operation].join('-');
	            var template = templates[key];
	            var value;
	            if (component.expression.type == 'string_literal') {
	              value = JSON.stringify(component.expression.value);
	            } else {
	              value = component.expression.value;
	            }
	            if (!template) throw new Error("couldn't find template " + key);
	            string += template.replace(/{{value}}/, value);
	          });
	          return string;
	        };
	        JSONPath.prototype._normalize = function (path) {
	          assert.ok(path, "we need a path");
	          if (typeof path == "string") {
	            return this.parser.parse(path);
	          } else if (Array.isArray(path) && typeof path[0] == "string") {
	            var _path = [{
	              expression: {
	                type: "root",
	                value: "$"
	              }
	            }];
	            path.forEach(function (component, index) {
	              if (component == '$' && index === 0) return;
	              if (typeof component == "string" && component.match("^" + dict.identifier + "$")) {
	                _path.push({
	                  operation: 'member',
	                  scope: 'child',
	                  expression: {
	                    value: component,
	                    type: 'identifier'
	                  }
	                });
	              } else {
	                var type = typeof component == "number" ? 'numeric_literal' : 'string_literal';
	                _path.push({
	                  operation: 'subscript',
	                  scope: 'child',
	                  expression: {
	                    value: component,
	                    type: type
	                  }
	                });
	              }
	            });
	            return _path;
	          } else if (Array.isArray(path) && _typeof(path[0]) == "object") {
	            return path;
	          }
	          throw new Error("couldn't understand path " + path);
	        };
	        function _is_string(obj) {
	          return Object.prototype.toString.call(obj) == '[object String]';
	        }
	        JSONPath.Handlers = Handlers;
	        JSONPath.Parser = Parser;
	        var instance = new JSONPath();
	        instance.JSONPath = JSONPath;
	        module.exports = instance;
	      }, {
	        "./dict": 2,
	        "./handlers": 4,
	        "./parser": 6,
	        "assert": 8
	      }],
	      6: [function (require, module, exports) {
	        var grammar = require('./grammar');
	        var gparser = require('../generated/parser');
	        var Parser = function Parser() {
	          var parser = new gparser.Parser();
	          var _parseError = parser.parseError;
	          parser.yy.parseError = function () {
	            if (parser.yy.ast) {
	              parser.yy.ast.initialize();
	            }
	            _parseError.apply(parser, arguments);
	          };
	          return parser;
	        };
	        Parser.grammar = grammar;
	        module.exports = Parser;
	      }, {
	        "../generated/parser": 1,
	        "./grammar": 3
	      }],
	      7: [function (require, module, exports) {
	        module.exports = function (arr, start, end, step) {
	          if (typeof start == 'string') throw new Error("start cannot be a string");
	          if (typeof end == 'string') throw new Error("end cannot be a string");
	          if (typeof step == 'string') throw new Error("step cannot be a string");
	          var len = arr.length;
	          if (step === 0) throw new Error("step cannot be zero");
	          step = step ? integer(step) : 1;

	          // normalize negative values
	          start = start < 0 ? len + start : start;
	          end = end < 0 ? len + end : end;

	          // default extents to extents
	          start = integer(start === 0 ? 0 : !start ? step > 0 ? 0 : len - 1 : start);
	          end = integer(end === 0 ? 0 : !end ? step > 0 ? len : -1 : end);

	          // clamp extents
	          start = step > 0 ? Math.max(0, start) : Math.min(len, start);
	          end = step > 0 ? Math.min(end, len) : Math.max(-1, end);

	          // return empty if extents are backwards
	          if (step > 0 && end <= start) return [];
	          if (step < 0 && start <= end) return [];
	          var result = [];
	          for (var i = start; i != end; i += step) {
	            if (step < 0 && i <= end || step > 0 && i >= end) break;
	            result.push(arr[i]);
	          }
	          return result;
	        };
	        function integer(val) {
	          return String(val).match(/^[0-9]+$/) ? parseInt(val) : Number.isFinite(val) ? parseInt(val, 10) : 0;
	        }
	      }, {}],
	      8: [function (require, module, exports) {
	        // http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	        //
	        // THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	        //
	        // Originally from narwhal.js (http://narwhaljs.org)
	        // Copyright (c) 2009 Thomas Robinson <280north.com>
	        //
	        // Permission is hereby granted, free of charge, to any person obtaining a copy
	        // of this software and associated documentation files (the 'Software'), to
	        // deal in the Software without restriction, including without limitation the
	        // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	        // sell copies of the Software, and to permit persons to whom the Software is
	        // furnished to do so, subject to the following conditions:
	        //
	        // The above copyright notice and this permission notice shall be included in
	        // all copies or substantial portions of the Software.
	        //
	        // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	        // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	        // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	        // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	        // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	        // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	        // when used in node, this will actually load the util module we depend on
	        // versus loading the builtin util module as happens otherwise
	        // this is a bug in node module loading as far as I am concerned
	        var util = require('util/');
	        var pSlice = Array.prototype.slice;
	        var hasOwn = Object.prototype.hasOwnProperty;

	        // 1. The assert module provides functions that throw
	        // AssertionError's when particular conditions are not met. The
	        // assert module must conform to the following interface.

	        var assert = module.exports = ok;

	        // 2. The AssertionError is defined in assert.
	        // new assert.AssertionError({ message: message,
	        //                             actual: actual,
	        //                             expected: expected })

	        assert.AssertionError = function AssertionError(options) {
	          this.name = 'AssertionError';
	          this.actual = options.actual;
	          this.expected = options.expected;
	          this.operator = options.operator;
	          if (options.message) {
	            this.message = options.message;
	            this.generatedMessage = false;
	          } else {
	            this.message = getMessage(this);
	            this.generatedMessage = true;
	          }
	          var stackStartFunction = options.stackStartFunction || fail;
	          if (Error.captureStackTrace) {
	            Error.captureStackTrace(this, stackStartFunction);
	          } else {
	            // non v8 browsers so we can have a stacktrace
	            var err = new Error();
	            if (err.stack) {
	              var out = err.stack;

	              // try to strip useless frames
	              var fn_name = stackStartFunction.name;
	              var idx = out.indexOf('\n' + fn_name);
	              if (idx >= 0) {
	                // once we have located the function frame
	                // we need to strip out everything before it (and its line)
	                var next_line = out.indexOf('\n', idx + 1);
	                out = out.substring(next_line + 1);
	              }
	              this.stack = out;
	            }
	          }
	        };

	        // assert.AssertionError instanceof Error
	        util.inherits(assert.AssertionError, Error);
	        function replacer(key, value) {
	          if (util.isUndefined(value)) {
	            return '' + value;
	          }
	          if (util.isNumber(value) && !isFinite(value)) {
	            return value.toString();
	          }
	          if (util.isFunction(value) || util.isRegExp(value)) {
	            return value.toString();
	          }
	          return value;
	        }
	        function truncate(s, n) {
	          if (util.isString(s)) {
	            return s.length < n ? s : s.slice(0, n);
	          } else {
	            return s;
	          }
	        }
	        function getMessage(self) {
	          return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' + self.operator + ' ' + truncate(JSON.stringify(self.expected, replacer), 128);
	        }

	        // At present only the three keys mentioned above are used and
	        // understood by the spec. Implementations or sub modules can pass
	        // other keys to the AssertionError's constructor - they will be
	        // ignored.

	        // 3. All of the following functions must throw an AssertionError
	        // when a corresponding condition is not met, with a message that
	        // may be undefined if not provided.  All assertion methods provide
	        // both the actual and expected values to the assertion error for
	        // display purposes.

	        function fail(actual, expected, message, operator, stackStartFunction) {
	          throw new assert.AssertionError({
	            message: message,
	            actual: actual,
	            expected: expected,
	            operator: operator,
	            stackStartFunction: stackStartFunction
	          });
	        }

	        // EXTENSION! allows for well behaved errors defined elsewhere.
	        assert.fail = fail;

	        // 4. Pure assertion tests whether a value is truthy, as determined
	        // by !!guard.
	        // assert.ok(guard, message_opt);
	        // This statement is equivalent to assert.equal(true, !!guard,
	        // message_opt);. To test strictly for the value true, use
	        // assert.strictEqual(true, guard, message_opt);.

	        function ok(value, message) {
	          if (!value) fail(value, true, message, '==', assert.ok);
	        }
	        assert.ok = ok;

	        // 5. The equality assertion tests shallow, coercive equality with
	        // ==.
	        // assert.equal(actual, expected, message_opt);

	        assert.equal = function equal(actual, expected, message) {
	          if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	        };

	        // 6. The non-equality assertion tests for whether two objects are not equal
	        // with != assert.notEqual(actual, expected, message_opt);

	        assert.notEqual = function notEqual(actual, expected, message) {
	          if (actual == expected) {
	            fail(actual, expected, message, '!=', assert.notEqual);
	          }
	        };

	        // 7. The equivalence assertion tests a deep equality relation.
	        // assert.deepEqual(actual, expected, message_opt);

	        assert.deepEqual = function deepEqual(actual, expected, message) {
	          if (!_deepEqual(actual, expected)) {
	            fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	          }
	        };
	        function _deepEqual(actual, expected) {
	          // 7.1. All identical values are equivalent, as determined by ===.
	          if (actual === expected) {
	            return true;
	          } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
	            if (actual.length != expected.length) return false;
	            for (var i = 0; i < actual.length; i++) {
	              if (actual[i] !== expected[i]) return false;
	            }
	            return true;

	            // 7.2. If the expected value is a Date object, the actual value is
	            // equivalent if it is also a Date object that refers to the same time.
	          } else if (util.isDate(actual) && util.isDate(expected)) {
	            return actual.getTime() === expected.getTime();

	            // 7.3 If the expected value is a RegExp object, the actual value is
	            // equivalent if it is also a RegExp object with the same source and
	            // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	          } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	            return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;

	            // 7.4. Other pairs that do not both pass typeof value == 'object',
	            // equivalence is determined by ==.
	          } else if (!util.isObject(actual) && !util.isObject(expected)) {
	            return actual == expected;

	            // 7.5 For all other Object pairs, including Array objects, equivalence is
	            // determined by having the same number of owned properties (as verified
	            // with Object.prototype.hasOwnProperty.call), the same set of keys
	            // (although not necessarily the same order), equivalent values for every
	            // corresponding key, and an identical 'prototype' property. Note: this
	            // accounts for both named and indexed properties on Arrays.
	          } else {
	            return objEquiv(actual, expected);
	          }
	        }
	        function isArguments(object) {
	          return Object.prototype.toString.call(object) == '[object Arguments]';
	        }
	        function objEquiv(a, b) {
	          if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b)) return false;
	          // an identical 'prototype' property.
	          if (a.prototype !== b.prototype) return false;
	          // if one is a primitive, the other must be same
	          if (util.isPrimitive(a) || util.isPrimitive(b)) {
	            return a === b;
	          }
	          var aIsArgs = isArguments(a),
	            bIsArgs = isArguments(b);
	          if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;
	          if (aIsArgs) {
	            a = pSlice.call(a);
	            b = pSlice.call(b);
	            return _deepEqual(a, b);
	          }
	          var ka = objectKeys(a),
	            kb = objectKeys(b),
	            key,
	            i;
	          // having the same number of owned properties (keys incorporates
	          // hasOwnProperty)
	          if (ka.length != kb.length) return false;
	          //the same set of keys (although not necessarily the same order),
	          ka.sort();
	          kb.sort();
	          //~~~cheap key test
	          for (i = ka.length - 1; i >= 0; i--) {
	            if (ka[i] != kb[i]) return false;
	          }
	          //equivalent values for every corresponding key, and
	          //~~~possibly expensive deep test
	          for (i = ka.length - 1; i >= 0; i--) {
	            key = ka[i];
	            if (!_deepEqual(a[key], b[key])) return false;
	          }
	          return true;
	        }

	        // 8. The non-equivalence assertion tests for any deep inequality.
	        // assert.notDeepEqual(actual, expected, message_opt);

	        assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	          if (_deepEqual(actual, expected)) {
	            fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	          }
	        };

	        // 9. The strict equality assertion tests strict equality, as determined by ===.
	        // assert.strictEqual(actual, expected, message_opt);

	        assert.strictEqual = function strictEqual(actual, expected, message) {
	          if (actual !== expected) {
	            fail(actual, expected, message, '===', assert.strictEqual);
	          }
	        };

	        // 10. The strict non-equality assertion tests for strict inequality, as
	        // determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

	        assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	          if (actual === expected) {
	            fail(actual, expected, message, '!==', assert.notStrictEqual);
	          }
	        };
	        function expectedException(actual, expected) {
	          if (!actual || !expected) {
	            return false;
	          }
	          if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	            return expected.test(actual);
	          } else if (actual instanceof expected) {
	            return true;
	          } else if (expected.call({}, actual) === true) {
	            return true;
	          }
	          return false;
	        }
	        function _throws(shouldThrow, block, expected, message) {
	          var actual;
	          if (util.isString(expected)) {
	            message = expected;
	            expected = null;
	          }
	          try {
	            block();
	          } catch (e) {
	            actual = e;
	          }
	          message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');
	          if (shouldThrow && !actual) {
	            fail(actual, expected, 'Missing expected exception' + message);
	          }
	          if (!shouldThrow && expectedException(actual, expected)) {
	            fail(actual, expected, 'Got unwanted exception' + message);
	          }
	          if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
	            throw actual;
	          }
	        }

	        // 11. Expected to throw an error:
	        // assert.throws(block, Error_opt, message_opt);

	        assert["throws"] = function (block, /*optional*/error, /*optional*/message) {
	          _throws.apply(this, [true].concat(pSlice.call(arguments)));
	        };

	        // EXTENSION! This is annoying to write outside this module.
	        assert.doesNotThrow = function (block, /*optional*/message) {
	          _throws.apply(this, [false].concat(pSlice.call(arguments)));
	        };
	        assert.ifError = function (err) {
	          if (err) {
	            throw err;
	          }
	        };
	        var objectKeys = Object.keys || function (obj) {
	          var keys = [];
	          for (var key in obj) {
	            if (hasOwn.call(obj, key)) keys.push(key);
	          }
	          return keys;
	        };
	      }, {
	        "util/": 11
	      }],
	      9: [function (require, module, exports) {
	        if (typeof Object.create === 'function') {
	          // implementation from standard node.js 'util' module
	          module.exports = function inherits(ctor, superCtor) {
	            ctor.super_ = superCtor;
	            ctor.prototype = Object.create(superCtor.prototype, {
	              constructor: {
	                value: ctor,
	                enumerable: false,
	                writable: true,
	                configurable: true
	              }
	            });
	          };
	        } else {
	          // old school shim for old browsers
	          module.exports = function inherits(ctor, superCtor) {
	            ctor.super_ = superCtor;
	            var TempCtor = function TempCtor() {};
	            TempCtor.prototype = superCtor.prototype;
	            ctor.prototype = new TempCtor();
	            ctor.prototype.constructor = ctor;
	          };
	        }
	      }, {}],
	      10: [function (require, module, exports) {
	        module.exports = function isBuffer(arg) {
	          return arg && _typeof(arg) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
	        };
	      }, {}],
	      11: [function (require, module, exports) {
	        (function (process, global) {
	          // Copyright Joyent, Inc. and other Node contributors.
	          //
	          // Permission is hereby granted, free of charge, to any person obtaining a
	          // copy of this software and associated documentation files (the
	          // "Software"), to deal in the Software without restriction, including
	          // without limitation the rights to use, copy, modify, merge, publish,
	          // distribute, sublicense, and/or sell copies of the Software, and to permit
	          // persons to whom the Software is furnished to do so, subject to the
	          // following conditions:
	          //
	          // The above copyright notice and this permission notice shall be included
	          // in all copies or substantial portions of the Software.
	          //
	          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	          // USE OR OTHER DEALINGS IN THE SOFTWARE.

	          var formatRegExp = /%[sdj%]/g;
	          exports.format = function (f) {
	            if (!isString(f)) {
	              var objects = [];
	              for (var i = 0; i < arguments.length; i++) {
	                objects.push(inspect(arguments[i]));
	              }
	              return objects.join(' ');
	            }
	            var i = 1;
	            var args = arguments;
	            var len = args.length;
	            var str = String(f).replace(formatRegExp, function (x) {
	              if (x === '%%') return '%';
	              if (i >= len) return x;
	              switch (x) {
	                case '%s':
	                  return String(args[i++]);
	                case '%d':
	                  return Number(args[i++]);
	                case '%j':
	                  try {
	                    return JSON.stringify(args[i++]);
	                  } catch (_) {
	                    return '[Circular]';
	                  }
	                default:
	                  return x;
	              }
	            });
	            for (var x = args[i]; i < len; x = args[++i]) {
	              if (isNull(x) || !isObject(x)) {
	                str += ' ' + x;
	              } else {
	                str += ' ' + inspect(x);
	              }
	            }
	            return str;
	          };

	          // Mark that a method should not be used.
	          // Returns a modified function which warns once by default.
	          // If --no-deprecation is set, then it is a no-op.
	          exports.deprecate = function (fn, msg) {
	            // Allow for deprecating things in the process of starting up.
	            if (isUndefined(global.process)) {
	              return function () {
	                return exports.deprecate(fn, msg).apply(this, arguments);
	              };
	            }
	            if (process.noDeprecation === true) {
	              return fn;
	            }
	            var warned = false;
	            function deprecated() {
	              if (!warned) {
	                if (process.throwDeprecation) {
	                  throw new Error(msg);
	                } else if (process.traceDeprecation) {
	                  console.trace(msg);
	                } else {
	                  console.error(msg);
	                }
	                warned = true;
	              }
	              return fn.apply(this, arguments);
	            }
	            return deprecated;
	          };
	          var debugs = {};
	          var debugEnviron;
	          exports.debuglog = function (set) {
	            if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
	            set = set.toUpperCase();
	            if (!debugs[set]) {
	              if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	                var pid = process.pid;
	                debugs[set] = function () {
	                  var msg = exports.format.apply(exports, arguments);
	                  console.error('%s %d: %s', set, pid, msg);
	                };
	              } else {
	                debugs[set] = function () {};
	              }
	            }
	            return debugs[set];
	          };

	          /**
	           * Echos the value of a value. Trys to print the value out
	           * in the best way possible given the different types.
	           *
	           * @param {Object} obj The object to print out.
	           * @param {Object} opts Optional options object that alters the output.
	           */
	          /* legacy: obj, showHidden, depth, colors*/
	          function inspect(obj, opts) {
	            // default options
	            var ctx = {
	              seen: [],
	              stylize: stylizeNoColor
	            };
	            // legacy...
	            if (arguments.length >= 3) ctx.depth = arguments[2];
	            if (arguments.length >= 4) ctx.colors = arguments[3];
	            if (isBoolean(opts)) {
	              // legacy...
	              ctx.showHidden = opts;
	            } else if (opts) {
	              // got an "options" object
	              exports._extend(ctx, opts);
	            }
	            // set default options
	            if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	            if (isUndefined(ctx.depth)) ctx.depth = 2;
	            if (isUndefined(ctx.colors)) ctx.colors = false;
	            if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	            if (ctx.colors) ctx.stylize = stylizeWithColor;
	            return formatValue(ctx, obj, ctx.depth);
	          }
	          exports.inspect = inspect;

	          // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	          inspect.colors = {
	            'bold': [1, 22],
	            'italic': [3, 23],
	            'underline': [4, 24],
	            'inverse': [7, 27],
	            'white': [37, 39],
	            'grey': [90, 39],
	            'black': [30, 39],
	            'blue': [34, 39],
	            'cyan': [36, 39],
	            'green': [32, 39],
	            'magenta': [35, 39],
	            'red': [31, 39],
	            'yellow': [33, 39]
	          };

	          // Don't use 'blue' not visible on cmd.exe
	          inspect.styles = {
	            'special': 'cyan',
	            'number': 'yellow',
	            'boolean': 'yellow',
	            'undefined': 'grey',
	            'null': 'bold',
	            'string': 'green',
	            'date': 'magenta',
	            // "name": intentionally not styling
	            'regexp': 'red'
	          };
	          function stylizeWithColor(str, styleType) {
	            var style = inspect.styles[styleType];
	            if (style) {
	              return "\x1B[" + inspect.colors[style][0] + 'm' + str + "\x1B[" + inspect.colors[style][1] + 'm';
	            } else {
	              return str;
	            }
	          }
	          function stylizeNoColor(str, styleType) {
	            return str;
	          }
	          function arrayToHash(array) {
	            var hash = {};
	            array.forEach(function (val, idx) {
	              hash[val] = true;
	            });
	            return hash;
	          }
	          function formatValue(ctx, value, recurseTimes) {
	            // Provide a hook for user-specified inspect functions.
	            // Check that value is an object with an inspect function on it
	            if (ctx.customInspect && value && isFunction(value.inspect) &&
	            // Filter out the util module, it's inspect function is special
	            value.inspect !== exports.inspect &&
	            // Also filter out any prototype objects using the circular check.
	            !(value.constructor && value.constructor.prototype === value)) {
	              var ret = value.inspect(recurseTimes, ctx);
	              if (!isString(ret)) {
	                ret = formatValue(ctx, ret, recurseTimes);
	              }
	              return ret;
	            }

	            // Primitive types cannot have properties
	            var primitive = formatPrimitive(ctx, value);
	            if (primitive) {
	              return primitive;
	            }

	            // Look up the keys of the object.
	            var keys = Object.keys(value);
	            var visibleKeys = arrayToHash(keys);
	            if (ctx.showHidden) {
	              keys = Object.getOwnPropertyNames(value);
	            }

	            // IE doesn't make error fields non-enumerable
	            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	            if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	              return formatError(value);
	            }

	            // Some type of object without properties can be shortcutted.
	            if (keys.length === 0) {
	              if (isFunction(value)) {
	                var name = value.name ? ': ' + value.name : '';
	                return ctx.stylize('[Function' + name + ']', 'special');
	              }
	              if (isRegExp(value)) {
	                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	              }
	              if (isDate(value)) {
	                return ctx.stylize(Date.prototype.toString.call(value), 'date');
	              }
	              if (isError(value)) {
	                return formatError(value);
	              }
	            }
	            var base = '',
	              array = false,
	              braces = ['{', '}'];

	            // Make Array say that they are Array
	            if (isArray(value)) {
	              array = true;
	              braces = ['[', ']'];
	            }

	            // Make functions say that they are functions
	            if (isFunction(value)) {
	              var n = value.name ? ': ' + value.name : '';
	              base = ' [Function' + n + ']';
	            }

	            // Make RegExps say that they are RegExps
	            if (isRegExp(value)) {
	              base = ' ' + RegExp.prototype.toString.call(value);
	            }

	            // Make dates with properties first say the date
	            if (isDate(value)) {
	              base = ' ' + Date.prototype.toUTCString.call(value);
	            }

	            // Make error with message first say the error
	            if (isError(value)) {
	              base = ' ' + formatError(value);
	            }
	            if (keys.length === 0 && (!array || value.length == 0)) {
	              return braces[0] + base + braces[1];
	            }
	            if (recurseTimes < 0) {
	              if (isRegExp(value)) {
	                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	              } else {
	                return ctx.stylize('[Object]', 'special');
	              }
	            }
	            ctx.seen.push(value);
	            var output;
	            if (array) {
	              output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	            } else {
	              output = keys.map(function (key) {
	                return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	              });
	            }
	            ctx.seen.pop();
	            return reduceToSingleString(output, base, braces);
	          }
	          function formatPrimitive(ctx, value) {
	            if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
	            if (isString(value)) {
	              var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
	              return ctx.stylize(simple, 'string');
	            }
	            if (isNumber(value)) return ctx.stylize('' + value, 'number');
	            if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
	            // For some reason typeof null is "object", so special case here.
	            if (isNull(value)) return ctx.stylize('null', 'null');
	          }
	          function formatError(value) {
	            return '[' + Error.prototype.toString.call(value) + ']';
	          }
	          function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	            var output = [];
	            for (var i = 0, l = value.length; i < l; ++i) {
	              if (hasOwnProperty(value, String(i))) {
	                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
	              } else {
	                output.push('');
	              }
	            }
	            keys.forEach(function (key) {
	              if (!key.match(/^\d+$/)) {
	                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
	              }
	            });
	            return output;
	          }
	          function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	            var name, str, desc;
	            desc = Object.getOwnPropertyDescriptor(value, key) || {
	              value: value[key]
	            };
	            if (desc.get) {
	              if (desc.set) {
	                str = ctx.stylize('[Getter/Setter]', 'special');
	              } else {
	                str = ctx.stylize('[Getter]', 'special');
	              }
	            } else {
	              if (desc.set) {
	                str = ctx.stylize('[Setter]', 'special');
	              }
	            }
	            if (!hasOwnProperty(visibleKeys, key)) {
	              name = '[' + key + ']';
	            }
	            if (!str) {
	              if (ctx.seen.indexOf(desc.value) < 0) {
	                if (isNull(recurseTimes)) {
	                  str = formatValue(ctx, desc.value, null);
	                } else {
	                  str = formatValue(ctx, desc.value, recurseTimes - 1);
	                }
	                if (str.indexOf('\n') > -1) {
	                  if (array) {
	                    str = str.split('\n').map(function (line) {
	                      return '  ' + line;
	                    }).join('\n').substr(2);
	                  } else {
	                    str = '\n' + str.split('\n').map(function (line) {
	                      return '   ' + line;
	                    }).join('\n');
	                  }
	                }
	              } else {
	                str = ctx.stylize('[Circular]', 'special');
	              }
	            }
	            if (isUndefined(name)) {
	              if (array && key.match(/^\d+$/)) {
	                return str;
	              }
	              name = JSON.stringify('' + key);
	              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	                name = name.substr(1, name.length - 2);
	                name = ctx.stylize(name, 'name');
	              } else {
	                name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
	                name = ctx.stylize(name, 'string');
	              }
	            }
	            return name + ': ' + str;
	          }
	          function reduceToSingleString(output, base, braces) {
	            var length = output.reduce(function (prev, cur) {
	              if (cur.indexOf('\n') >= 0) ;
	              return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	            }, 0);
	            if (length > 60) {
	              return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
	            }
	            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	          }

	          // NOTE: These type checking functions intentionally don't use `instanceof`
	          // because it is fragile and can be easily faked with `Object.create()`.
	          function isArray(ar) {
	            return Array.isArray(ar);
	          }
	          exports.isArray = isArray;
	          function isBoolean(arg) {
	            return typeof arg === 'boolean';
	          }
	          exports.isBoolean = isBoolean;
	          function isNull(arg) {
	            return arg === null;
	          }
	          exports.isNull = isNull;
	          function isNullOrUndefined(arg) {
	            return arg == null;
	          }
	          exports.isNullOrUndefined = isNullOrUndefined;
	          function isNumber(arg) {
	            return typeof arg === 'number';
	          }
	          exports.isNumber = isNumber;
	          function isString(arg) {
	            return typeof arg === 'string';
	          }
	          exports.isString = isString;
	          function isSymbol(arg) {
	            return _typeof(arg) === 'symbol';
	          }
	          exports.isSymbol = isSymbol;
	          function isUndefined(arg) {
	            return arg === void 0;
	          }
	          exports.isUndefined = isUndefined;
	          function isRegExp(re) {
	            return isObject(re) && objectToString(re) === '[object RegExp]';
	          }
	          exports.isRegExp = isRegExp;
	          function isObject(arg) {
	            return _typeof(arg) === 'object' && arg !== null;
	          }
	          exports.isObject = isObject;
	          function isDate(d) {
	            return isObject(d) && objectToString(d) === '[object Date]';
	          }
	          exports.isDate = isDate;
	          function isError(e) {
	            return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
	          }
	          exports.isError = isError;
	          function isFunction(arg) {
	            return typeof arg === 'function';
	          }
	          exports.isFunction = isFunction;
	          function isPrimitive(arg) {
	            return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || _typeof(arg) === 'symbol' ||
	            // ES6 symbol
	            typeof arg === 'undefined';
	          }
	          exports.isPrimitive = isPrimitive;
	          exports.isBuffer = require('./support/isBuffer');
	          function objectToString(o) {
	            return Object.prototype.toString.call(o);
	          }
	          function pad(n) {
	            return n < 10 ? '0' + n.toString(10) : n.toString(10);
	          }
	          var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

	          // 26 Feb 16:19:34
	          function timestamp() {
	            var d = new Date();
	            var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
	            return [d.getDate(), months[d.getMonth()], time].join(' ');
	          }

	          // log is just a thin wrapper to console.log that prepends a timestamp
	          exports.log = function () {
	            console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	          };

	          /**
	           * Inherit the prototype methods from one constructor into another.
	           *
	           * The Function.prototype.inherits from lang.js rewritten as a standalone
	           * function (not on Function.prototype). NOTE: If this file is to be loaded
	           * during bootstrapping this function needs to be rewritten using some native
	           * functions as prototype setup using normal JavaScript does not work as
	           * expected during bootstrapping (see mirror.js in r114903).
	           *
	           * @param {function} ctor Constructor function which needs to inherit the
	           *     prototype.
	           * @param {function} superCtor Constructor function to inherit prototype from.
	           */
	          exports.inherits = require('inherits');
	          exports._extend = function (origin, add) {
	            // Don't do anything if add isn't an object
	            if (!add || !isObject(add)) return origin;
	            var keys = Object.keys(add);
	            var i = keys.length;
	            while (i--) {
	              origin[keys[i]] = add[keys[i]];
	            }
	            return origin;
	          };
	          function hasOwnProperty(obj, prop) {
	            return Object.prototype.hasOwnProperty.call(obj, prop);
	          }
	        }).call(this, require('_process'), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
	      }, {
	        "./support/isBuffer": 10,
	        "_process": 14,
	        "inherits": 9
	      }],
	      12: [function (require, module, exports) {}, {}],
	      13: [function (require, module, exports) {
	        (function (process) {
	          // .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
	          // backported and transplited with Babel, with backwards-compat fixes

	          // Copyright Joyent, Inc. and other Node contributors.
	          //
	          // Permission is hereby granted, free of charge, to any person obtaining a
	          // copy of this software and associated documentation files (the
	          // "Software"), to deal in the Software without restriction, including
	          // without limitation the rights to use, copy, modify, merge, publish,
	          // distribute, sublicense, and/or sell copies of the Software, and to permit
	          // persons to whom the Software is furnished to do so, subject to the
	          // following conditions:
	          //
	          // The above copyright notice and this permission notice shall be included
	          // in all copies or substantial portions of the Software.
	          //
	          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	          // USE OR OTHER DEALINGS IN THE SOFTWARE.

	          // resolves . and .. elements in a path array with directory names there
	          // must be no slashes, empty elements, or device names (c:\) in the array
	          // (so also no leading and trailing slashes - it does not distinguish
	          // relative and absolute paths)
	          function normalizeArray(parts, allowAboveRoot) {
	            // if the path tries to go above the root, `up` ends up > 0
	            var up = 0;
	            for (var i = parts.length - 1; i >= 0; i--) {
	              var last = parts[i];
	              if (last === '.') {
	                parts.splice(i, 1);
	              } else if (last === '..') {
	                parts.splice(i, 1);
	                up++;
	              } else if (up) {
	                parts.splice(i, 1);
	                up--;
	              }
	            }

	            // if the path is allowed to go above the root, restore leading ..s
	            if (allowAboveRoot) {
	              for (; up--; up) {
	                parts.unshift('..');
	              }
	            }
	            return parts;
	          }

	          // path.resolve([from ...], to)
	          // posix version
	          exports.resolve = function () {
	            var resolvedPath = '',
	              resolvedAbsolute = false;
	            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	              var path = i >= 0 ? arguments[i] : process.cwd();

	              // Skip empty and invalid entries
	              if (typeof path !== 'string') {
	                throw new TypeError('Arguments to path.resolve must be strings');
	              } else if (!path) {
	                continue;
	              }
	              resolvedPath = path + '/' + resolvedPath;
	              resolvedAbsolute = path.charAt(0) === '/';
	            }

	            // At this point the path should be resolved to a full absolute path, but
	            // handle relative paths to be safe (might happen when process.cwd() fails)

	            // Normalize the path
	            resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
	              return !!p;
	            }), !resolvedAbsolute).join('/');
	            return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
	          };

	          // path.normalize(path)
	          // posix version
	          exports.normalize = function (path) {
	            var isAbsolute = exports.isAbsolute(path),
	              trailingSlash = substr(path, -1) === '/';

	            // Normalize the path
	            path = normalizeArray(filter(path.split('/'), function (p) {
	              return !!p;
	            }), !isAbsolute).join('/');
	            if (!path && !isAbsolute) {
	              path = '.';
	            }
	            if (path && trailingSlash) {
	              path += '/';
	            }
	            return (isAbsolute ? '/' : '') + path;
	          };

	          // posix version
	          exports.isAbsolute = function (path) {
	            return path.charAt(0) === '/';
	          };

	          // posix version
	          exports.join = function () {
	            var paths = Array.prototype.slice.call(arguments, 0);
	            return exports.normalize(filter(paths, function (p, index) {
	              if (typeof p !== 'string') {
	                throw new TypeError('Arguments to path.join must be strings');
	              }
	              return p;
	            }).join('/'));
	          };

	          // path.relative(from, to)
	          // posix version
	          exports.relative = function (from, to) {
	            from = exports.resolve(from).substr(1);
	            to = exports.resolve(to).substr(1);
	            function trim(arr) {
	              var start = 0;
	              for (; start < arr.length; start++) {
	                if (arr[start] !== '') break;
	              }
	              var end = arr.length - 1;
	              for (; end >= 0; end--) {
	                if (arr[end] !== '') break;
	              }
	              if (start > end) return [];
	              return arr.slice(start, end - start + 1);
	            }
	            var fromParts = trim(from.split('/'));
	            var toParts = trim(to.split('/'));
	            var length = Math.min(fromParts.length, toParts.length);
	            var samePartsLength = length;
	            for (var i = 0; i < length; i++) {
	              if (fromParts[i] !== toParts[i]) {
	                samePartsLength = i;
	                break;
	              }
	            }
	            var outputParts = [];
	            for (var i = samePartsLength; i < fromParts.length; i++) {
	              outputParts.push('..');
	            }
	            outputParts = outputParts.concat(toParts.slice(samePartsLength));
	            return outputParts.join('/');
	          };
	          exports.sep = '/';
	          exports.delimiter = ':';
	          exports.dirname = function (path) {
	            if (typeof path !== 'string') path = path + '';
	            if (path.length === 0) return '.';
	            var code = path.charCodeAt(0);
	            var hasRoot = code === 47 /*/*/;
	            var end = -1;
	            var matchedSlash = true;
	            for (var i = path.length - 1; i >= 1; --i) {
	              code = path.charCodeAt(i);
	              if (code === 47 /*/*/) {
	                if (!matchedSlash) {
	                  end = i;
	                  break;
	                }
	              } else {
	                // We saw the first non-path separator
	                matchedSlash = false;
	              }
	            }
	            if (end === -1) return hasRoot ? '/' : '.';
	            if (hasRoot && end === 1) {
	              // return '//';
	              // Backwards-compat fix:
	              return '/';
	            }
	            return path.slice(0, end);
	          };
	          function basename(path) {
	            if (typeof path !== 'string') path = path + '';
	            var start = 0;
	            var end = -1;
	            var matchedSlash = true;
	            var i;
	            for (i = path.length - 1; i >= 0; --i) {
	              if (path.charCodeAt(i) === 47 /*/*/) {
	                // If we reached a path separator that was not part of a set of path
	                // separators at the end of the string, stop now
	                if (!matchedSlash) {
	                  start = i + 1;
	                  break;
	                }
	              } else if (end === -1) {
	                // We saw the first non-path separator, mark this as the end of our
	                // path component
	                matchedSlash = false;
	                end = i + 1;
	              }
	            }
	            if (end === -1) return '';
	            return path.slice(start, end);
	          }

	          // Uses a mixed approach for backwards-compatibility, as ext behavior changed
	          // in new Node.js versions, so only basename() above is backported here
	          exports.basename = function (path, ext) {
	            var f = basename(path);
	            if (ext && f.substr(-1 * ext.length) === ext) {
	              f = f.substr(0, f.length - ext.length);
	            }
	            return f;
	          };
	          exports.extname = function (path) {
	            if (typeof path !== 'string') path = path + '';
	            var startDot = -1;
	            var startPart = 0;
	            var end = -1;
	            var matchedSlash = true;
	            // Track the state of characters (if any) we see before our first dot and
	            // after any path separator we find
	            var preDotState = 0;
	            for (var i = path.length - 1; i >= 0; --i) {
	              var code = path.charCodeAt(i);
	              if (code === 47 /*/*/) {
	                // If we reached a path separator that was not part of a set of path
	                // separators at the end of the string, stop now
	                if (!matchedSlash) {
	                  startPart = i + 1;
	                  break;
	                }
	                continue;
	              }
	              if (end === -1) {
	                // We saw the first non-path separator, mark this as the end of our
	                // extension
	                matchedSlash = false;
	                end = i + 1;
	              }
	              if (code === 46 /*.*/) {
	                // If this is our first dot, mark it as the start of our extension
	                if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
	              } else if (startDot !== -1) {
	                // We saw a non-dot and non-path separator before our dot, so we should
	                // have a good chance at having a non-empty extension
	                preDotState = -1;
	              }
	            }
	            if (startDot === -1 || end === -1 ||
	            // We saw a non-dot character immediately before the dot
	            preDotState === 0 ||
	            // The (right-most) trimmed path component is exactly '..'
	            preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
	              return '';
	            }
	            return path.slice(startDot, end);
	          };
	          function filter(xs, f) {
	            if (xs.filter) return xs.filter(f);
	            var res = [];
	            for (var i = 0; i < xs.length; i++) {
	              if (f(xs[i], i, xs)) res.push(xs[i]);
	            }
	            return res;
	          }

	          // String.prototype.substr - negative index don't work in IE8
	          var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
	            return str.substr(start, len);
	          } : function (str, start, len) {
	            if (start < 0) start = str.length + start;
	            return str.substr(start, len);
	          };
	        }).call(this, require('_process'));
	      }, {
	        "_process": 14
	      }],
	      14: [function (require, module, exports) {
	        // shim for using process in browser
	        var process = module.exports = {};

	        // cached from whatever global is present so that test runners that stub it
	        // don't break things.  But we need to wrap it in a try catch in case it is
	        // wrapped in strict mode code which doesn't define any globals.  It's inside a
	        // function because try/catches deoptimize in certain engines.

	        var cachedSetTimeout;
	        var cachedClearTimeout;
	        function defaultSetTimout() {
	          throw new Error('setTimeout has not been defined');
	        }
	        function defaultClearTimeout() {
	          throw new Error('clearTimeout has not been defined');
	        }
	        (function () {
	          try {
	            if (typeof setTimeout === 'function') {
	              cachedSetTimeout = setTimeout;
	            } else {
	              cachedSetTimeout = defaultSetTimout;
	            }
	          } catch (e) {
	            cachedSetTimeout = defaultSetTimout;
	          }
	          try {
	            if (typeof clearTimeout === 'function') {
	              cachedClearTimeout = clearTimeout;
	            } else {
	              cachedClearTimeout = defaultClearTimeout;
	            }
	          } catch (e) {
	            cachedClearTimeout = defaultClearTimeout;
	          }
	        })();
	        function runTimeout(fun) {
	          if (cachedSetTimeout === setTimeout) {
	            //normal enviroments in sane situations
	            return setTimeout(fun, 0);
	          }
	          // if setTimeout wasn't available but was latter defined
	          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	            cachedSetTimeout = setTimeout;
	            return setTimeout(fun, 0);
	          }
	          try {
	            // when when somebody has screwed with setTimeout but no I.E. maddness
	            return cachedSetTimeout(fun, 0);
	          } catch (e) {
	            try {
	              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	              return cachedSetTimeout.call(null, fun, 0);
	            } catch (e) {
	              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	              return cachedSetTimeout.call(this, fun, 0);
	            }
	          }
	        }
	        function runClearTimeout(marker) {
	          if (cachedClearTimeout === clearTimeout) {
	            //normal enviroments in sane situations
	            return clearTimeout(marker);
	          }
	          // if clearTimeout wasn't available but was latter defined
	          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	            cachedClearTimeout = clearTimeout;
	            return clearTimeout(marker);
	          }
	          try {
	            // when when somebody has screwed with setTimeout but no I.E. maddness
	            return cachedClearTimeout(marker);
	          } catch (e) {
	            try {
	              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	              return cachedClearTimeout.call(null, marker);
	            } catch (e) {
	              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	              return cachedClearTimeout.call(this, marker);
	            }
	          }
	        }
	        var queue = [];
	        var draining = false;
	        var currentQueue;
	        var queueIndex = -1;
	        function cleanUpNextTick() {
	          if (!draining || !currentQueue) {
	            return;
	          }
	          draining = false;
	          if (currentQueue.length) {
	            queue = currentQueue.concat(queue);
	          } else {
	            queueIndex = -1;
	          }
	          if (queue.length) {
	            drainQueue();
	          }
	        }
	        function drainQueue() {
	          if (draining) {
	            return;
	          }
	          var timeout = runTimeout(cleanUpNextTick);
	          draining = true;
	          var len = queue.length;
	          while (len) {
	            currentQueue = queue;
	            queue = [];
	            while (++queueIndex < len) {
	              if (currentQueue) {
	                currentQueue[queueIndex].run();
	              }
	            }
	            queueIndex = -1;
	            len = queue.length;
	          }
	          currentQueue = null;
	          draining = false;
	          runClearTimeout(timeout);
	        }
	        process.nextTick = function (fun) {
	          var args = new Array(arguments.length - 1);
	          if (arguments.length > 1) {
	            for (var i = 1; i < arguments.length; i++) {
	              args[i - 1] = arguments[i];
	            }
	          }
	          queue.push(new Item(fun, args));
	          if (queue.length === 1 && !draining) {
	            runTimeout(drainQueue);
	          }
	        };

	        // v8 likes predictible objects
	        function Item(fun, array) {
	          this.fun = fun;
	          this.array = array;
	        }
	        Item.prototype.run = function () {
	          this.fun.apply(null, this.array);
	        };
	        process.title = 'browser';
	        process.browser = true;
	        process.env = {};
	        process.argv = [];
	        process.version = ''; // empty string to avoid regexp issues
	        process.versions = {};
	        function noop() {}
	        process.on = noop;
	        process.addListener = noop;
	        process.once = noop;
	        process.off = noop;
	        process.removeListener = noop;
	        process.removeAllListeners = noop;
	        process.emit = noop;
	        process.prependListener = noop;
	        process.prependOnceListener = noop;
	        process.listeners = function (name) {
	          return [];
	        };
	        process.binding = function (name) {
	          throw new Error('process.binding is not supported');
	        };
	        process.cwd = function () {
	          return '/';
	        };
	        process.chdir = function (dir) {
	          throw new Error('process.chdir is not supported');
	        };
	        process.umask = function () {
	          return 0;
	        };
	      }, {}],
	      15: [function (require, module, exports) {
	        var unparse = require('escodegen').generate;
	        module.exports = function (ast, vars) {
	          if (!vars) vars = {};
	          var FAIL = {};
	          var result = function walk(node, scopeVars) {
	            if (node.type === 'Literal') {
	              return node.value;
	            } else if (node.type === 'UnaryExpression') {
	              var val = walk(node.argument);
	              if (node.operator === '+') return +val;
	              if (node.operator === '-') return -val;
	              if (node.operator === '~') return ~val;
	              if (node.operator === '!') return !val;
	              return FAIL;
	            } else if (node.type === 'ArrayExpression') {
	              var xs = [];
	              for (var i = 0, l = node.elements.length; i < l; i++) {
	                var x = walk(node.elements[i]);
	                if (x === FAIL) return FAIL;
	                xs.push(x);
	              }
	              return xs;
	            } else if (node.type === 'ObjectExpression') {
	              var obj = {};
	              for (var i = 0; i < node.properties.length; i++) {
	                var prop = node.properties[i];
	                var value = prop.value === null ? prop.value : walk(prop.value);
	                if (value === FAIL) return FAIL;
	                obj[prop.key.value || prop.key.name] = value;
	              }
	              return obj;
	            } else if (node.type === 'BinaryExpression' || node.type === 'LogicalExpression') {
	              var l = walk(node.left);
	              if (l === FAIL) return FAIL;
	              var r = walk(node.right);
	              if (r === FAIL) return FAIL;
	              var op = node.operator;
	              if (op === '==') return l == r;
	              if (op === '===') return l === r;
	              if (op === '!=') return l != r;
	              if (op === '!==') return l !== r;
	              if (op === '+') return l + r;
	              if (op === '-') return l - r;
	              if (op === '*') return l * r;
	              if (op === '/') return l / r;
	              if (op === '%') return l % r;
	              if (op === '<') return l < r;
	              if (op === '<=') return l <= r;
	              if (op === '>') return l > r;
	              if (op === '>=') return l >= r;
	              if (op === '|') return l | r;
	              if (op === '&') return l & r;
	              if (op === '^') return l ^ r;
	              if (op === '&&') return l && r;
	              if (op === '||') return l || r;
	              return FAIL;
	            } else if (node.type === 'Identifier') {
	              if ({}.hasOwnProperty.call(vars, node.name)) {
	                return vars[node.name];
	              } else return FAIL;
	            } else if (node.type === 'ThisExpression') {
	              if ({}.hasOwnProperty.call(vars, 'this')) {
	                return vars['this'];
	              } else return FAIL;
	            } else if (node.type === 'CallExpression') {
	              var callee = walk(node.callee);
	              if (callee === FAIL) return FAIL;
	              if (typeof callee !== 'function') return FAIL;
	              var ctx = node.callee.object ? walk(node.callee.object) : FAIL;
	              if (ctx === FAIL) ctx = null;
	              var args = [];
	              for (var i = 0, l = node.arguments.length; i < l; i++) {
	                var x = walk(node.arguments[i]);
	                if (x === FAIL) return FAIL;
	                args.push(x);
	              }
	              return callee.apply(ctx, args);
	            } else if (node.type === 'MemberExpression') {
	              var obj = walk(node.object);
	              // do not allow access to methods on Function 
	              if (obj === FAIL || typeof obj == 'function') {
	                return FAIL;
	              }
	              if (node.property.type === 'Identifier') {
	                return obj[node.property.name];
	              }
	              var prop = walk(node.property);
	              if (prop === FAIL) return FAIL;
	              return obj[prop];
	            } else if (node.type === 'ConditionalExpression') {
	              var val = walk(node.test);
	              if (val === FAIL) return FAIL;
	              return val ? walk(node.consequent) : walk(node.alternate);
	            } else if (node.type === 'ExpressionStatement') {
	              var val = walk(node.expression);
	              if (val === FAIL) return FAIL;
	              return val;
	            } else if (node.type === 'ReturnStatement') {
	              return walk(node.argument);
	            } else if (node.type === 'FunctionExpression') {
	              var bodies = node.body.body;

	              // Create a "scope" for our arguments
	              var oldVars = {};
	              Object.keys(vars).forEach(function (element) {
	                oldVars[element] = vars[element];
	              });
	              for (var i = 0; i < node.params.length; i++) {
	                var key = node.params[i];
	                if (key.type == 'Identifier') {
	                  vars[key.name] = null;
	                } else return FAIL;
	              }
	              for (var i in bodies) {
	                if (walk(bodies[i]) === FAIL) {
	                  return FAIL;
	                }
	              }
	              // restore the vars and scope after we walk
	              vars = oldVars;
	              var keys = Object.keys(vars);
	              var vals = keys.map(function (key) {
	                return vars[key];
	              });
	              return Function(keys.join(', '), 'return ' + unparse(node)).apply(null, vals);
	            } else if (node.type === 'TemplateLiteral') {
	              var str = '';
	              for (var i = 0; i < node.expressions.length; i++) {
	                str += walk(node.quasis[i]);
	                str += walk(node.expressions[i]);
	              }
	              str += walk(node.quasis[i]);
	              return str;
	            } else if (node.type === 'TaggedTemplateExpression') {
	              var tag = walk(node.tag);
	              var quasi = node.quasi;
	              var strings = quasi.quasis.map(walk);
	              var values = quasi.expressions.map(walk);
	              return tag.apply(null, [strings].concat(values));
	            } else if (node.type === 'TemplateElement') {
	              return node.value.cooked;
	            } else return FAIL;
	          }(ast);
	          return result === FAIL ? undefined : result;
	        };
	      }, {
	        "escodegen": 12
	      }],
	      "jsonpath": [function (require, module, exports) {
	        module.exports = require('./lib/index');
	      }, {
	        "./lib/index": 5
	      }]
	    }, {}, ["jsonpath"])("jsonpath");
	  });
	})(jsonpath$1);
	var jsonpath = jsonpath$1.exports;

	/** set of words that should be ignored by fulltext indexing */
	const genericEnglishStopwords = new Set([
	    'i',
	    'me',
	    'my',
	    'myself',
	    'we',
	    'our',
	    'ours',
	    'ourselves',
	    'you',
	    'your',
	    'yours',
	    'yourself',
	    'yourselves',
	    'he',
	    'him',
	    'his',
	    'himself',
	    'she',
	    'her',
	    'hers',
	    'herself',
	    'it',
	    'its',
	    'itself',
	    'they',
	    'them',
	    'their',
	    'theirs',
	    'themselves',
	    'what',
	    'which',
	    'who',
	    'whom',
	    'this',
	    'that',
	    'these',
	    'those',
	    'am',
	    'is',
	    'are',
	    'was',
	    'were',
	    'be',
	    'been',
	    'being',
	    'have',
	    'has',
	    'had',
	    'having',
	    'do',
	    'does',
	    'did',
	    'doing',
	    'a',
	    'an',
	    'the',
	    'and',
	    'but',
	    'if',
	    'or',
	    'because',
	    'as',
	    'until',
	    'while',
	    'of',
	    'at',
	    'by',
	    'for',
	    'with',
	    'about',
	    'against',
	    'between',
	    'into',
	    'through',
	    'during',
	    'before',
	    'after',
	    'above',
	    'below',
	    'to',
	    'from',
	    'up',
	    'down',
	    'in',
	    'out',
	    'on',
	    'off',
	    'over',
	    'under',
	    'again',
	    'further',
	    'then',
	    'once',
	    'here',
	    'there',
	    'when',
	    'where',
	    'why',
	    'how',
	    'all',
	    'any',
	    'both',
	    'each',
	    'few',
	    'more',
	    'most',
	    'other',
	    'some',
	    'such',
	    'no',
	    'nor',
	    'not',
	    'only',
	    'own',
	    'same',
	    'so',
	    'than',
	    'too',
	    'very',
	    's',
	    't',
	    'can',
	    'will',
	    'just',
	    'don',
	    'should',
	    'now',
	    '0',
	    '1',
	    '2',
	    '3',
	    '4',
	    '5',
	    '6',
	    '7',
	    '8',
	    '9',
	]);
	/**
	 * The set of stopwords we use for fulltext indexing. Currently
	 * just generic English stopwords, but will likely be expanded over time.
	 */
	const stopwords = genericEnglishStopwords;

	/**
	 * This file contains stuff dealing with IRI prefixes used in ontologies.
	 *
	 * ```
	 * const prefixes = new Map(['GO:', 'http://long.url/GO_'])
	 *
	 * applyPrefixes('http://long.url/GO_1234345') // returns 'GO:1234345'
	 *
	 * expandPrefixes('GO:1234345') // returns 'http://long.url/GO_1234345'
	 * ```
	 */
	/**
	 * compact the given URI using the given prefixes
	 */
	function applyPrefixes(uri, prefixes) {
	    for (const [prefix, uriBase] of prefixes.entries()) {
	        if (uri.startsWith(uriBase)) {
	            return uri.replace(uriBase, String(prefix));
	        }
	    }
	    return uri;
	}
	/**
	 * expand the given compacted URI using given prefixes
	 */
	function expandPrefixes(uri, prefixes) {
	    for (const [prefix, uriBase] of prefixes.entries()) {
	        if (uri.startsWith(String(prefix))) {
	            return uri.replace(String(prefix), uriBase);
	        }
	    }
	    return uri;
	}

	/* eslint-disable @typescript-eslint/no-unnecessary-condition */
	/** special value of jsonPath that gets the IRI (that is, ID) of the node with the configured prefixes applied */
	const PREFIXED_ID_PATH = '$PREFIXED_ID';
	/** small wrapper for jsonpath.query that intercepts requests for the special prefixed ID path */
	function jsonPathQuery(node, path, prefixes) {
	    if (path === PREFIXED_ID_PATH) {
	        return [applyPrefixes(node.id, prefixes)];
	    }
	    return jsonpath.query(node, path);
	}
	function wordsInString(str) {
	    return str
	        .toLowerCase()
	        .split(/[^\d:A-Za-z]+/)
	        .filter((word) => word && !stopwords.has(word));
	}
	/**
	 * recursively get the indexable words from an iterator
	 * of any objects
	 **/
	function* extractWords(strings) {
	    for (const str of strings) {
	        yield* wordsInString(str);
	    }
	}
	function* extractStrings(things) {
	    for (const thing of things) {
	        if (typeof thing === 'string') {
	            yield thing;
	        }
	        else if (typeof thing === 'object') {
	            const members = jsonpath.query(thing, '$..*');
	            yield* extractStrings(members);
	        }
	    }
	}
	/** @returns generator of tuples of [jsonpath, word] */
	function* getWords(node, jsonPaths, prefixes) {
	    for (const path of jsonPaths) {
	        const queryResult = jsonPathQuery(node, path, prefixes);
	        if (queryResult.length > 0) {
	            for (const word of extractWords(extractStrings(queryResult))) {
	                yield [path, word];
	            }
	        }
	    }
	}
	/**
	 *
	 **/
	async function textSearch(text, tx, signal) {
	    const db = await this.db;
	    const myTx = tx ?? db.transaction(['nodes']);
	    checkAbortSignal_1(signal);
	    const queryWords = [...wordsInString(text)];
	    const queries = [];
	    /**
	     * Build a structure of which terms match which words.
	     * This is a Map of term.id -\> Set\<query word number\>
	     **/
	    const initialMatches = new Map();
	    // find startsWith and complete matches
	    queries.push(...queryWords.map(async (queryWord, queryWordIndex) => {
	        checkAbortSignal_1(signal);
	        const idx = myTx.objectStore('nodes').index('full-text-words');
	        for await (const cursor of idx.iterate(IDBKeyRange.bound(queryWord, `${queryWord}\uFFFF`, false, false))) {
	            checkAbortSignal_1(signal);
	            const term = cursor.value;
	            const termMatches = initialMatches.get(term.id) ?? [
	                term,
	                new Set(),
	            ];
	            termMatches[1].add(queryWordIndex);
	            initialMatches.set(term.id, termMatches);
	        }
	    }));
	    await Promise.all(queries);
	    checkAbortSignal_1(signal);
	    // now rank the term matches and add some detail
	    const results = [];
	    for (const [, [term, wordIndexes]] of initialMatches) {
	        checkAbortSignal_1(signal);
	        results.push(...elaborateMatch(this.textIndexFields, term, wordIndexes, queryWords, this.prefixes));
	    }
	    // sort the terms by score descending
	    results.sort((a, b) => b.score - a.score);
	    // truncate if necessary
	    return results.slice(0, this.options.maxSearchResults ?? this.DEFAULT_MAX_SEARCH_RESULTS);
	}
	function elaborateMatch(textIndexPaths, term, queryWordIndexes, queryWords, prefixes) {
	    const sortedWordIndexes = [...queryWordIndexes].sort();
	    const matchedQueryWords = sortedWordIndexes.map((i) => queryWords[i]);
	    const queryWordRegexps = matchedQueryWords.map((queryWord) => {
	        const escaped = queryWord.replaceAll(/[$()*+./?[\\\]^{|}-]/g, String.raw `\$&`);
	        return new RegExp(`\\b${escaped}`, 'gi');
	    });
	    // const needle = matchedQueryWords.join(' ')
	    // ranking weights that can be tweaked if you know what you're doing
	    const FIELD_PRIORITY_WEIGHT = 1;
	    const MATCH_WORDS_CLOSENESS_WEIGHT = 0.05;
	    const MATCH_ADJACENCY_BONUS = 1;
	    const MATCH_RIGHT_ORDER_BONUS = 1;
	    const MATCH_LENGTH_WEIGHT = 0.01;
	    const PCT_OF_STRING_WEIGHT = 0.05;
	    const WORD_BONUS = 100; // bonus for each of the words matched
	    let matches = [];
	    let maxScore = 0;
	    for (const [fieldIdx, field] of textIndexPaths.entries()) {
	        const wordsMatched = new Set();
	        const fieldPriorityBonus = textIndexPaths.length - fieldIdx - 1;
	        const termStrings = [
	            ...extractStrings(jsonPathQuery(term, field.jsonPath, prefixes)),
	        ];
	        // find occurrences of each of the words in the strings
	        for (const str of termStrings) {
	            let score = 0;
	            const wordMatches = [];
	            for (const [wordIndex, re] of queryWordRegexps.entries()) {
	                for (const match of str.matchAll(re)) {
	                    score += 1 + fieldPriorityBonus * FIELD_PRIORITY_WEIGHT;
	                    wordsMatched.add(wordIndex);
	                    const position = match.index;
	                    const queryWord = queryWords[wordIndex];
	                    if (position !== undefined) {
	                        score += queryWord.length * MATCH_LENGTH_WEIGHT;
	                        score +=
	                            (queryWord.length / str.length) * 100 * PCT_OF_STRING_WEIGHT;
	                        wordMatches.push({ wordIndex, position });
	                    }
	                }
	            }
	            // apply the words-matched bonus
	            score += wordsMatched.size * WORD_BONUS;
	            if (maxScore < score) {
	                maxScore = score;
	            }
	            // sort the word matches by position in the target string ascending
	            wordMatches.sort((a, b) => a.position - b.position);
	            if (wordMatches.length > 0) {
	                matches.push({ term, field, str, score, wordMatches });
	            }
	        }
	    }
	    // Keep only the highest-scored matches. Usually 1, but there
	    // could be multiple if there is a tie for first place.
	    matches = matches.filter((m) => m.score === maxScore);
	    for (const match of matches) {
	        const { wordMatches } = match;
	        // re-examine the word order and spacing to give bonuses for the
	        // right order and close spacing
	        for (let i = 0; i < wordMatches.length - 1; i++) {
	            // bonus for pairs with adjacent word indexes and close spacing
	            const m1 = wordMatches[i];
	            const m2 = wordMatches[i + 1];
	            const wdiff = m2.wordIndex - m1.wordIndex;
	            if (wdiff === 1 || wdiff === -1) {
	                // they are adjacent, bonus
	                match.score += MATCH_ADJACENCY_BONUS;
	                if (wdiff === 1) {
	                    // they are in the right order, bonus
	                    match.score += MATCH_RIGHT_ORDER_BONUS;
	                }
	                // give additional bonus for how close they are
	                const spacing = Math.abs(m2.position -
	                    (m1.position + matchedQueryWords[m1.wordIndex].length)) - 1;
	                match.score -= spacing * MATCH_WORDS_CLOSENESS_WEIGHT;
	            }
	        }
	    }
	    return matches;
	}

	function isOntologyDBNode(node) {
	    return typeof node.id === 'string';
	}
	function isOntologyDBEdge(edge) {
	    return (typeof edge.sub === 'string' &&
	        typeof edge.pred === 'string' &&
	        typeof edge.obj === 'string');
	}
	function isDeprecated(thing) {
	    return Boolean(thing.meta?.deprecated);
	}

	var es6 = function equal(a, b) {
	  if (a === b) return true;
	  if (a && b && _typeof(a) == 'object' && _typeof(b) == 'object') {
	    if (a.constructor !== b.constructor) return false;
	    var length, i, keys;
	    if (Array.isArray(a)) {
	      length = a.length;
	      if (length != b.length) return false;
	      for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;
	      return true;
	    }
	    if (a instanceof Map && b instanceof Map) {
	      if (a.size !== b.size) return false;
	      var _iterator = _createForOfIteratorHelper(a.entries()),
	        _step;
	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          i = _step.value;
	          if (!b.has(i[0])) return false;
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }
	      var _iterator2 = _createForOfIteratorHelper(a.entries()),
	        _step2;
	      try {
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          i = _step2.value;
	          if (!equal(i[1], b.get(i[0]))) return false;
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }
	      return true;
	    }
	    if (a instanceof Set && b instanceof Set) {
	      if (a.size !== b.size) return false;
	      var _iterator3 = _createForOfIteratorHelper(a.entries()),
	        _step3;
	      try {
	        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	          i = _step3.value;
	          if (!b.has(i[0])) return false;
	        }
	      } catch (err) {
	        _iterator3.e(err);
	      } finally {
	        _iterator3.f();
	      }
	      return true;
	    }
	    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
	      length = a.length;
	      if (length != b.length) return false;
	      for (i = length; i-- !== 0;) if (a[i] !== b[i]) return false;
	      return true;
	    }
	    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
	    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
	    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
	    keys = Object.keys(a);
	    length = keys.length;
	    if (length !== Object.keys(b).length) return false;
	    for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
	    for (i = length; i-- !== 0;) {
	      var key = keys[i];
	      if (!equal(a[key], b[key])) return false;
	    }
	    return true;
	  }

	  // true if both NaN, false otherwise
	  return a !== a && b !== b;
	};

	/* eslint-disable @typescript-eslint/no-unnecessary-condition */
	/** schema version we are currently on, used for the IndexedDB schema open call */
	const schemaVersion = 2;
	/** open the IndexedDB and create the DB schema if necessary */
	async function openDatabase(dbName) {
	    // await deleteDB(dbName) // uncomment this to reload every time during development
	    return openDB(dbName, schemaVersion, {
	        upgrade(database, oldVersion, newVersion, transaction, _event) {
	            if (oldVersion < schemaVersion) {
	                if (database.objectStoreNames.contains('meta')) {
	                    database.deleteObjectStore('meta');
	                }
	                if (database.objectStoreNames.contains('nodes')) {
	                    database.deleteObjectStore('nodes');
	                }
	                if (database.objectStoreNames.contains('edges')) {
	                    database.deleteObjectStore('edges');
	                }
	            }
	            if (!database.objectStoreNames.contains('meta')) {
	                database.createObjectStore('meta');
	            }
	            if (!database.objectStoreNames.contains('nodes')) {
	                database.createObjectStore('nodes', { keyPath: 'id' });
	                const nodes = transaction.objectStore('nodes');
	                nodes.createIndex('by-label', 'lbl');
	                nodes.createIndex('by-type', 'type');
	                nodes.createIndex('by-synonym', ['meta', 'synonyms', 'val']);
	                nodes.createIndex('full-text-words', 'fullTextWords', {
	                    multiEntry: true,
	                });
	            }
	            if (!database.objectStoreNames.contains('edges')) {
	                database.createObjectStore('edges', { autoIncrement: true });
	                const edges = transaction.objectStore('edges');
	                edges.createIndex('by-subject', 'sub');
	                edges.createIndex('by-object', 'obj');
	                edges.createIndex('by-predicate', 'pred');
	            }
	        },
	    });
	}
	/** serialize all our words in the DB node so they can be indexed */
	function serializeWords(foundWords) {
	    const allWords = new Set();
	    for (const [, word] of foundWords) {
	        allWords.add(word);
	    }
	    return [...allWords];
	}
	/** load a OBO Graph JSON file into a database */
	async function loadOboGraphJson(db) {
	    const startTime = Date.now();
	    let percentProgress = 1;
	    this.options.update?.('Parsing JSON', percentProgress);
	    // TODO: using file streaming along with an event-based json parser
	    // instead of JSON.parse and .readFile could probably make this faster
	    // and less memory intensive
	    let oboGraph;
	    try {
	        oboGraph = JSON.parse(await io.openLocation(this.sourceLocation).readFile('utf8'));
	    }
	    catch {
	        throw new Error('Error in loading ontology');
	    }
	    percentProgress += 5;
	    this.options.update?.('Parsing JSON complete', percentProgress);
	    const parseTime = Date.now();
	    const [graph, ...additionalGraphs] = oboGraph.graphs ?? [];
	    if (!graph) {
	        return;
	    }
	    if (additionalGraphs.length > 0) {
	        throw new Error('multiple graphs not supported');
	    }
	    try {
	        const tx = db.transaction(['meta', 'nodes', 'edges'], 'readwrite');
	        await tx.objectStore('meta').clear();
	        await tx.objectStore('nodes').clear();
	        await tx.objectStore('edges').clear();
	        // load nodes
	        const nodeStore = tx.objectStore('nodes');
	        const fullTextIndexPaths = getTextIndexFields
	            .call(this)
	            .map((def) => def.jsonPath);
	        if (graph.nodes) {
	            let lastProgress = Math.round(percentProgress);
	            for (const [, node] of graph.nodes.entries()) {
	                percentProgress += 64 * (1 / graph.nodes.length);
	                if (Math.round(percentProgress) != lastProgress &&
	                    percentProgress < 100) {
	                    this.options.update?.('Processing nodes', percentProgress);
	                    lastProgress = Math.round(percentProgress);
	                }
	                if (isOntologyDBNode(node)) {
	                    await nodeStore.add({
	                        ...node,
	                        fullTextWords: serializeWords(getWords(node, fullTextIndexPaths, this.prefixes)),
	                    });
	                }
	            }
	        }
	        // load edges
	        const edgeStore = tx.objectStore('edges');
	        if (graph.edges) {
	            let lastProgress = Math.round(percentProgress);
	            for (const [, edge] of graph.edges.entries()) {
	                percentProgress += 30 * (1 / graph.edges.length);
	                if (Math.round(percentProgress) != lastProgress &&
	                    percentProgress < 100) {
	                    this.options.update?.('Processing edges', percentProgress);
	                    lastProgress = Math.round(percentProgress);
	                }
	                if (isOntologyDBEdge(edge)) {
	                    await edgeStore.add(edge);
	                }
	            }
	        }
	        await tx.done;
	        // record some metadata about this ontology and load operation
	        const tx2 = db.transaction('meta', 'readwrite');
	        // eslint-disable-next-line @typescript-eslint/unbound-method
	        const { update, ...otherOptions } = this.options;
	        await tx2.objectStore('meta').add({
	            ontologyRecord: {
	                name: this.ontologyName,
	                version: this.ontologyVersion,
	                sourceLocation: this.sourceLocation,
	            },
	            storeOptions: otherOptions,
	            graphMeta: graph.meta,
	            timestamp: String(new Date()),
	            schemaVersion,
	            timings: {
	                overall: Date.now() - startTime,
	                load: Date.now() - parseTime,
	            },
	        }, 'meta');
	        await tx2.done;
	    }
	    catch (error) {
	        await db.transaction('meta', 'readwrite').objectStore('meta').clear();
	        throw error;
	    }
	    return;
	}
	function getTextIndexFields() {
	    return [
	        { displayName: 'ID', jsonPath: PREFIXED_ID_PATH },
	        ...(this.options.textIndexing?.indexFields ?? defaultTextIndexFields),
	    ];
	}
	async function isDatabaseCurrent(db) {
	    // since metadata is loaded last, we use it as a signal that all the other data
	    // was loaded
	    const [meta] = await db.transaction('meta').objectStore('meta').getAll();
	    if (!meta) {
	        return false;
	    }
	    // check that the index paths and prefixes are the same as our current ones
	    return (es6(this.options.prefixes, meta.storeOptions.prefixes) &&
	        es6(this.options.textIndexing, meta.storeOptions.textIndexing));
	}

	/* eslint-disable @typescript-eslint/only-throw-error */
	async function arrayFromAsync(iter) {
	    const a = [];
	    for await (const i of iter) {
	        a.push(i);
	    }
	    return a;
	}
	/** query interface for a specific ontology */
	class OntologyStore {
	    ontologyName;
	    ontologyVersion;
	    sourceLocation;
	    db;
	    options;
	    loadOboGraphJson = loadOboGraphJson;
	    getTermsByFulltext = textSearch;
	    openDatabase = openDatabase;
	    isDatabaseCurrent = isDatabaseCurrent;
	    get textIndexFields() {
	        return getTextIndexFields.call(this);
	    }
	    get prefixes() {
	        return this.options.prefixes ?? new Map();
	    }
	    DEFAULT_MAX_SEARCH_RESULTS = 100;
	    constructor(name, version, source, options) {
	        this.ontologyName = name;
	        this.ontologyVersion = version;
	        this.sourceLocation = source;
	        this.options = options ?? {};
	        this.db = this.prepareDatabase();
	    }
	    /**
	     * check that the configuration of this ontology appears valid. Does not
	     * try to do any fetches, however.
	     */
	    validate() {
	        const errors = [];
	        // validate the source's file type
	        const { sourceLocation, sourceType } = this;
	        if (!sourceType) {
	            errors.push(new Error(`unable to determine format of ontology source file ${JSON.stringify(sourceLocation)}, file name must end with ".json", ".obo", or ".owl"`));
	        }
	        else if (sourceType !== 'obo-graph-json') {
	            errors.push(new Error(`ontology source file ${JSON.stringify(sourceLocation)} has type ${sourceType}, which is not yet supported`));
	        }
	        return errors;
	    }
	    get sourceType() {
	        if (require$$1$2.isUriLocation(this.sourceLocation)) {
	            if (this.sourceLocation.uri.endsWith('.json')) {
	                return 'obo-graph-json';
	            }
	        }
	        else if (require$$1$2.isLocalPathLocation(this.sourceLocation) &&
	            this.sourceLocation.localPath.endsWith('.json')) {
	            return 'obo-graph-json';
	        }
	        return undefined;
	    }
	    /** base name of the IndexedDB database for this ontology */
	    get dbName() {
	        return `Apollo Ontology "${this.ontologyName}" "${this.ontologyVersion}"`;
	    }
	    async prepareDatabase() {
	        const errors = this.validate();
	        if (errors.length > 0) {
	            throw errors;
	        }
	        const db = await this.openDatabase(this.dbName);
	        // if database is already completely loaded, just return it
	        if (await this.isDatabaseCurrent(db)) {
	            return db;
	        }
	        try {
	            const { options, sourceLocation, sourceType } = this;
	            if (sourceType === 'obo-graph-json') {
	                options.update?.('', 0);
	                // add more updates inside `loadOboGraphJson`
	                await this.loadOboGraphJson(db);
	                options.update?.('', 100);
	            }
	            else {
	                throw new Error(`ontology source file ${JSON.stringify(sourceLocation)} has type ${sourceType}, which is not yet supported`);
	            }
	            return db;
	        }
	        catch (error) {
	            db.close();
	            await deleteDB(this.dbName);
	            throw error;
	        }
	    }
	    async termCount(tx) {
	        const db = await this.db;
	        const myTx = tx ?? db.transaction('nodes');
	        return myTx.objectStore('nodes').count();
	    }
	    unique(nodes) {
	        const seen = new Map();
	        const result = [];
	        for (const node of nodes) {
	            if (!seen.has(node.id)) {
	                seen.set(node.id, true);
	                result.push(node);
	            }
	        }
	        return result;
	    }
	    async getTermsWithLabelOrSynonym(termLabelOrSynonym, options, tx) {
	        const includeSubclasses = options?.includeSubclasses ?? true;
	        const db = await this.db;
	        const myTx = tx ?? db.transaction(['nodes', 'edges']);
	        const nodes = myTx.objectStore('nodes');
	        const resultNodes = [
	            ...(await nodes.index('by-label').getAll(termLabelOrSynonym)),
	            ...(await nodes.index('by-synonym').getAll(termLabelOrSynonym)),
	        ];
	        if (includeSubclasses) {
	            // now recursively traverse is_a relations to gather nodes that are subclasses any of these
	            const subclassIds = await this.recurseEdges('by-object', resultNodes.map((n) => n.id), (edge) => edge.pred === 'is_a', 'sub', myTx);
	            for (const nodeId of subclassIds) {
	                const node = await nodes.get(nodeId);
	                if (node) {
	                    resultNodes.push(node);
	                }
	            }
	        }
	        return resultNodes;
	    }
	    /**
	     * Get the ontology term for the property with the given label,
	     * plus all the terms for the properties that are "subPropertyOf"
	     * that property.
	     *
	     * If there is more than one property with that label, treats it as
	     * equivalent and just returns all the properties and their subproperties.
	     *
	     * options.includeSubProperties default is true
	     */
	    async getPropertiesByLabel(propertyLabel, options, tx) {
	        const includeSubProperties = options?.includeSubProperties ?? true;
	        const db = await this.db;
	        const myTx = tx ?? db.transaction(['nodes', 'edges']);
	        const terms = await this.getTermsWithLabelOrSynonym(propertyLabel, { includeSubclasses: false }, myTx);
	        const properties = terms.filter((p) => isOntologyProperty(p));
	        if (includeSubProperties) {
	            const subPropertyIds = await this.recurseEdges('by-object', properties.map((p) => p.id), (edge) => edge.pred === 'subPropertyOf', 'sub', myTx);
	            const nodes = myTx.objectStore('nodes');
	            for (const subPropertyId of subPropertyIds) {
	                const property = await nodes.get(subPropertyId);
	                if (property && isOntologyProperty(property)) {
	                    properties.push(property);
	                }
	            }
	        }
	        return properties;
	    }
	    /** private helper for traversing the edges of the ontology graph. Does a breadth-first search of the graph */
	    async recurseEdges(queryIndex, inputQueryIds, filterEdge, resultProp, myTx) {
	        const resultIds = new Set();
	        async function recur(queryIds) {
	            await Promise.all([...queryIds].map(async (queryId) => {
	                const theseResults = (await myTx.objectStore('edges').index(queryIndex).getAll(queryId))
	                    .filter((element) => filterEdge(element))
	                    .map((edge) => edge[resultProp]);
	                if (theseResults.length > 0) {
	                    // report these subjects as results
	                    for (const resultId of theseResults) {
	                        resultIds.add(resultId);
	                    }
	                    // and now recurse further through the edges
	                    await recur(theseResults);
	                }
	            }));
	        }
	        await recur(inputQueryIds);
	        return resultIds.values();
	    }
	    /**
	     * given an array of node IDs, augment it with all of their subclasses or
	     * superclasses, and return the augmented array
	     **/
	    async *expandNodeSet(startingNodeIds, subclassRelation = 'is_a', direction, tx) {
	        const db = await this.db;
	        const myTx = tx ?? db.transaction(['edges']);
	        const startingNodes = [...startingNodeIds];
	        const subclassIds = await this.recurseEdges(direction === 'subclasses' ? 'by-object' : 'by-subject', startingNodes, (edge) => edge.pred === subclassRelation, direction === 'subclasses' ? 'sub' : 'obj', myTx);
	        for (const n of startingNodes) {
	            yield n;
	        }
	        for (const id of subclassIds) {
	            yield id;
	        }
	    }
	    /**
	     * given an iterator of node IDs, return a new iterator of those nodes plus all of their subclasses
	     */
	    expandSubclasses(startingNodeIds, subclassRelation = 'is_a', tx) {
	        return this.expandNodeSet(startingNodeIds, subclassRelation, 'subclasses', tx);
	    }
	    /**
	     * given an iterator of node IDs, return a new iterator of those nodes plus all of their superclasses
	     */
	    expandSuperclasses(startingNodeIds, subclassRelation = 'is_a', tx) {
	        return this.expandNodeSet(startingNodeIds, subclassRelation, 'superclasses', tx);
	    }
	    /**
	     * example: for the Sequence Ontology, store.getTermsThat('part_of', [geneTerm])
	     * would return all terms that are part_of, member_of, or integral_part_of a gene
	     */
	    async getClassesThat(propertyLabel, targetTerms, tx) {
	        const db = await this.db;
	        const myTx = tx ?? db.transaction(['nodes', 'edges']);
	        // find all the terms for the properties we are using
	        const relatingProperties = await this.getPropertiesByLabel(propertyLabel, { includeSubProperties: true }, myTx);
	        const relatingPropertyIds = new Set(relatingProperties.map((p) => p.id));
	        // expand to search all the superclasses of the target terms
	        const targetTermsWithSuperClasses = await arrayFromAsync(this.expandSuperclasses(targetTerms.map((t) => t.id), 'is_a', myTx));
	        // these are all the terms that are related to the targets by the given properties
	        const termIds = await this.recurseEdges('by-object', targetTermsWithSuperClasses, (edge) => relatingPropertyIds.has(edge.pred), 'sub', myTx);
	        // expand to include all the subclasses of those terms
	        const expanded = this.expandSubclasses(termIds, 'is_a', myTx);
	        // fetch the full nodes and filter out deprecated ones
	        const terms = [];
	        for await (const termId of expanded) {
	            const node = await myTx.objectStore('nodes').get(termId);
	            if (node && isOntologyClass(node) && !isDeprecated(node)) {
	                terms.push(node);
	            }
	        }
	        return terms;
	    }
	    async getClassesWithoutPropertyLabeled(propertyLabel, options, tx) {
	        const db = await this.db;
	        const myTx = tx ?? db.transaction(['nodes', 'edges']);
	        const nodeStore = myTx.objectStore('nodes');
	        const edgeStore = myTx.objectStore('edges');
	        // find all the terms (synonyms, subterms, etc) for the properties we are using
	        const relatingProperties = await this.getPropertiesByLabel(propertyLabel, options, myTx);
	        const relatingPropertyIds = relatingProperties.map((p) => p.id);
	        // make a blacklist of all the term IDs that have those properties, plus their subclasses
	        const termIdsWithProperties = await (async () => {
	            const ids = new Set();
	            for (const propertyId of relatingPropertyIds) {
	                for await (const cursor of edgeStore
	                    .index('by-predicate')
	                    .iterate(propertyId)) {
	                    ids.add(cursor.value.sub);
	                }
	            }
	            // expand their subclasses
	            const expanded = new Set();
	            for await (const id of this.expandSubclasses(ids, 'is_a', myTx)) {
	                expanded.add(id);
	            }
	            return expanded;
	        })();
	        // iterate through all terms in the store, find ones that are CLASS
	        // and are not in the blacklist
	        const termIds = [];
	        for await (const cursor of nodeStore) {
	            const node = cursor.value;
	            if (isOntologyClass(node) && !termIdsWithProperties.has(node.id)) {
	                termIds.push(node.id);
	            }
	        }
	        // fetch the full nodes and filter out deprecated ones
	        const terms = [];
	        for (const termId of termIds) {
	            const node = await myTx.objectStore('nodes').get(termId);
	            if (node && isOntologyClass(node) && !isDeprecated(node)) {
	                terms.push(node);
	            }
	        }
	        return terms;
	    }
	    async getAllClasses(tx) {
	        const db = await this.db;
	        const myTx = tx ?? db.transaction(['nodes']);
	        const all = (await myTx
	            .objectStore('nodes')
	            .index('by-type')
	            .getAll('CLASS'));
	        return all.filter((term) => !isDeprecated(term));
	    }
	    async getAllTerms(tx) {
	        const db = await this.db;
	        const myTx = tx ?? db.transaction(['nodes']);
	        const all = await myTx.objectStore('nodes').getAll();
	        return all.filter((term) => !isDeprecated(term));
	    }
	}

	const OntologyRecordType = require$$1$3.types
	    .model('OntologyRecord', {
	    name: require$$1$3.types.string,
	    version: 'unversioned',
	    source: require$$1$3.types.union(mst.LocalPathLocation, mst.UriLocation, mst.BlobLocation),
	    options: require$$1$3.types.frozen(),
	    equivalentTypes: require$$1$3.types.map(require$$1$3.types.array(require$$1$3.types.string)),
	})
	    .volatile((_self) => ({
	    dataStore: undefined,
	    startedEquivalentTypeRequests: new Set(),
	}))
	    .actions((self) => ({
	    /** does nothing, just used to access the model to force its lifecycle hooks to run */
	    ping() {
	        return;
	    },
	    initDataStore() {
	        self.dataStore = new OntologyStore(self.name, self.version, require$$1$3.getSnapshot(self.source), self.options);
	    },
	    afterCreate() {
	        require$$1$3.addDisposer(self, mobx.autorun(() => {
	            this.initDataStore();
	        }));
	    },
	    setEquivalentTypes(type, equivalentTypes) {
	        self.equivalentTypes.set(type, equivalentTypes);
	    },
	}))
	    .actions((self) => ({
	    loadEquivalentTypes: require$$1$3.flow(function* loadEquivalentTypes(type) {
	        if (!self.dataStore) {
	            return;
	        }
	        if (self.startedEquivalentTypeRequests.has(type)) {
	            return;
	        }
	        self.startedEquivalentTypeRequests.add(type);
	        const terms = (yield self.dataStore.getTermsWithLabelOrSynonym(type));
	        const equivalents = terms
	            .map((term) => term.lbl)
	            .filter((term) => term != undefined);
	        if (require$$1$3.isAlive(self)) {
	            self.setEquivalentTypes(type, equivalents);
	        }
	    }),
	}))
	    .actions((self) => ({
	    afterCreate() {
	        mobx.autorun((reaction) => {
	            if (!self.dataStore) {
	                return;
	            }
	            void self.loadEquivalentTypes('gene');
	            void self.loadEquivalentTypes('pseudogene');
	            void self.loadEquivalentTypes('transcript');
	            void self.loadEquivalentTypes('pseudogenic_transcript');
	            void self.loadEquivalentTypes('CDS');
	            void self.loadEquivalentTypes('mRNA');
	            reaction.dispose();
	        });
	    },
	    setEquivalentTypes(type, equivalentTypes) {
	        self.equivalentTypes.set(type, equivalentTypes);
	    },
	}))
	    .views((self) => ({
	    isTypeOf(queryType, typeOf) {
	        if (queryType === typeOf) {
	            return true;
	        }
	        if (!self.dataStore) {
	            return false;
	        }
	        const equivalents = self.equivalentTypes.get(typeOf);
	        if (!equivalents) {
	            void self.loadEquivalentTypes(typeOf);
	            return false;
	        }
	        return equivalents.includes(queryType);
	    },
	}));
	const OntologyManagerType = require$$1$3.types
	    .model('OntologyManager', {
	    // create, update, and delete ontologies
	    ontologies: require$$1$3.types.array(OntologyRecordType),
	    prefixes: require$$1$3.types.optional(require$$1$3.types.map(require$$1$3.types.string), {
	        'GO:': 'http://purl.obolibrary.org/obo/GO_',
	        'SO:': 'http://purl.obolibrary.org/obo/SO_',
	    }),
	})
	    .views((self) => ({
	    get featureTypeOntologyName() {
	        const jbConfig = require$$1$3.getRoot(self).jbrowse
	            .configuration;
	        const pluginConfiguration = jbConfig.ApolloPlugin;
	        const featureTypeOntologyName = configuration.readConfObject(pluginConfiguration, 'featureTypeOntologyName');
	        return featureTypeOntologyName;
	    },
	}))
	    .views((self) => ({
	    /**
	     * gets the OntologyRecord for the ontology we should be
	     * using for feature types (e.g. SO or maybe biotypes)
	     **/
	    get featureTypeOntology() {
	        return this.findOntology(self.featureTypeOntologyName);
	    },
	    findOntology(name, version) {
	        return self.ontologies.find((record) => {
	            return (record.name === name &&
	                (version === undefined || record.version === version));
	        });
	    },
	    openOntology(name, version) {
	        return this.findOntology(name, version)?.dataStore;
	    },
	    /**
	     * compact the given URI using the currently configured
	     * prefixes
	     */
	    applyPrefixes(uri) {
	        return applyPrefixes(uri, self.prefixes);
	    },
	    /**
	     * expand the given compacted URI using the currently
	     * configured prefixes
	     */
	    expandPrefixes(uri) {
	        return expandPrefixes(uri, self.prefixes);
	    },
	}))
	    .actions((self) => ({
	    addOntology(name, version, source, options) {
	        const newlen = self.ontologies.push({
	            name,
	            version,
	            source,
	            options: { prefixes: new Map(self.prefixes.entries()), ...options },
	        });
	        // access it immediately to fire its lifecycle hooks
	        // (see https://github.com/mobxjs/mobx-state-tree/issues/1665)
	        self.ontologies[newlen - 1].ping();
	    },
	}));
	const defaultTextIndexFields = [
	    { displayName: 'Label', jsonPath: '$.lbl' },
	    { displayName: 'Synonym', jsonPath: '$.meta.synonyms[*].val' },
	    { displayName: 'Definition', jsonPath: '$.meta.definition.val' },
	];
	const OntologyRecordConfiguration = configuration.ConfigurationSchema('OntologyRecord', {
	    name: {
	        type: 'string',
	        description: 'the full name of the ontology, e.g. "Gene Ontology"',
	        defaultValue: 'My Ontology',
	    },
	    version: {
	        type: 'string',
	        description: "the ontology's version string",
	        defaultValue: 'unversioned',
	    },
	    source: {
	        type: 'fileLocation',
	        description: "the download location for the ontology's source file",
	        defaultValue: {
	            locationType: 'UriLocation',
	            uri: 'http://example.com/myontology.json',
	        },
	    },
	    textIndexFields: {
	        type: 'frozen',
	        description: 'JSON paths for text fields that will be indexed for text searching',
	        defaultValue: defaultTextIndexFields,
	    },
	});
	function isOntologyClass(term) {
	    return term.type === 'CLASS';
	}
	function isOntologyProperty(term) {
	    return term.type === 'PROPERTY';
	}

	async function fetchValidDescendantTerms(parentFeature, ontologyStore, _signal) {
	    if (!parentFeature) {
	        return;
	    }
	    // since this is a child of an existing feature, restrict the autocomplete choices to valid
	    // parts of that feature
	    const parentTypeTerms = await ontologyStore.getTermsWithLabelOrSynonym(parentFeature.type, { includeSubclasses: false });
	    // eslint-disable-next-line unicorn/no-array-callback-reference
	    const parentTypeClassTerms = parentTypeTerms.filter(isOntologyClass);
	    if (parentTypeTerms.length === 0) {
	        return;
	    }
	    const subpartTerms = await ontologyStore.getClassesThat('part_of', parentTypeClassTerms);
	    if (subpartTerms.length === 0) {
	        return;
	    }
	    return subpartTerms;
	}

	/* eslint-disable @typescript-eslint/no-unnecessary-condition */
	function OntologyTermAutocomplete({ fetchValidTerms, filterTerms: filterTermsProp, includeDeprecated, onChange, ontologyName, ontologyVersion, renderInput, session, style, value: valueString, }) {
	    const [open, setOpen] = React.useState(false);
	    const [termChoices, setTermChoices] = React.useState();
	    const [currentOntologyTermInvalid, setCurrentOntologyTermInvalid] = React.useState('');
	    const [currentOntologyTerm, setCurrentOntologyTerm] = React.useState();
	    const { ontologyManager } = session.apolloDataStore;
	    const ontologyStore = ontologyManager.findOntology(ontologyName, ontologyVersion)?.dataStore;
	    const needToLoadTermChoices = ontologyStore && open && !termChoices;
	    const needToLoadCurrentTerm = ontologyStore && !currentOntologyTerm;
	    const filterTerms = React.useCallback((term) => 
	    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
	    (includeDeprecated || !isDeprecated(term)) &&
	        (!filterTermsProp || filterTermsProp(term)), [filterTermsProp, includeDeprecated]);
	    // effect for clearing choices when not open
	    React.useEffect(() => {
	        if (!open) {
	            setTermChoices(undefined);
	        }
	    }, [open]);
	    // effect for matching the current value with an ontology term
	    React.useEffect(() => {
	        const controller = new AbortController();
	        const { signal } = controller;
	        if (needToLoadCurrentTerm) {
	            setCurrentOntologyTermInvalid('');
	            getCurrentTerm(ontologyStore, valueString, filterTerms).then((term) => {
	                if (!signal.aborted) {
	                    setCurrentOntologyTerm(term);
	                }
	            }, (error) => {
	                if (!signal.aborted && !isAbortException_1(error)) {
	                    setCurrentOntologyTermInvalid(String(error));
	                }
	            });
	        }
	        return () => {
	            controller.abort();
	        };
	    }, [session, valueString, filterTerms, ontologyStore, needToLoadCurrentTerm]);
	    // effect for loading term autocompletions
	    React.useEffect(() => {
	        const controller = new AbortController();
	        const { signal } = controller;
	        if (needToLoadTermChoices) {
	            getValidTerms(ontologyStore, fetchValidTerms, filterTerms, signal).then((soTerms) => {
	                if (soTerms && !signal.aborted) {
	                    setTermChoices(soTerms);
	                }
	            }, (error) => {
	                if (!signal.aborted && !isAbortException_1(error)) {
	                    session.notify(error instanceof Error ? error.message : String(error), 'error');
	                }
	            });
	        }
	        return () => {
	            controller.abort();
	        };
	    }, [
	        needToLoadTermChoices,
	        filterTerms,
	        ontologyStore,
	        session,
	        fetchValidTerms,
	    ]);
	    const handleChange = (event, newValue) => {
	        if (!newValue) {
	            return;
	        }
	        if (typeof newValue === 'string') {
	            setCurrentOntologyTerm(undefined);
	            onChange(valueString, newValue);
	        }
	        else if (newValue.lbl !== valueString) {
	            setCurrentOntologyTermInvalid('');
	            setCurrentOntologyTerm(newValue);
	            onChange(valueString, newValue.lbl);
	        }
	    };
	    const extraTextFieldParams = {};
	    if (currentOntologyTermInvalid) {
	        extraTextFieldParams.error = true;
	        extraTextFieldParams.helperText = currentOntologyTermInvalid;
	    }
	    return (React__default["default"].createElement(material.Autocomplete, { style: style, autoComplete: true, filterSelectedOptions: true, disableClearable: true, selectOnFocus: true, clearOnBlur: true, handleHomeEndKeys: true, freeSolo: true, value: valueString, options: termChoices ?? [], onOpen: () => {
	            setOpen(true);
	        }, onClose: () => {
	            setOpen(false);
	        }, 
	        // noOptionsText={valueString ? 'No matches' : 'Start typing to search'}
	        loading: needToLoadTermChoices, renderInput: renderInput ??
	            ((params) => React__default["default"].createElement(material.TextField, { ...params, ...extraTextFieldParams })), getOptionLabel: (option) => {
	            if (typeof option === 'string') {
	                return option;
	            }
	            return option.lbl ?? '';
	        }, isOptionEqualToValue: (option, val) => option.lbl === val.lbl, onChange: handleChange }));
	}
	async function getCurrentTerm(ontologyStore, currentTermLabel, filterTerms, _signal) {
	    if (!currentTermLabel) {
	        return;
	    }
	    // TODO: support prefixed IDs as ontology terms here (e.g. SO:001234)
	    const terms = await ontologyStore.getTermsWithLabelOrSynonym(currentTermLabel, { includeSubclasses: false });
	    const term = terms.find((term) => (filterTerms ?? (() => true))(term));
	    if (!term) {
	        throw new Error(`not a valid ${ontologyStore.ontologyName} term`);
	    }
	    return term;
	}
	async function getValidTerms(ontologyStore, fetchValidTerms, filterTerms, signal) {
	    let result;
	    if (fetchValidTerms) {
	        const customTermList = await fetchValidTerms(ontologyStore, signal);
	        if (customTermList) {
	            result = customTermList;
	        }
	    }
	    if (!result) {
	        result = await ontologyStore.getAllTerms();
	    }
	    return filterTerms ? result.filter((element) => filterTerms(element)) : result;
	}

	/* eslint-disable @typescript-eslint/unbound-method */
	function AddChildFeature({ changeManager, handleClose, session, sourceAssemblyId, sourceFeature, }) {
	    const [end, setEnd] = React.useState(String(sourceFeature.max));
	    const [start, setStart] = React.useState(String(sourceFeature.min + 1));
	    const [type, setType] = React.useState('');
	    const [errorMessage, setErrorMessage] = React.useState('');
	    const [typeWarningText, setTypeWarningText] = React.useState('');
	    async function fetchValidTerms(parentFeature, ontologyStore, _signal) {
	        const terms = await fetchValidDescendantTerms(parentFeature, ontologyStore);
	        if (!terms) {
	            setTypeWarningText(`Type "${parentFeature?.type}" does not have any children in the ontology`);
	            return;
	        }
	        return terms;
	    }
	    function onSubmit(event) {
	        event.preventDefault();
	        setErrorMessage('');
	        const change = new dist$2.AddFeatureChange({
	            changedIds: [sourceFeature._id],
	            typeName: 'AddFeatureChange',
	            assembly: sourceAssemblyId,
	            addedFeature: {
	                _id: new objectid().toHexString(),
	                refSeq: sourceFeature.refSeq,
	                min: Number(start) - 1,
	                max: Number(end),
	                type,
	            },
	            parentFeatureId: sourceFeature._id,
	        });
	        void changeManager.submit(change);
	        handleClose();
	        event.preventDefault();
	    }
	    function handleChangeType(newType) {
	        setErrorMessage('');
	        setType(newType);
	    }
	    const error = Number(end) <= Number(start);
	    return (React__default["default"].createElement(Dialog, { open: true, title: "Add new child feature", handleClose: handleClose, maxWidth: false, "data-testid": "add-feature-dialog" },
	        React__default["default"].createElement("form", { onSubmit: onSubmit },
	            React__default["default"].createElement(material.DialogContent, { style: { display: 'flex', flexDirection: 'column' } },
	                React__default["default"].createElement(material.TextField, { margin: "dense", id: "start", label: "Start", type: "number", fullWidth: true, variant: "outlined", value: start, onChange: (e) => {
	                        setStart(e.target.value);
	                    } }),
	                React__default["default"].createElement(material.TextField, { margin: "dense", id: "end", label: "End", type: "number", fullWidth: true, variant: "outlined", value: end, onChange: (e) => {
	                        setEnd(e.target.value);
	                    }, error: error, helperText: error ? '"End" must be greater than "Start"' : null }),
	                React__default["default"].createElement(OntologyTermAutocomplete, { session: session, ontologyName: "Sequence Ontology", style: { width: 170 }, value: type, filterTerms: isOntologyClass, fetchValidTerms: fetchValidTerms.bind(null, sourceFeature), renderInput: (params) => (React__default["default"].createElement(material.TextField, { ...params, label: "Type", variant: "outlined", fullWidth: true, error: Boolean(typeWarningText), helperText: typeWarningText })), onChange: (oldValue, newValue) => {
	                        if (newValue) {
	                            handleChangeType(newValue);
	                        }
	                    } })),
	            React__default["default"].createElement(material.DialogActions, null,
	                React__default["default"].createElement(material.Button, { variant: "contained", type: "submit", disabled: error || !(start && end && type) }, "Submit"),
	                React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: handleClose }, "Cancel"))),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	/* eslint-disable @typescript-eslint/unbound-method */
	var NewFeature;
	(function (NewFeature) {
	    NewFeature["GENE_AND_SUBFEATURES"] = "GENE_AND_SUBFEATURES";
	    NewFeature["TRANSCRIPT_AND_SUBFEATURES"] = "TRANSCRIPT_AND_SUBFEATURES";
	    NewFeature["CUSTOM"] = "CUSTOM";
	})(NewFeature || (NewFeature = {}));
	function makeCodingMrna(refSeqId, strand, min, max) {
	    const cds = {
	        _id: new objectid().toHexString(),
	        refSeq: refSeqId,
	        type: 'CDS',
	        min,
	        max,
	        strand,
	    };
	    const exon = {
	        _id: new objectid().toHexString(),
	        refSeq: refSeqId,
	        type: 'exon',
	        min,
	        max,
	        strand,
	    };
	    const children = {};
	    children[cds._id] = cds;
	    children[exon._id] = exon;
	    const mRNA = {
	        _id: new objectid().toHexString(),
	        refSeq: refSeqId,
	        type: 'mRNA',
	        min,
	        max,
	        strand,
	        children,
	    };
	    return mRNA;
	}
	function AddFeature({ changeManager, handleClose, region, session, }) {
	    const [end, setEnd] = React.useState(String(region.end));
	    const [start, setStart] = React.useState(String(region.start + 1));
	    const [type, setType] = React.useState(NewFeature.GENE_AND_SUBFEATURES);
	    const [customType, setCustomType] = React.useState();
	    const [strand, setStrand] = React.useState();
	    const [errorMessage, setErrorMessage] = React.useState('');
	    function onSubmit(event) {
	        event.preventDefault();
	        setErrorMessage('');
	        let refSeqId;
	        for (const [, asm] of session.apolloDataStore.assemblies ?? new Map()) {
	            if (asm._id === region.assemblyName) {
	                for (const [, refseq] of asm.refSeqs ?? new Map()) {
	                    if (refseq.name === region.refName) {
	                        refSeqId = refseq._id;
	                    }
	                }
	            }
	        }
	        if (!refSeqId) {
	            setErrorMessage('Invalid refseq id. Make sure you have the Apollo annotation track open');
	            return;
	        }
	        if (type === NewFeature.GENE_AND_SUBFEATURES) {
	            const mRNA = makeCodingMrna(refSeqId, strand, Number(start) - 1, Number(end));
	            const children = {};
	            children[mRNA._id] = mRNA;
	            const id = new objectid().toHexString();
	            const change = new dist$2.AddFeatureChange({
	                changedIds: [id],
	                typeName: 'AddFeatureChange',
	                assembly: region.assemblyName,
	                addedFeature: {
	                    _id: id,
	                    refSeq: refSeqId,
	                    min: Number(start) - 1,
	                    max: Number(end),
	                    type: 'gene',
	                    strand,
	                    children,
	                },
	            });
	            void changeManager.submit(change);
	            handleClose();
	            return;
	        }
	        if (type === NewFeature.TRANSCRIPT_AND_SUBFEATURES) {
	            const mRNA = makeCodingMrna(refSeqId, strand, Number(start) - 1, Number(end));
	            const change = new dist$2.AddFeatureChange({
	                changedIds: [mRNA._id],
	                typeName: 'AddFeatureChange',
	                assembly: region.assemblyName,
	                addedFeature: mRNA,
	            });
	            void changeManager.submit(change);
	            handleClose();
	            return;
	        }
	        if (!customType) {
	            setErrorMessage('No type selected');
	            return;
	        }
	        const id = new objectid().toHexString();
	        const change = new dist$2.AddFeatureChange({
	            changedIds: [id],
	            typeName: 'AddFeatureChange',
	            assembly: region.assemblyName,
	            addedFeature: {
	                _id: id,
	                refSeq: refSeqId,
	                min: Number(start) - 1,
	                max: Number(end),
	                type: customType,
	                strand,
	            },
	        });
	        void changeManager.submit(change);
	        handleClose();
	        return;
	    }
	    function handleChangeStrand(e) {
	        setErrorMessage('');
	        switch (Number(e.target.value)) {
	            case 1: {
	                setStrand(1);
	                break;
	            }
	            case -1: {
	                setStrand(-1);
	                break;
	            }
	            default: {
	                setStrand(undefined);
	            }
	        }
	    }
	    const error = Number(end) <= Number(start);
	    function handleChangeOntologyType(newType) {
	        setErrorMessage('');
	        setCustomType(newType);
	    }
	    const handleTypeChange = (e) => {
	        setErrorMessage('');
	        const { value } = e.target;
	        if (Object.keys(NewFeature).includes(value)) {
	            setType(NewFeature[value]);
	        }
	    };
	    let submitDisabled = Boolean(error) || !(start && end && type);
	    if ((type === NewFeature.CUSTOM && !customType) ||
	        (!strand && type === NewFeature.GENE_AND_SUBFEATURES) ||
	        (!strand && type === NewFeature.TRANSCRIPT_AND_SUBFEATURES)) {
	        submitDisabled = true;
	    }
	    return (React__default["default"].createElement(Dialog, { open: true, title: "Add new feature", handleClose: handleClose, maxWidth: false, "data-testid": "add-feature-dialog" },
	        React__default["default"].createElement("form", { onSubmit: onSubmit, "data-testid": "submit-form" },
	            React__default["default"].createElement(material.DialogContent, { style: { display: 'flex', flexDirection: 'column' } },
	                React__default["default"].createElement(material.TextField, { margin: "dense", id: "start", label: "Start", type: "number", fullWidth: true, variant: "outlined", value: Number(start), onChange: (e) => {
	                        setStart(e.target.value);
	                    } }),
	                React__default["default"].createElement(material.TextField, { margin: "dense", id: "end", label: "End", type: "number", fullWidth: true, variant: "outlined", value: end, onChange: (e) => {
	                        setEnd(e.target.value);
	                    }, error: error, helperText: error ? '"End" must be greater than "Start"' : null }),
	                React__default["default"].createElement(material.FormControl, null,
	                    React__default["default"].createElement(material.InputLabel, { id: "demo-simple-select-label" }, "Strand"),
	                    React__default["default"].createElement(material.Select, { labelId: "demo-simple-select-label", id: "demo-simple-select", label: "Strand", value: strand?.toString(), onChange: handleChangeStrand },
	                        React__default["default"].createElement(material.MenuItem, { value: undefined }),
	                        React__default["default"].createElement(material.MenuItem, { value: 1 }, "+"),
	                        React__default["default"].createElement(material.MenuItem, { value: -1 }, "-"))),
	                React__default["default"].createElement(material.FormControl, { style: { marginTop: 20 } },
	                    React__default["default"].createElement(material.RadioGroup, { "aria-labelledby": "demo-radio-buttons-group-label", defaultValue: NewFeature.GENE_AND_SUBFEATURES, name: "radio-buttons-group", value: type, onChange: handleTypeChange },
	                        React__default["default"].createElement(material.FormControlLabel, { value: NewFeature.GENE_AND_SUBFEATURES, control: React__default["default"].createElement(material.Radio, null), label: React__default["default"].createElement(material.Box, { display: "flex", alignItems: "center" },
	                                "Add gene and sub-features",
	                                React__default["default"].createElement(material.Tooltip, { title: "This is a shortcut to create a gene with a single mRNA, exon, and CDS" },
	                                    React__default["default"].createElement(material.IconButton, { size: "small" },
	                                        React__default["default"].createElement(default_1$o, { sx: { fontSize: 18 } })))) }),
	                        React__default["default"].createElement(material.FormControlLabel, { value: NewFeature.TRANSCRIPT_AND_SUBFEATURES, control: React__default["default"].createElement(material.Radio, null), label: React__default["default"].createElement(material.Box, { display: "flex", alignItems: "center" },
	                                "Add transcript and sub-features",
	                                React__default["default"].createElement(material.Tooltip, { title: "This is a shortcut to create a single mRNA with exon and CDS, but without a parent gene" },
	                                    React__default["default"].createElement(material.IconButton, { size: "small" },
	                                        React__default["default"].createElement(default_1$o, { sx: { fontSize: 18 } })))) }),
	                        React__default["default"].createElement(material.FormControlLabel, { value: NewFeature.CUSTOM, checked: type !== NewFeature.GENE_AND_SUBFEATURES &&
	                                type !== NewFeature.TRANSCRIPT_AND_SUBFEATURES, control: React__default["default"].createElement(material.Radio, null), label: "Add feature with a sequence ontology type" }))),
	                type === NewFeature.CUSTOM ? (React__default["default"].createElement(OntologyTermAutocomplete, { session: session, ontologyName: "Sequence Ontology", style: { width: 170 }, value: "", filterTerms: isOntologyClass, renderInput: (params) => (React__default["default"].createElement(material.TextField, { ...params, label: "Type", variant: "outlined", fullWidth: true })), onChange: (_oldValue, newValue) => {
	                        if (newValue) {
	                            handleChangeOntologyType(newValue);
	                        }
	                    } })) : null),
	            React__default["default"].createElement(material.DialogActions, null,
	                React__default["default"].createElement(material.Button, { variant: "contained", type: "submit", disabled: submitDisabled }, "Submit"),
	                React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: handleClose }, "Cancel"))),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	/**
	 * Recursively assign new IDs to a feature
	 * @param feature - Parent feature
	 * @param featureIds -
	 */
	function generateNewIds(
	// feature: AnnotationFeatureSnapshot,
	feature, featureIds) {
	    const newId = new objectid().toHexString();
	    featureIds.push(newId);
	    const children = {};
	    if (feature.children) {
	        for (const child of Object.values(feature.children)) {
	            const newChild = generateNewIds(child, featureIds);
	            children[newChild._id] = newChild;
	        }
	    }
	    const referenceSeq = typeof feature.refSeq === 'string'
	        ? feature.refSeq
	        : feature.refSeq.toHexString();
	    return {
	        ...feature,
	        refSeq: referenceSeq,
	        children: feature.children && children,
	        _id: newId,
	    };
	}
	function CopyFeature({ changeManager, handleClose, session, sourceAssemblyId, sourceFeature, }) {
	    const { assemblyManager } = session;
	    const assemblies = assemblyManager.assemblyList;
	    const [selectedAssemblyId, setSelectedAssemblyId] = React.useState(assemblies.find((a) => a.name !== sourceAssemblyId)?.name);
	    const [refNames, setRefNames] = React.useState([]);
	    const [selectedRefSeqId, setSelectedRefSeqId] = React.useState('');
	    const [start, setStart] = React.useState(sourceFeature.min);
	    const [errorMessage, setErrorMessage] = React.useState('');
	    function handleChangeAssembly(e) {
	        setSelectedAssemblyId(e.target.value);
	    }
	    React.useEffect(() => {
	        setSelectedRefSeqId('');
	        async function getRefNames() {
	            if (!selectedAssemblyId) {
	                setErrorMessage('No assemblies to copy to');
	                return;
	            }
	            const assembly = await assemblyManager.waitForAssembly(selectedAssemblyId);
	            if (!assembly) {
	                return;
	            }
	            const { refNameAliases } = assembly;
	            if (!refNameAliases) {
	                return;
	            }
	            const newRefNames = [...Object.entries(refNameAliases)]
	                .filter(([id, refName]) => id !== refName)
	                .map(([id, refName]) => ({ _id: id, name: refName }));
	            setRefNames(newRefNames);
	            setSelectedRefSeqId(newRefNames[0]?._id || '');
	        }
	        getRefNames().catch((error) => {
	            setErrorMessage(String(error));
	        });
	    }, [selectedAssemblyId, assemblyManager]);
	    function handleChangeRefSeq(e) {
	        const refSeq = e.target.value;
	        setSelectedRefSeqId(refSeq);
	    }
	    async function onSubmit(event) {
	        if (!selectedAssemblyId) {
	            return;
	        }
	        event.preventDefault();
	        setErrorMessage('');
	        const featureLength = sourceFeature.length;
	        const assembly = await assemblyManager.waitForAssembly(selectedAssemblyId);
	        if (!assembly) {
	            setErrorMessage(`Assembly not found: ${selectedAssemblyId}.`);
	            return;
	        }
	        const canonicalRefName = assembly.getCanonicalRefName(selectedRefSeqId);
	        const region = assembly.regions?.find((r) => r.refName === canonicalRefName);
	        if (!region) {
	            setErrorMessage(`RefSeq not found: ${selectedRefSeqId}.`);
	            return;
	        }
	        const newEnd = start + featureLength;
	        if (newEnd > region.end) {
	            setErrorMessage(`Feature would extend beyond the bounds of the selected reference sequence. (Feature would end at ${newEnd}, but reference sequence ends at ${region.end})`);
	            return;
	        }
	        if (start < region.start) {
	            setErrorMessage(`Reference sequence starts at ${region.start}, feature cannot start before that.`);
	            return;
	        }
	        const featureIds = [];
	        // Let's add featureId to each child recursively
	        const newFeatureLine = generateNewIds(require$$1$3.getSnapshot(sourceFeature), featureIds);
	        // Clear possible parentId -attribute.
	        const attributeMap = {
	            ...newFeatureLine.attributes,
	        };
	        if ('Parent' in attributeMap) {
	            delete attributeMap.Parent;
	        }
	        newFeatureLine.refSeq = selectedRefSeqId;
	        const locationMove = start - newFeatureLine.min;
	        newFeatureLine.min = start;
	        newFeatureLine.max = start + featureLength;
	        // Updates children start and end values
	        const updatedChildren = updateRefSeqStartEnd(newFeatureLine, locationMove);
	        const change = new dist$2.AddFeatureChange({
	            changedIds: [newFeatureLine._id],
	            typeName: 'AddFeatureChange',
	            assembly: selectedAssemblyId,
	            addedFeature: {
	                _id: newFeatureLine._id,
	                refSeq: newFeatureLine.refSeq,
	                min: newFeatureLine.min,
	                max: newFeatureLine.max,
	                type: newFeatureLine.type,
	                children: updatedChildren.children,
	                attributes: attributeMap,
	                strand: newFeatureLine.strand,
	            },
	            copyFeature: true,
	            allIds: featureIds,
	        });
	        void changeManager.submit(change);
	        handleClose();
	        event.preventDefault();
	    }
	    /**
	     * Recursively loop children and update refSeq, start, and end values
	     * @param feature - parent feature
	     * @param locationMove - how much location has been moved from original
	     * @returns
	     */
	    function updateRefSeqStartEnd(feature, locationMove) {
	        const children = {};
	        if (feature.children) {
	            for (const child of Object.values(feature.children)) {
	                const newChild = updateRefSeqStartEnd(child, locationMove);
	                newChild.refSeq = selectedRefSeqId;
	                newChild.min = newChild.min + locationMove;
	                newChild.max = newChild.max + locationMove;
	                children[newChild._id] = newChild;
	            }
	        }
	        const refSeq = typeof feature.refSeq === 'string'
	            ? feature.refSeq
	            : feature.refSeq.toHexString();
	        const id = typeof feature._id === 'string'
	            ? feature._id
	            : feature._id.toHexString();
	        return {
	            ...feature,
	            refSeq,
	            children: feature.children && children,
	            _id: id,
	        };
	    }
	    return (React__default["default"].createElement(Dialog, { open: true, title: "Copy features and annotations", handleClose: handleClose, maxWidth: false, "data-testid": "copy-feature" },
	        React__default["default"].createElement("form", { onSubmit: onSubmit },
	            React__default["default"].createElement(material.DialogContent, { style: { display: 'flex', flexDirection: 'column' } },
	                React__default["default"].createElement(material.DialogContentText, null, "Target assembly"),
	                React__default["default"].createElement(material.Select, { labelId: "label", value: selectedAssemblyId, onChange: handleChangeAssembly }, assemblies
	                    .filter((option) => option.name !== sourceAssemblyId)
	                    .map((option) => (React__default["default"].createElement(material.MenuItem, { key: option.name, value: option.name }, configuration.readConfObject(option, 'displayName'))))),
	                React__default["default"].createElement(material.DialogContentText, null, "Target reference sequence"),
	                React__default["default"].createElement(material.Select, { labelId: "label", value: selectedRefSeqId, onChange: handleChangeRefSeq }, refNames.map((option) => (React__default["default"].createElement(material.MenuItem, { key: option._id, value: option._id }, option.name)))),
	                React__default["default"].createElement(material.DialogContentText, null, "Start position in target reference sequence"),
	                React__default["default"].createElement(material.TextField, { margin: "dense", type: "number", fullWidth: true, variant: "outlined", value: start, onChange: (e) => {
	                        setStart(Number(e.target.value));
	                    } })),
	            React__default["default"].createElement(material.DialogActions, null,
	                React__default["default"].createElement(material.Button, { disabled: !selectedAssemblyId || !selectedRefSeqId || !start, variant: "contained", type: "submit" }, "Submit"),
	                React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: handleClose }, "Cancel"))),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	/* eslint-disable @typescript-eslint/unbound-method */
	function DeleteAssembly({ changeManager, handleClose, session, }) {
	    const { internetAccounts } = require$$1$3.getRoot(session);
	    const [selectedAssembly, setSelectedAssembly] = React.useState();
	    const [errorMessage, setErrorMessage] = React.useState('');
	    const [confirmDelete, setconfirmDelete] = React.useState(false);
	    const [submitted, setSubmitted] = React.useState(false);
	    const apolloInternetAccounts = internetAccounts.filter((ia) => ia.type === 'ApolloInternetAccount');
	    if (apolloInternetAccounts.length === 0) {
	        throw new Error('No Apollo internet account found');
	    }
	    const [selectedInternetAccount, setSelectedInternetAccount] = React.useState(apolloInternetAccounts[0]);
	    const { collaborationServerDriver } = session.apolloDataStore;
	    const assemblies = collaborationServerDriver.getAssemblies();
	    React.useEffect(() => {
	        if (assemblies.length > 0 && selectedAssembly === undefined) {
	            setSelectedAssembly(assemblies[0]);
	        }
	    }, [assemblies, selectedAssembly]);
	    function handleChangeInternetAccount(e) {
	        setSubmitted(false);
	        const newlySelectedInternetAccount = apolloInternetAccounts.find((ia) => ia.internetAccountId === e.target.value);
	        if (!newlySelectedInternetAccount) {
	            throw new Error(`Could not find internetAccount with ID "${e.target.value}"`);
	        }
	        setSelectedInternetAccount(newlySelectedInternetAccount);
	    }
	    function handleChangeAssembly(e) {
	        const newAssembly = assemblies.find((asm) => asm.name === e.target.value);
	        setSelectedAssembly(newAssembly);
	    }
	    async function onSubmit(event) {
	        event.preventDefault();
	        setSubmitted(true);
	        setErrorMessage('');
	        if (!selectedAssembly) {
	            setErrorMessage('Must select assembly!');
	            return;
	        }
	        const change = new dist$2.DeleteAssemblyChange({
	            typeName: 'DeleteAssemblyChange',
	            assembly: selectedAssembly.name,
	        });
	        await changeManager.submit(change, {
	            internetAccountId: selectedInternetAccount.internetAccountId,
	        });
	        handleClose();
	        event.preventDefault();
	    }
	    return (React__default["default"].createElement(Dialog, { open: true, title: "Delete Assembly", handleClose: handleClose, maxWidth: false, "data-testid": "delete-assembly" },
	        React__default["default"].createElement("form", { onSubmit: onSubmit },
	            React__default["default"].createElement(material.DialogContent, { style: { display: 'flex', flexDirection: 'column' } },
	                apolloInternetAccounts.length > 1 ? (React__default["default"].createElement(React__default["default"].Fragment, null,
	                    React__default["default"].createElement(material.DialogContentText, null, "Select account"),
	                    React__default["default"].createElement(material.Select, { value: selectedInternetAccount.internetAccountId, onChange: handleChangeInternetAccount, disabled: submitted && !errorMessage }, internetAccounts.map((option) => (React__default["default"].createElement(material.MenuItem, { key: option.id, value: option.internetAccountId }, option.name)))))) : null,
	                React__default["default"].createElement(material.DialogContentText, null, "Select assembly"),
	                React__default["default"].createElement(material.Select, { labelId: "label", value: selectedAssembly?.name ?? '', onChange: handleChangeAssembly, disabled: assemblies.length === 0 }, assemblies.map((option) => (React__default["default"].createElement(material.MenuItem, { key: option.name, value: option.name }, option.displayName ?? option.name)))),
	                React__default["default"].createElement(material.DialogContentText, null,
	                    React__default["default"].createElement("strong", { style: { color: 'red' } }, "NOTE: All assembly data will be deleted and this operation cannot be undone!")),
	                React__default["default"].createElement(material.FormGroup, null,
	                    React__default["default"].createElement(material.FormControlLabel, { control: React__default["default"].createElement(material.Checkbox, { checked: confirmDelete, onChange: () => {
	                                setconfirmDelete(!confirmDelete);
	                            } }), label: "I understand that all assembly data will be deleted" }))),
	            React__default["default"].createElement(material.DialogActions, null,
	                React__default["default"].createElement(material.Button, { disabled: !selectedAssembly || !confirmDelete, variant: "contained", type: "submit" }, "Delete"),
	                React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: handleClose }, "Cancel"))),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	/* eslint-disable @typescript-eslint/unbound-method */
	function lumpLocationChanges(changes, assembly) {
	    if (changes.length === 0) {
	        return;
	    }
	    const locationStartChange = new dist$2.LocationStartChange({
	        typeName: 'LocationStartChange',
	        changedIds: [],
	        changes: [],
	        assembly,
	    });
	    const locationEndChange = new dist$2.LocationEndChange({
	        typeName: 'LocationEndChange',
	        changedIds: [],
	        changes: [],
	        assembly,
	    });
	    for (const change of changes) {
	        if (change.typeName === 'LocationStartChange') {
	            locationStartChange.changedIds.push(change.changedId);
	            const cc = {
	                featureId: change.featureId,
	                oldStart: change.oldLocation,
	                newStart: change.newLocation,
	            };
	            locationStartChange.changes.push(cc);
	        }
	        if (change.typeName === 'LocationEndChange') {
	            locationEndChange.changedIds.push(change.changedId);
	            const cc = {
	                featureId: change.featureId,
	                oldEnd: change.oldLocation,
	                newEnd: change.newLocation,
	            };
	            locationEndChange.changes.push(cc);
	        }
	    }
	    if (locationStartChange.changedIds.length > 0 &&
	        locationEndChange.changedIds.length === 0) {
	        return locationStartChange;
	    }
	    if (locationEndChange.changedIds.length > 0 &&
	        locationStartChange.changedIds.length === 0) {
	        return locationEndChange;
	    }
	    throw new Error('Unexpected list of changes');
	}
	function DeleteFeature({ changeManager, handleClose, selectedFeature, session, setSelectedFeature, sourceAssemblyId, sourceFeature, }) {
	    const [errorMessage, setErrorMessage] = React.useState('');
	    const { ontologyManager } = session.apolloDataStore;
	    const { featureTypeOntology } = ontologyManager;
	    function trimCDS(sourceFeature) {
	        if (!featureTypeOntology) {
	            return;
	        }
	        if (!featureTypeOntology.isTypeOf(sourceFeature.type, 'exon')) {
	            return;
	        }
	        if (!sourceFeature.parent?.cdsLocations ||
	            sourceFeature.parent.cdsLocations.length === 0 ||
	            sourceFeature.parent.cdsLocations[0].length === 0) {
	            // No CDS - parent of this exon is a non-coding transcript
	            return;
	        }
	        if (!sourceFeature.parent.children) {
	            throw new Error('Unable to find parent of CDS');
	        }
	        if (sourceFeature.parent.cdsLocations.length != 1) {
	            throw new Error('Unable to handle a transcript with multiple CDSs');
	        }
	        const _cdsLocations = sourceFeature.parent.cdsLocations.at(0) ?? [];
	        const cdsLocations = _cdsLocations.sort(({ min: a }, { min: b }) => a - b);
	        let cdsFeature;
	        for (const child of sourceFeature.parent.children.values()) {
	            if (child.type === cdsLocations[0].type) {
	                cdsFeature = child;
	                break;
	            }
	        }
	        if (!cdsFeature) {
	            throw new Error('Unable to find CDS');
	        }
	        const cdsStart = cdsLocations[0].min;
	        // eslint-disable-next-line unicorn/prefer-at
	        const cdsEnd = cdsLocations[cdsLocations.length - 1].max;
	        if ((sourceFeature.min > cdsStart && sourceFeature.max < cdsEnd) ||
	            sourceFeature.max < cdsStart ||
	            sourceFeature.min > cdsEnd) {
	            // No adjustment if the exon being deleted is fully contained in the CDS
	            // or completely outside of the CDS
	            return;
	        }
	        if (sourceFeature.min <= cdsStart && sourceFeature.max >= cdsEnd) {
	            // CDS is fully contained in the exon, delete CDS
	            return new dist$2.DeleteFeatureChange({
	                changedIds: [cdsFeature._id],
	                typeName: 'DeleteFeatureChange',
	                assembly: sourceAssemblyId,
	                changes: [
	                    {
	                        deletedFeature: require$$1$3.getSnapshot(cdsFeature),
	                        parentFeatureId: cdsFeature.parent?._id,
	                    },
	                ],
	            });
	        }
	        if (sourceFeature.min <= cdsStart && sourceFeature.max > cdsStart) {
	            // Exon overlaps the start of the CDS so we need to move the CDS start
	            let newCdsStart;
	            for (const cdsLocation of cdsLocations) {
	                if (cdsLocation.min > sourceFeature.max) {
	                    newCdsStart = cdsLocation.min;
	                    break;
	                }
	            }
	            if (!newCdsStart) {
	                throw new Error('Error setting new CDS start');
	            }
	            return {
	                typeName: 'LocationStartChange',
	                changedId: cdsFeature._id,
	                featureId: cdsFeature._id,
	                oldLocation: cdsFeature.min,
	                newLocation: newCdsStart,
	            };
	        }
	        if (sourceFeature.min < cdsEnd && sourceFeature.max >= cdsEnd) {
	            // Exon overlaps the end of the CDS so we need to move the CDS end
	            let newCdsEnd;
	            for (const cdsLocation of cdsLocations.reverse()) {
	                if (cdsLocation.max < sourceFeature.min) {
	                    newCdsEnd = cdsLocation.max;
	                    break;
	                }
	            }
	            if (!newCdsEnd) {
	                throw new Error('Error setting new CDS end');
	            }
	            return {
	                typeName: 'LocationEndChange',
	                changedId: cdsFeature._id,
	                featureId: cdsFeature._id,
	                oldLocation: cdsFeature.max,
	                newLocation: newCdsEnd,
	            };
	        }
	        throw new Error('Unexpected relationship between exon and CDS');
	    }
	    function trimParent(featureToDelete) {
	        if (!featureToDelete.parent?.children ||
	            featureToDelete.parent.children.size === 1) {
	            // Do not resize if this parent has only one child (i.e. the feature being deleted)
	            return;
	        }
	        const childrenByStart = [];
	        for (const x of featureToDelete.parent.children.values()) {
	            if (!featureTypeOntology?.isTypeOf(x.type, 'CDS')) {
	                // CDS has been already handled so don't use it to resize parent
	                childrenByStart.push(x);
	            }
	        }
	        childrenByStart.sort((a, b) => a.min - b.min);
	        const childrenByEnd = [];
	        for (const x of featureToDelete.parent.children.values()) {
	            if (!featureTypeOntology?.isTypeOf(x.type, 'CDS')) {
	                // CDS has been already handled so don't use it to resize parent
	                childrenByEnd.push(x);
	            }
	        }
	        childrenByEnd.sort((a, b) => b.max - a.max);
	        if (featureToDelete.min === childrenByStart[0].min) {
	            // The feature to delete has the lowest start coordinate of all children
	            // Find the next lowest coordinate and reset parent to this new start
	            let newParentFeatureStart;
	            for (const child of childrenByStart) {
	                if (child._id !== featureToDelete._id &&
	                    child.min >= featureToDelete.min) {
	                    newParentFeatureStart = child.min;
	                    break;
	                }
	            }
	            if (newParentFeatureStart &&
	                newParentFeatureStart != featureToDelete.parent.min) {
	                return {
	                    typeName: 'LocationStartChange',
	                    changedId: featureToDelete.parent._id,
	                    featureId: featureToDelete.parent._id,
	                    oldLocation: featureToDelete.parent.min,
	                    newLocation: newParentFeatureStart,
	                };
	            }
	        }
	        if (featureToDelete.max === childrenByEnd[0].max) {
	            // The feature to delete has the highest end coordinate of all children
	            // Find the next highest coordinate and reset parent to this new end
	            let newParentFeatureEnd;
	            for (const child of childrenByEnd) {
	                if (child._id != featureToDelete._id &&
	                    child.max <= featureToDelete.max) {
	                    newParentFeatureEnd = child.max;
	                    break;
	                }
	            }
	            if (newParentFeatureEnd &&
	                newParentFeatureEnd != featureToDelete.parent.max) {
	                return {
	                    typeName: 'LocationEndChange',
	                    changedId: featureToDelete.parent._id,
	                    featureId: featureToDelete.parent._id,
	                    oldLocation: featureToDelete.parent.max,
	                    newLocation: newParentFeatureEnd,
	                };
	            }
	        }
	        return;
	    }
	    async function onSubmit(event) {
	        event.preventDefault();
	        setErrorMessage('');
	        if (selectedFeature?._id === sourceFeature._id) {
	            setSelectedFeature();
	        }
	        const locationChanges = [];
	        // const deleteChanges: DeleteFeatureChange = []
	        const deleteChanges = new dist$2.DeleteFeatureChange({
	            changedIds: [sourceFeature._id],
	            typeName: 'DeleteFeatureChange',
	            assembly: sourceAssemblyId,
	            changes: [
	                {
	                    deletedFeature: require$$1$3.getSnapshot(sourceFeature),
	                    parentFeatureId: sourceFeature.parent?._id,
	                },
	            ],
	        });
	        if (featureTypeOntology &&
	            (featureTypeOntology.isTypeOf(sourceFeature.type, 'transcript') ||
	                featureTypeOntology.isTypeOf(sourceFeature.type, 'pseudogenic_transcript'))) {
	            const geneChange = trimParent(sourceFeature);
	            if (geneChange) {
	                locationChanges.push(geneChange);
	            }
	        }
	        if (featureTypeOntology &&
	            featureTypeOntology.isTypeOf(sourceFeature.type, 'exon')) {
	            const cdsChange = trimCDS(sourceFeature);
	            if (cdsChange) {
	                if (cdsChange.typeName === 'DeleteFeatureChange') {
	                    deleteChanges.changedIds.push(...cdsChange.changedIds);
	                    deleteChanges.changes.push(...cdsChange.changes);
	                }
	                else {
	                    locationChanges.push(cdsChange);
	                }
	            }
	            const txChange = trimParent(sourceFeature);
	            if (txChange) {
	                locationChanges.push(txChange);
	                // Parent transcript has changed. See if we need to resize the parent gene
	                const gene = sourceFeature.parent?.parent;
	                if (gene?.children) {
	                    if (txChange.typeName === 'LocationStartChange') {
	                        let newGeneStart = txChange.newLocation;
	                        for (const [, tx] of gene.children) {
	                            if (tx._id != txChange.featureId && tx.min < newGeneStart) {
	                                // Reset to longest child (tx)
	                                newGeneStart = tx.min;
	                            }
	                        }
	                        if (newGeneStart != gene.min) {
	                            locationChanges.push({
	                                typeName: txChange.typeName,
	                                changedId: gene._id,
	                                featureId: gene._id,
	                                oldLocation: gene.min,
	                                newLocation: newGeneStart,
	                            });
	                        }
	                    }
	                    else {
	                        let newGeneEnd = txChange.newLocation;
	                        for (const [, tx] of gene.children) {
	                            if (tx._id != txChange.featureId && tx.max > newGeneEnd) {
	                                // Reset to longest child (tx)
	                                newGeneEnd = tx.max;
	                            }
	                        }
	                        if (newGeneEnd != gene.max) {
	                            locationChanges.push({
	                                typeName: txChange.typeName,
	                                changedId: gene._id,
	                                featureId: gene._id,
	                                oldLocation: gene.max,
	                                newLocation: newGeneEnd,
	                            });
	                        }
	                    }
	                }
	            }
	        }
	        const lumpedLocChanges = lumpLocationChanges(locationChanges, sourceAssemblyId);
	        await changeManager.submit(deleteChanges);
	        if (lumpedLocChanges) {
	            await changeManager.submit(lumpedLocChanges);
	        }
	        handleClose();
	        event.preventDefault();
	    }
	    return (React__default["default"].createElement(Dialog, { open: true, title: "Delete feature", handleClose: handleClose, maxWidth: false, "data-testid": "delete-feature" },
	        React__default["default"].createElement("form", { onSubmit: (event) => {
	                void onSubmit(event);
	            } },
	            React__default["default"].createElement(material.DialogContent, { style: { display: 'flex', flexDirection: 'column' } },
	                React__default["default"].createElement(material.DialogContentText, null, "Are you sure you want to delete the selected feature?")),
	            React__default["default"].createElement(material.DialogActions, null,
	                React__default["default"].createElement(material.Button, { variant: "contained", type: "submit" }, "Yes"),
	                React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: handleClose }, "Cancel"))),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	var FileSaver_min = {exports: {}};

	(function (module, exports) {
	  (function (a, b) {
	    b();
	  })(commonjsGlobal, function () {

	    function b(a, b) {
	      return "undefined" == typeof b ? b = {
	        autoBom: !1
	      } : "object" != _typeof(b) && (console.warn("Deprecated: Expected third argument to be a object"), b = {
	        autoBom: !b
	      }), b.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type) ? new Blob(["\uFEFF", a], {
	        type: a.type
	      }) : a;
	    }
	    function c(a, b, c) {
	      var d = new XMLHttpRequest();
	      d.open("GET", a), d.responseType = "blob", d.onload = function () {
	        g(d.response, b, c);
	      }, d.onerror = function () {
	        console.error("could not download file");
	      }, d.send();
	    }
	    function d(a) {
	      var b = new XMLHttpRequest();
	      b.open("HEAD", a, !1);
	      try {
	        b.send();
	      } catch (a) {}
	      return 200 <= b.status && 299 >= b.status;
	    }
	    function e(a) {
	      try {
	        a.dispatchEvent(new MouseEvent("click"));
	      } catch (c) {
	        var b = document.createEvent("MouseEvents");
	        b.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), a.dispatchEvent(b);
	      }
	    }
	    var f = "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && window.window === window ? window : "object" == (typeof self === "undefined" ? "undefined" : _typeof(self)) && self.self === self ? self : "object" == _typeof(commonjsGlobal) && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0,
	      a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent),
	      g = f.saveAs || ("object" != (typeof window === "undefined" ? "undefined" : _typeof(window)) || window !== f ? function () {} : "download" in HTMLAnchorElement.prototype && !a ? function (b, g, h) {
	        var i = f.URL || f.webkitURL,
	          j = document.createElement("a");
	        g = g || b.name || "download", j.download = g, j.rel = "noopener", "string" == typeof b ? (j.href = b, j.origin === location.origin ? e(j) : d(j.href) ? c(b, g, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b), setTimeout(function () {
	          i.revokeObjectURL(j.href);
	        }, 4E4), setTimeout(function () {
	          e(j);
	        }, 0));
	      } : "msSaveOrOpenBlob" in navigator ? function (f, g, h) {
	        if (g = g || f.name || "download", "string" != typeof f) navigator.msSaveOrOpenBlob(b(f, h), g);else if (d(f)) c(f, g, h);else {
	          var i = document.createElement("a");
	          i.href = f, i.target = "_blank", setTimeout(function () {
	            e(i);
	          });
	        }
	      } : function (b, d, e, g) {
	        if (g = g || open("", "_blank"), g && (g.document.title = g.document.body.innerText = "downloading..."), "string" == typeof b) return c(b, d, e);
	        var h = "application/octet-stream" === b.type,
	          i = /constructor/i.test(f.HTMLElement) || f.safari,
	          j = /CriOS\/[\d]+/.test(navigator.userAgent);
	        if ((j || h && i || a) && "undefined" != typeof FileReader) {
	          var k = new FileReader();
	          k.onloadend = function () {
	            var a = k.result;
	            a = j ? a : a.replace(/^data:[^;]*;/, "data:attachment/file;"), g ? g.location.href = a : location = a, g = null;
	          }, k.readAsDataURL(b);
	        } else {
	          var l = f.URL || f.webkitURL,
	            m = l.createObjectURL(b);
	          g ? g.location = m : location.href = m, g = null, setTimeout(function () {
	            l.revokeObjectURL(m);
	          }, 4E4);
	        }
	      });
	    f.saveAs = g.saveAs = g, (module.exports = g);
	  });
	})(FileSaver_min);

	function DownloadGFF3({ handleClose, session }) {
	    const [includeFASTA, setincludeFASTA] = React.useState(false);
	    const [selectedAssembly, setSelectedAssembly] = React.useState();
	    const [errorMessage, setErrorMessage] = React.useState('');
	    const { collaborationServerDriver, getInternetAccount, inMemoryFileDriver } = session.apolloDataStore;
	    const assemblies = [
	        ...collaborationServerDriver.getAssemblies(),
	        ...inMemoryFileDriver.getAssemblies(),
	    ];
	    function handleChangeAssembly(e) {
	        const newAssembly = assemblies.find((asm) => asm.name === e.target.value);
	        setSelectedAssembly(newAssembly);
	    }
	    async function onSubmit(event) {
	        event.preventDefault();
	        setErrorMessage('');
	        if (!selectedAssembly) {
	            setErrorMessage('Must select assembly to download');
	            return;
	        }
	        const { internetAccountConfigId } = configuration.getConf(selectedAssembly, [
	            'sequence',
	            'metadata',
	        ]);
	        if (internetAccountConfigId) {
	            await exportFromCollaborationServer(internetAccountConfigId);
	        }
	        else {
	            exportFromMemory(session);
	        }
	        handleClose();
	    }
	    async function exportFromCollaborationServer(internetAccountConfigId) {
	        if (!selectedAssembly) {
	            setErrorMessage('Must select assembly to download');
	            return;
	        }
	        const internetAccount = getInternetAccount(selectedAssembly.configuration.name, internetAccountConfigId);
	        const url = new URL('export/getID', internetAccount.baseURL);
	        const searchParams = new URLSearchParams({
	            assembly: selectedAssembly.name,
	        });
	        url.search = searchParams.toString();
	        const uri = url.toString();
	        const apolloFetch = internetAccount.getFetcher({
	            locationType: 'UriLocation',
	            uri,
	        });
	        const response = await apolloFetch(uri, { method: 'GET' });
	        if (!response.ok) {
	            const newErrorMessage = await createFetchErrorMessage(response, 'Error when exporting ID');
	            setErrorMessage(newErrorMessage);
	            return;
	        }
	        const { exportID } = (await response.json());
	        const exportURL = new URL('export', internetAccount.baseURL);
	        const params = {
	            exportID,
	            includeFASTA: includeFASTA ? 'true' : 'false',
	        };
	        const exportSearchParams = new URLSearchParams(params);
	        exportURL.search = exportSearchParams.toString();
	        const exportUri = exportURL.toString();
	        window.open(exportUri, '_blank');
	    }
	    function exportFromMemory(session) {
	        if (!selectedAssembly) {
	            setErrorMessage('Must select assembly to download');
	            return;
	        }
	        const { assemblies } = session.apolloDataStore;
	        const assembly = assemblies.get(selectedAssembly.name);
	        const refSeqs = assembly?.refSeqs;
	        if (!refSeqs) {
	            setErrorMessage(`No refSeqs found for assembly "${selectedAssembly.name}"`);
	            return;
	        }
	        const gff3Items = [{ directive: 'gff-version', value: '3' }];
	        const sequenceFeatures = configuration.getConf(selectedAssembly, [
	            'sequence',
	            'adapter',
	            'features',
	        ]);
	        for (const sequenceFeature of sequenceFeatures) {
	            const { end, refName, start } = sequenceFeature;
	            gff3Items.push({
	                directive: 'sequence-region',
	                value: `${refName} ${start + 1} ${end}`,
	            });
	        }
	        for (const [, refSeq] of refSeqs) {
	            const { features } = refSeq;
	            if (!features) {
	                continue;
	            }
	            for (const [, feature] of features) {
	                gff3Items.push(dist$2.annotationFeatureToGFF3(require$$1$3.getSnapshot(feature)));
	            }
	        }
	        for (const sequenceFeature of sequenceFeatures) {
	            const { refName, seq } = sequenceFeature;
	            gff3Items.push({ id: refName, description: '', sequence: seq });
	        }
	        const gff3 = gff.formatSync(gff3Items);
	        const gff3Blob = new Blob([gff3], { type: 'text/plain;charset=utf-8' });
	        FileSaver_min.exports.saveAs(gff3Blob, `${selectedAssembly.displayName ?? selectedAssembly.name}.gff3`);
	    }
	    return (React__default["default"].createElement(Dialog, { open: true, title: "Export GFF3", handleClose: handleClose, maxWidth: false, "data-testid": "download-gff3" },
	        React__default["default"].createElement("form", { onSubmit: onSubmit },
	            React__default["default"].createElement(material.DialogContent, { style: { display: 'flex', flexDirection: 'column' } },
	                React__default["default"].createElement(material.DialogContentText, null, "Select assembly"),
	                React__default["default"].createElement(material.Select, { labelId: "label", value: selectedAssembly?.name ?? '', onChange: handleChangeAssembly, disabled: assemblies.length === 0 }, assemblies.map((option) => (React__default["default"].createElement(material.MenuItem, { key: option.name, value: option.name }, option.displayName ?? option.name)))),
	                React__default["default"].createElement(material.DialogContentText, null, "Select assembly to export to GFF3"),
	                React__default["default"].createElement(material.FormGroup, null,
	                    React__default["default"].createElement(material.FormControlLabel, { "data-testid": "include-fasta-checkbox", control: React__default["default"].createElement(material.Checkbox, { checked: includeFASTA, onChange: () => {
	                                setincludeFASTA(!includeFASTA);
	                            } }), label: "Include fasta sequence in GFF output" }))),
	            React__default["default"].createElement(material.DialogActions, null,
	                React__default["default"].createElement(material.Button, { disabled: !selectedAssembly, variant: "contained", type: "submit" }, "Download"),
	                React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: handleClose }, "Cancel"))),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	/* eslint-disable @typescript-eslint/use-unknown-in-catch-callback-variable */
	function ImportFeatures({ changeManager, handleClose, session, }) {
	    const { apolloDataStore } = session;
	    const [file, setFile] = React.useState();
	    const [selectedAssembly, setSelectedAssembly] = React.useState();
	    const [errorMessage, setErrorMessage] = React.useState('');
	    const [submitted, setSubmitted] = React.useState(false);
	    // default is -1, submit button should be disabled until count is set
	    const [featuresCount, setFeaturesCount] = React.useState();
	    const [deleteFeatures, setDeleteFeatures] = React.useState(false);
	    const [loading, setLoading] = React.useState(false);
	    const { collaborationServerDriver, getInternetAccount } = apolloDataStore;
	    const assemblies = collaborationServerDriver.getAssemblies();
	    function handleChangeAssembly(e) {
	        const newAssembly = assemblies.find((asm) => asm.name === e.target.value);
	        setSelectedAssembly(newAssembly);
	        setSubmitted(false);
	    }
	    function handleDeleteFeatures(e) {
	        setDeleteFeatures(e.target.checked);
	    }
	    // fetch and set features count for selected assembly
	    React.useEffect(() => {
	        if (!selectedAssembly) {
	            return;
	        }
	        const updateFeaturesCount = async () => {
	            // TODO: this code will not work for running on desktop
	            const { internetAccountConfigId } = configuration.getConf(selectedAssembly, [
	                'sequence',
	                'metadata',
	            ]);
	            const apolloInternetAccount = getInternetAccount(selectedAssembly.name, internetAccountConfigId);
	            if (!apolloInternetAccount) {
	                throw new Error('No Apollo internet account found');
	            }
	            const { baseURL } = apolloInternetAccount;
	            const uri = new URL('features/count', baseURL);
	            const searchParams = new URLSearchParams({
	                assemblyId: selectedAssembly.name,
	            });
	            uri.search = searchParams.toString();
	            const fetch = apolloInternetAccount.getFetcher({
	                locationType: 'UriLocation',
	                uri: uri.toString(),
	            });
	            setLoading(true);
	            const response = await fetch(uri.toString(), { method: 'GET' });
	            if (response.ok) {
	                const countObj = (await response.json());
	                setFeaturesCount(countObj.count);
	            }
	            else {
	                throw new Error(await createFetchErrorMessage(response));
	            }
	            setLoading(false);
	        };
	        updateFeaturesCount().catch((error) => {
	            console.error(error);
	            setErrorMessage(error.message ?? error);
	        });
	    }, [getInternetAccount, session, selectedAssembly]);
	    function handleChangeFile(e) {
	        setSubmitted(false);
	        if (!e.target.files) {
	            return;
	        }
	        setFile(e.target.files[0]);
	    }
	    async function onSubmit(event) {
	        event.preventDefault();
	        setErrorMessage('');
	        setLoading(true);
	        setSubmitted(true);
	        // let fileChecksum = ''
	        let fileId = '';
	        if (!file) {
	            setErrorMessage('must select a file');
	            return;
	        }
	        if (!selectedAssembly) {
	            setErrorMessage('Must select assembly to download');
	            return;
	        }
	        const { internetAccountConfigId } = configuration.getConf(selectedAssembly, [
	            'sequence',
	            'metadata',
	        ]);
	        const apolloInternetAccount = getInternetAccount(selectedAssembly.name, internetAccountConfigId);
	        const { baseURL } = apolloInternetAccount;
	        // First upload file
	        const url = new URL('files', baseURL);
	        url.searchParams.set('type', 'text/x-gff3');
	        const uri = url.href;
	        const formData = new FormData();
	        formData.append('file', file);
	        formData.append('fileName', file.name);
	        formData.append('type', 'text/x-gff3');
	        const apolloFetchFile = apolloInternetAccount.getFetcher({
	            locationType: 'UriLocation',
	            uri,
	        });
	        handleClose();
	        const { jobsManager } = session;
	        const controller = new AbortController();
	        const job = {
	            name: `Importing features for ${selectedAssembly.displayName}`,
	            statusMessage: 'Uploading file, this may take awhile',
	            progressPct: 0,
	            cancelCallback: () => {
	                controller.abort();
	                jobsManager.abortJob(job.name);
	            },
	        };
	        jobsManager.runJob(job);
	        if (apolloFetchFile) {
	            const { signal } = controller;
	            const response = await apolloFetchFile(uri, {
	                method: 'POST',
	                body: formData,
	                signal,
	            });
	            if (!response.ok) {
	                const newErrorMessage = await createFetchErrorMessage(response, 'Error when inserting new features (while uploading file)');
	                jobsManager.abortJob(job.name, newErrorMessage);
	                setErrorMessage(newErrorMessage);
	                return;
	            }
	            const result = await response.json();
	            // fileChecksum = result.checksum
	            fileId = result._id;
	        }
	        // Add features
	        const change = new dist$2.AddFeaturesFromFileChange({
	            typeName: 'AddFeaturesFromFileChange',
	            assembly: selectedAssembly.name,
	            fileId,
	            deleteExistingFeatures: deleteFeatures,
	        });
	        jobsManager.done(job);
	        await changeManager.submit(change, { updateJobsManager: true });
	    }
	    return (React__default["default"].createElement(Dialog, { open: true, title: "Import Features from GFF3 file", handleClose: handleClose, maxWidth: false, "data-testid": "import-features-dialog" },
	        loading ? React__default["default"].createElement(LinearProgress__default["default"], null) : null,
	        React__default["default"].createElement("form", { onSubmit: onSubmit },
	            React__default["default"].createElement(material.DialogContent, { style: { display: 'flex', flexDirection: 'column' } },
	                React__default["default"].createElement(material.DialogContentText, null, "Select assembly"),
	                React__default["default"].createElement(material.Select, { labelId: "label", value: selectedAssembly?.name ?? '', onChange: handleChangeAssembly, disabled: submitted && !errorMessage }, assemblies.map((option) => (React__default["default"].createElement(material.MenuItem, { key: option.name, value: option.name }, option.displayName ?? option.name))))),
	            React__default["default"].createElement(material.DialogContent, { style: { display: 'flex', flexDirection: 'column' } },
	                React__default["default"].createElement(material.DialogContentText, null, "Upload GFF3 to load features"),
	                React__default["default"].createElement("input", { type: "file", onChange: handleChangeFile, disabled: submitted && !errorMessage })),
	            featuresCount && featuresCount > 0 ? (React__default["default"].createElement(material.DialogContent, null,
	                React__default["default"].createElement(material.DialogContentText, null,
	                    "This assembly already has ",
	                    featuresCount,
	                    " features, would you like to delete the existing features before importing new ones?"),
	                React__default["default"].createElement(FormControlLabel__default["default"], { label: "Yes, delete existing features", disabled: submitted && !errorMessage, control: React__default["default"].createElement(Checkbox__default["default"], { checked: deleteFeatures, onChange: handleDeleteFeatures, inputProps: { 'aria-label': 'controlled' }, color: "warning" }) }))) : null,
	            React__default["default"].createElement(material.DialogActions, null,
	                React__default["default"].createElement(material.Button, { disabled: !(selectedAssembly && file && featuresCount !== undefined) ||
	                        submitted, variant: "contained", type: "submit" }, submitted ? 'Submitting...' : 'Submit'),
	                React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: handleClose }, "Close"))),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	/* eslint-disable @typescript-eslint/unbound-method */
	function LogOut({ handleClose, session }) {
	    const { internetAccounts } = require$$1$3.getRoot(session);
	    const [errorMessage, setErrorMessage] = React.useState('');
	    const apolloInternetAccounts = internetAccounts.filter((ia) => ia.type === 'ApolloInternetAccount');
	    if (apolloInternetAccounts.length === 0) {
	        throw new Error('No Apollo internet account found');
	    }
	    const [selectedInternetAccount, setSelectedInternetAccount] = React.useState(apolloInternetAccounts[0]);
	    function handleChangeInternetAccount(e) {
	        const newlySelectedInternetAccount = apolloInternetAccounts.find((ia) => ia.internetAccountId === e.target.value);
	        if (!newlySelectedInternetAccount) {
	            throw new Error(`Could not find internetAccount with ID "${e.target.value}"`);
	        }
	        setSelectedInternetAccount(newlySelectedInternetAccount);
	    }
	    function onSubmit(event) {
	        event.preventDefault();
	        setErrorMessage('');
	        selectedInternetAccount.removeToken();
	        globalThis.location.reload();
	    }
	    return (React__default["default"].createElement(Dialog, { open: true, title: "Log out", handleClose: handleClose, maxWidth: false, "data-testid": "log-out" },
	        React__default["default"].createElement("form", { onSubmit: onSubmit },
	            React__default["default"].createElement(material.DialogContent, { style: { display: 'flex', flexDirection: 'column' } },
	                apolloInternetAccounts.length > 1 ? (React__default["default"].createElement(React__default["default"].Fragment, null,
	                    React__default["default"].createElement(material.DialogContentText, null, "Select account"),
	                    React__default["default"].createElement(material.Select, { value: selectedInternetAccount.internetAccountId, onChange: handleChangeInternetAccount }, internetAccounts.map((option) => (React__default["default"].createElement(material.MenuItem, { key: option.id, value: option.internetAccountId }, option.name)))))) : null,
	                React__default["default"].createElement(material.DialogContentText, null, "Are you sure you want to log out?")),
	            React__default["default"].createElement(material.DialogActions, null,
	                React__default["default"].createElement(material.Button, { disabled: !selectedInternetAccount, variant: "contained", type: "submit" }, "Log Out"),
	                React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: handleClose }, "Cancel"))),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	function ManageChecks({ handleClose, session }) {
	    const { internetAccounts } = require$$1$3.getRoot(session);
	    const [selectedAssembly, setSelectedAssembly] = React.useState();
	    const [errorMessage, setErrorMessage] = React.useState('');
	    const [submitted, setSubmitted] = React.useState(false);
	    const apolloInternetAccounts = internetAccounts.filter((ia) => ia.type === 'ApolloInternetAccount');
	    if (apolloInternetAccounts.length === 0) {
	        throw new Error('No Apollo internet account found');
	    }
	    const [selectedInternetAccount, setSelectedInternetAccount] = React.useState(apolloInternetAccounts[0]);
	    const [checks, setChecks] = React.useState([]);
	    const [selectedChecks, setSelectedChecks] = React.useState([]);
	    const { collaborationServerDriver } = session.apolloDataStore;
	    const assemblies = collaborationServerDriver.getAssemblies();
	    React.useEffect(() => {
	        async function getChecks() {
	            const { baseURL, getFetcher } = selectedInternetAccount;
	            const uri = new URL('checks/types', baseURL).href;
	            const apolloFetch = getFetcher({ locationType: 'UriLocation', uri });
	            const response = await apolloFetch(uri, { method: 'GET' });
	            if (!response.ok) {
	                const newErrorMessage = await createFetchErrorMessage(response, 'Error when retrieving checks from server');
	                setErrorMessage(newErrorMessage);
	                return;
	            }
	            const data = (await response.json());
	            setChecks(data);
	        }
	        getChecks().catch((error) => {
	            setErrorMessage(String(error));
	        });
	    }, [selectedInternetAccount]);
	    React.useEffect(() => {
	        if (assemblies.length > 0 && selectedAssembly === undefined) {
	            setSelectedAssembly(assemblies[0]);
	        }
	    }, [assemblies, selectedAssembly]);
	    React.useEffect(() => {
	        async function getChecks() {
	            if (!selectedAssembly) {
	                return;
	            }
	            const { baseURL, getFetcher } = selectedInternetAccount;
	            const uri = new URL(`/assemblies/${selectedAssembly.name}`, baseURL).href;
	            const apolloFetch = getFetcher({ locationType: 'UriLocation', uri });
	            const response = await apolloFetch(uri, { method: 'GET' });
	            if (!response.ok) {
	                const newErrorMessage = await createFetchErrorMessage(response, 'Error when retrieving assembly from server');
	                setErrorMessage(newErrorMessage);
	                return;
	            }
	            const assembly = (await response.json());
	            setSelectedChecks(assembly.checks);
	        }
	        getChecks().catch((error) => {
	            setErrorMessage(String(error));
	        });
	    }, [selectedAssembly, selectedInternetAccount]);
	    function handleChangeAssembly(e) {
	        const newAssembly = assemblies.find((asm) => asm.name === e.target.value);
	        setSelectedAssembly(newAssembly);
	    }
	    async function onSubmit(event) {
	        event.preventDefault();
	        if (!selectedAssembly) {
	            setErrorMessage('Must select assembly!');
	            return;
	        }
	        const { notify } = session;
	        const { baseURL, getFetcher } = selectedInternetAccount;
	        const uri = new URL('assemblies/checks', baseURL).href;
	        const apolloFetch = getFetcher({
	            locationType: 'UriLocation',
	            uri,
	        });
	        const response = await apolloFetch(uri, {
	            method: 'POST',
	            body: JSON.stringify({
	                _id: selectedAssembly.name,
	                checks: selectedChecks,
	                name: '',
	            }),
	            headers: { 'Content-Type': 'application/json' },
	        });
	        if (response.ok) {
	            notify('Assembly checks updated successfully', 'success');
	            handleClose();
	        }
	        else {
	            const newErrorMessage = await createFetchErrorMessage(response, 'Error when updating assembly checks');
	            setErrorMessage(newErrorMessage);
	        }
	        return;
	    }
	    function handleCheckboxChange(e, checked) {
	        const checks = [...selectedChecks];
	        const _id = e.target.value;
	        if (checked) {
	            if (!checks.includes(_id)) {
	                checks.push(_id);
	                setSelectedChecks(checks);
	            }
	        }
	        else {
	            const index = checks.indexOf(_id, 0);
	            if (index !== -1) {
	                checks.splice(index, 1);
	            }
	            setSelectedChecks(checks);
	        }
	    }
	    function handleChangeInternetAccount(e) {
	        setSubmitted(false);
	        const newlySelectedInternetAccount = apolloInternetAccounts.find((ia) => ia.internetAccountId === e.target.value);
	        if (!newlySelectedInternetAccount) {
	            throw new Error(`Could not find internetAccount with ID "${e.target.value}"`);
	        }
	        setSelectedInternetAccount(newlySelectedInternetAccount);
	    }
	    return (React__default["default"].createElement(Dialog, { open: true, title: "Manage Checks", handleClose: handleClose, "data-testid": "manage-checks" },
	        React__default["default"].createElement("form", { onSubmit: onSubmit },
	            React__default["default"].createElement(material.DialogContent, null,
	                apolloInternetAccounts.length > 1 ? (React__default["default"].createElement(React__default["default"].Fragment, null,
	                    React__default["default"].createElement(material.DialogContentText, null, "Select account"),
	                    React__default["default"].createElement(material.Select, { value: selectedInternetAccount.internetAccountId, onChange: handleChangeInternetAccount, disabled: submitted && !errorMessage }, internetAccounts.map((option) => (React__default["default"].createElement(material.MenuItem, { key: option.id, value: option.internetAccountId }, option.name)))))) : null,
	                React__default["default"].createElement(material.DialogContentText, null, "Select assembly"),
	                React__default["default"].createElement(material.Select, { style: { width: 300 }, labelId: "label", value: selectedAssembly?.name ?? '', onChange: handleChangeAssembly, disabled: assemblies.length === 0 }, assemblies.map((option) => (React__default["default"].createElement(material.MenuItem, { key: option.name, value: option.name }, option.displayName ?? option.name)))),
	                React__default["default"].createElement("br", null),
	                React__default["default"].createElement("br", null),
	                React__default["default"].createElement(material.TableContainer, { component: material.Paper },
	                    React__default["default"].createElement(material.Table, null,
	                        React__default["default"].createElement(material.TableHead, null,
	                            React__default["default"].createElement(material.TableRow, null,
	                                React__default["default"].createElement(material.TableCell, null, "Check name"),
	                                React__default["default"].createElement(material.TableCell, null, "Use check"))),
	                        React__default["default"].createElement(material.TableBody, null, checks.map((check) => (React__default["default"].createElement(material.TableRow, { key: check._id },
	                            React__default["default"].createElement(material.TableCell, null, check.name),
	                            React__default["default"].createElement(material.TableCell, null,
	                                React__default["default"].createElement(material.Checkbox, { value: check._id, checked: selectedChecks.includes(check._id), onChange: handleCheckboxChange }))))))))),
	            React__default["default"].createElement(material.DialogActions, null,
	                React__default["default"].createElement(material.Button, { variant: "contained", type: "submit" }, "Submit"),
	                React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: handleClose }, "Cancel"))),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	var Delete = {};

	var _interopRequireDefault$j = interopRequireDefault.exports;
	Object.defineProperty(Delete, "__esModule", {
	  value: true
	});
	var default_1$j = Delete["default"] = void 0;
	var _createSvgIcon$j = /*#__PURE__*/_interopRequireDefault$j(createSvgIcon);
	var _jsxRuntime$j = require$$2__default["default"];
	var _default$l = /*#__PURE__*/(0, _createSvgIcon$j["default"])( /*#__PURE__*/(0, _jsxRuntime$j.jsx)("path", {
	  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"
	}), 'Delete');
	default_1$j = Delete["default"] = _default$l;

	/* eslint-disable @typescript-eslint/unbound-method */
	function ManageUsers({ changeManager, handleClose, session, }) {
	    const { internetAccounts } = require$$1$3.getRoot(session);
	    const apolloInternetAccounts = internetAccounts.filter((ia) => ia.type === 'ApolloInternetAccount' && ia.role?.includes('admin'));
	    if (apolloInternetAccounts.length === 0) {
	        throw new Error('No Apollo internet account found');
	    }
	    const [errorMessage, setErrorMessage] = React.useState('');
	    const [selectedInternetAccount, setSelectedInternetAccount] = React.useState(apolloInternetAccounts[0]);
	    const [users, setUsers] = React.useState([]);
	    const getUsers = React.useCallback(async () => {
	        const { baseURL } = selectedInternetAccount;
	        const uri = new URL('users', baseURL).href;
	        const apolloFetch = selectedInternetAccount.getFetcher({
	            locationType: 'UriLocation',
	            uri,
	        });
	        if (apolloFetch) {
	            const response = await apolloFetch(uri, { method: 'GET' });
	            if (!response.ok) {
	                const newErrorMessage = await createFetchErrorMessage(response, 'Error when getting user data from db');
	                setErrorMessage(newErrorMessage);
	                return;
	            }
	            const data = (await response.json());
	            setUsers(data.map((u) => (u.role === undefined ? { ...u, role: '' } : u)));
	        }
	    }, [selectedInternetAccount]);
	    React.useEffect(() => {
	        getUsers().catch((error) => {
	            setErrorMessage(String(error));
	        });
	    }, [getUsers]);
	    async function deleteUser(id) {
	        const change = new dist$2.DeleteUserChange({
	            typeName: 'DeleteUserChange',
	            userId: id,
	        });
	        await changeManager.submit(change, {
	            internetAccountId: selectedInternetAccount.internetAccountId,
	        });
	        setUsers((prevUsers) => prevUsers.filter((row) => row._id !== id));
	    }
	    function isCurrentUser(id) {
	        if (id === selectedInternetAccount.getUserId()) {
	            return true;
	        }
	        return false;
	    }
	    const gridColumns = [
	        { field: 'username', headerName: 'User', width: 140 },
	        { field: 'email', headerName: 'Email', width: 160 },
	        {
	            field: 'role',
	            headerName: 'Role',
	            width: 140,
	            type: 'singleSelect',
	            valueOptions: ['readOnly', 'user', 'admin', 'none'],
	            getOptionLabel(value) {
	                switch (value) {
	                    case 'readOnly': {
	                        return 'Read-only';
	                    }
	                    case 'user': {
	                        return 'User';
	                    }
	                    case 'admin': {
	                        return 'Admin';
	                    }
	                    case 'none': {
	                        return 'None';
	                    }
	                    default: {
	                        return 'unknown';
	                    }
	                }
	            },
	            editable: true,
	        },
	        {
	            field: 'actions',
	            type: 'actions',
	            getActions: (params) => [
	                React__default["default"].createElement(xDataGrid.GridActionsCellItem, { key: `delete-${params.id}`, icon: React__default["default"].createElement(default_1$j, null), onClick: async () => {
	                        if (globalThis.confirm('Delete this user?')) {
	                            await deleteUser(params.id);
	                        }
	                    }, disabled: isCurrentUser(params.id), label: "Delete" }),
	            ],
	        },
	    ];
	    function handleChangeInternetAccount(e) {
	        const newlySelectedInternetAccount = apolloInternetAccounts.find((ia) => ia.internetAccountId === e.target.value);
	        if (!newlySelectedInternetAccount) {
	            throw new Error(`Could not find internetAccount with ID "${e.target.value}"`);
	        }
	        setSelectedInternetAccount(newlySelectedInternetAccount);
	    }
	    async function processRowUpdate(newRow) {
	        const change = new dist$2.UserChange({
	            typeName: 'UserChange',
	            role: newRow.role,
	            userId: newRow._id,
	        });
	        await changeManager.submit(change, {
	            internetAccountId: selectedInternetAccount.internetAccountId,
	        });
	        return newRow;
	    }
	    return (React__default["default"].createElement(Dialog, { open: true, fullScreen: true, title: "Manage users", handleClose: handleClose, "data-testid": "manage-users" },
	        React__default["default"].createElement(material.DialogContent, null,
	            apolloInternetAccounts.length > 1 ? (React__default["default"].createElement(React__default["default"].Fragment, null,
	                React__default["default"].createElement(material.DialogContentText, null, "Select account"),
	                React__default["default"].createElement(material.Select, { value: selectedInternetAccount.internetAccountId, onChange: handleChangeInternetAccount, disabled: !errorMessage }, internetAccounts.map((option) => (React__default["default"].createElement(material.MenuItem, { key: option.id, value: option.internetAccountId }, option.name)))))) : null,
	            React__default["default"].createElement("div", { style: { height: '100%', width: '100%' } },
	                React__default["default"].createElement(xDataGrid.DataGrid, { pagination: true, rows: users, columns: gridColumns, getRowId: (row) => row._id, slots: { toolbar: xDataGrid.GridToolbar }, getRowHeight: () => 'auto', isCellEditable: (params) => !isCurrentUser(params.id), processRowUpdate: processRowUpdate, onProcessRowUpdateError: (error) => {
	                        setErrorMessage(String(error));
	                    } }))),
	        React__default["default"].createElement(material.DialogActions, null,
	            React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: handleClose }, "Close")),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	/* eslint-disable @typescript-eslint/unbound-method */
	function getNeighboringExons(referenceExon) {
	    const neighboringExons = {};
	    const tx = referenceExon.parent;
	    if (!tx) {
	        throw new Error('Unable to find parent of reference exon');
	    }
	    let exons = [];
	    if (tx.children) {
	        for (const [, feature] of tx.children) {
	            if (feature.type === 'exon') {
	                exons.push(feature);
	            }
	        }
	    }
	    exons = exons.sort((a, b) => {
	        if (a.min === b.min) {
	            return a.max - b.max;
	        }
	        return a.min - b.min;
	    });
	    if (tx.strand && tx.strand === -1) {
	        exons = exons.reverse();
	    }
	    let i = 0;
	    for (const x of exons) {
	        if (x._id === referenceExon._id) {
	            if (exons.length > i + 1) {
	                neighboringExons.three_prime = exons[i + 1];
	            }
	            if (i > 0) {
	                neighboringExons.five_prime = exons[i - 1];
	            }
	            break;
	        }
	        i++;
	    }
	    return neighboringExons;
	}
	function makeRadioButtonName$1(key, neighboringExons) {
	    const neighboringExon = neighboringExons[key];
	    let name;
	    if (key === 'three_prime') {
	        name = `3'end (coords: ${neighboringExon.min + 1}-${neighboringExon.max})`;
	    }
	    else if (key === 'five_prime') {
	        name = `5'end (coords: ${neighboringExon.min + 1}-${neighboringExon.max})`;
	    }
	    else {
	        throw new Error(`Unexpected direction: "${key}"`);
	    }
	    return name;
	}
	function MergeExons({ changeManager, handleClose, selectedFeature, setSelectedFeature, sourceAssemblyId, sourceFeature, }) {
	    const [errorMessage, setErrorMessage] = React.useState('');
	    const [selectedExon, setSelectedExon] = React.useState();
	    function onSubmit(event) {
	        event.preventDefault();
	        setErrorMessage('');
	        const { parent } = sourceFeature;
	        if (!(selectedExon && parent)) {
	            return;
	        }
	        if (selectedFeature?._id === sourceFeature._id) {
	            setSelectedFeature();
	        }
	        const change = new dist$2.MergeExonsChange({
	            changedIds: [sourceFeature._id],
	            typeName: 'MergeExonsChange',
	            assembly: sourceAssemblyId,
	            firstExon: require$$1$3.getSnapshot(sourceFeature),
	            secondExon: require$$1$3.getSnapshot(selectedExon),
	            parentFeatureId: parent._id,
	        });
	        void changeManager.submit(change);
	        handleClose();
	        event.preventDefault();
	    }
	    const handleTypeChange = (e) => {
	        setErrorMessage('');
	        const { value } = e.target;
	        setSelectedExon(neighboringExons[value]);
	    };
	    const neighboringExons = getNeighboringExons(sourceFeature);
	    return (React__default["default"].createElement(Dialog, { open: true, title: "Merge exons", handleClose: handleClose, maxWidth: false, "data-testid": "merge-exons" },
	        React__default["default"].createElement("form", { onSubmit: onSubmit },
	            React__default["default"].createElement(material.DialogContent, { style: { display: 'flex', flexDirection: 'column' } },
	                Object.keys(neighboringExons).length === 0
	                    ? 'There are no neighbouring exons to merge with'
	                    : 'Merge with exon on:',
	                React__default["default"].createElement(material.FormControl, { style: { marginTop: 5 } },
	                    React__default["default"].createElement(material.RadioGroup, { "aria-labelledby": "demo-radio-buttons-group-label", name: "radio-buttons-group", value: selectedExon, onChange: handleTypeChange }, Object.keys(neighboringExons).map((key) => (React__default["default"].createElement(material.FormControlLabel, { value: key, key: key, control: React__default["default"].createElement(material.Radio, null), label: React__default["default"].createElement(material.Box, { display: "flex", alignItems: "center" }, makeRadioButtonName$1(key, neighboringExons)) })))))),
	            React__default["default"].createElement(material.DialogActions, null,
	                React__default["default"].createElement(material.Button, { variant: "contained", type: "submit", disabled: Object.keys(neighboringExons).length === 0 ||
	                        selectedExon === undefined }, "Submit"),
	                React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: handleClose }, "Cancel"))),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	function getTranscripts(referenceTranscript, session) {
	    const gene = referenceTranscript.parent;
	    if (!gene) {
	        throw new Error('Unable to find parent of reference transcript');
	    }
	    const { featureTypeOntology } = session.apolloDataStore.ontologyManager;
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    const transcripts = {};
	    if (gene.children) {
	        for (const [, feature] of gene.children) {
	            if (featureTypeOntology.isTypeOf(feature.type, 'transcript') &&
	                feature._id !== referenceTranscript._id) {
	                transcripts[feature._id] = feature;
	            }
	        }
	    }
	    return transcripts;
	}
	function makeRadioButtonName(transcript) {
	    let id;
	    if (transcript.attributes.get('gff_name')) {
	        id = transcript.attributes.get('gff_name')?.join(',');
	    }
	    else if (transcript.attributes.get('gff_id')) {
	        id = transcript.attributes.get('gff_id')?.join(',');
	    }
	    else {
	        id = transcript._id;
	    }
	    return `${id} [${transcript.min + 1}-${transcript.max}]`;
	}
	function MergeTranscripts({ changeManager, handleClose, selectedFeature, session, setSelectedFeature, sourceAssemblyId, sourceFeature, }) {
	    const { notify } = session;
	    const [errorMessage, setErrorMessage] = React.useState('');
	    const [selectedTranscript, setSelectedTranscript] = React.useState();
	    async function onSubmit(event) {
	        event.preventDefault();
	        setErrorMessage('');
	        if (!selectedTranscript) {
	            return;
	        }
	        if (selectedFeature?._id === sourceFeature._id) {
	            setSelectedFeature();
	        }
	        if (!sourceFeature.parent) {
	            throw new Error('Cannot find parent');
	        }
	        const change = new dist$2.MergeTranscriptsChange({
	            changedIds: [sourceFeature._id],
	            typeName: 'MergeTranscriptsChange',
	            assembly: sourceAssemblyId,
	            firstTranscript: require$$1$3.getSnapshot(sourceFeature),
	            secondTranscript: require$$1$3.getSnapshot(selectedTranscript),
	            parentFeatureId: sourceFeature.parent._id,
	        });
	        await changeManager.submit(change);
	        notify('Transcripts successfully merged', 'success');
	        handleClose();
	        event.preventDefault();
	    }
	    const handleTypeChange = (e) => {
	        setErrorMessage('');
	        const { value } = e.target;
	        setSelectedTranscript(transcripts[value]);
	    };
	    const transcripts = getTranscripts(sourceFeature, session);
	    return (React__default["default"].createElement(Dialog, { open: true, title: "Merge transcripts", handleClose: handleClose, maxWidth: false, "data-testid": "merge-transcripts" },
	        React__default["default"].createElement("form", { onSubmit: onSubmit },
	            React__default["default"].createElement(material.DialogContent, { style: { display: 'flex', flexDirection: 'column' } },
	                Object.keys(transcripts).length === 0
	                    ? 'There are no transcripts to merge with'
	                    : 'Merge with transcript:',
	                React__default["default"].createElement(material.FormControl, { style: { marginTop: 5 } },
	                    React__default["default"].createElement(material.RadioGroup, { "aria-labelledby": "demo-radio-buttons-group-label", name: "radio-buttons-group", value: selectedTranscript, onChange: handleTypeChange }, Object.keys(transcripts).map((key) => (React__default["default"].createElement(material.FormControlLabel, { value: key, key: key, control: React__default["default"].createElement(material.Radio, null), label: React__default["default"].createElement(material.Box, { display: "flex", alignItems: "center" }, makeRadioButtonName(transcripts[key])) })))))),
	            React__default["default"].createElement(material.DialogActions, null,
	                React__default["default"].createElement(material.Button, { variant: "contained", type: "submit", disabled: Object.keys(transcripts).length === 0 ||
	                        selectedTranscript === undefined }, "Submit"),
	                React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: handleClose }, "Cancel"))),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	var nanoid = function nanoid() {
	  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 21;
	  return crypto.getRandomValues(new Uint8Array(size)).reduce(function (id, _byte) {
	    _byte &= 63;
	    if (_byte < 36) {
	      id += _byte.toString(36);
	    } else if (_byte < 62) {
	      id += (_byte - 26).toString(36).toUpperCase();
	    } else if (_byte > 62) {
	      id += '-';
	    } else {
	      id += '_';
	    }
	    return id;
	  }, '');
	};

	/* eslint-disable @typescript-eslint/no-unsafe-call */
	function OpenLocalFile({ handleClose, session }) {
	    const { apolloDataStore } = session;
	    const { addAssembly, addSessionAssembly, assemblyManager, notify } = session;
	    const [file, setFile] = React.useState(null);
	    const [assemblyName, setAssemblyName] = React.useState('');
	    const [errorMessage, setErrorMessage] = React.useState('');
	    const [submitted, setSubmitted] = React.useState(false);
	    const theme = material.useTheme();
	    function handleChangeFile(e) {
	        const selectedFile = e.target.files?.item(0);
	        if (!selectedFile) {
	            return;
	        }
	        setErrorMessage('');
	        setFile(selectedFile);
	        if (!assemblyName) {
	            const fileName = selectedFile.name;
	            const lastDotIndex = fileName.lastIndexOf('.');
	            if (lastDotIndex === -1) {
	                setAssemblyName(fileName);
	            }
	            else {
	                setAssemblyName(fileName.slice(0, lastDotIndex));
	            }
	        }
	    }
	    async function onSubmit(event) {
	        event.preventDefault();
	        setErrorMessage('');
	        setSubmitted(true);
	        if (!file) {
	            throw new Error('No file selected');
	        }
	        // Right now we are not using stream because there was a problem with 'pipe' in ReadStream
	        const fileData = await new Response(file).text();
	        const assemblyId = `${assemblyName}-${file.name}-${nanoid(8)}`;
	        try {
	            await loadAssemblyIntoClient(assemblyId, fileData, apolloDataStore);
	        }
	        catch (error) {
	            console.error(error);
	            notify(`Error loading GFF3 ${file.name}, ${String(error)}`, 'error');
	            handleClose();
	            return;
	        }
	        const assemblyConfig = {
	            name: assemblyId,
	            aliases: [assemblyName],
	            displayName: assemblyName,
	            sequence: {
	                trackId: `sequenceConfigId-${assemblyName}`,
	                type: 'ReferenceSequenceTrack',
	                adapter: { type: 'ApolloSequenceAdapter', assemblyId },
	                metadata: {
	                    apollo: true,
	                    ...(require$$1$2.isElectron
	                        ? { file: file.path }
	                        : {}),
	                },
	            },
	        };
	        // Save assembly into session
	        await (addSessionAssembly || addAssembly)(assemblyConfig);
	        const a = await assemblyManager.waitForAssembly(assemblyConfig.name);
	        if (a) {
	            // @ts-expect-error MST type coercion problem?
	            session.addApolloTrackConfig(a);
	            notify(`Loaded GFF3 ${file.name}`, 'success');
	        }
	        else {
	            notify(`Error loading GFF3 ${file.name}`, 'error');
	        }
	        handleClose();
	    }
	    function handleAssemblyNameChange(event) {
	        setAssemblyName(event.target.value);
	    }
	    return (React__default["default"].createElement(Dialog, { open: true, title: "Open local GFF3 file", handleClose: handleClose, maxWidth: false, "data-testid": "open-local-file" },
	        React__default["default"].createElement("form", { onSubmit: onSubmit },
	            React__default["default"].createElement(material.DialogContent, { style: { display: 'flex', flexDirection: 'column' } },
	                React__default["default"].createElement(material.FormControl, null,
	                    React__default["default"].createElement("div", { style: { flexDirection: 'row' } },
	                        React__default["default"].createElement(material.Button, { variant: "contained", component: "label", style: { marginRight: theme.spacing() } },
	                            "Choose File",
	                            React__default["default"].createElement("input", { type: "file", required: true, hidden: true, onChange: handleChangeFile })),
	                        file ? file.name : 'No file chosen'),
	                    React__default["default"].createElement(material.FormHelperText, null, "Make sure your GFF3 has an embedded FASTA section")),
	                React__default["default"].createElement(material.TextField, { required: true, label: "Assembly name", value: assemblyName, onChange: handleAssemblyNameChange })),
	            React__default["default"].createElement(material.DialogActions, null,
	                React__default["default"].createElement(material.Button, { disabled: false, variant: "contained", type: "submit" }, submitted ? 'Submitting...' : 'Submit'),
	                React__default["default"].createElement(material.Button, { disabled: submitted, variant: "outlined", type: "submit", onClick: handleClose }, "Cancel"))),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	var ContentCopy = {};

	var _interopRequireDefault$i = interopRequireDefault.exports;
	Object.defineProperty(ContentCopy, "__esModule", {
	  value: true
	});
	var default_1$i = ContentCopy["default"] = void 0;
	var _createSvgIcon$i = /*#__PURE__*/_interopRequireDefault$i(createSvgIcon);
	var _jsxRuntime$i = require$$2__default["default"];
	var _default$k = /*#__PURE__*/(0, _createSvgIcon$i["default"])( /*#__PURE__*/(0, _jsxRuntime$i.jsx)("path", {
	  d: "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"
	}), 'ContentCopy');
	default_1$i = ContentCopy["default"] = _default$k;

	var FirstPage = {};

	var _interopRequireDefault$h = interopRequireDefault.exports;
	Object.defineProperty(FirstPage, "__esModule", {
	  value: true
	});
	var default_1$h = FirstPage["default"] = void 0;
	var _createSvgIcon$h = /*#__PURE__*/_interopRequireDefault$h(createSvgIcon);
	var _jsxRuntime$h = require$$2__default["default"];
	var _default$j = /*#__PURE__*/(0, _createSvgIcon$h["default"])( /*#__PURE__*/(0, _jsxRuntime$h.jsx)("path", {
	  d: "M18.41 16.59 13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"
	}), 'FirstPage');
	default_1$h = FirstPage["default"] = _default$j;

	var KeyboardArrowDown = {};

	var _interopRequireDefault$g = interopRequireDefault.exports;
	Object.defineProperty(KeyboardArrowDown, "__esModule", {
	  value: true
	});
	var default_1$g = KeyboardArrowDown["default"] = void 0;
	var _createSvgIcon$g = /*#__PURE__*/_interopRequireDefault$g(createSvgIcon);
	var _jsxRuntime$g = require$$2__default["default"];
	var _default$i = /*#__PURE__*/(0, _createSvgIcon$g["default"])( /*#__PURE__*/(0, _jsxRuntime$g.jsx)("path", {
	  d: "M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"
	}), 'KeyboardArrowDown');
	default_1$g = KeyboardArrowDown["default"] = _default$i;

	var KeyboardArrowLeft = {};

	var _interopRequireDefault$f = interopRequireDefault.exports;
	Object.defineProperty(KeyboardArrowLeft, "__esModule", {
	  value: true
	});
	var default_1$f = KeyboardArrowLeft["default"] = void 0;
	var _createSvgIcon$f = /*#__PURE__*/_interopRequireDefault$f(createSvgIcon);
	var _jsxRuntime$f = require$$2__default["default"];
	var _default$h = /*#__PURE__*/(0, _createSvgIcon$f["default"])( /*#__PURE__*/(0, _jsxRuntime$f.jsx)("path", {
	  d: "M15.41 16.59 10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
	}), 'KeyboardArrowLeft');
	default_1$f = KeyboardArrowLeft["default"] = _default$h;

	var KeyboardArrowRight = {};

	var _interopRequireDefault$e = interopRequireDefault.exports;
	Object.defineProperty(KeyboardArrowRight, "__esModule", {
	  value: true
	});
	var default_1$e = KeyboardArrowRight["default"] = void 0;
	var _createSvgIcon$e = /*#__PURE__*/_interopRequireDefault$e(createSvgIcon);
	var _jsxRuntime$e = require$$2__default["default"];
	var _default$g = /*#__PURE__*/(0, _createSvgIcon$e["default"])( /*#__PURE__*/(0, _jsxRuntime$e.jsx)("path", {
	  d: "M8.59 16.59 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
	}), 'KeyboardArrowRight');
	default_1$e = KeyboardArrowRight["default"] = _default$g;

	var KeyboardArrowUp = {};

	var _interopRequireDefault$d = interopRequireDefault.exports;
	Object.defineProperty(KeyboardArrowUp, "__esModule", {
	  value: true
	});
	var default_1$d = KeyboardArrowUp["default"] = void 0;
	var _createSvgIcon$d = /*#__PURE__*/_interopRequireDefault$d(createSvgIcon);
	var _jsxRuntime$d = require$$2__default["default"];
	var _default$f = /*#__PURE__*/(0, _createSvgIcon$d["default"])( /*#__PURE__*/(0, _jsxRuntime$d.jsx)("path", {
	  d: "M7.41 15.41 12 10.83l4.59 4.58L18 14l-6-6-6 6z"
	}), 'KeyboardArrowUp');
	default_1$d = KeyboardArrowUp["default"] = _default$f;

	var LastPage = {};

	var _interopRequireDefault$c = interopRequireDefault.exports;
	Object.defineProperty(LastPage, "__esModule", {
	  value: true
	});
	var default_1$c = LastPage["default"] = void 0;
	var _createSvgIcon$c = /*#__PURE__*/_interopRequireDefault$c(createSvgIcon);
	var _jsxRuntime$c = require$$2__default["default"];
	var _default$e = /*#__PURE__*/(0, _createSvgIcon$c["default"])( /*#__PURE__*/(0, _jsxRuntime$c.jsx)("path", {
	  d: "M5.59 7.41 10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"
	}), 'LastPage');
	default_1$c = LastPage["default"] = _default$e;

	async function copyToClipboard(element) {
	    if (isSecureContext) {
	        const textBlob = new Blob([element.outerText], { type: 'text/plain' });
	        const htmlBlob = new Blob([element.outerHTML], { type: 'text/html' });
	        const clipboardItem = new ClipboardItem({
	            [textBlob.type]: textBlob,
	            [htmlBlob.type]: htmlBlob,
	        });
	        return navigator.clipboard.write([clipboardItem]);
	    }
	    const copyCallback = (event) => {
	        event.clipboardData?.setData('text/plain', element.outerText);
	        event.clipboardData?.setData('text/html', element.outerHTML);
	        event.preventDefault();
	    };
	    document.addEventListener('copy', copyCallback);
	    // fall back to deprecated only in non-secure contexts
	    // eslint-disable-next-line @typescript-eslint/no-deprecated
	    document.execCommand('copy');
	    document.removeEventListener('copy', copyCallback);
	}

	/* eslint-disable @typescript-eslint/no-explicit-any */
	const changeTypeMapping = {
	    FeatureAttributeChange: 'Attribute Change',
	    UserChange: 'User Change',
	    UndoSplitExonChange: 'Undo Split Exon',
	    UndoMergeTranscriptsChange: 'Undo Merge Transcripts',
	    UndoMergeExonsChange: 'Undo Merge Exons',
	    TypeChange: 'Type Change',
	    StrandChange: 'Strand Change',
	    SplitExonChange: 'Split Exon',
	    MergeTranscriptsChange: 'Merge Transcripts',
	    MergeExonsChange: 'Merge Exons',
	    LocationStartChange: 'Location Start Change',
	    LocationEndChange: 'Location End Change',
	    DeleteUserChange: 'Delete User',
	    DeleteFeatureChange: 'Delete Feature',
	    DeleteAssemblyChange: 'Delete Assembly',
	    AddFeatureChange: 'Add Feature',
	};
	function getFeatureId$1(feature) {
	    if (!feature) {
	        return '';
	    }
	    const keys = ['gene_id', 'transcript_id', 'exon_id', 'protein_id'];
	    for (const key of keys) {
	        const value = feature.attributes?.[key];
	        if (value && Array.isArray(value) && value.length > 0) {
	            return value[0];
	        }
	    }
	    return feature._id || '';
	}
	function ViewChangeLog({ handleClose, session }) {
	    const { internetAccounts } = require$$1$3.getRoot(session);
	    const apolloInternetAccount = internetAccounts.find((ia) => ia.type === 'ApolloInternetAccount');
	    if (!apolloInternetAccount) {
	        throw new Error('No Apollo internet account found');
	    }
	    const { baseURL } = apolloInternetAccount;
	    const [errorMessage, setErrorMessage] = React.useState();
	    const [assemblyCollection, setAssemblyCollection] = React.useState([]);
	    const [assemblyId, setAssemblyId] = React.useState('');
	    const [tableData, setTableData] = React.useState([]);
	    const [page, setPage] = React__default["default"].useState(0);
	    const [rowsPerPage, setRowsPerPage] = React__default["default"].useState(5);
	    const [searchText, setSearchText] = React.useState('');
	    React.useEffect(() => {
	        async function getAssemblies() {
	            const uri = new URL('assemblies', baseURL).href;
	            const apolloFetch = apolloInternetAccount?.getFetcher({
	                locationType: 'UriLocation',
	                uri,
	            });
	            if (apolloFetch) {
	                const response = await apolloFetch(uri, { method: 'GET' });
	                if (!response.ok) {
	                    const newErrorMessage = await createFetchErrorMessage(response, 'Error when retrieving assemblies from server');
	                    setErrorMessage(newErrorMessage);
	                    return;
	                }
	                const data = (await response.json());
	                setAssemblyCollection(data);
	            }
	        }
	        getAssemblies().catch((error) => {
	            setErrorMessage(String(error));
	        });
	    }, [apolloInternetAccount, baseURL]);
	    React.useEffect(() => {
	        if (!assemblyId && assemblyCollection.length > 0) {
	            setAssemblyId(assemblyCollection[0]._id);
	        }
	    }, [assemblyId, assemblyCollection]);
	    React.useEffect(() => {
	        async function getGridData() {
	            if (!assemblyId) {
	                return;
	            }
	            // Get changes
	            const url = new URL('changes', baseURL);
	            const searchParams = new URLSearchParams({ assembly: assemblyId });
	            url.search = searchParams.toString();
	            const uri = url.toString();
	            const apolloFetch = apolloInternetAccount?.getFetcher({
	                locationType: 'UriLocation',
	                uri,
	            });
	            if (apolloFetch) {
	                const response = await apolloFetch(uri, {
	                    headers: new Headers({ 'Content-Type': 'application/json' }),
	                });
	                if (!response.ok) {
	                    const newErrorMessage = await createFetchErrorMessage(response, 'Error when retrieving changes');
	                    setErrorMessage(newErrorMessage);
	                    return;
	                }
	                const data = await response.json();
	                const changes = data;
	                const changesData = [];
	                for (const change of changes) {
	                    const { changedIds } = change;
	                    const changesArray = Array.isArray(change.changes)
	                        ? change.changes
	                        : [];
	                    let i = 0;
	                    for (const c of changesArray) {
	                        const newChange = {
	                            ...change,
	                            changes: [c],
	                            _id: `${change._id}-${i}`,
	                        };
	                        if ('featureId' in c &&
	                            changedIds.includes(c.featureId)) {
	                            newChange.changedIds = [c.featureId];
	                            newChange._id = `${change._id}-${c.featureId}`;
	                        }
	                        changesData.push(newChange);
	                        i++;
	                    }
	                }
	                setTableData(changesData);
	            }
	        }
	        getGridData().catch((error) => {
	            setErrorMessage(String(error));
	        });
	    }, [assemblyId, apolloInternetAccount, baseURL]);
	    function handleChangeAssembly(e) {
	        setAssemblyId(e.target.value);
	    }
	    const handleChangePage = (event, newPage) => {
	        setPage(newPage);
	    };
	    const handleChangeRowsPerPage = (event) => {
	        setRowsPerPage(Number.parseInt(event.target.value, 10));
	        setPage(0);
	    };
	    const getRowsForPage = () => {
	        const rows = rowsPerPage > 0
	            ? getFilteredRows().slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)
	            : getFilteredRows();
	        return rows;
	    };
	    const getFilteredRows = () => {
	        if (!searchText || searchText.trim() === '') {
	            return tableData;
	        }
	        const lower = searchText.toLowerCase();
	        return tableData.filter((row) => {
	            const { _id = '', typeName = '', user = '', createdAt = '', updatedAt = '', changedIds = [], changes = [], } = row;
	            const content = [
	                _id,
	                typeName,
	                user,
	                createdAt,
	                updatedAt,
	                ...changedIds,
	                JSON.stringify(changes),
	            ]
	                .join(' ')
	                .toLowerCase();
	            return content.includes(lower);
	        });
	    };
	    return (React__default["default"].createElement(Dialog, { open: true, title: "Change history", handleClose: handleClose, "data-testid": "view-changelog", maxWidth: "xl", fullWidth: true },
	        React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.Grid2, { container: true, spacing: 2 },
	                React__default["default"].createElement(material.Grid2, { size: 6 },
	                    React__default["default"].createElement(material.Select, { value: assemblyId, onChange: handleChangeAssembly, size: "small", style: {
	                            width: 300,
	                            margin: 0,
	                        } }, assemblyCollection.map((option) => (React__default["default"].createElement(material.MenuItem, { key: option._id, value: option._id }, option.name))))),
	                React__default["default"].createElement(material.Grid2, { size: 6 },
	                    React__default["default"].createElement(material.TextField, { id: "outlined-basic", label: "Filter", size: "small", variant: "outlined", style: {
	                            float: 'right',
	                            width: 300,
	                            margin: 0,
	                        }, value: searchText, onChange: (e) => {
	                            setSearchText(e.target.value);
	                        } })),
	                React__default["default"].createElement(material.Grid2, { size: 12, sx: { height: '70vh', overflowY: 'scroll' } },
	                    React__default["default"].createElement(TableContainer__default["default"], { component: Paper__default["default"] },
	                        React__default["default"].createElement(Table__default["default"], { "aria-label": "collapsible table" },
	                            React__default["default"].createElement(TableHead__default["default"], null,
	                                React__default["default"].createElement(TableRow__default["default"], null,
	                                    React__default["default"].createElement(TableCell__default["default"], null),
	                                    React__default["default"].createElement(TableCell__default["default"], null, "Change type"),
	                                    React__default["default"].createElement(TableCell__default["default"], null, "Feature ID"),
	                                    React__default["default"].createElement(TableCell__default["default"], { align: "right" }, "User"),
	                                    React__default["default"].createElement(TableCell__default["default"], { align: "right" }, "Created At"))),
	                            React__default["default"].createElement(TableBody__default["default"], null,
	                                getRowsForPage().map((row) => (React__default["default"].createElement(Row, { key: row._id, row: row, session: session, assemblyId: assemblyId }))),
	                                getRowsForPage().length === 0 && (React__default["default"].createElement(TableRow__default["default"], null,
	                                    React__default["default"].createElement(TableCell__default["default"], { colSpan: 6, align: "center" }, "No changes found")))),
	                            React__default["default"].createElement(TableFooter__default["default"], null,
	                                React__default["default"].createElement(TableRow__default["default"], null,
	                                    React__default["default"].createElement(TableCell__default["default"], { colSpan: 6, align: "left" },
	                                        React__default["default"].createElement(TablePagination__default["default"], { rowsPerPageOptions: [
	                                                5,
	                                                10,
	                                                25,
	                                                { label: 'All', value: -1 },
	                                            ], colSpan: 3, count: getFilteredRows().length, rowsPerPage: rowsPerPage, page: page, slotProps: {
	                                                select: {
	                                                    inputProps: {
	                                                        'aria-label': 'rows per page',
	                                                    },
	                                                    native: true,
	                                                },
	                                            }, onPageChange: handleChangePage, onRowsPerPageChange: handleChangeRowsPerPage, ActionsComponent: TablePaginationActions }))))))))),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}
	function Row(props) {
	    const { row, key, session, assemblyId } = props;
	    const [open, setOpen] = React__default["default"].useState(false);
	    const [collapsedContent, setCollapsedContent] = React.useState(null);
	    // TODO: Refactor
	    React.useEffect(() => {
	        switch (row.typeName) {
	            case 'LocationStartChange':
	            case 'LocationEndChange': {
	                setCollapsedContent(React__default["default"].createElement(CollapsedLocationChangeContent, { row: row, session: session, assemblyId: assemblyId }));
	                break;
	            }
	            case 'FeatureAttributeChange': {
	                setCollapsedContent(React__default["default"].createElement(CollapsedFeatureAttributeContent, { row: row, session: session, assemblyId: assemblyId }));
	                break;
	            }
	            case 'TypeChange': {
	                setCollapsedContent(React__default["default"].createElement(CollapsedTypeChangeContent, { row: row, session: session, assemblyId: assemblyId }));
	                break;
	            }
	            case 'AddFeatureChange': {
	                setCollapsedContent(React__default["default"].createElement(CollapsedAddFeatureContent, { row: row, session: session, assemblyId: assemblyId }));
	                break;
	            }
	            case 'DeleteFeatureChange': {
	                setCollapsedContent(React__default["default"].createElement(CollapsedDeleteFeatureContent, { row: row }));
	                break;
	            }
	            default: {
	                setCollapsedContent(React__default["default"].createElement(CollapsedJsonContent, { row: row }));
	            }
	        }
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [row]);
	    return (React__default["default"].createElement(React__default["default"].Fragment, null,
	        React__default["default"].createElement(TableRow__default["default"], { key: key, sx: { borderBottom: '1px solid #e0e0e0' } },
	            React__default["default"].createElement(TableCell__default["default"], { sx: { borderBottom: 'none', width: '40px', maxWidth: '40px' } },
	                React__default["default"].createElement(IconButton__default["default"], { "aria-label": "expand row", size: "small", onClick: () => {
	                        setOpen(!open);
	                    } }, open ? React__default["default"].createElement(default_1$d, null) : React__default["default"].createElement(default_1$g, null))),
	            React__default["default"].createElement(TableCell__default["default"], { component: "th", scope: "row", sx: { borderBottom: 'none' } }, changeTypeMapping[row.typeName] || row.typeName),
	            React__default["default"].createElement(TableCell__default["default"], { sx: { borderBottom: 'none' } }, row.changedIds.length > 0 ? row.changedIds.join(', ') : '-'),
	            React__default["default"].createElement(TableCell__default["default"], { align: "right", sx: { borderBottom: 'none' } }, row.user),
	            React__default["default"].createElement(TableCell__default["default"], { align: "right", sx: { borderBottom: 'none' } }, row.createdAt)),
	        open && (React__default["default"].createElement(TableRow__default["default"], null,
	            React__default["default"].createElement(TableCell__default["default"], { style: { paddingBottom: 0, paddingTop: 0 }, colSpan: 6 },
	                React__default["default"].createElement(Collapse__default["default"], { in: open, timeout: "auto", unmountOnExit: true },
	                    React__default["default"].createElement(Box__default["default"], { sx: { margin: 1 } }, collapsedContent)))))));
	}
	function CollapsedAddFeatureContent(props) {
	    const { row, session, assemblyId } = props;
	    const { changes } = row;
	    const { addedFeature } = changes?.[0] || {};
	    const feature = addedFeature;
	    const [addedFeatureRows, setAddedFeatureRows] = React.useState([]);
	    const [gene, setGene] = React.useState();
	    React.useEffect(() => {
	        const fetchGeneFeature = async (featureId) => {
	            if (!featureId) {
	                return;
	            }
	            const driver = session.apolloDataStore.collaborationServerDriver;
	            const fetchedFeature = await driver.getFeatureById(featureId, assemblyId, true);
	            if (!fetchedFeature) {
	                return;
	            }
	            setGene(fetchedFeature);
	        };
	        if (feature.type === 'gene') {
	            setGene(feature);
	        }
	        else {
	            const featureId = feature._id;
	            fetchGeneFeature(featureId).catch((error) => {
	                console.error('Error fetching feature by ID:', error);
	                setGene(undefined);
	            });
	        }
	        const rows = [];
	        rows.push({
	            id: feature._id,
	            type: feature.type,
	        });
	        if (feature.children) {
	            for (const [, child] of Object.entries(feature.children)) {
	                rows.push({
	                    id: child._id,
	                    type: child.type,
	                });
	                if (child.children) {
	                    for (const [, grandChild] of Object.entries(child.children)) {
	                        rows.push({
	                            id: grandChild._id,
	                            type: grandChild.type,
	                        });
	                    }
	                }
	            }
	        }
	        setAddedFeatureRows(rows);
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [row]);
	    if (!addedFeature) {
	        return React__default["default"].createElement(CollapsedJsonContent, { row: row });
	    }
	    return (React__default["default"].createElement(TableContainer__default["default"], { component: Paper__default["default"], style: { margin: 10, maxHeight: '300px', overflow: 'auto' } },
	        React__default["default"].createElement(Table__default["default"], { size: "small" },
	            React__default["default"].createElement(TableBody__default["default"], null,
	                React__default["default"].createElement(TableRow__default["default"], { style: { borderTop: '1px solid #e0e0e0' } },
	                    React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, "Feature ID")),
	                    React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, "Type")),
	                    React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, "Status"))),
	                addedFeatureRows.map((r) => (React__default["default"].createElement(TableRow__default["default"], { key: r.id },
	                    React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, r.id)),
	                    React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, r.type)),
	                    React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, getFeatureStatus(gene, row))))))))));
	}
	function CollapsedDeleteFeatureContent(props) {
	    const { row } = props;
	    const { changes } = row;
	    const { deletedFeature } = changes?.[0] || {};
	    if (!deletedFeature) {
	        return React__default["default"].createElement(CollapsedJsonContent, { row: row });
	    }
	    const feature = deletedFeature;
	    const deletedFeatureRows = [];
	    deletedFeatureRows.push({
	        id: feature._id,
	        type: feature.type,
	    });
	    if (feature.children) {
	        for (const [, child] of Object.entries(feature.children)) {
	            deletedFeatureRows.push({
	                id: child._id,
	                type: child.type,
	            });
	            if (child.children) {
	                for (const [, grandChild] of Object.entries(child.children)) {
	                    deletedFeatureRows.push({
	                        id: grandChild._id,
	                        type: grandChild.type,
	                    });
	                }
	            }
	        }
	    }
	    return (React__default["default"].createElement(TableContainer__default["default"], { component: Paper__default["default"], style: { margin: 10, maxHeight: '300px', overflow: 'auto' } },
	        React__default["default"].createElement(Table__default["default"], { size: "small" },
	            React__default["default"].createElement(TableBody__default["default"], null,
	                React__default["default"].createElement(TableRow__default["default"], { style: { borderTop: '1px solid #e0e0e0' } },
	                    React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, "Feature ID")),
	                    React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, "Type"))),
	                deletedFeatureRows.map((row) => (React__default["default"].createElement(TableRow__default["default"], { key: row.id },
	                    React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, row.id)),
	                    React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, row.type)))))))));
	}
	function CollapsedTypeChangeContent(props) {
	    const { row, session, assemblyId } = props;
	    const [featureId] = row.changedIds;
	    const [gene, setGene] = React.useState();
	    const [feature, setFeature] = React.useState();
	    const [diffAttributes, setDiffAttributes] = React.useState([]);
	    React.useEffect(() => {
	        const fetchFeature = async () => {
	            if (!featureId) {
	                return;
	            }
	            const driver = session.apolloDataStore.collaborationServerDriver;
	            const fetchedFeature = await driver.getFeatureById(featureId, assemblyId, true);
	            setGene(fetchedFeature);
	            if (!fetchedFeature) {
	                return;
	            }
	            if (featureId === fetchedFeature._id) {
	                setFeature(fetchedFeature);
	                return;
	            }
	            for (const [k, t] of new Map(Object.entries(fetchedFeature.children ?? {}))) {
	                if (k === featureId) {
	                    setFeature(t);
	                    return;
	                }
	                for (const [tk, c] of new Map(Object.entries(t.children ?? {}))) {
	                    if (tk === featureId) {
	                        setFeature(c);
	                        return;
	                    }
	                }
	            }
	        };
	        fetchFeature().catch((error) => {
	            console.error('Error fetching feature by ID:', error);
	            setFeature(undefined);
	        });
	        const diffAttrs = [];
	        diffAttrs.push({
	            attribute: '',
	            old: [String(row.changes?.[0].oldType)],
	            new: [String(row.changes?.[0].newType)],
	        });
	        setDiffAttributes(diffAttrs);
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [featureId, assemblyId]);
	    if (!feature) {
	        return React__default["default"].createElement(CollapsedJsonContent, { ...props });
	    }
	    return (React__default["default"].createElement("div", null,
	        React__default["default"].createElement(CollapsedInfoContent, { feature: feature, gene: gene, row: row }),
	        React__default["default"].createElement(CollapsedDiffAttributesContent, { diffAttributes: diffAttributes })));
	}
	function CollapsedLocationChangeContent(props) {
	    const { row, session, assemblyId } = props;
	    const [featureId] = row.changedIds;
	    const [gene, setGene] = React.useState();
	    const [feature, setFeature] = React.useState();
	    const [diffAttributes, setDiffAttributes] = React.useState([]);
	    React.useEffect(() => {
	        const fetchFeature = async () => {
	            if (!featureId) {
	                return;
	            }
	            const driver = session.apolloDataStore.collaborationServerDriver;
	            const fetchedFeature = await driver.getFeatureById(featureId, assemblyId, true);
	            setGene(fetchedFeature);
	            if (!fetchedFeature) {
	                return;
	            }
	            if (featureId === fetchedFeature._id) {
	                setFeature(fetchedFeature);
	                return;
	            }
	            for (const [k, t] of new Map(Object.entries(fetchedFeature.children ?? {}))) {
	                if (k === featureId) {
	                    setFeature(t);
	                    return;
	                }
	                for (const [tk, c] of new Map(Object.entries(t.children ?? {}))) {
	                    if (tk === featureId) {
	                        setFeature(c);
	                        return;
	                    }
	                }
	            }
	        };
	        fetchFeature().catch((error) => {
	            console.error('Error fetching feature by ID:', error);
	            setFeature(undefined);
	        });
	        const diffAttrs = [];
	        if (row.typeName === 'LocationStartChange') {
	            diffAttrs.push({
	                attribute: '',
	                old: [String(row.changes?.[0].oldStart)],
	                new: [String(row.changes?.[0].newStart)],
	            });
	        }
	        if (row.typeName === 'LocationEndChange') {
	            diffAttrs.push({
	                attribute: '',
	                old: [String(row.changes?.[0].oldEnd)],
	                new: [String(row.changes?.[0].newEnd)],
	            });
	        }
	        setDiffAttributes(diffAttrs);
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [featureId, assemblyId]);
	    if (!feature) {
	        return React__default["default"].createElement(CollapsedJsonContent, { ...props });
	    }
	    return (React__default["default"].createElement("div", null,
	        React__default["default"].createElement(CollapsedInfoContent, { feature: feature, gene: gene, row: row }),
	        React__default["default"].createElement(CollapsedDiffAttributesContent, { diffAttributes: diffAttributes })));
	}
	function CollapsedFeatureAttributeContent(props) {
	    const { row, session, assemblyId } = props;
	    const [featureId] = row.changedIds;
	    const [gene, setGene] = React.useState();
	    const [feature, setFeature] = React.useState();
	    const [diffAttributes, setDiffAttributes] = React.useState([]);
	    const getDiffAttributes = (oldAttrs, newAttrs) => {
	        const allKeys = new Set([
	            ...Object.keys(oldAttrs),
	            ...Object.keys(newAttrs),
	        ]);
	        const diff = [];
	        for (const key of allKeys) {
	            const oldValues = oldAttrs[key] ?? [];
	            const newValues = newAttrs[key] ?? [];
	            const oldSet = new Set(oldValues);
	            const newSet = new Set(newValues);
	            const isEqual = oldValues.length === newValues.length &&
	                oldSet.size === newSet.size &&
	                [...oldSet].every((value) => newSet.has(value));
	            if (!isEqual) {
	                diff.push({
	                    attribute: key,
	                    old: oldValues,
	                    new: newValues,
	                });
	            }
	        }
	        return diff;
	    };
	    React.useEffect(() => {
	        const fetchFeature = async () => {
	            if (!featureId) {
	                return;
	            }
	            const driver = session.apolloDataStore.collaborationServerDriver;
	            const fetchedFeature = await driver.getFeatureById(featureId, assemblyId, true);
	            setGene(fetchedFeature);
	            if (!fetchedFeature) {
	                return;
	            }
	            if (featureId === fetchedFeature._id) {
	                setFeature(fetchedFeature);
	                return;
	            }
	            for (const [k, t] of new Map(Object.entries(fetchedFeature.children ?? {}))) {
	                if (k === featureId) {
	                    setFeature(t);
	                    return;
	                }
	                for (const [tk, c] of new Map(Object.entries(t.children ?? {}))) {
	                    if (tk === featureId) {
	                        setFeature(c);
	                        return;
	                    }
	                }
	            }
	        };
	        fetchFeature().catch((error) => {
	            console.error('Error fetching feature by ID:', error);
	            setFeature(undefined);
	        });
	        const diffAttrs = getDiffAttributes((row.changes?.[0].oldAttributes ?? {}), (row.changes?.[0].newAttributes ?? {}));
	        setDiffAttributes(diffAttrs);
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [featureId, assemblyId]);
	    if (!feature) {
	        return React__default["default"].createElement(CollapsedJsonContent, { ...props });
	    }
	    return (React__default["default"].createElement("div", null,
	        React__default["default"].createElement(CollapsedInfoContent, { feature: feature, gene: gene, row: row }),
	        React__default["default"].createElement(CollapsedDiffAttributesContent, { diffAttributes: diffAttributes })));
	}
	function CollapsedDiffAttributesContent(props) {
	    const { diffAttributes } = props;
	    return (React__default["default"].createElement("div", null, diffAttributes.length > 0 && (React__default["default"].createElement(TableContainer__default["default"], { component: Paper__default["default"], style: { margin: 10 } },
	        React__default["default"].createElement(Table__default["default"], { size: "small" },
	            React__default["default"].createElement(TableBody__default["default"], null,
	                React__default["default"].createElement(TableRow__default["default"], { style: { borderTop: '1px solid #e0e0e0' } },
	                    React__default["default"].createElement(TableCell__default["default"], { align: "left" },
	                        React__default["default"].createElement("small", null, "Attribute")),
	                    React__default["default"].createElement(TableCell__default["default"], { align: "left" },
	                        React__default["default"].createElement("small", null, "Old")),
	                    React__default["default"].createElement(TableCell__default["default"], { align: "left" },
	                        React__default["default"].createElement("small", null, "New"))),
	                diffAttributes.map((attr, index) => (React__default["default"].createElement(TableRow__default["default"], { key: index },
	                    React__default["default"].createElement(TableCell__default["default"], { align: "left" },
	                        React__default["default"].createElement("small", null, attr.attribute)),
	                    React__default["default"].createElement(TableCell__default["default"], null, attr.old.length > 0 ? (React__default["default"].createElement("ul", null, attr.old.map((value, i) => (React__default["default"].createElement("li", { key: i }, value))))) : (React__default["default"].createElement("small", null, "N/A"))),
	                    React__default["default"].createElement(TableCell__default["default"], { align: "left" }, attr.new.length > 0 ? (React__default["default"].createElement("ul", null, attr.new.map((value, i) => (React__default["default"].createElement("li", { key: i }, value))))) : (React__default["default"].createElement("small", null, "N/A"))))))))))));
	}
	const getFeatureStatus = (gene, row) => {
	    if (!gene) {
	        return 'Unknown';
	    }
	    const savedAt = gene.attributes?.savedAt?.[0];
	    if (savedAt && row.updatedAt) {
	        const havanaSavedAtDate = new Date(savedAt);
	        const geneUpdatedAtDate = new Date(row.updatedAt);
	        if (havanaSavedAtDate >= geneUpdatedAtDate) {
	            return 'Done';
	        }
	    }
	    return 'Pending';
	};
	function CollapsedInfoContent(props) {
	    const { feature, gene, row } = props;
	    return (React__default["default"].createElement(TableContainer__default["default"], { component: Paper__default["default"], style: { margin: 10 } },
	        React__default["default"].createElement(Table__default["default"], { size: "small" },
	            React__default["default"].createElement(TableBody__default["default"], null,
	                React__default["default"].createElement(TableRow__default["default"], { style: { borderTop: '1px solid #e0e0e0' } },
	                    React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, "Type")),
	                    React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, "Feature ID")),
	                    gene?.type !== feature.type && (React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, "Gene ID"))),
	                    React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, "Status"))),
	                React__default["default"].createElement(TableRow__default["default"], null,
	                    React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, feature.type)),
	                    React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, getFeatureId$1(feature))),
	                    gene?.type !== feature.type && (React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, getFeatureId$1(gene)))),
	                    React__default["default"].createElement(TableCell__default["default"], null,
	                        React__default["default"].createElement("small", null, getFeatureStatus(gene, row))))))));
	}
	function CollapsedJsonContent(props) {
	    const { row } = props;
	    const objectRef = React.useRef(null);
	    const onCopyClick = () => {
	        const objectDiv = objectRef.current;
	        if (!objectDiv) {
	            return;
	        }
	        void copyToClipboard(objectDiv);
	    };
	    return (React__default["default"].createElement("div", null,
	        React__default["default"].createElement("div", { style: {
	                marginTop: 10,
	                display: 'flex',
	                flexDirection: 'row',
	                alignItems: 'center',
	                gap: 10,
	            } },
	            React__default["default"].createElement(Typography__default["default"], null, "Change Object"),
	            React__default["default"].createElement(material.Tooltip, { title: "Copy" },
	                React__default["default"].createElement(default_1$i, { style: { fontSize: 15, cursor: 'pointer' }, onClick: onCopyClick }))),
	        React__default["default"].createElement("div", { style: {
	                height: '100px',
	                overflowY: 'scroll',
	                border: '1px solid #e0e0e0',
	                borderRadius: 5,
	            }, ref: objectRef },
	            React__default["default"].createElement("pre", null, JSON.stringify(row.changes, null, 2)))));
	}
	function TablePaginationActions(props) {
	    const theme = styles.useTheme();
	    const { count, page, rowsPerPage, onPageChange } = props;
	    const handleFirstPageButtonClick = (event) => {
	        onPageChange(event, 0);
	    };
	    const handleBackButtonClick = (event) => {
	        onPageChange(event, page - 1);
	    };
	    const handleNextButtonClick = (event) => {
	        onPageChange(event, page + 1);
	    };
	    const handleLastPageButtonClick = (event) => {
	        onPageChange(event, Math.max(0, Math.ceil(count / rowsPerPage) - 1));
	    };
	    return (React__default["default"].createElement(Box__default["default"], { sx: { flexShrink: 0, ml: 2.5 } },
	        React__default["default"].createElement(IconButton__default["default"], { onClick: handleFirstPageButtonClick, disabled: page === 0, "aria-label": "first page" }, theme.direction === 'rtl' ? React__default["default"].createElement(default_1$c, null) : React__default["default"].createElement(default_1$h, null)),
	        React__default["default"].createElement(IconButton__default["default"], { onClick: handleBackButtonClick, disabled: page === 0, "aria-label": "previous page" }, theme.direction === 'rtl' ? (React__default["default"].createElement(default_1$e, null)) : (React__default["default"].createElement(default_1$f, null))),
	        React__default["default"].createElement(IconButton__default["default"], { onClick: handleNextButtonClick, disabled: page >= Math.ceil(count / rowsPerPage) - 1, "aria-label": "next page" }, theme.direction === 'rtl' ? (React__default["default"].createElement(default_1$f, null)) : (React__default["default"].createElement(default_1$e, null))),
	        React__default["default"].createElement(IconButton__default["default"], { onClick: handleLastPageButtonClick, disabled: page >= Math.ceil(count / rowsPerPage) - 1, "aria-label": "last page" }, theme.direction === 'rtl' ? React__default["default"].createElement(default_1$h, null) : React__default["default"].createElement(default_1$c, null))));
	}

	/* eslint-disable @typescript-eslint/unbound-method */
	const columns$1 = [
	    { field: 'refName', headerName: 'Ref Name' },
	    { field: 'aliases', headerName: 'Aliases', editable: true },
	];
	const isGeneratedObjectId = (key) => {
	    const pattern = /^[\da-f]{24}$/i;
	    return pattern.test(key);
	};
	function AddRefSeqAliases({ changeManager, handleClose, session, }) {
	    const fileRef = React.useRef(null);
	    const [errorMessage, setErrorMessage] = React.useState('');
	    const [enableSubmit, setEnableSubmit] = React.useState(false);
	    const [selectedAssembly, setSelectedAssembly] = React.useState();
	    const [selectedRows, setSelectedRows] = React.useState([]);
	    const [refNameAliasMap, setRefNameAliasMap] = React.useState(new Map());
	    const { apolloDataStore } = session;
	    const { collaborationServerDriver } = apolloDataStore;
	    const assemblies = collaborationServerDriver.getAssemblies();
	    React.useEffect(() => {
	        let retry = 0;
	        const maxRetries = 2;
	        const initializeRefNameAliasMap = () => {
	            if (!selectedAssembly) {
	                return;
	            }
	            const initialMap = new Map();
	            if (retry < maxRetries && !selectedAssembly.refNames) {
	                retry++;
	                setTimeout(initializeRefNameAliasMap, 50);
	            }
	            if (!selectedAssembly.refNames) {
	                return;
	            }
	            const refNameAliasess = selectedAssembly.refNameAliases;
	            for (const key in refNameAliasess) {
	                const value = refNameAliasess[key];
	                if (!value || isGeneratedObjectId(key)) {
	                    continue;
	                }
	                if (initialMap.has(value)) {
	                    const aliases = initialMap.get(value) ?? [];
	                    initialMap.set(value, [...aliases, key]);
	                }
	                else {
	                    initialMap.set(value, [key]);
	                }
	            }
	            setRefNameAliasMap(initialMap);
	        };
	        initializeRefNameAliasMap();
	    }, [selectedAssembly]);
	    const handleChangeAssembly = (e) => {
	        const newAssembly = assemblies.find((asm) => asm.name === e.target.value);
	        setSelectedAssembly(newAssembly);
	        setEnableSubmit(false);
	        setErrorMessage('');
	        if (fileRef.current) {
	            fileRef.current.value = '';
	        }
	    };
	    const handleChangeFile = async (e) => {
	        if (!e.target.files) {
	            return;
	        }
	        // eslint-disable-next-line prefer-destructuring
	        const file = e.target.files[0];
	        const fileContent = await file.text();
	        const lines = fileContent.split('\n');
	        const newMap = new Map(refNameAliasMap);
	        setErrorMessage('');
	        for (const line of lines) {
	            const aliases = line.split('\t');
	            for (const alias of aliases) {
	                if (newMap.has(alias)) {
	                    newMap.set(alias, [...(newMap.get(alias) ?? []), ...aliases]);
	                }
	            }
	        }
	        setRefNameAliasMap(newMap);
	    };
	    const handleChangeFileHandler = (e) => {
	        handleChangeFile(e).catch(() => {
	            setErrorMessage('Error reading file');
	        });
	    };
	    const rowSelectionChange = (ids) => {
	        if (ids.length > 0) {
	            setEnableSubmit(true);
	            const selectedRows = ids.flatMap((id) => getTableRows().filter((row) => row.id === id));
	            setSelectedRows(selectedRows);
	        }
	        else {
	            setEnableSubmit(false);
	            setSelectedRows([]);
	        }
	    };
	    const getTableRows = () => {
	        return [...refNameAliasMap].map((ele, i) => ({
	            id: i,
	            refName: ele[0],
	            aliases: ele[1].filter((alias) => alias !== ele[0]).join(', '),
	        }));
	    };
	    const processRowUpdate = (newRow, _oldRow) => {
	        const newMap = new Map(refNameAliasMap);
	        newMap.set(newRow.refName, newRow.aliases.split(','));
	        setRefNameAliasMap(newMap);
	        return newRow;
	    };
	    const handleSubmit = () => {
	        const refSeqAliases = [];
	        for (const row of selectedRows) {
	            const { refName } = row;
	            const aliases = row.aliases
	                .split(',')
	                .map((alias) => alias.trim())
	                .filter((alias) => alias.length > 0);
	            refSeqAliases.push({
	                refName,
	                aliases,
	            });
	        }
	        setErrorMessage('');
	        if (!selectedAssembly) {
	            setErrorMessage('No assembly selected');
	            return;
	        }
	        const change = new dist$2.AddRefSeqAliasesChange({
	            typeName: 'AddRefSeqAliasesChange',
	            assembly: selectedAssembly.name,
	            refSeqAliases,
	        });
	        changeManager.submit(change).catch(() => {
	            setErrorMessage('Error submitting change');
	        });
	        handleClose();
	    };
	    return (React__default["default"].createElement(Dialog, { open: true, title: "Add reference sequence aliases", handleClose: handleClose, maxWidth: 'sm', "data-testid": "add-refseq-alias", fullWidth: true },
	        React__default["default"].createElement(material.DialogContent, { style: { display: 'flex', flexDirection: 'column' } },
	            React__default["default"].createElement(material.Grid2, { container: true, spacing: 2 },
	                React__default["default"].createElement(material.Grid2, null,
	                    React__default["default"].createElement(material.FormControl, { disabled: enableSubmit && !errorMessage, fullWidth: true },
	                        React__default["default"].createElement(material.InputLabel, { id: "demo-simple-select-label" }, "Assembly"),
	                        React__default["default"].createElement(material.Select, { labelId: "demo-simple-select-label", id: "demo-simple-select", label: "Assembly", value: selectedAssembly?.name ?? '', onChange: handleChangeAssembly }, assemblies.map((option) => (React__default["default"].createElement(material.MenuItem, { key: option.name, value: option.name }, option.displayName ?? option.name)))))),
	                React__default["default"].createElement(material.Grid2, null,
	                    React__default["default"].createElement(material.InputLabel, null, "Load RefName alias"),
	                    React__default["default"].createElement("input", { type: "file", onChange: handleChangeFileHandler, ref: fileRef, disabled: (enableSubmit && !errorMessage) || !selectedAssembly }))),
	            selectedAssembly && refNameAliasMap.size > 0 ? (React__default["default"].createElement("div", { style: { height: 200, width: '100%', marginTop: 20 } },
	                React__default["default"].createElement(material.InputLabel, null, "Refname aliases found for selected assembly."),
	                React__default["default"].createElement(xDataGrid.DataGrid, { rows: getTableRows(), columns: columns$1, initialState: {
	                        pagination: {
	                            paginationModel: { page: 0, pageSize: 5 },
	                        },
	                    }, pageSizeOptions: [5, 10], onRowSelectionModelChange: (ids) => {
	                        rowSelectionChange(ids);
	                    }, processRowUpdate: processRowUpdate, checkboxSelection: true }))) : null),
	        React__default["default"].createElement(material.DialogActions, null,
	            React__default["default"].createElement(material.Button, { variant: "contained", type: "submit", disabled: !enableSubmit, onClick: handleSubmit }, "Submit"),
	            React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: handleClose }, "Close")),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	function ViewCheckResults({ handleClose, session, }) {
	    const { internetAccounts } = require$$1$3.getRoot(session);
	    const { collaborationServerDriver } = session.apolloDataStore;
	    const apolloInternetAccount = internetAccounts.find((ia) => ia.type === 'ApolloInternetAccount');
	    if (!apolloInternetAccount) {
	        throw new Error('No Apollo internet account found');
	    }
	    const { baseURL } = apolloInternetAccount;
	    const [errorMessage, setErrorMessage] = React.useState();
	    const [selectedAssembly, setSelectedAssembly] = React.useState();
	    const [displayGridData, setDisplayGridData] = React.useState([]);
	    const gridColumns = [
	        { field: '_id', headerName: 'id', width: 50 },
	        {
	            field: 'name',
	            headerName: 'Check name',
	            width: 200,
	        },
	        { field: 'refSeq', headerName: 'Reference sequence ID', width: 200 },
	        { field: 'ids', headerName: 'Feature IDs', width: 200 },
	        { field: 'message', headerName: 'Message', flex: 1 },
	    ];
	    const assemblies = collaborationServerDriver.getAssemblies();
	    React.useEffect(() => {
	        if (!selectedAssembly && assemblies.length > 0) {
	            setSelectedAssembly(assemblies[0]);
	        }
	    }, [assemblies, selectedAssembly]);
	    React.useEffect(() => {
	        async function getGridData() {
	            const assemblyId = selectedAssembly?.name;
	            if (!assemblyId) {
	                return;
	            }
	            const url = new URL('checks', baseURL);
	            const searchParams = new URLSearchParams({ assembly: assemblyId });
	            url.search = searchParams.toString();
	            const uri = url.toString();
	            const apolloFetch = apolloInternetAccount?.getFetcher({
	                locationType: 'UriLocation',
	                uri,
	            });
	            if (apolloFetch) {
	                const response = await apolloFetch(uri, {
	                    headers: new Headers({ 'Content-Type': 'application/json' }),
	                });
	                if (!response.ok) {
	                    const newErrorMessage = await createFetchErrorMessage(response, 'Error when retrieving checks');
	                    setErrorMessage(newErrorMessage);
	                    return;
	                }
	                const data = await response.json();
	                setDisplayGridData(data);
	            }
	        }
	        getGridData().catch((error) => {
	            setErrorMessage(String(error));
	        });
	    }, [selectedAssembly, apolloInternetAccount, baseURL]);
	    function handleChangeAssembly(e) {
	        const newAssembly = assemblies.find((asm) => asm.name === e.target.value);
	        setSelectedAssembly(newAssembly);
	    }
	    return (React__default["default"].createElement(Dialog, { open: true, fullScreen: true, title: "View check results", handleClose: handleClose, "data-testid": "view-check-results" },
	        React__default["default"].createElement(material.Select, { style: { width: 200, marginLeft: 40 }, value: selectedAssembly?.name ?? '', onChange: handleChangeAssembly, disabled: assemblies.length === 0 }, assemblies.map((option) => (React__default["default"].createElement(material.MenuItem, { key: option.name, value: option.name }, option.displayName ?? option.name)))),
	        React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(xDataGrid.DataGrid, { pagination: true, rows: displayGridData, columns: gridColumns, getRowId: (row) => row._id, slots: { toolbar: xDataGrid.GridToolbar }, initialState: {
	                    sorting: { sortModel: [{ field: 'name', sort: 'asc' }] },
	                    columns: { columnVisibilityModel: { name: true } },
	                } })),
	        React__default["default"].createElement(material.DialogActions, null,
	            React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: handleClose }, "Close")),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	/* eslint-disable @typescript-eslint/unbound-method */
	function exonIsSplittable(exonToBeSplit) {
	    if (exonToBeSplit.max - exonToBeSplit.min < 2) {
	        return {
	            isSplittable: false,
	            comment: 'This exon is too short to be split',
	        };
	    }
	    return { isSplittable: true, comment: '' };
	}
	function makeDialogText(splitExon) {
	    const splittable = exonIsSplittable(splitExon);
	    if (splittable.isSplittable) {
	        return 'Are you sure you want to split the selected exon?';
	    }
	    return splittable.comment;
	}
	function SplitExon({ changeManager, handleClose, selectedFeature, setSelectedFeature, sourceAssemblyId, sourceFeature, }) {
	    const [errorMessage, setErrorMessage] = React.useState('');
	    const exonToBeSplit = require$$1$3.getSnapshot(sourceFeature);
	    function onSubmit(event) {
	        event.preventDefault();
	        setErrorMessage('');
	        if (selectedFeature?._id === sourceFeature._id) {
	            setSelectedFeature();
	        }
	        const midpoint = exonToBeSplit.min + (exonToBeSplit.max - exonToBeSplit.min) / 2;
	        const upstreamCut = Math.floor(midpoint);
	        const downstreamCut = Math.ceil(midpoint);
	        if (!sourceFeature.parent?._id) {
	            throw new Error('Splitting an exon without parent is not possible yet');
	        }
	        const change = new dist$2.SplitExonChange({
	            changedIds: [sourceFeature._id],
	            typeName: 'SplitExonChange',
	            assembly: sourceAssemblyId,
	            exonToBeSplit,
	            parentFeatureId: sourceFeature.parent._id,
	            upstreamCut,
	            downstreamCut,
	            leftExonId: new objectid().toHexString(),
	            rightExonId: new objectid().toHexString(),
	        });
	        void changeManager.submit(change);
	        handleClose();
	        event.preventDefault();
	    }
	    return (React__default["default"].createElement(Dialog, { open: true, title: "Split exon", handleClose: handleClose, maxWidth: false, "data-testid": "split-exon" },
	        React__default["default"].createElement("form", { onSubmit: onSubmit },
	            React__default["default"].createElement(material.DialogContent, { style: { display: 'flex', flexDirection: 'column' } },
	                React__default["default"].createElement(material.DialogContentText, null, makeDialogText(exonToBeSplit))),
	            React__default["default"].createElement(material.DialogActions, null,
	                React__default["default"].createElement(material.Button, { variant: "contained", type: "submit", disabled: !exonIsSplittable(exonToBeSplit).isSplittable }, "Yes"),
	                React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: handleClose }, "Cancel"))),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	const columns = [
	    {
	        field: 'name',
	        headerName: 'Assembly Name',
	        width: 150,
	        editable: false,
	    },
	    {
	        field: 'aliases',
	        headerName: 'Aliases',
	        width: 300,
	        editable: true,
	    },
	];
	function AddAssemblyAliases({ changeManager, handleClose, session, }) {
	    const { apolloDataStore } = session;
	    const { collaborationServerDriver } = apolloDataStore;
	    const assemblies = collaborationServerDriver.getAssemblies();
	    const rows = assemblies.map((assembly) => {
	        return {
	            id: assembly.name,
	            name: assembly.displayName ?? assembly.name,
	            aliases: assembly.aliases.join(', '),
	        };
	    });
	    const [errorMessage, setErrorMessage] = React__default["default"].useState('');
	    const processRowUpdate = (newRow, _oldRow) => {
	        const change = new dist$2.AddAssemblyAliasesChange({
	            typeName: 'AddAssemblyAliasesChange',
	            assembly: newRow.id,
	            aliases: newRow.aliases.split(','),
	        });
	        void changeManager.submit(change).catch(() => {
	            setErrorMessage('Error submitting change');
	        });
	        handleClose();
	        return newRow;
	    };
	    return (React__default["default"].createElement(Dialog, { open: true, title: "Add assembly aliases", handleClose: handleClose, maxWidth: 'sm', "data-testid": "add-assembly-alias", fullWidth: true },
	        React__default["default"].createElement(material.DialogContent, { style: { display: 'flex', flexDirection: 'column' } },
	            React__default["default"].createElement(material.Box, { sx: { height: 400, width: '100%' } },
	                React__default["default"].createElement(xDataGrid.DataGrid, { rows: rows, columns: columns, initialState: {
	                        pagination: {
	                            paginationModel: {
	                                pageSize: 5,
	                            },
	                        },
	                    }, pageSizeOptions: [5], processRowUpdate: processRowUpdate, disableRowSelectionOnClick: true }))),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	function addMenuItems(rootModel) {
	    rootModel.appendToMenu('Apollo', {
	        label: 'Add Assembly',
	        onClick: (session) => {
	            session.queueDialog((doneCallback) => [
	                AddAssembly,
	                {
	                    session,
	                    handleClose: () => {
	                        doneCallback();
	                    },
	                    changeManager: session.apolloDataStore.changeManager,
	                },
	            ]);
	        },
	    });
	    rootModel.appendToMenu('Apollo', {
	        label: 'Delete Assembly',
	        onClick: (session) => {
	            session.queueDialog((doneCallback) => [
	                DeleteAssembly,
	                {
	                    session,
	                    handleClose: () => {
	                        doneCallback();
	                    },
	                    changeManager: session.apolloDataStore.changeManager,
	                },
	            ]);
	        },
	    });
	    rootModel.appendToMenu('Apollo', {
	        label: 'Import Features',
	        onClick: (session) => {
	            session.queueDialog((doneCallback) => [
	                ImportFeatures,
	                {
	                    session,
	                    handleClose: () => {
	                        doneCallback();
	                    },
	                    changeManager: session.apolloDataStore.changeManager,
	                },
	            ]);
	        },
	    });
	    rootModel.appendToMenu('Apollo', {
	        label: 'Add reference sequence aliases',
	        onClick: (session) => {
	            session.queueDialog((doneCallback) => [
	                AddRefSeqAliases,
	                {
	                    session,
	                    handleClose: () => {
	                        doneCallback();
	                    },
	                    changeManager: session.apolloDataStore.changeManager,
	                },
	            ]);
	        },
	    });
	    rootModel.appendToMenu('Apollo', {
	        label: 'Add Assembly aliases',
	        onClick: (session) => {
	            session.queueDialog((doneCallback) => [
	                AddAssemblyAliases,
	                {
	                    session,
	                    handleClose: () => {
	                        doneCallback();
	                    },
	                    changeManager: session.apolloDataStore.changeManager,
	                },
	            ]);
	        },
	    });
	    rootModel.appendToMenu('Apollo', {
	        label: 'Manage Users',
	        onClick: (session) => {
	            session.queueDialog((doneCallback) => [
	                ManageUsers,
	                {
	                    session,
	                    handleClose: () => {
	                        doneCallback();
	                    },
	                    changeManager: session.apolloDataStore.changeManager,
	                },
	            ]);
	        },
	    });
	    rootModel.appendToMenu('Apollo', {
	        label: 'Undo',
	        onClick: (session) => {
	            const { apolloDataStore } = session;
	            const { notify } = session;
	            if (apolloDataStore.changeManager.recentChanges.length > 0) {
	                void apolloDataStore.changeManager.revertLastChange();
	            }
	            else {
	                notify('No changes to undo', 'info');
	            }
	        },
	    });
	}

	var AccountCircle = {};

	var _interopRequireDefault$b = interopRequireDefault.exports;
	Object.defineProperty(AccountCircle, "__esModule", {
	  value: true
	});
	var default_1$b = AccountCircle["default"] = void 0;
	var _createSvgIcon$b = /*#__PURE__*/_interopRequireDefault$b(createSvgIcon);
	var _jsxRuntime$b = require$$2__default["default"];
	var _default$d = /*#__PURE__*/(0, _createSvgIcon$b["default"])( /*#__PURE__*/(0, _jsxRuntime$b.jsx)("path", {
	  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 4c1.93 0 3.5 1.57 3.5 3.5S13.93 13 12 13s-3.5-1.57-3.5-3.5S10.07 6 12 6zm0 14c-2.03 0-4.43-.82-6.14-2.88C7.55 15.8 9.68 15 12 15s4.45.8 6.14 2.12C16.43 19.18 14.03 20 12 20z"
	}), 'AccountCircle');
	default_1$b = AccountCircle["default"] = _default$d;

	// Icon source: https://developers.google.com/identity/branding-guidelines
	function Google(props) {
	    const { color } = props;
	    return (React__default["default"].createElement(material.SvgIcon, { viewBox: "0 0 18 18", style: { fontSize: 18, marginRight: 4 }, ...props }, color === 'disabled' ? (React__default["default"].createElement("path", { d: "M9.001,10.71 l0,-3.348 l8.424,0 c0.126,0.567,0.225,1.098,0.225,1.845 c0,5.139,-3.447,8.793,-8.64,8.793 c-4.968,0,-9,-4.032,-9,-9 c0,-4.968,4.032,-9,9,-9 c2.43,0,4.464,0.891,6.021,2.349 l-2.556,2.484 c-0.648,-0.612,-1.782,-1.332,-3.465,-1.332 c-2.979,0,-5.409,2.475,-5.409,5.508 c0,3.033,2.43,5.508,5.409,5.508 c3.447,0,4.716,-2.385,4.95,-3.798 l-4.959,0 l0,-0.009 z" })) : (React__default["default"].createElement(React__default["default"].Fragment, null,
	        React__default["default"].createElement("path", { d: "M17.64,9.20454545 c0,-0.638,-0.057,-1.252,-0.164,-1.841 l-8.476,0 l0,3.481 l4.844,0 c-0.209,1.125,-0.843,2.079,-1.796,2.717 l0,2.258 l2.908,0 c1.702,-1.567,2.684,-3.874,2.684,-6.615 l0,0 z", fill: "#4285F4" }),
	        React__default["default"].createElement("path", { d: "M9,18 c2.43,0,4.467,-0.806,5.956,-2.18 l-2.908,-2.259 c-0.806,0.54,-1.837,0.859,-3.048,0.859 c-2.344,0,-4.328,-1.583,-5.036,-3.71 l-3.007,0 l0,2.332 c1.481,2.941,4.525,4.958,8.043,4.958 l0,0 z", fill: "#34A853" }),
	        React__default["default"].createElement("path", { d: "M3.96409091,10.71 c-0.18,-0.54,-0.282,-1.117,-0.282,-1.71 c0,-0.593,0.102,-1.17,0.282,-1.71 l0,-2.332 l-3.007,0 c-0.609,1.215,-0.957,2.59,-0.957,4.042 c0,1.452,0.348,2.827,0.957,4.042 l3.007,-2.332 l0,0 z", fill: "#FBBC05" }),
	        React__default["default"].createElement("path", { d: "M9,3.57954545 c1.321,0,2.508,0.454,3.44,1.346 l2.582,-2.581 c-1.559,-1.453,-3.596,-2.345,-6.022,-2.345 c-3.518,0,-6.562,2.017,-8.043,4.959 l3.007,2.331 c0.708,-2.127,2.692,-3.71,5.036,-3.71 l0,0 z", fill: "#EA4335" })))));
	}
	// Icon source: https://learn.microsoft.com/en-us/azure/active-directory/develop/howto-add-branding-in-azure-ad-apps
	function Microsoft(props) {
	    const { color } = props;
	    return (React__default["default"].createElement(material.SvgIcon, { viewBox: "0 0 21 21", style: { fontSize: 21 }, ...props },
	        React__default["default"].createElement("rect", { x: "1", y: "1", width: "9", height: "9", fill: color === 'disabled' ? '#7B7B7B' : '#F25022' }),
	        React__default["default"].createElement("rect", { x: "1", y: "11", width: "9", height: "9", fill: color === 'disabled' ? '#7B7B7B' : '#00A4EF' }),
	        React__default["default"].createElement("rect", { x: "11", y: "1", width: "9", height: "9", fill: color === 'disabled' ? '#939393' : '#7FBA00' }),
	        React__default["default"].createElement("rect", { x: "11", y: "11", width: "9", height: "9", fill: color === 'disabled' ? '#B9B9B9' : '#FFB900' })));
	}

	const useStyles$e = mui.makeStyles()((theme) => ({
	    loginButton: {
	        marginBottom: theme.spacing(1),
	        width: '220px',
	        height: '40px',
	        fontSize: '16px',
	        textTransform: 'none',
	        justifyContent: 'left',
	        padding: '3px 12px',
	    },
	}));
	function GoogleButton(props) {
	    const { classes } = useStyles$e();
	    const { disabled } = props;
	    return (React__default["default"].createElement(material.Button, { className: classes.loginButton, variant: "outlined", startIcon: React__default["default"].createElement(Google, { color: disabled ? 'disabled' : undefined }), ...props }, "Sign in with Google"));
	}
	function MicrosoftButton(props) {
	    const { classes } = useStyles$e();
	    const { disabled } = props;
	    return (React__default["default"].createElement(material.Button, { className: classes.loginButton, variant: "outlined", startIcon: React__default["default"].createElement(Microsoft, { color: disabled ? 'disabled' : undefined }), ...props }, "Sign in with Microsoft"));
	}
	function GuestButton(props) {
	    const { classes } = useStyles$e();
	    return (React__default["default"].createElement(material.Button, { className: classes.loginButton, variant: "outlined", startIcon: React__default["default"].createElement(default_1$b, { fontSize: "small" }), ...props }, "Continue as Guest"));
	}

	/* eslint-disable @typescript-eslint/use-unknown-in-catch-callback-variable */
	const useStyles$d = mui.makeStyles()((theme) => ({
	    divider: {
	        marginTop: theme.spacing(4),
	        marginBottom: theme.spacing(5),
	    },
	}));
	const AuthTypeSelector = ({ baseURL, handleClose, name, }) => {
	    const { classes } = useStyles$d();
	    const [errorMessage, setErrorMessage] = React.useState('');
	    const [loginTypes, setLoginTypes] = React.useState([]);
	    React.useEffect(() => {
	        const controller = new AbortController();
	        const { signal } = controller;
	        async function getAuthTypes() {
	            const uri = new URL('auth/types', baseURL).href;
	            const response = await fetch(uri, { method: 'GET', signal });
	            if (!response.ok) {
	                const newErrorMessage = await createFetchErrorMessage(response, 'Error when retrieving auth types from server');
	                setErrorMessage(newErrorMessage);
	                return;
	            }
	            const data = (await response.json());
	            setLoginTypes(data);
	        }
	        getAuthTypes().catch((error) => {
	            if (!isAbortException_1(error)) {
	                setErrorMessage(String(error));
	            }
	        });
	        return () => {
	            controller.abort();
	        };
	    }, [baseURL]);
	    function handleClick(authType) {
	        if (authType === 'google') {
	            handleClose('google');
	        }
	        else if (authType === 'microsoft') {
	            handleClose('microsoft');
	        }
	        else {
	            handleClose('guest');
	        }
	    }
	    const allowGoogle = loginTypes.includes('google');
	    const allowMicrosoft = loginTypes.includes('microsoft');
	    const allowGuest = loginTypes.includes('guest');
	    return (React__default["default"].createElement(Dialog, { open: true, title: `Log in to ${name}`, handleClose: handleClose, maxWidth: false, "data-testid": "login-apollo" },
	        React__default["default"].createElement(material.DialogContent, { style: { display: 'flex', flexDirection: 'column', paddingTop: 8 } },
	            allowGoogle ? (React__default["default"].createElement(GoogleButton, { disabled: !allowGoogle, onClick: () => {
	                    handleClick('google');
	                } })) : null,
	            allowMicrosoft ? (React__default["default"].createElement(MicrosoftButton, { disabled: !allowMicrosoft, onClick: () => {
	                    handleClick('microsoft');
	                } })) : null,
	            allowGuest ? (React__default["default"].createElement(React__default["default"].Fragment, null,
	                React__default["default"].createElement(material.Divider, { className: classes.divider }),
	                React__default["default"].createElement(GuestButton, { onClick: () => {
	                        handleClick('guest');
	                    } }))) : null),
	        React__default["default"].createElement(material.DialogActions, null,
	            React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: () => {
	                    handleClose();
	                } }, "Cancel")),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	};

	/* eslint-disable @typescript-eslint/no-unsafe-return */
	const inWebWorker$1 = typeof sessionStorage === 'undefined';
	const stateModelFactory$2 = (configSchema) => {
	    return pluggableElementTypes.InternetAccount.named('ApolloInternetAccount')
	        .props({
	        type: require$$1$3.types.literal('ApolloInternetAccount'),
	        configuration: configuration.ConfigurationReference(configSchema),
	    })
	        .views((self) => ({
	        get baseURL() {
	            return configuration.getConf(self, 'baseURL');
	        },
	        getUserId() {
	            const token = self.retrieveToken();
	            if (!token) {
	                return;
	            }
	            const dec = dist$2.getDecodedToken(token);
	            return dec.id;
	        },
	    }))
	        .volatile(() => ({
	        role: undefined,
	    }))
	        .actions((self) => {
	        let roleNotificationSent = false;
	        return {
	            setRole() {
	                const token = self.retrieveToken();
	                if (!token) {
	                    self.role = undefined;
	                    return;
	                }
	                const dec = dist$2.getDecodedToken(token);
	                const { role } = dec;
	                if (!role && !roleNotificationSent) {
	                    const { session } = require$$1$3.getRoot(self);
	                    session.notify('You have registered as a user but have not been given access. Ask your administrator to enable access for your account.', 'warning');
	                    // notify
	                    roleNotificationSent = true;
	                }
	                if (self.role !== role) {
	                    self.role = role;
	                }
	            },
	        };
	    })
	        .actions((self) => {
	        let listener;
	        return {
	            addMessageChannel(resolve, reject) {
	                listener = (event) => {
	                    this.finishOAuthWindow(event, resolve, reject);
	                };
	                window.addEventListener('message', listener);
	            },
	            deleteMessageChannel() {
	                window.removeEventListener('message', listener);
	            },
	            finishOAuthWindow(event, resolve, reject) {
	                if (event.data.name !== `JBrowseAuthWindow-${self.internetAccountId}`) {
	                    this.deleteMessageChannel();
	                    return;
	                }
	                const redirectUriWithInfo = event.data.redirectUri;
	                const fixedQueryString = redirectUriWithInfo.replace('#', '?');
	                const redirectUrl = new URL(fixedQueryString);
	                const queryStringSearch = redirectUrl.search;
	                const urlParams = new URLSearchParams(queryStringSearch);
	                const token = urlParams.get('access_token');
	                this.deleteMessageChannel();
	                if (!token) {
	                    reject(new Error('Error with token endpoint'));
	                    return;
	                }
	                self.storeToken(token);
	                self.setRole();
	                resolve(token);
	            },
	            async openAuthWindow(type, resolve, reject) {
	                const redirectUri = require$$1$2.isElectron
	                    ? 'http://localhost/auth'
	                    : globalThis.location.origin + globalThis.location.pathname;
	                const url = new URL('auth/login', self.baseURL);
	                const params = new URLSearchParams({
	                    type,
	                    redirect_uri: redirectUri,
	                });
	                url.search = params.toString();
	                const eventName = `JBrowseAuthWindow-${self.internetAccountId}`;
	                if (require$$1$2.isElectron) {
	                    const { ipcRenderer } = globalThis.require('electron');
	                    const redirectUriFromElectron = await ipcRenderer.invoke('openAuthWindow', {
	                        internetAccountId: self.internetAccountId,
	                        data: { redirect_uri: redirectUri },
	                        url: url.toString(),
	                    });
	                    const eventFromDesktop = new MessageEvent('message', {
	                        data: { name: eventName, redirectUri: redirectUriFromElectron },
	                    });
	                    this.finishOAuthWindow(eventFromDesktop, resolve, reject);
	                }
	                else {
	                    this.addMessageChannel(resolve, reject);
	                    window.open(url, eventName, 'width=500,height=600');
	                }
	            },
	        };
	    })
	        .actions((self) => ({
	        async getTokenFromUser(resolve, reject) {
	            const { baseURL } = self;
	            const authType = await new Promise((resolve, reject) => {
	                const { session } = require$$1$3.getRoot(self);
	                const { baseURL, name } = self;
	                session.queueDialog((doneCallback) => [
	                    AuthTypeSelector,
	                    {
	                        name,
	                        handleClose: (newAuthType) => {
	                            if (!newAuthType) {
	                                reject(new Error('user cancelled entry'));
	                            }
	                            else if (newAuthType instanceof Error) {
	                                reject(newAuthType);
	                            }
	                            else {
	                                resolve(newAuthType);
	                            }
	                            doneCallback();
	                        },
	                        baseURL,
	                    },
	                ]);
	            });
	            if (authType !== 'guest') {
	                // eslint-disable-next-line @typescript-eslint/no-floating-promises
	                self.openAuthWindow(authType, resolve, reject);
	                return;
	            }
	            const url = new URL('auth/login', baseURL);
	            const searchParams = new URLSearchParams({ type: authType });
	            url.search = searchParams.toString();
	            const uri = url.toString();
	            const response = await fetch(uri);
	            if (!response.ok) {
	                const errorMessage = await createFetchErrorMessage(response, 'Error when logging in');
	                reject(new Error(errorMessage));
	                return;
	            }
	            const { token } = await response.json();
	            resolve(token);
	        },
	    }))
	        .volatile(() => ({
	        lastChangeSequenceNumber: undefined,
	    }))
	        .actions((self) => ({
	        setLastChangeSequenceNumber(sequenceNumber) {
	            self.lastChangeSequenceNumber = sequenceNumber;
	        },
	    }))
	        .actions((self) => ({
	        updateLastChangeSequenceNumber: require$$1$3.flow(function* updateLastChangeSequenceNumber() {
	            const { baseURL } = self;
	            const url = new URL('changes', baseURL);
	            const searchParams = new URLSearchParams({ limit: '1' });
	            url.search = searchParams.toString();
	            const uri = url.toString();
	            const apolloFetch = self.getFetcher({
	                locationType: 'UriLocation',
	                uri,
	            });
	            const response = yield apolloFetch(uri, { method: 'GET' });
	            if (!response.ok) {
	                const errorMessage = yield createFetchErrorMessage(response, 'Error when fetching server LastChangeSequence');
	                throw new Error(errorMessage);
	            }
	            const changes = yield response.json();
	            const sequence = changes.length > 0 ? changes[0].sequence : 0;
	            self.setLastChangeSequenceNumber(sequence);
	        }),
	        getMissingChanges: require$$1$3.flow(function* getMissingChanges() {
	            const { session } = require$$1$3.getRoot(self);
	            const { changeManager } = session.apolloDataStore;
	            if (!self.lastChangeSequenceNumber) {
	                throw new Error('No LastChangeSequence stored in session. Please, refresh you browser to get last updates from server');
	            }
	            const { baseURL, lastChangeSequenceNumber } = self;
	            const url = new URL('changes', baseURL);
	            const searchParams = new URLSearchParams({
	                since: String(lastChangeSequenceNumber),
	                sort: '1',
	            });
	            url.search = searchParams.toString();
	            const uri = url.toString();
	            const apolloFetch = self.getFetcher({
	                locationType: 'UriLocation',
	                uri,
	            });
	            const response = yield apolloFetch(uri, { method: 'GET' });
	            if (!response.ok) {
	                console.error(`Error when fetching the last updates to recover socket connection — ${response.status}`);
	                return;
	            }
	            const serializedChanges = yield response.json();
	            for (const serializedChange of serializedChanges) {
	                const change = dist$3.Change.fromJSON(serializedChange);
	                void changeManager.submit(change, { submitToBackend: false });
	            }
	        }),
	    }))
	        .volatile((self) => {
	        const { origin, pathname: path } = new URL('socket.io/', self.baseURL);
	        return { socket: lookup(origin, { path }) };
	    })
	        .actions((self) => ({
	        addSocketListeners() {
	            const { session } = require$$1$3.getRoot(self);
	            const { notify } = session;
	            const token = self.retrieveToken();
	            if (!token) {
	                throw new Error('No Token found');
	            }
	            const { socket } = self;
	            const { addCheckResult, changeManager, deleteCheckResult } = session.apolloDataStore;
	            socket.on('connect', async () => {
	                await self.getMissingChanges();
	            });
	            socket.on('connect_error', (error) => {
	                console.error(error);
	                notify('Could not connect to the Apollo server.', 'error');
	            });
	            socket.on('COMMON', (message) => {
	                if ('checkResult' in message) {
	                    if (message.deleted) {
	                        deleteCheckResult(message.checkResult._id.toString());
	                    }
	                    else {
	                        addCheckResult(message.checkResult);
	                    }
	                    return;
	                }
	                // Save server last change sequence into session storage
	                sessionStorage.setItem('LastChangeSequence', String(message.changeSequence));
	                if (message.userSessionId === token) {
	                    return; // we did this change, no need to apply it again
	                }
	                const change = dist$3.Change.fromJSON(message.changeInfo);
	                void changeManager.submit(change, { submitToBackend: false });
	            });
	            socket.on('USER_LOCATION', (message) => {
	                const { channel, locations, userName, userSessionId } = message;
	                const user = dist$2.getDecodedToken(token);
	                const localSessionId = dist$2.makeUserSessionId(user);
	                if (channel === 'USER_LOCATION' && userSessionId !== localSessionId) {
	                    const collaborator = {
	                        name: userName,
	                        id: userSessionId,
	                        locations,
	                    };
	                    session.addOrUpdateCollaborator(collaborator);
	                }
	            });
	            socket.on('REQUEST_INFORMATION', (message) => {
	                const { channel, userSessionId } = message;
	                if (channel === 'REQUEST_INFORMATION' && userSessionId !== token) {
	                    session.broadcastLocations();
	                }
	            });
	        },
	    }))
	        .actions((self) => {
	        async function postUserLocation(userLoc) {
	            const { baseURL } = self;
	            const url = new URL('users/userLocation', baseURL).href;
	            const userLocation = new URLSearchParams(JSON.stringify(userLoc));
	            const apolloFetch = self.getFetcher({
	                locationType: 'UriLocation',
	                uri: url,
	            });
	            try {
	                const response = await apolloFetch(url, {
	                    method: 'POST',
	                    body: userLocation,
	                });
	                if (!response.ok) {
	                    throw new Error('ignore'); // ignore message, will get caught by "catch"
	                }
	            }
	            catch {
	                console.error('Broadcasting user location failed');
	            }
	        }
	        const debounceTimeout = 300;
	        const debouncePostUserLocation = (fn) => {
	            let timeoutId;
	            return (userLocation) => {
	                clearTimeout(timeoutId);
	                timeoutId = setTimeout(() => {
	                    fn(userLocation);
	                }, debounceTimeout);
	            };
	        };
	        return { postUserLocation: debouncePostUserLocation(postUserLocation) };
	    })
	        .actions((self) => ({
	        initialize: require$$1$3.flow(function* initialize(role) {
	            if (role === 'admin') {
	                const rootModel = require$$1$3.getRoot(self);
	                if (require$$1$2.isAbstractMenuManager(rootModel)) {
	                    addMenuItems(rootModel);
	                }
	            }
	            // Get and set server last change sequence into session storage
	            yield self.updateLastChangeSequenceNumber();
	            // Open socket listeners
	            self.addSocketListeners();
	            // request user locations
	            const { baseURL } = self;
	            const uri = new URL('users/locations', baseURL).href;
	            const apolloFetch = self.getFetcher({
	                locationType: 'UriLocation',
	                uri,
	            });
	            yield apolloFetch(uri, { method: 'GET' });
	            window.addEventListener('beforeunload', () => {
	                self.postUserLocation([]);
	            });
	            document.addEventListener('visibilitychange', () => {
	                // fires when user switches tabs, apps, goes to homescreen, etc.
	                if (document.visibilityState === 'hidden') {
	                    self.postUserLocation([]);
	                }
	                // fires when app transitions from prerender, user returns to the app / tab.
	                if (document.visibilityState === 'visible') {
	                    const { session } = require$$1$3.getRoot(self);
	                    session.broadcastLocations();
	                }
	            });
	        }),
	    }))
	        .actions((self) => ({
	        afterAttach() {
	            self.setRole();
	            mobx.autorun(async (reaction) => {
	                if (inWebWorker$1) {
	                    return;
	                }
	                const { session } = require$$1$3.getRoot(self);
	                // This can be undefined if there is no session loaded, e.g. on
	                // the start screen
	                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	                if (!session) {
	                    return;
	                }
	                if (self.role) {
	                    await self.initialize(self.role);
	                    reaction.dispose();
	                }
	            }, { name: 'ApolloInternetAccount' });
	        },
	    }));
	};

	function isApolloRefNameAliasMessage(data) {
	    return (typeof data === 'object' &&
	        data !== null &&
	        'apollo' in data &&
	        data.apollo === true &&
	        'refNameAliases' in data);
	}
	const isInWebWorker$1 = typeof sessionStorage === 'undefined';
	class RefNameAliasAdapter extends BaseAdapter.BaseAdapter {
	    refNameAliases;
	    async getRefNameAliases() {
	        const assemblyId = configuration.readConfObject(this.config, 'assemblyId');
	        if (!isInWebWorker$1) {
	            const dataStore = this.pluginManager?.rootModel?.session?.apolloDataStore;
	            if (!dataStore) {
	                throw new Error('No Apollo data store found');
	            }
	            const backendDriver = dataStore.getBackendDriver(assemblyId);
	            const refNameAliases = await backendDriver.getRefNameAliases(assemblyId);
	            return refNameAliases;
	        }
	        const refNameAliases = await new Promise((resolve, reject) => {
	            const timeoutId = setTimeout(() => {
	                reject(new Error('timeout'));
	            }, 20_000);
	            const messageId = nanoid();
	            const messageListener = (event) => {
	                const data = event.data;
	                if (!isApolloRefNameAliasMessage(data)) {
	                    return;
	                }
	                if (data.messageId !== messageId) {
	                    return;
	                }
	                clearTimeout(timeoutId);
	                removeEventListener('message', messageListener);
	                resolve(data.refNameAliases);
	            };
	            addEventListener('message', messageListener);
	            rpcServer.emit('apollo', {
	                apollo: true,
	                method: 'getRefNameAliases',
	                assembly: assemblyId,
	                messageId,
	            });
	        });
	        this.refNameAliases = refNameAliases;
	        return refNameAliases;
	    }
	    freeResources() {
	        // no resources to free
	    }
	}

	var configSchema$4 = configuration.ConfigurationSchema('ApolloRefNameAliasAdapter', {
	    assemblyId: {
	        type: 'string',
	        defaultValue: '',
	    },
	}, { explicitlyTyped: true });

	function installApolloRefNameAliasAdapter(pluginManager) {
	    pluginManager.addAdapterType(() => new AdapterType__default["default"]({
	        name: 'ApolloRefNameAliasAdapter',
	        configSchema: configSchema$4,
	        adapterMetadata: {
	            category: undefined,
	            hiddenFromGUI: true,
	            description: undefined,
	        },
	        AdapterClass: RefNameAliasAdapter,
	    }));
	}

	var simpleFeature = {};

	Object.defineProperty(simpleFeature, "__esModule", {
	  value: true
	});
	simpleFeature.isFeature = isFeature;
	function isFeature(thing) {
	  return _typeof(thing) === 'object' && thing !== null && typeof thing.get === 'function' && typeof thing.id === 'function';
	}
	function isSimpleFeatureSerialized(args) {
	  return 'uniqueId' in args && _typeof(args.data) !== 'object';
	}
	var SimpleFeature = /*#__PURE__*/function () {
	  function SimpleFeature(args) {
	    var _this = this;
	    _classCallCheck(this, SimpleFeature);
	    var _a;
	    if (isSimpleFeatureSerialized(args)) {
	      this.data = args;
	    } else {
	      this.data = args.data;
	      this.parentHandle = args.parent;
	    }
	    var id = isSimpleFeatureSerialized(args) ? args.uniqueId : args.id;
	    if (id === undefined || id === null) {
	      throw new Error('SimpleFeature requires a unique `id` or `data.uniqueId` attribute');
	    }
	    this.uniqueId = String(id);
	    if (!(this.data.aliases || this.data.end - this.data.start >= 0)) {
	      throw new Error("invalid feature data, end less than start. end: ".concat(this.data.end, " start: ").concat(this.data.start));
	    }
	    if (this.data.subfeatures) {
	      this.subfeatures = (_a = this.data.subfeatures) === null || _a === void 0 ? void 0 : _a.map(function (f, i) {
	        return typeof f.get !== 'function' ? new SimpleFeature({
	          id: f.uniqueId || "".concat(id, "-").concat(i),
	          data: _objectSpread2({
	            strand: _this.data.strand
	          }, f),
	          parent: _this
	        }) : f;
	      });
	    }
	  }
	  _createClass(SimpleFeature, [{
	    key: "get",
	    value: function get(name) {
	      return name === 'subfeatures' ? this.subfeatures : name === 'parent' ? this.parent() : this.data[name];
	    }
	  }, {
	    key: "set",
	    value: function set(name, val) {
	      this.data[name] = val;
	    }
	  }, {
	    key: "tags",
	    value: function tags() {
	      return Object.keys(this.data);
	    }
	  }, {
	    key: "id",
	    value: function id() {
	      return this.uniqueId;
	    }
	  }, {
	    key: "parent",
	    value: function parent() {
	      return this.parentHandle;
	    }
	  }, {
	    key: "children",
	    value: function children() {
	      return this.get('subfeatures');
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      var d = _objectSpread2(_objectSpread2({}, this.data), {}, {
	        uniqueId: this.id()
	      });
	      var p = this.parent();
	      if (p) {
	        d.parentId = p.id();
	      }
	      var c = this.children();
	      if (c) {
	        d.subfeatures = c.map(function (child) {
	          return child.toJSON();
	        });
	      }
	      return d;
	    }
	  }], [{
	    key: "fromJSON",
	    value: function fromJSON(json) {
	      return new SimpleFeature(_objectSpread2({}, json));
	    }
	  }]);
	  return SimpleFeature;
	}();
	var _default$c = simpleFeature["default"] = SimpleFeature;

	/* eslint-disable @typescript-eslint/prefer-promise-reject-errors */
	function isApolloMessageData$1(data) {
	    return (typeof data === 'object' &&
	        data !== null &&
	        'apollo' in data &&
	        data.apollo === true);
	}
	const isInWebWorker = typeof sessionStorage === 'undefined';
	class ApolloSequenceAdapter extends BaseAdapter.BaseSequenceAdapter {
	    regions;
	    async getRefNames() {
	        const regions = await this.getRegions();
	        return regions.map((regions) => regions.refName);
	    }
	    async getRegions() {
	        if (this.regions) {
	            return this.regions;
	        }
	        const assemblyId = configuration.readConfObject(this.config, 'assemblyId');
	        if (!isInWebWorker) {
	            const dataStore = this.pluginManager?.rootModel?.session?.apolloDataStore;
	            if (!dataStore) {
	                throw new Error('No Apollo data store found');
	            }
	            const backendDriver = dataStore.getBackendDriver(assemblyId);
	            const regions = await backendDriver.getRegions(assemblyId);
	            this.regions = regions;
	            return regions;
	        }
	        const regions = await new Promise((resolve, reject) => {
	            const timeoutId = setTimeout(() => {
	                reject('timeout');
	            }, 20_000);
	            const messageId = nanoid();
	            const messageListener = (event) => {
	                const { data } = event;
	                if (!isApolloMessageData$1(data)) {
	                    return;
	                }
	                if (data.messageId !== messageId) {
	                    return;
	                }
	                clearTimeout(timeoutId);
	                removeEventListener('message', messageListener);
	                resolve(data.regions);
	            };
	            addEventListener('message', messageListener);
	            // @ts-expect-error waiting for types to be published
	            globalThis.rpcServer.emit('apollo', {
	                apollo: true,
	                method: 'getRegions',
	                assembly: assemblyId,
	                messageId,
	            });
	        });
	        this.regions = regions;
	        return regions;
	    }
	    /**
	     * Fetch features for a certain region
	     * @param param -
	     * @returns Observable of Feature objects in the region
	     */
	    getFeatures(region) {
	        const { end, refName, start } = region;
	        const assemblyId = configuration.readConfObject(this.config, 'assemblyId');
	        const regionWithAssemblyName = { ...region, assemblyName: assemblyId };
	        return rxjs.ObservableCreate(async (observer) => {
	            if (!isInWebWorker) {
	                const dataStore = this.pluginManager?.rootModel?.session?.apolloDataStore;
	                if (!dataStore) {
	                    observer.error('No Apollo data store found');
	                    return;
	                }
	                const backendDriver = dataStore.getBackendDriver(assemblyId);
	                const regions = await backendDriver.getRegions(regionWithAssemblyName.assemblyName);
	                const region = regions.find((region) => region.refName === regionWithAssemblyName.refName);
	                if (!region) {
	                    observer.error('Cannot get region');
	                    return;
	                }
	                if (regionWithAssemblyName.end > region.end) {
	                    regionWithAssemblyName.end = region.end;
	                }
	                const { seq } = await backendDriver.getSequence(regionWithAssemblyName);
	                observer.next(new _default$c({
	                    id: `${refName} ${start}-${end}`,
	                    data: { refName, start, end, seq },
	                }));
	                observer.complete();
	                return;
	            }
	            const seq = await new Promise((resolve, reject) => {
	                const timeoutId = setTimeout(() => {
	                    reject('timeout');
	                }, 20_000);
	                const messageId = nanoid();
	                const messageListener = (event) => {
	                    const { data } = event;
	                    if (!isApolloMessageData$1(data)) {
	                        return;
	                    }
	                    if (data.messageId !== messageId) {
	                        return;
	                    }
	                    clearTimeout(timeoutId);
	                    removeEventListener('message', messageListener);
	                    resolve(data.sequence);
	                };
	                addEventListener('message', messageListener);
	                // @ts-expect-error waiting for types to be published
	                globalThis.rpcServer.emit('apollo', {
	                    apollo: true,
	                    method: 'getSequence',
	                    region: regionWithAssemblyName,
	                    messageId,
	                });
	            });
	            observer.next(new _default$c({
	                id: `${refName} ${start}-${end}`,
	                data: { refName, start, end, seq },
	            }));
	            observer.complete();
	        });
	    }
	    /**
	     * called to provide a hint that data tied to a certain region
	     * will not be needed for the foreseeable future and can be purged
	     * from caches, etc
	     */
	    // eslint-disable-next-line @typescript-eslint/no-empty-function
	    freeResources( /* { region } */) { }
	}

	var configSchema$3 = configuration.ConfigurationSchema('ApolloSequenceAdapter', {
	    assemblyId: {
	        type: 'string',
	        defaultValue: '',
	    },
	}, { explicitlyTyped: true });

	function installApolloSequenceAdapter(pluginManager) {
	    pluginManager.addAdapterType(() => new AdapterType__default["default"]({
	        name: 'ApolloSequenceAdapter',
	        configSchema: configSchema$3,
	        adapterMetadata: {
	            category: undefined,
	            hiddenFromGUI: true,
	            description: undefined,
	        },
	        AdapterClass: ApolloSequenceAdapter,
	    }));
	}

	var BaseResults = {};

	Object.defineProperty(BaseResults, "__esModule", {
	  value: true
	});
	BaseResults.RefSequenceResult = void 0;
	var BaseResult = /*#__PURE__*/function () {
	  function BaseResult(args) {
	    _classCallCheck(this, BaseResult);
	    this.label = args.label;
	    this.locString = args.locString;
	    this.renderingComponent = args.renderingComponent;
	    this.displayString = args.displayString;
	    this.matchedAttribute = args.matchedAttribute;
	    this.matchedObject = args.matchedObject;
	    this.textSearchAdapter = args.textSearchAdapter;
	    this.relevance = args.relevance;
	    this.trackId = args.trackId;
	    this.score = args.score || 1;
	    this.results = args.results || [];
	  }
	  _createClass(BaseResult, [{
	    key: "getLabel",
	    value: function getLabel() {
	      return this.label;
	    }
	  }, {
	    key: "getDisplayString",
	    value: function getDisplayString() {
	      return this.displayString || this.label;
	    }
	  }, {
	    key: "getRenderingComponent",
	    value: function getRenderingComponent() {
	      return this.renderingComponent;
	    }
	  }, {
	    key: "getTrackId",
	    value: function getTrackId() {
	      return this.trackId;
	    }
	  }, {
	    key: "getScore",
	    value: function getScore() {
	      return this.score;
	    }
	  }, {
	    key: "updateScore",
	    value: function updateScore(newScore) {
	      this.score = newScore;
	      return this.score;
	    }
	  }, {
	    key: "getId",
	    value: function getId() {
	      return "".concat(this.getLabel(), "-").concat(this.getLocation(), "-").concat(this.getTrackId());
	    }
	  }, {
	    key: "hasLocation",
	    value: function hasLocation() {
	      return !!this.locString;
	    }
	  }, {
	    key: "getLocation",
	    value: function getLocation() {
	      return this.locString;
	    }
	  }, {
	    key: "getComboResults",
	    value: function getComboResults() {
	      return this.results;
	    }
	  }]);
	  return BaseResult;
	}();
	var _default$b = BaseResults["default"] = BaseResult;
	var RefSequenceResult = /*#__PURE__*/function (_BaseResult) {
	  _inherits(RefSequenceResult, _BaseResult);
	  var _super = /*#__PURE__*/_createSuper(RefSequenceResult);
	  function RefSequenceResult(args) {
	    var _this;
	    _classCallCheck(this, RefSequenceResult);
	    var _a;
	    _this = _super.call(this, args);
	    _this.refName = (_a = args.refName) !== null && _a !== void 0 ? _a : '';
	    return _this;
	  }
	  _createClass(RefSequenceResult, [{
	    key: "getLocation",
	    value: function getLocation() {
	      return this.refName;
	    }
	  }]);
	  return RefSequenceResult;
	}(BaseResult);
	BaseResults.RefSequenceResult = RefSequenceResult;

	class ApolloTextSearchAdapter extends BaseAdapter.BaseAdapter {
	    get baseURL() {
	        return configuration.readConfObject(this.config, 'baseURL').uri;
	    }
	    get trackId() {
	        return configuration.readConfObject(this.config, 'trackId');
	    }
	    get assemblyNames() {
	        return configuration.readConfObject(this.config, 'assemblyNames');
	    }
	    mapBaseResult(features, assembly, query) {
	        return features.map((feature) => {
	            const refName = assembly.getCanonicalRefName(feature.refSeq);
	            return new _default$b({
	                label: query,
	                trackId: this.trackId,
	                locString: `${refName}:${feature.min + 1}..${feature.max}`,
	            });
	        });
	    }
	    async searchIndex(args) {
	        const query = args.queryString;
	        const results = [];
	        const session = this.pluginManager?.rootModel?.session;
	        if (!session) {
	            return results;
	        }
	        const { apolloDataStore } = session;
	        const { assemblyManager } = session;
	        for (const assemblyName of this.assemblyNames) {
	            const backendDriver = apolloDataStore.getBackendDriver(assemblyName);
	            const assembly = assemblyManager.get(assemblyName);
	            if (!(backendDriver && assembly)) {
	                continue;
	            }
	            const features = await backendDriver.searchFeatures(args.queryString, [
	                assemblyName,
	            ]);
	            results.push(...this.mapBaseResult(features, assembly, query));
	        }
	        return results;
	    }
	    // eslint-disable-next-line @typescript-eslint/no-empty-function
	    freeResources() { }
	}

	var configSchema$2 = configuration.ConfigurationSchema('ApolloTextSearchAdapter', {
	    assemblyNames: {
	        type: 'stringArray',
	        defaultValue: [],
	        description: 'List of assemblies covered by text search adapter',
	    },
	    trackId: {
	        type: 'string',
	        defaultValue: '',
	    },
	    baseURL: {
	        type: 'fileLocation',
	        defaultValue: {
	            uri: '',
	            locationType: 'UriLocation',
	        },
	    },
	}, { explicitlyTyped: true, explicitIdentifier: 'textSearchAdapterId' });

	function installApolloTextSearchAdapter(pluginManager) {
	    pluginManager.addTextSearchAdapterType(() => new pluggableElementTypes.TextSearchAdapterType({
	        name: 'ApolloTextSearchAdapter',
	        displayName: 'Apollo text search adapter',
	        configSchema: configSchema$2,
	        AdapterClass: ApolloTextSearchAdapter,
	        description: 'Apollo Text Search adapter',
	    }));
	}

	var ExpandMore = {};

	var _interopRequireDefault$a = interopRequireDefault.exports;
	Object.defineProperty(ExpandMore, "__esModule", {
	  value: true
	});
	var default_1$a = ExpandMore["default"] = void 0;
	var _createSvgIcon$a = /*#__PURE__*/_interopRequireDefault$a(createSvgIcon);
	var _jsxRuntime$a = require$$2__default["default"];
	var _default$a = /*#__PURE__*/(0, _createSvgIcon$a["default"])( /*#__PURE__*/(0, _jsxRuntime$a.jsx)("path", {
	  d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
	}), 'ExpandMore');
	default_1$a = ExpandMore["default"] = _default$a;

	var Edit = {};

	var _interopRequireDefault$9 = interopRequireDefault.exports;
	Object.defineProperty(Edit, "__esModule", {
	  value: true
	});
	var default_1$9 = Edit["default"] = void 0;
	var _createSvgIcon$9 = /*#__PURE__*/_interopRequireDefault$9(createSvgIcon);
	var _jsxRuntime$9 = require$$2__default["default"];
	var _default$9 = /*#__PURE__*/(0, _createSvgIcon$9["default"])( /*#__PURE__*/(0, _jsxRuntime$9.jsx)("path", {
	  d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"
	}), 'Edit');
	default_1$9 = Edit["default"] = _default$9;

	var MoreHoriz = {};

	var _interopRequireDefault$8 = interopRequireDefault.exports;
	Object.defineProperty(MoreHoriz, "__esModule", {
	  value: true
	});
	var default_1$8 = MoreHoriz["default"] = void 0;
	var _createSvgIcon$8 = /*#__PURE__*/_interopRequireDefault$8(createSvgIcon);
	var _jsxRuntime$8 = require$$2__default["default"];
	var _default$8 = /*#__PURE__*/(0, _createSvgIcon$8["default"])( /*#__PURE__*/(0, _jsxRuntime$8.jsx)("path", {
	  d: "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
	}), 'MoreHoriz');
	default_1$8 = MoreHoriz["default"] = _default$8;

	const useStyles$c = mui.makeStyles()((theme) => ({
	    attributeKey: {
	        fontWeight: 'bold',
	        marginRight: theme.spacing(2),
	    },
	}));
	function AttributeKey({ attributeKey: key }) {
	    const { classes } = useStyles$c();
	    const startsWithCapital = /^[A-Z]/.test(key);
	    let displayKey = key;
	    let titleText;
	    if (dist$2.isGFFInternalAttribute(key)) {
	        displayKey = dist$2.internalToGFF[key];
	        titleText = `On GFF3 export, this will be assigned to the GFF3's reserved "${displayKey}" attribute`;
	    }
	    else if (dist$2.isGFFColumnInternal(key)) {
	        displayKey = dist$2.gffInternalToColumn[key];
	        titleText = `On GFF3 export, this will be placed in the GFF3's "${displayKey}" column`;
	    }
	    else if (startsWithCapital) {
	        titleText =
	            'On GFF3 export, this attribute will be changed to start with a lower-case letter because attributes starting with an upper-case letter are reserved in GFF3';
	    }
	    return (React__default["default"].createElement("div", { style: { display: 'flex' } },
	        React__default["default"].createElement(material.Typography, { className: classes.attributeKey }, displayKey),
	        titleText ? (React__default["default"].createElement(material.Tooltip, { title: titleText },
	            React__default["default"].createElement(material.Chip, { icon: React__default["default"].createElement(default_1$o, null), label: "GFF3", size: "small", variant: "outlined" }))) : null));
	}

	const customKeyName = 'Custom';
	const gffKeys = {
	    [customKeyName]: 'custom',
	};
	for (const [value, key] of Object.entries(dist$2.gffToInternal)) {
	    gffKeys[`GFF ${key}`] = value;
	}
	for (const [value, key] of Object.entries(dist$2.gffColumnToInternal)) {
	    gffKeys[`GFF ${key}`] = value;
	}
	const AttributeKeySelector = mobxReact.observer(function AttributeKeySelector({ setKey, session, }) {
	    const { pluginManager } = require$$1$2.getEnv(session);
	    const reservedKeys = pluginManager.evaluateExtensionPoint('Apollo-ReservedAttributeKeys', gffKeys);
	    const firstKey = Object.keys(reservedKeys).at(0) ?? customKeyName;
	    const [selectedKey, setSelectedKey] = React.useState(firstKey);
	    const [customKey, setCustomKey] = React.useState();
	    const isCustom = selectedKey === customKeyName;
	    function handleSubmit(event) {
	        event.preventDefault();
	        if (isCustom) {
	            setKey(customKey);
	            return;
	        }
	        setKey(reservedKeys[selectedKey]);
	    }
	    function handleCancel() {
	        setKey();
	    }
	    return (React__default["default"].createElement("form", { onSubmit: handleSubmit },
	        React__default["default"].createElement("div", { style: { display: 'flex', flexDirection: 'column', margin: 8 } },
	            React__default["default"].createElement(material.FormControl, { variant: "outlined" },
	                React__default["default"].createElement(material.InputLabel, { id: "attribute-key-select-label" }, "Key"),
	                React__default["default"].createElement(material.Select, { labelId: "attribute-key-select-label", value: selectedKey, label: "Key", onChange: (event) => {
	                        setSelectedKey(event.target.value);
	                    } }, Object.keys(reservedKeys).map((val) => (React__default["default"].createElement(material.MenuItem, { key: val, value: val }, val))))),
	            isCustom ? (React__default["default"].createElement(material.TextField, { label: "Attribute key", variant: "outlined", id: "attributeKey", onChange: (event) => {
	                    setCustomKey(event.target.value);
	                } })) : null),
	        React__default["default"].createElement(material.DialogActions, null,
	            React__default["default"].createElement(material.Button, { color: "primary", variant: "contained", type: "submit", disabled: isCustom && !customKey }, "Add"),
	            React__default["default"].createElement(material.Button, { variant: "outlined", onClick: handleCancel }, "Cancel"))));
	});

	var AddBox = {};

	var _interopRequireDefault$7 = interopRequireDefault.exports;
	Object.defineProperty(AddBox, "__esModule", {
	  value: true
	});
	var default_1$7 = AddBox["default"] = void 0;
	var _createSvgIcon$7 = /*#__PURE__*/_interopRequireDefault$7(createSvgIcon);
	var _jsxRuntime$7 = require$$2__default["default"];
	var _default$7 = /*#__PURE__*/(0, _createSvgIcon$7["default"])( /*#__PURE__*/(0, _jsxRuntime$7.jsx)("path", {
	  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"
	}), 'AddBox');
	default_1$7 = AddBox["default"] = _default$7;

	/* eslint-disable @typescript-eslint/unbound-method */
	const StringTextField = mobxReact.observer(function StringTextField({ onChangeCommitted, value: initialValue, ...props }) {
	    const [value, setValue] = React.useState(String(initialValue));
	    const [blur, setBlur] = React.useState(false);
	    const [inputNode, setInputNode] = React.useState(null);
	    React.useEffect(() => {
	        setValue(String(initialValue));
	    }, [initialValue]);
	    React.useEffect(() => {
	        if (blur) {
	            inputNode?.blur();
	            setBlur(false);
	        }
	    }, [blur, inputNode]);
	    function onChange(event) {
	        setValue(event.target.value);
	    }
	    return (React__default["default"].createElement(material.TextField, { ...props, type: "text", onChange: onChange, value: value, onKeyDown: (event) => {
	            if (event.key === 'Enter') {
	                inputNode?.blur();
	            }
	            else if (event.key === 'Escape') {
	                setValue(String(initialValue));
	                setBlur(true);
	            }
	        }, onBlur: () => {
	            if (value !== String(initialValue)) {
	                onChangeCommitted(value);
	            }
	        }, inputRef: (node) => {
	            setInputNode(node);
	        } }));
	});

	const DefaultAttributeEditor = mobxReact.observer(function DefaultAttributeEditor({ attributeValues, setAttribute, isNew = false, }) {
	    const [newValues, setNewValues] = React.useState(attributeValues && attributeValues.length > 0 ? attributeValues : ['']);
	    function updateValue(idx, newValue) {
	        setNewValues((oldValues) => {
	            const newValues = [...oldValues];
	            newValues[idx] = newValue;
	            return newValues;
	        });
	    }
	    function deleteValue(idx) {
	        setNewValues((oldValues) => {
	            const newValues = [...oldValues];
	            newValues.splice(idx, 1);
	            return newValues;
	        });
	    }
	    function addValue() {
	        setNewValues((oldValues) => {
	            const newValues = [...oldValues];
	            newValues.push('');
	            return newValues;
	        });
	    }
	    return (React__default["default"].createElement(React__default["default"].Fragment, null,
	        newValues.map((value, idx) => (React__default["default"].createElement("div", { key: `${idx}-${value}`, style: { display: 'flex' } },
	            React__default["default"].createElement(StringTextField, { value: value, onChangeCommitted: (editedValue) => {
	                    updateValue(idx, editedValue);
	                }, variant: "outlined", fullWidth: true }),
	            React__default["default"].createElement(material.IconButton, { "aria-label": "delete", size: "medium", edge: "end", onClick: () => {
	                    deleteValue(idx);
	                } },
	                React__default["default"].createElement(default_1$j, { fontSize: "inherit" }))))),
	        React__default["default"].createElement(material.IconButton, { "aria-label": "add", size: "medium", color: "secondary", edge: "start", onClick: addValue },
	            React__default["default"].createElement(default_1$7, { fontSize: "inherit" })),
	        React__default["default"].createElement(material.DialogActions, null,
	            React__default["default"].createElement(material.Button, { color: "primary", variant: "contained", onClick: () => {
	                    setAttribute(newValues.filter(Boolean));
	                } }, isNew ? 'Add' : 'Update'),
	            React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: () => {
	                    setAttribute();
	                } }, "Cancel"))));
	});

	function DefaultAttributeViewer({ values }) {
	    return (React__default["default"].createElement(React__default["default"].Fragment, null, values?.map((value, idx) => (React__default["default"].createElement(material.Typography, { key: `${idx}.${value}`, variant: "body2", color: "textSecondary" }, value)))));
	}

	const useStyles$b = mui.makeStyles()((theme) => ({
	    list: {
	        'li:nth-of-type(odd)': {
	            backgroundColor: theme.palette.action.focus,
	        },
	        'li:nth-of-type(even)': {
	            backgroundColor: theme.palette.action.hover,
	        },
	    },
	}));
	const Attributes = mobxReact.observer(function Attributes({ assembly, editable, feature, session, }) {
	    const { pluginManager } = require$$1$2.getEnv(session);
	    const { classes } = useStyles$b();
	    const [anchorEl, setAnchorEl] = React.useState(null);
	    const [selectedKey, setSelectedKey] = React.useState(null);
	    const [editingKey, setEditingKey] = React.useState(null);
	    const [showAddNewForm, setShowAddNewForm] = React.useState(false);
	    const [newKey, setNewKey] = React.useState();
	    const open = Boolean(anchorEl);
	    const { changeManager } = session.apolloDataStore;
	    const { notify } = session;
	    function handleListMenuClick(event, key) {
	        setAnchorEl(event.currentTarget);
	        setSelectedKey(key);
	    }
	    function handleClose() {
	        setAnchorEl(null);
	        setSelectedKey(null);
	    }
	    function handleDelete() {
	        if (selectedKey) {
	            deleteFeatureAttribute(selectedKey);
	        }
	        handleClose();
	    }
	    function handleEdit() {
	        if (selectedKey) {
	            setEditingKey(selectedKey);
	        }
	        handleClose();
	    }
	    const { _id, attributes } = feature;
	    function deleteFeatureAttribute(key) {
	        const attributesSerialized = require$$1$3.getSnapshot(attributes);
	        const { [key]: deletedAttribute, ...remainingAttributes } = attributesSerialized;
	        const change = new dist$2.FeatureAttributeChange({
	            changedIds: [_id],
	            typeName: 'FeatureAttributeChange',
	            assembly,
	            featureId: _id,
	            oldAttributes: attributesSerialized,
	            newAttributes: remainingAttributes,
	        });
	        void changeManager.submit(change);
	    }
	    function modifyFeatureAttribute(key, attribute) {
	        const serializedAttributes = { ...require$$1$3.getSnapshot(attributes) };
	        const oldAttributes = structuredClone(serializedAttributes);
	        if (!(key in serializedAttributes)) {
	            notify(`"${key}" not found in feature attributes`, 'error');
	            return;
	        }
	        const oldAttribute = serializedAttributes[key];
	        if (oldAttribute.toString() === attribute.toString()) {
	            return;
	        }
	        serializedAttributes[key] = attribute;
	        const change = new dist$2.FeatureAttributeChange({
	            changedIds: [feature._id],
	            typeName: 'FeatureAttributeChange',
	            assembly,
	            featureId: feature._id,
	            oldAttributes,
	            newAttributes: serializedAttributes,
	        });
	        void changeManager.submit(change);
	    }
	    function addFeatureAttribute(key, attribute) {
	        const serializedAttributes = { ...require$$1$3.getSnapshot(attributes) };
	        const oldAttributes = structuredClone(serializedAttributes);
	        if (key in serializedAttributes) {
	            notify(`Feature already has attribute "${key}"`, 'error');
	            return;
	        }
	        serializedAttributes[key] = attribute;
	        const change = new dist$2.FeatureAttributeChange({
	            changedIds: [feature._id],
	            typeName: 'FeatureAttributeChange',
	            assembly,
	            featureId: feature._id,
	            oldAttributes,
	            newAttributes: serializedAttributes,
	        });
	        void changeManager.submit(change);
	    }
	    const NewKeyAttributeEditor = pluginManager.evaluateExtensionPoint('Apollo-AttributeEditorComponent', DefaultAttributeEditor, { key: newKey });
	    return (React__default["default"].createElement(React__default["default"].Fragment, null,
	        React__default["default"].createElement(material.List, { className: classes.list },
	            mobx.entries(attributes).map(([key, values]) => {
	                const AttributeEditor = pluginManager.evaluateExtensionPoint('Apollo-AttributeEditorComponent', DefaultAttributeEditor, { key });
	                const AttributeViewer = pluginManager.evaluateExtensionPoint('Apollo-AttributeViewerComponent', DefaultAttributeViewer, { key });
	                return (React__default["default"].createElement(material.ListItem, { key: key, secondaryAction: editable && !editingKey ? (React__default["default"].createElement(material.IconButton, { edge: "end", onClick: (event) => {
	                            handleListMenuClick(event, key);
	                        } },
	                        React__default["default"].createElement(default_1$8, null))) : null },
	                    React__default["default"].createElement(material.ListItemText, { disableTypography: true, primary: React__default["default"].createElement(AttributeKey, { attributeKey: key }), secondary: editingKey === key ? (React__default["default"].createElement(AttributeEditor, { session: session, attributeValues: values, setAttribute: (newValues) => {
	                                setEditingKey(null);
	                                if (newValues) {
	                                    modifyFeatureAttribute(key, newValues);
	                                }
	                            } })) : (React__default["default"].createElement(AttributeViewer, { values: values })) })));
	            }),
	            newKey ? (React__default["default"].createElement(material.ListItem, null,
	                React__default["default"].createElement(material.ListItemText, { disableTypography: true, primary: React__default["default"].createElement(AttributeKey, { attributeKey: newKey }), secondary: React__default["default"].createElement(NewKeyAttributeEditor, { session: session, attributeValues: [], setAttribute: (newValues) => {
	                            if (newValues) {
	                                addFeatureAttribute(newKey, newValues);
	                            }
	                            setNewKey(undefined);
	                        }, isNew: true }) }))) : null),
	        editable ? (React__default["default"].createElement(material.Button, { color: "primary", variant: "contained", disabled: showAddNewForm || Boolean(newKey), onClick: () => {
	                setShowAddNewForm(true);
	            } }, "Add new")) : null,
	        showAddNewForm ? (React__default["default"].createElement(material.Paper, { variant: "outlined", style: { marginTop: 8 } },
	            React__default["default"].createElement(AttributeKeySelector, { session: session, setKey: (newKey) => {
	                    setNewKey(newKey);
	                    setShowAddNewForm(false);
	                } }))) : null,
	        React__default["default"].createElement(material.Menu, { anchorEl: anchorEl, open: open, onClose: handleClose },
	            React__default["default"].createElement(material.MenuItem, { onClick: handleDelete },
	                React__default["default"].createElement(material.ListItemIcon, null,
	                    React__default["default"].createElement(default_1$j, { fontSize: "small" })),
	                React__default["default"].createElement(material.Typography, { variant: "inherit" }, "Delete")),
	            React__default["default"].createElement(material.MenuItem, { onClick: handleEdit },
	                React__default["default"].createElement(material.ListItemIcon, null,
	                    React__default["default"].createElement(default_1$9, { fontSize: "small" })),
	                React__default["default"].createElement(material.Typography, { variant: "inherit" }, "Edit")))));
	});

	/* eslint-disable @typescript-eslint/unbound-method */
	const NumberTextField = mobxReact.observer(function NumberTextField({ onChangeCommitted, value: initialValue, ...props }) {
	    const [value, setValue] = React.useState(String(initialValue));
	    const [blur, setBlur] = React.useState(false);
	    const [inputNode, setInputNode] = React.useState(null);
	    React.useEffect(() => {
	        setValue(String(initialValue));
	    }, [initialValue]);
	    React.useEffect(() => {
	        if (blur) {
	            inputNode?.blur();
	            setBlur(false);
	        }
	    }, [blur, inputNode]);
	    function onChange(event) {
	        setValue(event.target.value);
	    }
	    const error = Number.isNaN(Number(value));
	    return (React__default["default"].createElement(material.TextField, { ...props, type: "text", onChange: onChange, value: value, onKeyDown: (event) => {
	            if (event.key === 'Enter') {
	                inputNode?.blur();
	            }
	            else if (event.key === 'Escape') {
	                setValue(String(initialValue));
	                setBlur(true);
	            }
	        }, onBlur: () => {
	            const valueAsNumber = Number(value);
	            if (value !== String(initialValue)) {
	                if (Number.isNaN(valueAsNumber)) {
	                    setValue(String(initialValue));
	                }
	                else {
	                    onChangeCommitted(valueAsNumber);
	                }
	            }
	        }, inputRef: (node) => {
	            setInputNode(node);
	        }, error: error, helperText: error ? 'Not a valid number' : undefined }));
	});

	const BasicInformation = mobxReact.observer(function BasicInformation({ assembly, feature, session, }) {
	    const [errorMessage, setErrorMessage] = React.useState('');
	    const [typeWarningText, setTypeWarningText] = React.useState('');
	    const { _id, assemblyId, max, min, strand, type } = feature;
	    const notifyError = (e) => {
	        session.notify(e.message, 'error');
	    };
	    const { changeManager } = session.apolloDataStore;
	    function handleTypeChange(newType) {
	        setErrorMessage('');
	        const featureId = _id;
	        const change = new dist$2.TypeChange({
	            typeName: 'TypeChange',
	            changedIds: [featureId],
	            featureId,
	            oldType: type,
	            newType,
	            assembly: assemblyId,
	        });
	        return changeManager.submit(change);
	    }
	    function handleStrandChange(event) {
	        const { value } = event.target;
	        const newStrand = value ? Number(value) : undefined;
	        const change = new dist$2.StrandChange({
	            typeName: 'StrandChange',
	            changedIds: [_id],
	            featureId: _id,
	            oldStrand: strand,
	            newStrand,
	            assembly,
	        });
	        return changeManager.submit(change);
	    }
	    function handleStartChange(newStart) {
	        newStart--;
	        const change = new dist$2.LocationStartChange({
	            typeName: 'LocationStartChange',
	            changedIds: [_id],
	            featureId: _id,
	            oldStart: min,
	            newStart,
	            assembly,
	        });
	        return changeManager.submit(change);
	    }
	    function handleEndChange(newEnd) {
	        const change = new dist$2.LocationEndChange({
	            typeName: 'LocationEndChange',
	            changedIds: [_id],
	            featureId: _id,
	            oldEnd: max,
	            newEnd,
	            assembly,
	        });
	        return changeManager.submit(change);
	    }
	    async function fetchValidTerms(parentFeature, ontologyStore, _signal) {
	        const terms = await fetchValidDescendantTerms(parentFeature, ontologyStore);
	        if (!terms) {
	            setTypeWarningText(`Type "${parentFeature?.type}" does not have any children in the ontology`);
	            return;
	        }
	        return terms;
	    }
	    return (React__default["default"].createElement("div", { "data-testid": "basic_information" },
	        React__default["default"].createElement(NumberTextField, { margin: "dense", id: "start", label: "Start", fullWidth: true, variant: "outlined", value: min + 1, onChangeCommitted: handleStartChange }),
	        React__default["default"].createElement(NumberTextField, { margin: "dense", id: "end", label: "End", fullWidth: true, variant: "outlined", value: max, onChangeCommitted: handleEndChange }),
	        React__default["default"].createElement(OntologyTermAutocomplete, { session: session, ontologyName: "Sequence Ontology", value: type, filterTerms: isOntologyClass, fetchValidTerms: fetchValidTerms.bind(null, feature), renderInput: (params) => (React__default["default"].createElement(material.TextField, { ...params, label: "Type", variant: "outlined", fullWidth: true, error: Boolean(typeWarningText), helperText: typeWarningText })), onChange: (oldValue, newValue) => {
	                if (newValue) {
	                    handleTypeChange(newValue).catch(notifyError);
	                }
	            } }),
	        React__default["default"].createElement("label", null,
	            React__default["default"].createElement("input", { type: "radio", value: "1", checked: strand === 1, onChange: handleStrandChange }),
	            "Positive Strand (+)"),
	        React__default["default"].createElement("label", null,
	            React__default["default"].createElement("input", { type: "radio", value: "-1", checked: strand === -1, onChange: handleStrandChange }),
	            "Negative Strand (-)"),
	        React__default["default"].createElement("label", null,
	            React__default["default"].createElement("input", { type: "radio", value: "", checked: strand === undefined, onChange: handleStrandChange }),
	            "No Strand Information"),
	        errorMessage ? (React__default["default"].createElement(material.Typography, { color: "error" }, errorMessage)) : null));
	});

	const FeatureDetailsNavigation = mobxReact.observer(function FeatureDetailsNavigation(props) {
	    const { feature, model } = props;
	    const { children, parent } = feature;
	    const childFeatures = [];
	    if (children) {
	        for (const [, child] of children) {
	            childFeatures.push(child);
	        }
	    }
	    if (!(parent ?? childFeatures.length > 0)) {
	        return null;
	    }
	    return (React__default["default"].createElement("div", { style: { marginTop: 10 } },
	        parent && (React__default["default"].createElement("div", null,
	            React__default["default"].createElement(material.Typography, { variant: "h6" }, "Parent:"),
	            React__default["default"].createElement(material.Button, { variant: "contained", onClick: () => {
	                    model.setFeature(parent);
	                } },
	                parent.type,
	                getFeatureNameOrId$1(parent),
	                " (",
	                parent.min,
	                "..",
	                parent.max,
	                ")"))),
	        childFeatures.length > 0 && (React__default["default"].createElement("div", null,
	            React__default["default"].createElement(material.Typography, { variant: "h6" },
	                childFeatures.length === 1 ? 'Child' : 'Children',
	                ":"),
	            childFeatures.map((child) => (React__default["default"].createElement("div", { key: child._id, style: { marginBottom: 5 } },
	                React__default["default"].createElement(material.Button, { variant: "contained", onClick: () => {
	                        model.setFeature(child);
	                    } },
	                    child.type,
	                    getFeatureNameOrId$1(child),
	                    " (",
	                    child.min,
	                    "..",
	                    child.max,
	                    ")"))))))));
	});

	function formatSequence(seq, refName, start, end, wrap) {
	    const header = `>${refName}:${start + 1}–${end}\n`;
	    const body = wrap === undefined ? seq : dist$2.splitStringIntoChunks(seq, wrap).join('\n');
	    return `${header}${body}`;
	}
	const useStyles$a = mui.makeStyles()({
	    sequence: {
	        width: '100%',
	        resize: 'vertical',
	    },
	});
	const Sequence = mobxReact.observer(function Sequence({ assembly, feature, refName, session, }) {
	    const currentAssembly = session.apolloDataStore.assemblies.get(assembly);
	    const { classes } = useStyles$a();
	    if (!(feature && currentAssembly)) {
	        return null;
	    }
	    const refSeq = currentAssembly.getByRefName(refName);
	    if (!refSeq) {
	        return null;
	    }
	    const { max, min } = feature;
	    let sequence = refSeq.getSequence(min, max);
	    if (sequence) {
	        sequence = formatSequence(sequence, refName, min, max);
	    }
	    else {
	        void session.apolloDataStore.loadRefSeq([
	            { assemblyName: assembly, refName, start: min, end: max },
	        ]);
	    }
	    return (React__default["default"].createElement("div", null,
	        React__default["default"].createElement("textarea", { readOnly: true, rows: 20, className: classes.sequence, value: sequence })));
	});

	const useStyles$9 = mui.makeStyles()((theme) => ({
	    root: {
	        padding: theme.spacing(2),
	    },
	}));
	const ApolloFeatureDetailsWidget = mobxReact.observer(function ApolloFeatureDetailsWidget(props) {
	    const { model } = props;
	    const { assembly, feature, refName } = model;
	    const session = require$$1$2.getSession(model);
	    const currentAssembly = session.apolloDataStore.assemblies.get(assembly);
	    const { classes } = useStyles$9();
	    const [panelState, setPanelState] = React.useState(['attributes']);
	    React.useEffect(() => {
	        setPanelState(['attributes']);
	    }, [feature]);
	    if (!(feature && currentAssembly)) {
	        return null;
	    }
	    const refSeq = currentAssembly.getByRefName(refName);
	    if (!refSeq) {
	        return null;
	    }
	    const { max, min } = feature;
	    const sequence = refSeq.getSequence(min, max);
	    if (!sequence) {
	        void session.apolloDataStore.loadRefSeq([
	            { assemblyName: assembly, refName, start: min, end: max },
	        ]);
	    }
	    function handlePanelChange(expanded, panel) {
	        if (expanded) {
	            setPanelState([...panelState, panel]);
	        }
	        else {
	            setPanelState(panelState.filter((p) => p !== panel));
	        }
	    }
	    return (React__default["default"].createElement("div", { className: classes.root },
	        React__default["default"].createElement(BasicInformation, { feature: feature, session: session, assembly: currentAssembly._id }),
	        React__default["default"].createElement(material.Accordion, { style: { marginTop: 10 }, expanded: panelState.includes('attributes'), onChange: (e, expanded) => {
	                handlePanelChange(expanded, 'attributes');
	            } },
	            React__default["default"].createElement(material.AccordionSummary, { expandIcon: React__default["default"].createElement(default_1$a, { style: { color: 'white' } }), "aria-controls": "panel1-content", id: "panel1-header" },
	                React__default["default"].createElement(material.Typography, { component: "span" }, "Attributes")),
	            React__default["default"].createElement(material.AccordionDetails, null,
	                React__default["default"].createElement(Attributes, { feature: feature, session: session, assembly: currentAssembly._id, editable: true }))),
	        React__default["default"].createElement(material.Accordion, { style: { marginTop: 10 }, expanded: panelState.includes('sequence'), onChange: (e, expanded) => {
	                handlePanelChange(expanded, 'sequence');
	            } },
	            React__default["default"].createElement(material.AccordionSummary, { expandIcon: React__default["default"].createElement(default_1$a, { style: { color: 'white' } }), "aria-controls": "panel2-content", id: "panel2-header" },
	                React__default["default"].createElement(material.Typography, { component: "span" }, "Sequence")),
	            React__default["default"].createElement(material.AccordionDetails, null, panelState.includes('sequence') && (React__default["default"].createElement(Sequence, { feature: feature, session: session, assembly: currentAssembly._id, refName: refName })))),
	        React__default["default"].createElement(material.Accordion, { style: { marginTop: 10 }, expanded: panelState.includes('related_features'), onChange: (e, expanded) => {
	                handlePanelChange(expanded, 'related_features');
	            } },
	            React__default["default"].createElement(material.AccordionSummary, { expandIcon: React__default["default"].createElement(default_1$a, { style: { color: 'white' } }), "aria-controls": "panel3-content", id: "panel3-header" },
	                React__default["default"].createElement(material.Typography, { component: "span" }, "Related features")),
	            React__default["default"].createElement(material.AccordionDetails, null,
	                React__default["default"].createElement(FeatureDetailsNavigation, { model: model, feature: feature })))));
	});

	var dist = {};

	var AnnotationFeatureModel = {};

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.AnnotationFeatureModel = void 0;
	  /* eslint-disable @typescript-eslint/no-unsafe-assignment */
	  /* eslint-disable @typescript-eslint/no-unsafe-member-access */
	  /* eslint-disable @typescript-eslint/no-unsafe-call */
	  var util_1 = require$$1__default$1["default"];
	  var mobx_state_tree_1 = require$$1__default$2["default"];
	  var _1 = dist;
	  var LateAnnotationFeature = /*#__PURE__*/mobx_state_tree_1.types.late(function () {
	    return exports.AnnotationFeatureModel;
	  });
	  exports.AnnotationFeatureModel = /*#__PURE__*/mobx_state_tree_1.types.model('AnnotationFeatureModel', {
	    _id: mobx_state_tree_1.types.identifier,
	    /** Unique ID of the reference sequence on which this feature is located */
	    refSeq: mobx_state_tree_1.types.string,
	    /**
	     * Type of feature. Can be any string, but is usually an ontology term,
	     * e.g. "gene" from the
	     * {@link http://sequenceontology.org/browser/current_release/term/SO:0000704 |Sequence Ontology}.
	     */
	    type: mobx_state_tree_1.types.string,
	    /**
	     * Coordinate of the edge of the feature that is closer to the beginning of
	     * the reference sequence. This can be thought of as the "start" of features
	     * on the positive strand. Uses interbase (0-based half-open) coordinates.
	     */
	    min: mobx_state_tree_1.types.number,
	    /**
	     * Coordinate of the edge of the feature that is closer to the end of the
	     * reference sequence. This can be thought of as the "end" of features on
	     * the positive strand. Uses interbase (0-based half-open) coordinates.
	     */
	    max: mobx_state_tree_1.types.number,
	    /**
	     * The strand on which the feature is located. `+1` for the positive (a.k.a.
	     * plus or forward) and `-1` for the negative (a.k.a minus or reverse)
	     * strand.
	     */
	    strand: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.union(mobx_state_tree_1.types.literal(1), mobx_state_tree_1.types.literal(-1))),
	    /** Child features of this feature */
	    children: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.map(LateAnnotationFeature)),
	    /**
	     * Additional attributes of the feature. This could include name, source,
	     * note, dbxref, etc.
	     */
	    attributes: mobx_state_tree_1.types.map(mobx_state_tree_1.types.array(mobx_state_tree_1.types.string)),
	    updatedAt: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string)
	  }).views(function (self) {
	    return {
	      get length() {
	        return self.max - self.min;
	      },
	      get featureId() {
	        return self.attributes.get('id');
	      },
	      /**
	       * Possibly different from `min` because "The GFF3 format does not enforce a
	       * rule in which features must be wholly contained within the location of
	       * their parents"
	       */
	      get minWithChildren() {
	        var min = self.min;
	        var children = self.children;
	        if (!children) {
	          return min;
	        }
	        var _iterator = _createForOfIteratorHelper(children),
	          _step;
	        try {
	          for (_iterator.s(); !(_step = _iterator.n()).done;) {
	            var _step$value = _slicedToArray(_step.value, 2),
	              child = _step$value[1];
	            min = Math.min(min, child.min);
	          }
	        } catch (err) {
	          _iterator.e(err);
	        } finally {
	          _iterator.f();
	        }
	        return min;
	      },
	      /**
	       * Possibly different from `max` because "The GFF3 format does not enforce a
	       * rule in which features must be wholly contained within the location of
	       * their parents"
	       */
	      get maxWithChildren() {
	        var max = self.max;
	        var children = self.children;
	        if (!children) {
	          return max;
	        }
	        var _iterator2 = _createForOfIteratorHelper(children),
	          _step2;
	        try {
	          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	            var _step2$value = _slicedToArray(_step2.value, 2),
	              child = _step2$value[1];
	            max = Math.max(max, child.max);
	          }
	        } catch (err) {
	          _iterator2.e(err);
	        } finally {
	          _iterator2.f();
	        }
	        return max;
	      },
	      hasDescendant: function hasDescendant(featureId) {
	        var children = self.children;
	        if (!children) {
	          return false;
	        }
	        var _iterator3 = _createForOfIteratorHelper(children),
	          _step3;
	        try {
	          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	            var _step3$value = _slicedToArray(_step3.value, 2),
	              id = _step3$value[0],
	              child = _step3$value[1];
	            if (id === featureId) {
	              return true;
	            }
	            if (child.hasDescendant(featureId)) {
	              return true;
	            }
	          }
	        } catch (err) {
	          _iterator3.e(err);
	        } finally {
	          _iterator3.f();
	        }
	        return false;
	      },
	      get transcriptExonParts() {
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	        var session = (0, util_1.getSession)(self);
	        var apolloDataStore = session.apolloDataStore;
	        var featureTypeOntology = apolloDataStore.ontologyManager.featureTypeOntology;
	        if (!featureTypeOntology.isTypeOf(self.type, 'transcript') && !featureTypeOntology.isTypeOf(self.type, 'pseudogenic_transcript')) {
	          throw new Error('Feature is not a transcript or equivalent, cannot calculate exon locations');
	        }
	        var children = self.children;
	        if (!children) {
	          throw new Error('No exons in transcript');
	        }
	        var sortedChildren = _toConsumableArray(children.values()).filter(function (child) {
	          return featureTypeOntology.isTypeOf(child.type, 'exon');
	        }).sort(function (a, b) {
	          return a.min - b.min;
	        });
	        var lastMax = self.min;
	        var parts = [];
	        var _iterator4 = _createForOfIteratorHelper(sortedChildren),
	          _step4;
	        try {
	          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
	            var child = _step4.value;
	            if (child.min > lastMax) {
	              parts.push({
	                min: lastMax,
	                max: child.min,
	                type: 'intron'
	              });
	            }
	            parts.push({
	              min: child.min,
	              max: child.max,
	              type: 'exon'
	            });
	            lastMax = child.max;
	          }
	        } catch (err) {
	          _iterator4.e(err);
	        } finally {
	          _iterator4.f();
	        }
	        if (lastMax < self.max) {
	          parts.push({
	            min: lastMax,
	            max: self.max,
	            type: 'intron'
	          });
	        }
	        if (self.strand === -1) {
	          parts.reverse();
	        }
	        return parts;
	      },
	      get transcriptParts() {
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	        var session = (0, util_1.getSession)(self);
	        var apolloDataStore = session.apolloDataStore;
	        var featureTypeOntology = apolloDataStore.ontologyManager.featureTypeOntology;
	        if (!featureTypeOntology.isTypeOf(self.type, 'transcript') && !featureTypeOntology.isTypeOf(self.type, 'pseudogenic_transcript')) {
	          throw new Error('Only features of type "transcript" or equivalent can calculate CDS locations');
	        }
	        var children = self.children;
	        if (!children) {
	          throw new Error('no CDS or exons in transcript');
	        }
	        var cdsChildren = _toConsumableArray(children.values()).filter(function (child) {
	          return featureTypeOntology.isTypeOf(child.type, 'CDS');
	        });
	        var transcriptParts = [];
	        if (cdsChildren.length === 0) {
	          transcriptParts.push(this.transcriptExonParts);
	          return transcriptParts;
	        }
	        var _iterator5 = _createForOfIteratorHelper(cdsChildren),
	          _step5;
	        try {
	          var _loop = function _loop() {
	            var cds = _step5.value;
	            var cdsMax = cds.max,
	              cdsMin = cds.min;
	            var parts = [];
	            var hasIntersected = false;
	            var exonLocations = [];
	            var _iterator6 = _createForOfIteratorHelper(children),
	              _step6;
	            try {
	              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
	                var _step6$value = _slicedToArray(_step6.value, 2),
	                  _child = _step6$value[1];
	                if (featureTypeOntology.isTypeOf(_child.type, 'exon')) {
	                  exonLocations.push({
	                    min: _child.min,
	                    max: _child.max
	                  });
	                }
	              }
	            } catch (err) {
	              _iterator6.e(err);
	            } finally {
	              _iterator6.f();
	            }
	            exonLocations.sort(function (_ref, _ref2) {
	              var a = _ref.min;
	              var b = _ref2.min;
	              return a - b;
	            });
	            for (var _i = 0, _exonLocations = exonLocations; _i < _exonLocations.length; _i++) {
	              var child = _exonLocations[_i];
	              var lastPart = parts.at(-1);
	              if (lastPart) {
	                parts.push({
	                  min: lastPart.max,
	                  max: child.min,
	                  type: 'intron'
	                });
	              }
	              var _ref3 = (0, util_1.intersection2)(cdsMin, cdsMax, child.min, child.max),
	                _ref4 = _slicedToArray(_ref3, 2),
	                start = _ref4[0],
	                end = _ref4[1];
	              var utrType = void 0;
	              if (hasIntersected) {
	                utrType = self.strand === 1 ? 'threePrimeUTR' : 'fivePrimeUTR';
	              } else {
	                utrType = self.strand === 1 ? 'fivePrimeUTR' : 'threePrimeUTR';
	              }
	              if (start !== undefined && end !== undefined) {
	                hasIntersected = true;
	                if (start === child.min && end === child.max) {
	                  parts.push({
	                    min: start,
	                    max: end,
	                    phase: 0,
	                    type: 'CDS'
	                  });
	                } else if (start === child.min) {
	                  parts.push({
	                    min: start,
	                    max: end,
	                    phase: 0,
	                    type: 'CDS'
	                  }, {
	                    min: end,
	                    max: child.max,
	                    type: utrType
	                  });
	                } else if (end === child.max) {
	                  parts.push({
	                    min: child.min,
	                    max: start,
	                    type: utrType
	                  }, {
	                    min: start,
	                    max: end,
	                    phase: 0,
	                    type: 'CDS'
	                  });
	                } else {
	                  parts.push({
	                    min: child.min,
	                    max: start,
	                    type: utrType
	                  }, {
	                    min: start,
	                    max: end,
	                    phase: 0,
	                    type: 'CDS'
	                  }, {
	                    min: end,
	                    max: child.max,
	                    type: utrType === 'fivePrimeUTR' ? 'threePrimeUTR' : 'fivePrimeUTR'
	                  });
	                }
	              } else {
	                parts.push({
	                  min: child.min,
	                  max: child.max,
	                  type: utrType
	                });
	              }
	            }
	            parts.sort(function (_ref5, _ref6) {
	              var a = _ref5.min;
	              var b = _ref6.min;
	              return a - b;
	            });
	            if (self.strand === -1) {
	              parts.reverse();
	            }
	            var nextPhase = 0;
	            var phasedParts = parts.map(function (loc) {
	              if (loc.type !== 'CDS') {
	                return loc;
	              }
	              var phase = nextPhase;
	              nextPhase = (3 - (loc.max - loc.min - phase + 3) % 3) % 3;
	              return _objectSpread2(_objectSpread2({}, loc), {}, {
	                phase: phase
	              });
	            });
	            transcriptParts.push(phasedParts);
	          };
	          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
	            _loop();
	          }
	        } catch (err) {
	          _iterator5.e(err);
	        } finally {
	          _iterator5.f();
	        }
	        return transcriptParts;
	      }
	    };
	  }).views(function (self) {
	    return {
	      get cdsLocations() {
	        var transcriptParts = self.transcriptParts;
	        return transcriptParts.map(function (transcript) {
	          return transcript.filter(function (transcriptPart) {
	            return transcriptPart.type === 'CDS';
	          });
	        });
	      },
	      get looksLikeGene() {
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	        var session = (0, util_1.getSession)(self);
	        var apolloDataStore = session.apolloDataStore;
	        var featureTypeOntology = apolloDataStore.ontologyManager.featureTypeOntology;
	        if (!featureTypeOntology) {
	          return false;
	        }
	        var children = self.children;
	        if (!(children !== null && children !== void 0 && children.size)) {
	          return false;
	        }
	        var isGene = featureTypeOntology.isTypeOf(self.type, 'gene') || featureTypeOntology.isTypeOf(self.type, 'pseudogene');
	        if (!isGene) {
	          return false;
	        }
	        var _iterator7 = _createForOfIteratorHelper(children),
	          _step7;
	        try {
	          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
	            var _step7$value = _slicedToArray(_step7.value, 2),
	              child = _step7$value[1];
	            if (featureTypeOntology.isTypeOf(child.type, 'transcript') || featureTypeOntology.isTypeOf(child.type, 'pseudogenic_transcript')) {
	              var grandChildren = child.children;
	              if (!(grandChildren !== null && grandChildren !== void 0 && grandChildren.size)) {
	                return false;
	              }
	              return _toConsumableArray(grandChildren.values()).some(function (grandchild) {
	                return featureTypeOntology.isTypeOf(grandchild.type, 'exon');
	              });
	            }
	          }
	        } catch (err) {
	          _iterator7.e(err);
	        } finally {
	          _iterator7.f();
	        }
	        return false;
	      }
	    };
	  }).actions(function (self) {
	    return {
	      setAttributes: function setAttributes(attributes) {
	        self.attributes.clear();
	        var _iterator8 = _createForOfIteratorHelper(attributes.entries()),
	          _step8;
	        try {
	          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
	            var _step8$value = _slicedToArray(_step8.value, 2),
	              key = _step8$value[0],
	              value = _step8$value[1];
	            self.attributes.set(key, value);
	          }
	        } catch (err) {
	          _iterator8.e(err);
	        } finally {
	          _iterator8.f();
	        }
	      },
	      setAttribute: function setAttribute(key, value) {
	        self.attributes.merge(_defineProperty({}, key, value));
	      },
	      setType: function setType(type) {
	        self.type = type;
	      },
	      setRefSeq: function setRefSeq(refSeq) {
	        self.refSeq = refSeq;
	      },
	      setMin: function setMin(min) {
	        if (min > self.max) {
	          throw new Error("Min \"".concat(min + 1, "\" is greater than max \"").concat(self.max, "\""));
	        }
	        if (self.min !== min) {
	          self.min = min;
	        }
	      },
	      setMax: function setMax(max) {
	        if (max < self.min) {
	          throw new Error("Max \"".concat(max, "\" is less than Min \"").concat(self.min, "\""));
	        }
	        if (self.max !== max) {
	          self.max = max;
	        }
	      },
	      setStrand: function setStrand(strand) {
	        self.strand = strand;
	      },
	      addChild: function addChild(childFeature) {
	        if (self.children && self.children.size > 0) {
	          var existingChildren = (0, mobx_state_tree_1.getSnapshot)(self.children);
	          self.children.clear();
	          var _iterator9 = _createForOfIteratorHelper(Object.entries(_objectSpread2(_objectSpread2({}, existingChildren), {}, _defineProperty({}, childFeature._id, childFeature))).sort(function (_ref7, _ref8) {
	              var _ref9 = _slicedToArray(_ref7, 2),
	                a = _ref9[1];
	              var _ref10 = _slicedToArray(_ref8, 2),
	                b = _ref10[1];
	              return a.min - b.min;
	            })),
	            _step9;
	          try {
	            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
	              var _step9$value = _slicedToArray(_step9.value, 2),
	                child = _step9$value[1];
	              self.children.put(child);
	            }
	          } catch (err) {
	            _iterator9.e(err);
	          } finally {
	            _iterator9.f();
	          }
	        } else {
	          var _self$children;
	          self.children = (0, mobx_state_tree_1.cast)({});
	          (_self$children = self.children) === null || _self$children === void 0 || _self$children.put(childFeature);
	        }
	      },
	      deleteChild: function deleteChild(childFeatureId) {
	        var _self$children2;
	        (_self$children2 = self.children) === null || _self$children2 === void 0 || _self$children2["delete"](childFeatureId);
	      }
	    };
	  }).actions(function (self) {
	    return {
	      update: function update(_ref11) {
	        var children = _ref11.children,
	          max = _ref11.max,
	          min = _ref11.min,
	          refSeq = _ref11.refSeq,
	          strand = _ref11.strand;
	        self.setRefSeq(refSeq);
	        self.setMin(min);
	        self.setMax(max);
	        self.setStrand(strand);
	        if (children) {
	          self.children = (0, mobx_state_tree_1.cast)(children);
	        }
	      }
	    };
	  })
	  // This views block has to be last to avoid:
	  // "'parent' is referenced directly or indirectly in its own type annotation."
	  .views(function (self) {
	    return {
	      get parent() {
	        var parent;
	        try {
	          parent = (0, mobx_state_tree_1.getParentOfType)(self, exports.AnnotationFeatureModel);
	        } catch (_unused) {
	          // pass
	        }
	        return parent;
	      },
	      get topLevelFeature() {
	        var feature = self;
	        var parent;
	        do {
	          try {
	            parent = (0, mobx_state_tree_1.getParentOfType)(feature, exports.AnnotationFeatureModel);
	            feature = parent;
	          } catch (_unused2) {
	            parent = undefined;
	          }
	        } while (parent);
	        return feature;
	      },
	      get assemblyId() {
	        return (0, mobx_state_tree_1.getParentOfType)(self, _1.ApolloAssembly)._id;
	      }
	    };
	  });
	})(AnnotationFeatureModel);

	var ApolloAssembly = {};

	var ApolloRefSeq = {};

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.ApolloRefSeq = exports.Sequence = void 0;
	  var util_1 = require$$1__default$1["default"];
	  var mobx_state_tree_1 = require$$1__default$2["default"];
	  var AnnotationFeatureModel_1 = AnnotationFeatureModel;
	  exports.Sequence = /*#__PURE__*/mobx_state_tree_1.types.model({
	    start: mobx_state_tree_1.types.number,
	    stop: mobx_state_tree_1.types.number,
	    sequence: mobx_state_tree_1.types.string
	  });
	  exports.ApolloRefSeq = /*#__PURE__*/mobx_state_tree_1.types.model('ApolloRefSeq', {
	    _id: mobx_state_tree_1.types.identifier,
	    name: mobx_state_tree_1.types.string,
	    description: '',
	    features: mobx_state_tree_1.types.map(AnnotationFeatureModel_1.AnnotationFeatureModel),
	    sequence: mobx_state_tree_1.types.array(exports.Sequence)
	  }).actions(function (self) {
	    return {
	      addFeature: function addFeature(feature) {
	        self.features.put(feature);
	      },
	      deleteFeature: function deleteFeature(featureId) {
	        return self.features["delete"](featureId);
	      },
	      setDescription: function setDescription(description) {
	        self.description = description;
	      },
	      addSequence: function addSequence(seq) {
	        var _self$sequence;
	        if (seq.sequence.length !== seq.stop - seq.start) {
	          throw new Error("sequence does not match declared length: ".concat(JSON.stringify(seq)));
	        }
	        if (self.sequence.length === 0) {
	          self.sequence.push(seq);
	          return;
	        }
	        var newSequences = self.sequence.map(function (s) {
	          return {
	            start: s.start,
	            stop: s.stop,
	            sequence: s.sequence
	          };
	        });
	        newSequences.push({
	          start: seq.start,
	          stop: seq.stop,
	          sequence: seq.sequence
	        });
	        newSequences.sort(function (s1, s2) {
	          if (s1.start === s2.start) {
	            return s1.stop - s2.stop;
	          }
	          return s1.start - s2.start;
	        });
	        // eslint-disable-next-line unicorn/no-array-reduce
	        var consolidatedSequences = newSequences.reduce(function (result, current) {
	          var lastRange = result.at(-1);
	          if (lastRange === undefined) {
	            return [current];
	          }
	          if (lastRange.stop >= current.start) {
	            if (current.stop > lastRange.stop) {
	              var overlapLength = lastRange.stop - current.start;
	              lastRange.stop = current.stop;
	              lastRange.sequence += current.sequence.slice(overlapLength);
	            }
	          } else {
	            result.push(current);
	          }
	          return result;
	        }, []);
	        var _iterator = _createForOfIteratorHelper(consolidatedSequences),
	          _step;
	        try {
	          for (_iterator.s(); !(_step = _iterator.n()).done;) {
	            var _seq = _step.value;
	            if (_seq.sequence.length !== _seq.stop - _seq.start) {
	              throw new Error('Consolidated sequence does not match declared length');
	            }
	          }
	        } catch (err) {
	          _iterator.e(err);
	        } finally {
	          _iterator.f();
	        }
	        if (self.sequence.length === consolidatedSequences.length && self.sequence.every(function (s, idx) {
	          return s.start === consolidatedSequences[idx].start && s.stop === consolidatedSequences[idx].stop;
	        })) {
	          // sequences was unchanged
	          return;
	        }
	        self.sequence.clear();
	        (_self$sequence = self.sequence).push.apply(_self$sequence, _toConsumableArray(consolidatedSequences));
	      }
	    };
	  }).views(function (self) {
	    return {
	      getSequence: function getSequence(start, stop) {
	        var _iterator2 = _createForOfIteratorHelper(self.sequence),
	          _step2;
	        try {
	          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	            var _step2$value = _step2.value,
	              sequence = _step2$value.sequence,
	              seqStart = _step2$value.start,
	              seqStop = _step2$value.stop;
	            // adjacent to existing sequence - modify
	            if ((0, util_1.isContainedWithin)(start, stop, seqStart, seqStop)) {
	              return sequence.slice(start - seqStart, stop - seqStart);
	            }
	          }
	        } catch (err) {
	          _iterator2.e(err);
	        } finally {
	          _iterator2.f();
	        }
	        return '';
	      },
	      getFeatures: function getFeatures(min, max) {
	        var features = [];
	        var _iterator3 = _createForOfIteratorHelper(self.features),
	          _step3;
	        try {
	          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	            var _step3$value = _slicedToArray(_step3.value, 2),
	              feature = _step3$value[1];
	            if ((0, util_1.doesIntersect2)(feature.min, feature.max, min, max)) {
	              features.push(feature);
	            }
	          }
	        } catch (err) {
	          _iterator3.e(err);
	        } finally {
	          _iterator3.f();
	        }
	        return features;
	      }
	    };
	  });
	})(ApolloRefSeq);

	Object.defineProperty(ApolloAssembly, "__esModule", {
	  value: true
	});
	ApolloAssembly.ApolloAssembly = void 0;
	var mobx_state_tree_1$1 = require$$1__default$2["default"];
	var ApolloRefSeq_1 = ApolloRefSeq;
	ApolloAssembly.ApolloAssembly = /*#__PURE__*/mobx_state_tree_1$1.types.model('ApolloAssembly', {
	  _id: mobx_state_tree_1$1.types.identifier,
	  refSeqs: mobx_state_tree_1$1.types.map(ApolloRefSeq_1.ApolloRefSeq),
	  comments: mobx_state_tree_1$1.types.array(mobx_state_tree_1$1.types.string),
	  backendDriverType: mobx_state_tree_1$1.types.optional(mobx_state_tree_1$1.types.enumeration('backendDriverType', ['CollaborationServerDriver', 'InMemoryFileDriver', 'DesktopFileDriver']), 'CollaborationServerDriver')
	}).views(function (self) {
	  return {
	    getByRefName: function getByRefName(refName) {
	      return _toConsumableArray(self.refSeqs.values()).find(function (val) {
	        return val.name === refName;
	      });
	    }
	  };
	}).actions(function (self) {
	  return {
	    addRefSeq: function addRefSeq(id, name, description) {
	      return self.refSeqs.put({
	        _id: id,
	        name: name,
	        description: description
	      });
	    },
	    addComment: function addComment(comment) {
	      return self.comments.push(comment);
	    }
	  };
	});

	var CheckResult = {};

	Object.defineProperty(CheckResult, "__esModule", {
	  value: true
	});
	CheckResult.CheckResult = void 0;
	var mobx_state_tree_1 = require$$1__default$2["default"];
	var AnnotationFeatureModel_1 = AnnotationFeatureModel;
	CheckResult.CheckResult = /*#__PURE__*/mobx_state_tree_1.types.model('CheckResult', {
	  _id: mobx_state_tree_1.types.identifier,
	  name: mobx_state_tree_1.types.string,
	  cause: mobx_state_tree_1.types.string,
	  ids: /*#__PURE__*/mobx_state_tree_1.types.array( /*#__PURE__*/mobx_state_tree_1.types.safeReference(AnnotationFeatureModel_1.AnnotationFeatureModel)),
	  refSeq: mobx_state_tree_1.types.string,
	  start: mobx_state_tree_1.types.number,
	  end: mobx_state_tree_1.types.number,
	  ignored: false,
	  message: mobx_state_tree_1.types.string
	});

	(function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var tslib_1 = require$$0$1;
	  tslib_1.__exportStar(AnnotationFeatureModel, exports);
	  tslib_1.__exportStar(ApolloAssembly, exports);
	  tslib_1.__exportStar(ApolloRefSeq, exports);
	  tslib_1.__exportStar(CheckResult, exports);
	})(dist);

	/* eslint-disable @typescript-eslint/no-unsafe-call */
	const ApolloFeatureDetailsWidgetModel = require$$1$3.types
	    .model('ApolloFeatureDetailsWidget', {
	    id: mst.ElementId,
	    type: require$$1$3.types.literal('ApolloFeatureDetailsWidget'),
	    feature: require$$1$3.types.maybe(require$$1$3.types.reference(dist.AnnotationFeatureModel, {
	        onInvalidated(ev) {
	            ev.parent.setTryReload(ev.invalidId);
	            ev.removeRef();
	        },
	    })),
	    assembly: require$$1$3.types.string,
	    refName: require$$1$3.types.string,
	})
	    .volatile(() => ({
	    tryReload: undefined,
	}))
	    .actions((self) => ({
	    setFeature(feature) {
	        // @ts-expect-error Not sure why TS thinks these MST types don't match
	        self.feature = feature;
	    },
	    setTryReload(featureId) {
	        self.tryReload = featureId;
	    },
	}))
	    .actions((self) => ({
	    afterAttach() {
	        require$$1$3.addDisposer(self, mobx.autorun((reaction) => {
	            if (!self.tryReload) {
	                return;
	            }
	            const session = require$$1$2.getSession(self);
	            const { apolloDataStore } = session;
	            if (!apolloDataStore) {
	                return;
	            }
	            const feature = apolloDataStore.getFeature(self.tryReload);
	            if (feature) {
	                self.setFeature(feature);
	                self.setTryReload();
	                reaction.dispose();
	            }
	        }));
	    },
	}));
	const ApolloTranscriptDetailsModel = require$$1$3.types
	    .model('ApolloTranscriptDetails', {
	    id: mst.ElementId,
	    type: require$$1$3.types.literal('ApolloTranscriptDetails'),
	    feature: require$$1$3.types.maybe(require$$1$3.types.reference(dist.AnnotationFeatureModel, {
	        onInvalidated(ev) {
	            ev.parent.setTryReload(ev.invalidId);
	            ev.removeRef();
	        },
	    })),
	    assembly: require$$1$3.types.string,
	    refName: require$$1$3.types.string,
	})
	    .volatile(() => ({
	    tryReload: undefined,
	}))
	    .actions((self) => ({
	    setFeature(feature) {
	        // @ts-expect-error Not sure why TS thinks these MST types don't match
	        self.feature = feature;
	    },
	    setTryReload(featureId) {
	        self.tryReload = featureId;
	    },
	}))
	    .actions((self) => ({
	    afterAttach() {
	        require$$1$3.addDisposer(self, mobx.autorun((reaction) => {
	            if (!self.tryReload) {
	                return;
	            }
	            const session = require$$1$2.getSession(self);
	            const { apolloDataStore } = session;
	            if (!apolloDataStore) {
	                return;
	            }
	            const feature = apolloDataStore.getFeature(self.tryReload);
	            if (feature) {
	                self.setFeature(feature);
	                self.setTryReload();
	                reaction.dispose();
	            }
	        }));
	    },
	}));

	function _extends() {
	  _extends = Object.assign ? Object.assign.bind() : function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  return _extends.apply(this, arguments);
	}

	function memoize(fn) {
	  var cache = Object.create(null);
	  return function (arg) {
	    if (cache[arg] === undefined) cache[arg] = fn(arg);
	    return cache[arg];
	  };
	}

	var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

	var isPropValid = /* #__PURE__ */memoize(function (prop) {
	  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
	  /* o */ && prop.charCodeAt(1) === 110
	  /* n */ && prop.charCodeAt(2) < 91;
	}
	/* Z+1 */);

	/*

	Based off glamor's StyleSheet, thanks Sunil ❤️

	high performance StyleSheet for css-in-js systems

	- uses multiple style tags behind the scenes for millions of rules
	- uses `insertRule` for appending in production for *much* faster performance

	// usage

	import { StyleSheet } from '@emotion/sheet'

	let styleSheet = new StyleSheet({ key: '', container: document.head })

	styleSheet.insert('#box { border: 1px solid red; }')
	- appends a css rule into the stylesheet

	styleSheet.flush()
	- empties the stylesheet of all its contents

	*/
	// $FlowFixMe
	function sheetForTag(tag) {
	  if (tag.sheet) {
	    // $FlowFixMe
	    return tag.sheet;
	  } // this weirdness brought to you by firefox

	  /* istanbul ignore next */

	  for (var i = 0; i < document.styleSheets.length; i++) {
	    if (document.styleSheets[i].ownerNode === tag) {
	      // $FlowFixMe
	      return document.styleSheets[i];
	    }
	  }
	}
	function createStyleElement(options) {
	  var tag = document.createElement('style');
	  tag.setAttribute('data-emotion', options.key);
	  if (options.nonce !== undefined) {
	    tag.setAttribute('nonce', options.nonce);
	  }
	  tag.appendChild(document.createTextNode(''));
	  tag.setAttribute('data-s', '');
	  return tag;
	}
	var StyleSheet = /*#__PURE__*/function () {
	  // Using Node instead of HTMLElement since container may be a ShadowRoot
	  function StyleSheet(options) {
	    var _this = this;
	    this._insertTag = function (tag) {
	      var before;
	      if (_this.tags.length === 0) {
	        if (_this.insertionPoint) {
	          before = _this.insertionPoint.nextSibling;
	        } else if (_this.prepend) {
	          before = _this.container.firstChild;
	        } else {
	          before = _this.before;
	        }
	      } else {
	        before = _this.tags[_this.tags.length - 1].nextSibling;
	      }
	      _this.container.insertBefore(tag, before);
	      _this.tags.push(tag);
	    };
	    this.isSpeedy = options.speedy === undefined ? process$1.env.NODE_ENV === 'production' : options.speedy;
	    this.tags = [];
	    this.ctr = 0;
	    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

	    this.key = options.key;
	    this.container = options.container;
	    this.prepend = options.prepend;
	    this.insertionPoint = options.insertionPoint;
	    this.before = null;
	  }
	  var _proto = StyleSheet.prototype;
	  _proto.hydrate = function hydrate(nodes) {
	    nodes.forEach(this._insertTag);
	  };
	  _proto.insert = function insert(rule) {
	    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
	    // it's 1 in dev because we insert source maps that map a single rule to a location
	    // and you can only have one source map per style tag
	    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
	      this._insertTag(createStyleElement(this));
	    }
	    var tag = this.tags[this.tags.length - 1];
	    if (process$1.env.NODE_ENV !== 'production') {
	      var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
	      if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) {
	        // this would only cause problem in speedy mode
	        // but we don't want enabling speedy to affect the observable behavior
	        // so we report this error at all times
	        console.error("You're attempting to insert the following rule:\n" + rule + '\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.');
	      }
	      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;
	    }
	    if (this.isSpeedy) {
	      var sheet = sheetForTag(tag);
	      try {
	        // this is the ultrafast version, works across browsers
	        // the big drawback is that the css won't be editable in devtools
	        sheet.insertRule(rule, sheet.cssRules.length);
	      } catch (e) {
	        if (process$1.env.NODE_ENV !== 'production' && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
	          console.error("There was a problem inserting the following rule: \"" + rule + "\"", e);
	        }
	      }
	    } else {
	      tag.appendChild(document.createTextNode(rule));
	    }
	    this.ctr++;
	  };
	  _proto.flush = function flush() {
	    // $FlowFixMe
	    this.tags.forEach(function (tag) {
	      return tag.parentNode && tag.parentNode.removeChild(tag);
	    });
	    this.tags = [];
	    this.ctr = 0;
	    if (process$1.env.NODE_ENV !== 'production') {
	      this._alreadyInsertedOrderInsensitiveRule = false;
	    }
	  };
	  return StyleSheet;
	}();

	var MS = '-ms-';
	var MOZ = '-moz-';
	var WEBKIT = '-webkit-';
	var COMMENT = 'comm';
	var RULESET = 'rule';
	var DECLARATION = 'decl';
	var IMPORT = '@import';
	var KEYFRAMES = '@keyframes';
	var LAYER = '@layer';

	/**
	 * @param {number}
	 * @return {number}
	 */
	var abs = Math.abs;

	/**
	 * @param {number}
	 * @return {string}
	 */
	var from = String.fromCharCode;

	/**
	 * @param {object}
	 * @return {object}
	 */
	var assign = Object.assign;

	/**
	 * @param {string} value
	 * @param {number} length
	 * @return {number}
	 */
	function hash(value, length) {
	  return charat(value, 0) ^ 45 ? (((length << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
	}

	/**
	 * @param {string} value
	 * @return {string}
	 */
	function trim(value) {
	  return value.trim();
	}

	/**
	 * @param {string} value
	 * @param {RegExp} pattern
	 * @return {string?}
	 */
	function match(value, pattern) {
	  return (value = pattern.exec(value)) ? value[0] : value;
	}

	/**
	 * @param {string} value
	 * @param {(string|RegExp)} pattern
	 * @param {string} replacement
	 * @return {string}
	 */
	function replace(value, pattern, replacement) {
	  return value.replace(pattern, replacement);
	}

	/**
	 * @param {string} value
	 * @param {string} search
	 * @return {number}
	 */
	function indexof(value, search) {
	  return value.indexOf(search);
	}

	/**
	 * @param {string} value
	 * @param {number} index
	 * @return {number}
	 */
	function charat(value, index) {
	  return value.charCodeAt(index) | 0;
	}

	/**
	 * @param {string} value
	 * @param {number} begin
	 * @param {number} end
	 * @return {string}
	 */
	function substr(value, begin, end) {
	  return value.slice(begin, end);
	}

	/**
	 * @param {string} value
	 * @return {number}
	 */
	function strlen(value) {
	  return value.length;
	}

	/**
	 * @param {any[]} value
	 * @return {number}
	 */
	function sizeof(value) {
	  return value.length;
	}

	/**
	 * @param {any} value
	 * @param {any[]} array
	 * @return {any}
	 */
	function append(value, array) {
	  return array.push(value), value;
	}

	/**
	 * @param {string[]} array
	 * @param {function} callback
	 * @return {string}
	 */
	function combine(array, callback) {
	  return array.map(callback).join('');
	}

	var line = 1;
	var column = 1;
	var length = 0;
	var position = 0;
	var character = 0;
	var characters = '';

	/**
	 * @param {string} value
	 * @param {object | null} root
	 * @param {object | null} parent
	 * @param {string} type
	 * @param {string[] | string} props
	 * @param {object[] | string} children
	 * @param {number} length
	 */
	function node(value, root, parent, type, props, children, length) {
	  return {
	    value: value,
	    root: root,
	    parent: parent,
	    type: type,
	    props: props,
	    children: children,
	    line: line,
	    column: column,
	    length: length,
	    "return": ''
	  };
	}

	/**
	 * @param {object} root
	 * @param {object} props
	 * @return {object}
	 */
	function copy(root, props) {
	  return assign(node('', null, null, '', null, null, 0), root, {
	    length: -root.length
	  }, props);
	}

	/**
	 * @return {number}
	 */
	function _char() {
	  return character;
	}
	function prev() {
	  character = position > 0 ? charat(characters, --position) : 0;
	  if (column--, character === 10) column = 1, line--;
	  return character;
	}

	/**
	 * @return {number}
	 */
	function next() {
	  character = position < length ? charat(characters, position++) : 0;
	  if (column++, character === 10) column = 1, line++;
	  return character;
	}

	/**
	 * @return {number}
	 */
	function peek() {
	  return charat(characters, position);
	}

	/**
	 * @return {number}
	 */
	function caret() {
	  return position;
	}

	/**
	 * @param {number} begin
	 * @param {number} end
	 * @return {string}
	 */
	function slice(begin, end) {
	  return substr(characters, begin, end);
	}

	/**
	 * @param {number} type
	 * @return {number}
	 */
	function token(type) {
	  switch (type) {
	    // \0 \t \n \r \s whitespace token
	    case 0:
	    case 9:
	    case 10:
	    case 13:
	    case 32:
	      return 5;
	    // ! + , / > @ ~ isolate token
	    case 33:
	    case 43:
	    case 44:
	    case 47:
	    case 62:
	    case 64:
	    case 126:
	    // ; { } breakpoint token
	    case 59:
	    case 123:
	    case 125:
	      return 4;
	    // : accompanied token
	    case 58:
	      return 3;
	    // " ' ( [ opening delimit token
	    case 34:
	    case 39:
	    case 40:
	    case 91:
	      return 2;
	    // ) ] closing delimit token
	    case 41:
	    case 93:
	      return 1;
	  }
	  return 0;
	}

	/**
	 * @param {string} value
	 * @return {any[]}
	 */
	function alloc(value) {
	  return line = column = 1, length = strlen(characters = value), position = 0, [];
	}

	/**
	 * @param {any} value
	 * @return {any}
	 */
	function dealloc(value) {
	  return characters = '', value;
	}

	/**
	 * @param {number} type
	 * @return {string}
	 */
	function delimit(type) {
	  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
	}

	/**
	 * @param {number} type
	 * @return {string}
	 */
	function whitespace(type) {
	  while (character = peek()) if (character < 33) next();else break;
	  return token(type) > 2 || token(character) > 3 ? '' : ' ';
	}

	/**
	 * @param {number} index
	 * @param {number} count
	 * @return {string}
	 */
	function escaping(index, count) {
	  while (--count && next())
	  // not 0-9 A-F a-f
	  if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97) break;
	  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
	}

	/**
	 * @param {number} type
	 * @return {number}
	 */
	function delimiter(type) {
	  while (next()) switch (character) {
	    // ] ) " '
	    case type:
	      return position;
	    // " '
	    case 34:
	    case 39:
	      if (type !== 34 && type !== 39) delimiter(character);
	      break;
	    // (
	    case 40:
	      if (type === 41) delimiter(type);
	      break;
	    // \
	    case 92:
	      next();
	      break;
	  }
	  return position;
	}

	/**
	 * @param {number} type
	 * @param {number} index
	 * @return {number}
	 */
	function commenter(type, index) {
	  while (next())
	  // //
	  if (type + character === 47 + 10) break;
	  // /*
	  else if (type + character === 42 + 42 && peek() === 47) break;
	  return '/*' + slice(index, position - 1) + '*' + from(type === 47 ? type : next());
	}

	/**
	 * @param {number} index
	 * @return {string}
	 */
	function identifier(index) {
	  while (!token(peek())) next();
	  return slice(index, position);
	}

	/**
	 * @param {string} value
	 * @return {object[]}
	 */
	function compile(value) {
	  return dealloc(parse('', null, null, null, [''], value = alloc(value), 0, [0], value));
	}

	/**
	 * @param {string} value
	 * @param {object} root
	 * @param {object?} parent
	 * @param {string[]} rule
	 * @param {string[]} rules
	 * @param {string[]} rulesets
	 * @param {number[]} pseudo
	 * @param {number[]} points
	 * @param {string[]} declarations
	 * @return {object}
	 */
	function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
	  var index = 0;
	  var offset = 0;
	  var length = pseudo;
	  var atrule = 0;
	  var property = 0;
	  var previous = 0;
	  var variable = 1;
	  var scanning = 1;
	  var ampersand = 1;
	  var character = 0;
	  var type = '';
	  var props = rules;
	  var children = rulesets;
	  var reference = rule;
	  var characters = type;
	  while (scanning) switch (previous = character, character = next()) {
	    // (
	    case 40:
	      if (previous != 108 && charat(characters, length - 1) == 58) {
	        if (indexof(characters += replace(delimit(character), '&', '&\f'), '&\f') != -1) ampersand = -1;
	        break;
	      }
	    // " ' [
	    case 34:
	    case 39:
	    case 91:
	      characters += delimit(character);
	      break;
	    // \t \n \r \s
	    case 9:
	    case 10:
	    case 13:
	    case 32:
	      characters += whitespace(previous);
	      break;
	    // \
	    case 92:
	      characters += escaping(caret() - 1, 7);
	      continue;
	    // /
	    case 47:
	      switch (peek()) {
	        case 42:
	        case 47:
	          append(comment(commenter(next(), caret()), root, parent), declarations);
	          break;
	        default:
	          characters += '/';
	      }
	      break;
	    // {
	    case 123 * variable:
	      points[index++] = strlen(characters) * ampersand;
	    // } ; \0
	    case 125 * variable:
	    case 59:
	    case 0:
	      switch (character) {
	        // \0 }
	        case 0:
	        case 125:
	          scanning = 0;
	        // ;
	        case 59 + offset:
	          if (ampersand == -1) characters = replace(characters, /\f/g, '');
	          if (property > 0 && strlen(characters) - length) append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations);
	          break;
	        // @ ;
	        case 59:
	          characters += ';';
	        // { rule/at-rule
	        default:
	          append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);
	          if (character === 123) if (offset === 0) parse(characters, root, reference, reference, props, rulesets, length, points, children);else switch (atrule === 99 && charat(characters, 3) === 110 ? 100 : atrule) {
	            // d l m s
	            case 100:
	            case 108:
	            case 109:
	            case 115:
	              parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);
	              break;
	            default:
	              parse(characters, reference, reference, reference, [''], children, 0, points, children);
	          }
	      }
	      index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
	      break;
	    // :
	    case 58:
	      length = 1 + strlen(characters), property = previous;
	    default:
	      if (variable < 1) if (character == 123) --variable;else if (character == 125 && variable++ == 0 && prev() == 125) continue;
	      switch (characters += from(character), character * variable) {
	        // &
	        case 38:
	          ampersand = offset > 0 ? 1 : (characters += '\f', -1);
	          break;
	        // ,
	        case 44:
	          points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
	          break;
	        // @
	        case 64:
	          // -
	          if (peek() === 45) characters += delimit(next());
	          atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;
	          break;
	        // -
	        case 45:
	          if (previous === 45 && strlen(characters) == 2) variable = 0;
	      }
	  }
	  return rulesets;
	}

	/**
	 * @param {string} value
	 * @param {object} root
	 * @param {object?} parent
	 * @param {number} index
	 * @param {number} offset
	 * @param {string[]} rules
	 * @param {number[]} points
	 * @param {string} type
	 * @param {string[]} props
	 * @param {string[]} children
	 * @param {number} length
	 * @return {object}
	 */
	function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length) {
	  var post = offset - 1;
	  var rule = offset === 0 ? rules : [''];
	  var size = sizeof(rule);
	  for (var i = 0, j = 0, k = 0; i < index; ++i) for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x) if (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\f/g, rule[x]))) props[k++] = z;
	  return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length);
	}

	/**
	 * @param {number} value
	 * @param {object} root
	 * @param {object?} parent
	 * @return {object}
	 */
	function comment(value, root, parent) {
	  return node(value, root, parent, COMMENT, from(_char()), substr(value, 2, -2), 0);
	}

	/**
	 * @param {string} value
	 * @param {object} root
	 * @param {object?} parent
	 * @param {number} length
	 * @return {object}
	 */
	function declaration(value, root, parent, length) {
	  return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length);
	}

	/**
	 * @param {object[]} children
	 * @param {function} callback
	 * @return {string}
	 */
	function serialize(children, callback) {
	  var output = '';
	  var length = sizeof(children);
	  for (var i = 0; i < length; i++) output += callback(children[i], i, children, callback) || '';
	  return output;
	}

	/**
	 * @param {object} element
	 * @param {number} index
	 * @param {object[]} children
	 * @param {function} callback
	 * @return {string}
	 */
	function stringify(element, index, children, callback) {
	  switch (element.type) {
	    case LAYER:
	      if (element.children.length) break;
	    case IMPORT:
	    case DECLARATION:
	      return element["return"] = element["return"] || element.value;
	    case COMMENT:
	      return '';
	    case KEYFRAMES:
	      return element["return"] = element.value + '{' + serialize(element.children, callback) + '}';
	    case RULESET:
	      element.value = element.props.join(',');
	  }
	  return strlen(children = serialize(element.children, callback)) ? element["return"] = element.value + '{' + children + '}' : '';
	}

	/**
	 * @param {function[]} collection
	 * @return {function}
	 */
	function middleware(collection) {
	  var length = sizeof(collection);
	  return function (element, index, children, callback) {
	    var output = '';
	    for (var i = 0; i < length; i++) output += collection[i](element, index, children, callback) || '';
	    return output;
	  };
	}

	/**
	 * @param {function} callback
	 * @return {function}
	 */
	function rulesheet(callback) {
	  return function (element) {
	    if (!element.root) if (element = element["return"]) callback(element);
	  };
	}

	var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
	  var previous = 0;
	  var character = 0;
	  while (true) {
	    previous = character;
	    character = peek(); // &\f

	    if (previous === 38 && character === 12) {
	      points[index] = 1;
	    }
	    if (token(character)) {
	      break;
	    }
	    next();
	  }
	  return slice(begin, position);
	};
	var toRules = function toRules(parsed, points) {
	  // pretend we've started with a comma
	  var index = -1;
	  var character = 44;
	  do {
	    switch (token(character)) {
	      case 0:
	        // &\f
	        if (character === 38 && peek() === 12) {
	          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
	          // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
	          // and when it should just concatenate the outer and inner selectors
	          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
	          points[index] = 1;
	        }
	        parsed[index] += identifierWithPointTracking(position - 1, points, index);
	        break;
	      case 2:
	        parsed[index] += delimit(character);
	        break;
	      case 4:
	        // comma
	        if (character === 44) {
	          // colon
	          parsed[++index] = peek() === 58 ? '&\f' : '';
	          points[index] = parsed[index].length;
	          break;
	        }

	      // fallthrough

	      default:
	        parsed[index] += from(character);
	    }
	  } while (character = next());
	  return parsed;
	};
	var getRules = function getRules(value, points) {
	  return dealloc(toRules(alloc(value), points));
	}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11

	var fixedElements = /* #__PURE__ */new WeakMap();
	var compat = function compat(element) {
	  if (element.type !== 'rule' || !element.parent ||
	  // positive .length indicates that this rule contains pseudo
	  // negative .length indicates that this rule has been already prefixed
	  element.length < 1) {
	    return;
	  }
	  var value = element.value,
	    parent = element.parent;
	  var isImplicitRule = element.column === parent.column && element.line === parent.line;
	  while (parent.type !== 'rule') {
	    parent = parent.parent;
	    if (!parent) return;
	  } // short-circuit for the simplest case

	  if (element.props.length === 1 && value.charCodeAt(0) !== 58
	  /* colon */ && !fixedElements.get(parent)) {
	    return;
	  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
	  // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"

	  if (isImplicitRule) {
	    return;
	  }
	  fixedElements.set(element, true);
	  var points = [];
	  var rules = getRules(value, points);
	  var parentRules = parent.props;
	  for (var i = 0, k = 0; i < rules.length; i++) {
	    for (var j = 0; j < parentRules.length; j++, k++) {
	      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
	    }
	  }
	};
	var removeLabel = function removeLabel(element) {
	  if (element.type === 'decl') {
	    var value = element.value;
	    if (
	    // charcode for l
	    value.charCodeAt(0) === 108 &&
	    // charcode for b
	    value.charCodeAt(2) === 98) {
	      // this ignores label
	      element["return"] = '';
	      element.value = '';
	    }
	  }
	};
	var ignoreFlag = 'emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason';
	var isIgnoringComment = function isIgnoringComment(element) {
	  return element.type === 'comm' && element.children.indexOf(ignoreFlag) > -1;
	};
	var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {
	  return function (element, index, children) {
	    if (element.type !== 'rule' || cache.compat) return;
	    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
	    if (unsafePseudoClasses) {
	      var isNested = !!element.parent; // in nested rules comments become children of the "auto-inserted" rule and that's always the `element.parent`
	      //
	      // considering this input:
	      // .a {
	      //   .b /* comm */ {}
	      //   color: hotpink;
	      // }
	      // we get output corresponding to this:
	      // .a {
	      //   & {
	      //     /* comm */
	      //     color: hotpink;
	      //   }
	      //   .b {}
	      // }

	      var commentContainer = isNested ? element.parent.children :
	      // global rule at the root level
	      children;
	      for (var i = commentContainer.length - 1; i >= 0; i--) {
	        var node = commentContainer[i];
	        if (node.line < element.line) {
	          break;
	        } // it is quite weird but comments are *usually* put at `column: element.column - 1`
	        // so we seek *from the end* for the node that is earlier than the rule's `element` and check that
	        // this will also match inputs like this:
	        // .a {
	        //   /* comm */
	        //   .b {}
	        // }
	        //
	        // but that is fine
	        //
	        // it would be the easiest to change the placement of the comment to be the first child of the rule:
	        // .a {
	        //   .b { /* comm */ }
	        // }
	        // with such inputs we wouldn't have to search for the comment at all
	        // TODO: consider changing this comment placement in the next major version

	        if (node.column < element.column) {
	          if (isIgnoringComment(node)) {
	            return;
	          }
	          break;
	        }
	      }
	      unsafePseudoClasses.forEach(function (unsafePseudoClass) {
	        console.error("The pseudo class \"" + unsafePseudoClass + "\" is potentially unsafe when doing server-side rendering. Try changing it to \"" + unsafePseudoClass.split('-child')[0] + "-of-type\".");
	      });
	    }
	  };
	};
	var isImportRule = function isImportRule(element) {
	  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
	};
	var isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {
	  for (var i = index - 1; i >= 0; i--) {
	    if (!isImportRule(children[i])) {
	      return true;
	    }
	  }
	  return false;
	}; // use this to remove incorrect elements from further processing
	// so they don't get handed to the `sheet` (or anything else)
	// as that could potentially lead to additional logs which in turn could be overhelming to the user

	var nullifyElement = function nullifyElement(element) {
	  element.type = '';
	  element.value = '';
	  element["return"] = '';
	  element.children = '';
	  element.props = '';
	};
	var incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {
	  if (!isImportRule(element)) {
	    return;
	  }
	  if (element.parent) {
	    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
	    nullifyElement(element);
	  } else if (isPrependedWithRegularRules(index, children)) {
	    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
	    nullifyElement(element);
	  }
	};

	/* eslint-disable no-fallthrough */

	function prefix(value, length) {
	  switch (hash(value, length)) {
	    // color-adjust
	    case 5103:
	      return WEBKIT + 'print-' + value + value;
	    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

	    case 5737:
	    case 4201:
	    case 3177:
	    case 3433:
	    case 1641:
	    case 4457:
	    case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

	    case 5572:
	    case 6356:
	    case 5844:
	    case 3191:
	    case 6645:
	    case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

	    case 6391:
	    case 5879:
	    case 5623:
	    case 6135:
	    case 4599:
	    case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

	    case 4215:
	    case 6389:
	    case 5109:
	    case 5365:
	    case 5621:
	    case 3829:
	      return WEBKIT + value + value;
	    // appearance, user-select, transform, hyphens, text-size-adjust

	    case 5349:
	    case 4246:
	    case 4810:
	    case 6968:
	    case 2756:
	      return WEBKIT + value + MOZ + value + MS + value + value;
	    // flex, flex-direction

	    case 6828:
	    case 4268:
	      return WEBKIT + value + MS + value + value;
	    // order

	    case 6165:
	      return WEBKIT + value + MS + 'flex-' + value + value;
	    // align-items

	    case 5187:
	      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value;
	    // align-self

	    case 5443:
	      return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/, '') + value;
	    // align-content

	    case 4675:
	      return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/, '') + value;
	    // flex-shrink

	    case 5548:
	      return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value;
	    // flex-basis

	    case 5292:
	      return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value;
	    // flex-grow

	    case 6060:
	      return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value;
	    // transition

	    case 4554:
	      return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value;
	    // cursor

	    case 6187:
	      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value;
	    // background, background-image

	    case 5495:
	    case 3959:
	      return replace(value, /(image-set\([^]*)/, WEBKIT + '$1' + '$`$1');
	    // justify-content

	    case 4968:
	      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value;
	    // (margin|padding)-inline-(start|end)

	    case 4095:
	    case 3583:
	    case 4068:
	    case 2532:
	      return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value;
	    // (min|max)?(width|height|inline-size|block-size)

	    case 8116:
	    case 7059:
	    case 5753:
	    case 5535:
	    case 5445:
	    case 5701:
	    case 4933:
	    case 4677:
	    case 5533:
	    case 5789:
	    case 5021:
	    case 4765:
	      // stretch, max-content, min-content, fill-available
	      if (strlen(value) - 1 - length > 6) switch (charat(value, length + 1)) {
	        // (m)ax-content, (m)in-content
	        case 109:
	          // -
	          if (charat(value, length + 4) !== 45) break;
	        // (f)ill-available, (f)it-content

	        case 102:
	          return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
	        // (s)tretch

	        case 115:
	          return ~indexof(value, 'stretch') ? prefix(replace(value, 'stretch', 'fill-available'), length) + value : value;
	      }
	      break;
	    // position: sticky

	    case 4949:
	      // (s)ticky?
	      if (charat(value, length + 1) !== 115) break;
	    // display: (flex|inline-flex)

	    case 6444:
	      switch (charat(value, strlen(value) - 3 - (~indexof(value, '!important') && 10))) {
	        // stic(k)y
	        case 107:
	          return replace(value, ':', ':' + WEBKIT) + value;
	        // (inline-)?fl(e)x

	        case 101:
	          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + WEBKIT + (charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value;
	      }
	      break;
	    // writing-mode

	    case 5936:
	      switch (charat(value, length + 11)) {
	        // vertical-l(r)
	        case 114:
	          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
	        // vertical-r(l)

	        case 108:
	          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
	        // horizontal(-)tb

	        case 45:
	          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
	      }
	      return WEBKIT + value + MS + value + value;
	  }
	  return value;
	}
	var prefixer = function prefixer(element, index, children, callback) {
	  if (element.length > -1) if (!element["return"]) switch (element.type) {
	    case DECLARATION:
	      element["return"] = prefix(element.value, element.length);
	      break;
	    case KEYFRAMES:
	      return serialize([copy(element, {
	        value: replace(element.value, '@', '@' + WEBKIT)
	      })], callback);
	    case RULESET:
	      if (element.length) return combine(element.props, function (value) {
	        switch (match(value, /(::plac\w+|:read-\w+)/)) {
	          // :read-(only|write)
	          case ':read-only':
	          case ':read-write':
	            return serialize([copy(element, {
	              props: [replace(value, /:(read-\w+)/, ':' + MOZ + '$1')]
	            })], callback);
	          // :placeholder

	          case '::placeholder':
	            return serialize([copy(element, {
	              props: [replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1')]
	            }), copy(element, {
	              props: [replace(value, /:(plac\w+)/, ':' + MOZ + '$1')]
	            }), copy(element, {
	              props: [replace(value, /:(plac\w+)/, MS + 'input-$1')]
	            })], callback);
	        }
	        return '';
	      });
	  }
	};
	var defaultStylisPlugins = [prefixer];
	var createCache = function createCache(options) {
	  var key = options.key;
	  if (process$1.env.NODE_ENV !== 'production' && !key) {
	    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\n" + "If multiple caches share the same key they might \"fight\" for each other's style elements.");
	  }
	  if (key === 'css') {
	    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
	    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
	    // note this very very intentionally targets all style elements regardless of the key to ensure
	    // that creating a cache works inside of render of a React component

	    Array.prototype.forEach.call(ssrStyles, function (node) {
	      // we want to only move elements which have a space in the data-emotion attribute value
	      // because that indicates that it is an Emotion 11 server-side rendered style elements
	      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
	      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
	      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
	      // will not result in the Emotion 10 styles being destroyed
	      var dataEmotionAttribute = node.getAttribute('data-emotion');
	      if (dataEmotionAttribute.indexOf(' ') === -1) {
	        return;
	      }
	      document.head.appendChild(node);
	      node.setAttribute('data-s', '');
	    });
	  }
	  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
	  if (process$1.env.NODE_ENV !== 'production') {
	    // $FlowFixMe
	    if (/[^a-z-]/.test(key)) {
	      throw new Error("Emotion key must only contain lower case alphabetical characters and - but \"" + key + "\" was passed");
	    }
	  }
	  var inserted = {};
	  var container;
	  var nodesToHydrate = [];
	  {
	    container = options.container || document.head;
	    Array.prototype.forEach.call(
	    // this means we will ignore elements which don't have a space in them which
	    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
	    document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
	      var attrib = node.getAttribute("data-emotion").split(' '); // $FlowFixMe

	      for (var i = 1; i < attrib.length; i++) {
	        inserted[attrib[i]] = true;
	      }
	      nodesToHydrate.push(node);
	    });
	  }
	  var _insert;
	  var omnipresentPlugins = [compat, removeLabel];
	  if (process$1.env.NODE_ENV !== 'production') {
	    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
	      get compat() {
	        return cache.compat;
	      }
	    }), incorrectImportAlarm);
	  }
	  {
	    var currentSheet;
	    var finalizingPlugins = [stringify, process$1.env.NODE_ENV !== 'production' ? function (element) {
	      if (!element.root) {
	        if (element["return"]) {
	          currentSheet.insert(element["return"]);
	        } else if (element.value && element.type !== COMMENT) {
	          // insert empty rule in non-production environments
	          // so @emotion/jest can grab `key` from the (JS)DOM for caches without any rules inserted yet
	          currentSheet.insert(element.value + "{}");
	        }
	      }
	    } : rulesheet(function (rule) {
	      currentSheet.insert(rule);
	    })];
	    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
	    var stylis = function stylis(styles) {
	      return serialize(compile(styles), serializer);
	    };
	    _insert = function insert(selector, serialized, sheet, shouldCache) {
	      currentSheet = sheet;
	      if (process$1.env.NODE_ENV !== 'production' && serialized.map !== undefined) {
	        currentSheet = {
	          insert: function insert(rule) {
	            sheet.insert(rule + serialized.map);
	          }
	        };
	      }
	      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
	      if (shouldCache) {
	        cache.inserted[serialized.name] = true;
	      }
	    };
	  }
	  var cache = {
	    key: key,
	    sheet: new StyleSheet({
	      key: key,
	      container: container,
	      nonce: options.nonce,
	      speedy: options.speedy,
	      prepend: options.prepend,
	      insertionPoint: options.insertionPoint
	    }),
	    nonce: options.nonce,
	    inserted: inserted,
	    registered: {},
	    insert: _insert
	  };
	  cache.sheet.hydrate(nodesToHydrate);
	  return cache;
	};

	var isBrowser = "object" !== 'undefined';
	function getRegisteredStyles(registered, registeredStyles, classNames) {
	  var rawClassName = '';
	  classNames.split(' ').forEach(function (className) {
	    if (registered[className] !== undefined) {
	      registeredStyles.push(registered[className] + ";");
	    } else {
	      rawClassName += className + " ";
	    }
	  });
	  return rawClassName;
	}
	var registerStyles = function registerStyles(cache, serialized, isStringTag) {
	  var className = cache.key + "-" + serialized.name;
	  if (
	  // we only need to add the styles to the registered cache if the
	  // class name could be used further down
	  // the tree but if it's a string tag, we know it won't
	  // so we don't have to add it to registered cache.
	  // this improves memory usage since we can avoid storing the whole style string
	  (isStringTag === false ||
	  // we need to always store it if we're in compat mode and
	  // in node since emotion-server relies on whether a style is in
	  // the registered cache to know whether a style is global or not
	  // also, note that this check will be dead code eliminated in the browser
	  isBrowser === false) && cache.registered[className] === undefined) {
	    cache.registered[className] = serialized.styles;
	  }
	};
	var insertStyles = function insertStyles(cache, serialized, isStringTag) {
	  registerStyles(cache, serialized, isStringTag);
	  var className = cache.key + "-" + serialized.name;
	  if (cache.inserted[serialized.name] === undefined) {
	    var current = serialized;
	    do {
	      cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);
	      current = current.next;
	    } while (current !== undefined);
	  }
	};

	/* eslint-disable */
	// Inspired by https://github.com/garycourt/murmurhash-js
	// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
	function murmur2(str) {
	  // 'm' and 'r' are mixing constants generated offline.
	  // They're not really 'magic', they just happen to work well.
	  // const m = 0x5bd1e995;
	  // const r = 24;
	  // Initialize the hash
	  var h = 0; // Mix 4 bytes at a time into the hash

	  var k,
	    i = 0,
	    len = str.length;
	  for (; len >= 4; ++i, len -= 4) {
	    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
	    k = /* Math.imul(k, m): */
	    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
	    k ^= /* k >>> r: */
	    k >>> 24;
	    h = /* Math.imul(k, m): */
	    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^ /* Math.imul(h, m): */
	    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
	  } // Handle the last few bytes of the input array

	  switch (len) {
	    case 3:
	      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
	    case 2:
	      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
	    case 1:
	      h ^= str.charCodeAt(i) & 0xff;
	      h = /* Math.imul(h, m): */
	      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
	  } // Do a few final mixes of the hash to ensure the last few
	  // bytes are well-incorporated.

	  h ^= h >>> 13;
	  h = /* Math.imul(h, m): */
	  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
	  return ((h ^ h >>> 15) >>> 0).toString(36);
	}

	var unitlessKeys = {
	  animationIterationCount: 1,
	  aspectRatio: 1,
	  borderImageOutset: 1,
	  borderImageSlice: 1,
	  borderImageWidth: 1,
	  boxFlex: 1,
	  boxFlexGroup: 1,
	  boxOrdinalGroup: 1,
	  columnCount: 1,
	  columns: 1,
	  flex: 1,
	  flexGrow: 1,
	  flexPositive: 1,
	  flexShrink: 1,
	  flexNegative: 1,
	  flexOrder: 1,
	  gridRow: 1,
	  gridRowEnd: 1,
	  gridRowSpan: 1,
	  gridRowStart: 1,
	  gridColumn: 1,
	  gridColumnEnd: 1,
	  gridColumnSpan: 1,
	  gridColumnStart: 1,
	  msGridRow: 1,
	  msGridRowSpan: 1,
	  msGridColumn: 1,
	  msGridColumnSpan: 1,
	  fontWeight: 1,
	  lineHeight: 1,
	  opacity: 1,
	  order: 1,
	  orphans: 1,
	  tabSize: 1,
	  widows: 1,
	  zIndex: 1,
	  zoom: 1,
	  WebkitLineClamp: 1,
	  // SVG-related properties
	  fillOpacity: 1,
	  floodOpacity: 1,
	  stopOpacity: 1,
	  strokeDasharray: 1,
	  strokeDashoffset: 1,
	  strokeMiterlimit: 1,
	  strokeOpacity: 1,
	  strokeWidth: 1
	};

	var ILLEGAL_ESCAPE_SEQUENCE_ERROR$1 = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
	var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
	var hyphenateRegex = /[A-Z]|^ms/g;
	var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
	var isCustomProperty = function isCustomProperty(property) {
	  return property.charCodeAt(1) === 45;
	};
	var isProcessableValue = function isProcessableValue(value) {
	  return value != null && typeof value !== 'boolean';
	};
	var processStyleName = /* #__PURE__ */memoize(function (styleName) {
	  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
	});
	var processStyleValue = function processStyleValue(key, value) {
	  switch (key) {
	    case 'animation':
	    case 'animationName':
	      {
	        if (typeof value === 'string') {
	          return value.replace(animationRegex, function (match, p1, p2) {
	            cursor = {
	              name: p1,
	              styles: p2,
	              next: cursor
	            };
	            return p1;
	          });
	        }
	      }
	  }
	  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
	    return value + 'px';
	  }
	  return value;
	};
	if (process$1.env.NODE_ENV !== 'production') {
	  var contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
	  var contentValues = ['normal', 'none', 'initial', 'inherit', 'unset'];
	  var oldProcessStyleValue = processStyleValue;
	  var msPattern = /^-ms-/;
	  var hyphenPattern = /-(.)/g;
	  var hyphenatedCache = {};
	  processStyleValue = function processStyleValue(key, value) {
	    if (key === 'content') {
	      if (typeof value !== 'string' || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
	        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
	      }
	    }
	    var processed = oldProcessStyleValue(key, value);
	    if (processed !== '' && !isCustomProperty(key) && key.indexOf('-') !== -1 && hyphenatedCache[key] === undefined) {
	      hyphenatedCache[key] = true;
	      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, 'ms-').replace(hyphenPattern, function (str, _char) {
	        return _char.toUpperCase();
	      }) + "?");
	    }
	    return processed;
	  };
	}
	var noComponentSelectorMessage = 'Component selectors can only be used in conjunction with ' + '@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware ' + 'compiler transform.';
	function handleInterpolation(mergedProps, registered, interpolation) {
	  if (interpolation == null) {
	    return '';
	  }
	  if (interpolation.__emotion_styles !== undefined) {
	    if (process$1.env.NODE_ENV !== 'production' && interpolation.toString() === 'NO_COMPONENT_SELECTOR') {
	      throw new Error(noComponentSelectorMessage);
	    }
	    return interpolation;
	  }
	  switch (_typeof(interpolation)) {
	    case 'boolean':
	      {
	        return '';
	      }
	    case 'object':
	      {
	        if (interpolation.anim === 1) {
	          cursor = {
	            name: interpolation.name,
	            styles: interpolation.styles,
	            next: cursor
	          };
	          return interpolation.name;
	        }
	        if (interpolation.styles !== undefined) {
	          var next = interpolation.next;
	          if (next !== undefined) {
	            // not the most efficient thing ever but this is a pretty rare case
	            // and there will be very few iterations of this generally
	            while (next !== undefined) {
	              cursor = {
	                name: next.name,
	                styles: next.styles,
	                next: cursor
	              };
	              next = next.next;
	            }
	          }
	          var styles = interpolation.styles + ";";
	          if (process$1.env.NODE_ENV !== 'production' && interpolation.map !== undefined) {
	            styles += interpolation.map;
	          }
	          return styles;
	        }
	        return createStringFromObject(mergedProps, registered, interpolation);
	      }
	    case 'function':
	      {
	        if (mergedProps !== undefined) {
	          var previousCursor = cursor;
	          var result = interpolation(mergedProps);
	          cursor = previousCursor;
	          return handleInterpolation(mergedProps, registered, result);
	        } else if (process$1.env.NODE_ENV !== 'production') {
	          console.error('Functions that are interpolated in css calls will be stringified.\n' + 'If you want to have a css call based on props, create a function that returns a css call like this\n' + 'let dynamicStyle = (props) => css`color: ${props.color}`\n' + 'It can be called directly with props or interpolated in a styled call like this\n' + "let SomeComponent = styled('div')`${dynamicStyle}`");
	        }
	        break;
	      }
	    case 'string':
	      if (process$1.env.NODE_ENV !== 'production') {
	        var matched = [];
	        var replaced = interpolation.replace(animationRegex, function (match, p1, p2) {
	          var fakeVarName = "animation" + matched.length;
	          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, '') + "`");
	          return "${" + fakeVarName + "}";
	        });
	        if (matched.length) {
	          console.error('`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\n' + 'Instead of doing this:\n\n' + [].concat(matched, ["`" + replaced + "`"]).join('\n') + '\n\nYou should wrap it with `css` like this:\n\n' + ("css`" + replaced + "`"));
	        }
	      }
	      break;
	  } // finalize string values (regular strings and functions interpolated into css calls)

	  if (registered == null) {
	    return interpolation;
	  }
	  var cached = registered[interpolation];
	  return cached !== undefined ? cached : interpolation;
	}
	function createStringFromObject(mergedProps, registered, obj) {
	  var string = '';
	  if (Array.isArray(obj)) {
	    for (var i = 0; i < obj.length; i++) {
	      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
	    }
	  } else {
	    for (var _key in obj) {
	      var value = obj[_key];
	      if (_typeof(value) !== 'object') {
	        if (registered != null && registered[value] !== undefined) {
	          string += _key + "{" + registered[value] + "}";
	        } else if (isProcessableValue(value)) {
	          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
	        }
	      } else {
	        if (_key === 'NO_COMPONENT_SELECTOR' && process$1.env.NODE_ENV !== 'production') {
	          throw new Error(noComponentSelectorMessage);
	        }
	        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
	          for (var _i = 0; _i < value.length; _i++) {
	            if (isProcessableValue(value[_i])) {
	              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
	            }
	          }
	        } else {
	          var interpolated = handleInterpolation(mergedProps, registered, value);
	          switch (_key) {
	            case 'animation':
	            case 'animationName':
	              {
	                string += processStyleName(_key) + ":" + interpolated + ";";
	                break;
	              }
	            default:
	              {
	                if (process$1.env.NODE_ENV !== 'production' && _key === 'undefined') {
	                  console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
	                }
	                string += _key + "{" + interpolated + "}";
	              }
	          }
	        }
	      }
	    }
	  }
	  return string;
	}
	var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
	var sourceMapPattern;
	if (process$1.env.NODE_ENV !== 'production') {
	  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
	} // this is the cursor for keyframes
	// keyframes are stored on the SerializedStyles object as a linked list

	var cursor;
	var serializeStyles = function serializeStyles(args, registered, mergedProps) {
	  if (args.length === 1 && _typeof(args[0]) === 'object' && args[0] !== null && args[0].styles !== undefined) {
	    return args[0];
	  }
	  var stringMode = true;
	  var styles = '';
	  cursor = undefined;
	  var strings = args[0];
	  if (strings == null || strings.raw === undefined) {
	    stringMode = false;
	    styles += handleInterpolation(mergedProps, registered, strings);
	  } else {
	    if (process$1.env.NODE_ENV !== 'production' && strings[0] === undefined) {
	      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$1);
	    }
	    styles += strings[0];
	  } // we start at 1 since we've already handled the first arg

	  for (var i = 1; i < args.length; i++) {
	    styles += handleInterpolation(mergedProps, registered, args[i]);
	    if (stringMode) {
	      if (process$1.env.NODE_ENV !== 'production' && strings[i] === undefined) {
	        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$1);
	      }
	      styles += strings[i];
	    }
	  }
	  var sourceMap;
	  if (process$1.env.NODE_ENV !== 'production') {
	    styles = styles.replace(sourceMapPattern, function (match) {
	      sourceMap = match;
	      return '';
	    });
	  } // using a global regex with .exec is stateful so lastIndex has to be reset each time

	  labelPattern.lastIndex = 0;
	  var identifierName = '';
	  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

	  while ((match = labelPattern.exec(styles)) !== null) {
	    identifierName += '-' +
	    // $FlowFixMe we know it's not null
	    match[1];
	  }
	  var name = murmur2(styles) + identifierName;
	  if (process$1.env.NODE_ENV !== 'production') {
	    // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)
	    return {
	      name: name,
	      styles: styles,
	      map: sourceMap,
	      next: cursor,
	      toString: function toString() {
	        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
	      }
	    };
	  }
	  return {
	    name: name,
	    styles: styles,
	    next: cursor
	  };
	};

	var syncFallback = function syncFallback(create) {
	  return create();
	};
	var useInsertionEffect = React__namespace['useInsertion' + 'Effect'] ? React__namespace['useInsertion' + 'Effect'] : false;
	var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;

	var hasOwnProperty = {}.hasOwnProperty;
	var EmotionCacheContext = /* #__PURE__ */React__namespace.createContext(
	// we're doing this to avoid preconstruct's dead code elimination in this one case
	// because this module is primarily intended for the browser and node
	// but it's also required in react native and similar environments sometimes
	// and we could have a special build just for that
	// but this is much easier and the native packages
	// might use a different theme context in the future anyway
	typeof HTMLElement !== 'undefined' ? /* #__PURE__ */createCache({
	  key: 'css'
	}) : null);
	if (process$1.env.NODE_ENV !== 'production') {
	  EmotionCacheContext.displayName = 'EmotionCacheContext';
	}
	var withEmotionCache = function withEmotionCache(func) {
	  // $FlowFixMe
	  return /*#__PURE__*/React.forwardRef(function (props, ref) {
	    // the cache will never be null in the browser
	    var cache = React.useContext(EmotionCacheContext);
	    return func(props, cache, ref);
	  });
	};
	var ThemeContext = /* #__PURE__ */React__namespace.createContext({});
	if (process$1.env.NODE_ENV !== 'production') {
	  ThemeContext.displayName = 'EmotionThemeContext';
	}
	var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
	var labelPropName = '__EMOTION_LABEL_PLEASE_DO_NOT_USE__';
	var Insertion$1 = function Insertion(_ref) {
	  var cache = _ref.cache,
	    serialized = _ref.serialized,
	    isStringTag = _ref.isStringTag;
	  registerStyles(cache, serialized, isStringTag);
	  useInsertionEffectAlwaysWithSyncFallback(function () {
	    return insertStyles(cache, serialized, isStringTag);
	  });
	  return null;
	};
	var Emotion = /* #__PURE__ */withEmotionCache(function (props, cache, ref) {
	  var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
	  // not passing the registered cache to serializeStyles because it would
	  // make certain babel optimisations not possible

	  if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
	    cssProp = cache.registered[cssProp];
	  }
	  var WrappedComponent = props[typePropName];
	  var registeredStyles = [cssProp];
	  var className = '';
	  if (typeof props.className === 'string') {
	    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
	  } else if (props.className != null) {
	    className = props.className + " ";
	  }
	  var serialized = serializeStyles(registeredStyles, undefined, React__namespace.useContext(ThemeContext));
	  if (process$1.env.NODE_ENV !== 'production' && serialized.name.indexOf('-') === -1) {
	    var labelFromStack = props[labelPropName];
	    if (labelFromStack) {
	      serialized = serializeStyles([serialized, 'label:' + labelFromStack + ';']);
	    }
	  }
	  className += cache.key + "-" + serialized.name;
	  var newProps = {};
	  for (var key in props) {
	    if (hasOwnProperty.call(props, key) && key !== 'css' && key !== typePropName && (process$1.env.NODE_ENV === 'production' || key !== labelPropName)) {
	      newProps[key] = props[key];
	    }
	  }
	  newProps.ref = ref;
	  newProps.className = className;
	  return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(Insertion$1, {
	    cache: cache,
	    serialized: serialized,
	    isStringTag: typeof WrappedComponent === 'string'
	  }), /*#__PURE__*/React__namespace.createElement(WrappedComponent, newProps));
	});
	if (process$1.env.NODE_ENV !== 'production') {
	  Emotion.displayName = 'EmotionCssPropInternal';
	}

	var testOmitPropsOnStringTag = isPropValid;
	var testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {
	  return key !== 'theme';
	};
	var getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {
	  return typeof tag === 'string' &&
	  // 96 is one less than the char code
	  // for "a" so this is checking that
	  // it's a lowercase character
	  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
	};
	var composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {
	  var shouldForwardProp;
	  if (options) {
	    var optionsShouldForwardProp = options.shouldForwardProp;
	    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function (propName) {
	      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
	    } : optionsShouldForwardProp;
	  }
	  if (typeof shouldForwardProp !== 'function' && isReal) {
	    shouldForwardProp = tag.__emotion_forwardProp;
	  }
	  return shouldForwardProp;
	};
	var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
	var Insertion = function Insertion(_ref) {
	  var cache = _ref.cache,
	    serialized = _ref.serialized,
	    isStringTag = _ref.isStringTag;
	  registerStyles(cache, serialized, isStringTag);
	  useInsertionEffectAlwaysWithSyncFallback(function () {
	    return insertStyles(cache, serialized, isStringTag);
	  });
	  return null;
	};
	var createStyled = function createStyled(tag, options) {
	  if (process$1.env.NODE_ENV !== 'production') {
	    if (tag === undefined) {
	      throw new Error('You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it.');
	    }
	  }
	  var isReal = tag.__emotion_real === tag;
	  var baseTag = isReal && tag.__emotion_base || tag;
	  var identifierName;
	  var targetClassName;
	  if (options !== undefined) {
	    identifierName = options.label;
	    targetClassName = options.target;
	  }
	  var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
	  var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
	  var shouldUseAs = !defaultShouldForwardProp('as');
	  return function () {
	    var args = arguments;
	    var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];
	    if (identifierName !== undefined) {
	      styles.push("label:" + identifierName + ";");
	    }
	    if (args[0] == null || args[0].raw === undefined) {
	      styles.push.apply(styles, args);
	    } else {
	      if (process$1.env.NODE_ENV !== 'production' && args[0][0] === undefined) {
	        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
	      }
	      styles.push(args[0][0]);
	      var len = args.length;
	      var i = 1;
	      for (; i < len; i++) {
	        if (process$1.env.NODE_ENV !== 'production' && args[0][i] === undefined) {
	          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
	        }
	        styles.push(args[i], args[0][i]);
	      }
	    } // $FlowFixMe: we need to cast StatelessFunctionalComponent to our PrivateStyledComponent class

	    var Styled = withEmotionCache(function (props, cache, ref) {
	      var FinalTag = shouldUseAs && props.as || baseTag;
	      var className = '';
	      var classInterpolations = [];
	      var mergedProps = props;
	      if (props.theme == null) {
	        mergedProps = {};
	        for (var key in props) {
	          mergedProps[key] = props[key];
	        }
	        mergedProps.theme = React__namespace.useContext(ThemeContext);
	      }
	      if (typeof props.className === 'string') {
	        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
	      } else if (props.className != null) {
	        className = props.className + " ";
	      }
	      var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
	      className += cache.key + "-" + serialized.name;
	      if (targetClassName !== undefined) {
	        className += " " + targetClassName;
	      }
	      var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
	      var newProps = {};
	      for (var _key in props) {
	        if (shouldUseAs && _key === 'as') continue;
	        if (
	        // $FlowFixMe
	        finalShouldForwardProp(_key)) {
	          newProps[_key] = props[_key];
	        }
	      }
	      newProps.className = className;
	      newProps.ref = ref;
	      return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(Insertion, {
	        cache: cache,
	        serialized: serialized,
	        isStringTag: typeof FinalTag === 'string'
	      }), /*#__PURE__*/React__namespace.createElement(FinalTag, newProps));
	    });
	    Styled.displayName = identifierName !== undefined ? identifierName : "Styled(" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + ")";
	    Styled.defaultProps = tag.defaultProps;
	    Styled.__emotion_real = Styled;
	    Styled.__emotion_base = baseTag;
	    Styled.__emotion_styles = styles;
	    Styled.__emotion_forwardProp = shouldForwardProp;
	    Object.defineProperty(Styled, 'toString', {
	      value: function value() {
	        if (targetClassName === undefined && process$1.env.NODE_ENV !== 'production') {
	          return 'NO_COMPONENT_SELECTOR';
	        } // $FlowFixMe: coerce undefined to string

	        return "." + targetClassName;
	      }
	    });
	    Styled.withComponent = function (nextTag, nextOptions) {
	      return createStyled(nextTag, _extends({}, options, nextOptions, {
	        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
	      })).apply(void 0, styles);
	    };
	    return Styled;
	  };
	};

	var tags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr',
	// SVG
	'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];
	var newStyled = /*#__PURE__*/createStyled.bind();
	tags.forEach(function (tagName) {
	  // $FlowFixMe: we can ignore this because its exposed type is defined by the CreateStyled type
	  newStyled[tagName] = newStyled(tagName);
	});

	const SEQUENCE_WRAP_LENGTH = 60;
	function getSequenceSegments(segmentType, feature, getSequence) {
	    const segments = [];
	    const { cdsLocations, strand, transcriptParts } = feature;
	    switch (segmentType) {
	        case 'genomic':
	        case 'cDNA': {
	            const [firstLocation] = transcriptParts;
	            for (const loc of firstLocation) {
	                if (segmentType === 'cDNA' && loc.type === 'intron') {
	                    continue;
	                }
	                let sequence = getSequence(loc.min, loc.max);
	                if (strand === -1) {
	                    sequence = require$$1$2.revcom(sequence);
	                }
	                const type = loc.type === 'fivePrimeUTR' || loc.type === 'threePrimeUTR'
	                    ? 'UTR'
	                    : loc.type;
	                const previousSegment = segments.at(-1);
	                if (!previousSegment) {
	                    const sequenceLines = dist$2.splitStringIntoChunks(sequence, SEQUENCE_WRAP_LENGTH);
	                    segments.push({
	                        type,
	                        sequenceLines,
	                        locs: [{ min: loc.min, max: loc.max }],
	                    });
	                    continue;
	                }
	                if (previousSegment.type === type) {
	                    const [previousSegmentFirstLine, ...previousSegmentFollowingLines] = previousSegment.sequenceLines;
	                    const newSequence = previousSegmentFollowingLines.join('') + sequence;
	                    previousSegment.sequenceLines = [
	                        previousSegmentFirstLine,
	                        ...dist$2.splitStringIntoChunks(newSequence, SEQUENCE_WRAP_LENGTH),
	                    ];
	                    previousSegment.locs.push({ min: loc.min, max: loc.max });
	                }
	                else {
	                    const count = segments.reduce((accumulator, currentSegment) => accumulator +
	                        currentSegment.sequenceLines.reduce((subAccumulator, currentLine) => subAccumulator + currentLine.length, 0), 0);
	                    const previousLineLength = count % SEQUENCE_WRAP_LENGTH;
	                    const newSegmentFirstLineLength = SEQUENCE_WRAP_LENGTH - previousLineLength;
	                    const newSegmentFirstLine = sequence.slice(0, newSegmentFirstLineLength);
	                    const newSegmentRemainderLines = dist$2.splitStringIntoChunks(sequence.slice(newSegmentFirstLineLength), SEQUENCE_WRAP_LENGTH);
	                    segments.push({
	                        type,
	                        sequenceLines: [newSegmentFirstLine, ...newSegmentRemainderLines],
	                        locs: [{ min: loc.min, max: loc.max }],
	                    });
	                }
	            }
	            return segments;
	        }
	        case 'CDS': {
	            let wholeSequence = '';
	            const [firstLocation] = cdsLocations;
	            const locs = [];
	            for (const loc of firstLocation) {
	                wholeSequence += getSequence(loc.min, loc.max);
	                locs.push({ min: loc.min, max: loc.max });
	            }
	            if (strand === -1) {
	                wholeSequence = require$$1$2.revcom(wholeSequence);
	            }
	            const sequenceLines = dist$2.splitStringIntoChunks(wholeSequence, SEQUENCE_WRAP_LENGTH);
	            segments.push({ type: 'CDS', sequenceLines, locs });
	            return segments;
	        }
	        case 'protein': {
	            let wholeSequence = '';
	            const [firstLocation] = cdsLocations;
	            const locs = [];
	            for (const loc of firstLocation) {
	                wholeSequence += getSequence(loc.min, loc.max);
	                locs.push({ min: loc.min, max: loc.max });
	            }
	            if (strand === -1) {
	                wholeSequence = require$$1$2.revcom(wholeSequence);
	            }
	            let protein = '';
	            for (let i = 0; i < wholeSequence.length; i += 3) {
	                const codonSeq = wholeSequence.slice(i, i + 3).toUpperCase();
	                protein +=
	                    require$$1$2.defaultCodonTable[codonSeq] || '&';
	            }
	            const sequenceLines = dist$2.splitStringIntoChunks(protein, SEQUENCE_WRAP_LENGTH);
	            segments.push({ type: 'protein', sequenceLines, locs });
	            return segments;
	        }
	    }
	}
	function getSegmentColor(type) {
	    switch (type) {
	        case 'upOrDownstream': {
	            return 'rgb(255,255,255)';
	        }
	        case 'exon':
	        case 'UTR': {
	            return 'rgb(194,106,119)';
	        }
	        case 'CDS': {
	            return 'rgb(93,168,153)';
	        }
	        case 'intron': {
	            return 'rgb(187,187,187)';
	        }
	        case 'protein': {
	            return 'rgb(148,203,236)';
	        }
	    }
	}
	function getLocationIntervals(seqSegments) {
	    const locIntervals = [];
	    const allLocs = seqSegments.flatMap((segment) => segment.locs);
	    let [previous] = allLocs;
	    for (let i = 1; i < allLocs.length; i++) {
	        if (previous.min === allLocs[i].max || previous.max === allLocs[i].min) {
	            previous = {
	                min: Math.min(previous.min, allLocs[i].min),
	                max: Math.max(previous.max, allLocs[i].max),
	            };
	        }
	        else {
	            locIntervals.push(previous);
	            previous = allLocs[i];
	        }
	    }
	    locIntervals.push(previous);
	    return locIntervals;
	}
	const TranscriptSequence = mobxReact.observer(function TranscriptSequence({ assembly, feature, refName, session, }) {
	    const currentAssembly = session.apolloDataStore.assemblies.get(assembly);
	    const refData = currentAssembly?.getByRefName(refName);
	    const { featureTypeOntology } = session.apolloDataStore.ontologyManager;
	    const defaultSelectedOption = 'genomic';
	    const defaultSequenceOptions = ['genomic', 'cDNA'];
	    const [sequenceOptions, setSequenceOptions] = React.useState(defaultSequenceOptions);
	    const [selectedOption, setSelectedOption] = React.useState(defaultSelectedOption);
	    const [sequenceSegments, setSequenceSegments] = React.useState(() => {
	        return refData
	            ? getSequenceSegments(defaultSelectedOption, feature, (min, max) => refData.getSequence(min, max))
	            : [];
	    });
	    const [locationIntervals, setLocationIntervals] = React.useState(() => {
	        return getLocationIntervals(sequenceSegments);
	    });
	    const theme = material.useTheme();
	    const seqRef = React.useRef(null);
	    React.useEffect(() => {
	        const { cdsLocations } = feature;
	        const [firstLocation] = cdsLocations;
	        if (firstLocation.length > 0) {
	            setSequenceOptions([...defaultSequenceOptions, 'CDS', 'protein']);
	        }
	        else {
	            setSequenceOptions(defaultSequenceOptions);
	        }
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [feature]);
	    if (!(currentAssembly && refData)) {
	        return null;
	    }
	    const refSeq = currentAssembly.getByRefName(refName);
	    if (!refSeq) {
	        return null;
	    }
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    if (!featureTypeOntology.isTypeOf(feature.type, 'transcript')) {
	        return null;
	    }
	    function handleChangeSeqOption(e) {
	        const option = e.target.value;
	        setSelectedOption(option);
	        const seqSegments = refData
	            ? getSequenceSegments(option, feature, (min, max) => refData.getSequence(min, max))
	            : [];
	        const locIntervals = getLocationIntervals(seqSegments);
	        setSequenceSegments(seqSegments);
	        setLocationIntervals(locIntervals);
	    }
	    const onCopyClick = () => {
	        const seqDiv = seqRef.current;
	        if (!seqDiv) {
	            return;
	        }
	        void copyToClipboard(seqDiv);
	    };
	    return (React__default["default"].createElement(React__default["default"].Fragment, null,
	        React__default["default"].createElement(material.Select, { defaultValue: "genomic", value: selectedOption, onChange: handleChangeSeqOption, size: "small" }, sequenceOptions.map((option) => (React__default["default"].createElement(material.MenuItem, { key: option, value: option }, option)))),
	        React__default["default"].createElement(material.Button, { variant: "contained", onClick: onCopyClick, style: { marginLeft: 10 }, size: "medium" }, "Copy sequence"),
	        React__default["default"].createElement(material.Paper, { style: {
	                fontFamily: 'monospace',
	                padding: theme.spacing(),
	                overflowX: 'auto',
	            }, ref: seqRef },
	            ">",
	            refSeq.name,
	            ":",
	            locationIntervals
	                .map((interval) => feature.strand === 1
	                ? `${interval.min + 1}-${interval.max}`
	                : `${interval.max}-${interval.min + 1}`)
	                .join(';'),
	            "(",
	            feature.strand === 1 ? '+' : '-',
	            ")",
	            React__default["default"].createElement("br", null),
	            sequenceSegments.map((segment, index) => (React__default["default"].createElement("span", { key: `${segment.type}-${index}`, style: {
	                    background: getSegmentColor(segment.type),
	                    color: theme.palette.getContrastText(getSegmentColor(segment.type)),
	                } }, segment.sequenceLines.map((sequenceLine, idx) => (React__default["default"].createElement(React__default["default"].Fragment, { key: `${sequenceLine.slice(0, 5)}-${idx}` },
	                sequenceLine,
	                idx === segment.sequenceLines.length - 1 &&
	                    sequenceLine.length !== SEQUENCE_WRAP_LENGTH ? null : (React__default["default"].createElement("br", null)))))))))));
	});

	var ContentCut = {};

	var _interopRequireDefault$6 = interopRequireDefault.exports;
	Object.defineProperty(ContentCut, "__esModule", {
	  value: true
	});
	var default_1$6 = ContentCut["default"] = void 0;
	var _createSvgIcon$6 = /*#__PURE__*/_interopRequireDefault$6(createSvgIcon);
	var _jsxRuntime$6 = require$$2__default["default"];
	var _default$6 = /*#__PURE__*/(0, _createSvgIcon$6["default"])( /*#__PURE__*/(0, _jsxRuntime$6.jsx)("path", {
	  d: "M9.64 7.64c.23-.5.36-1.05.36-1.64 0-2.21-1.79-4-4-4S2 3.79 2 6s1.79 4 4 4c.59 0 1.14-.13 1.64-.36L10 12l-2.36 2.36C7.14 14.13 6.59 14 6 14c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4c0-.59-.13-1.14-.36-1.64L12 14l7 7h3v-1L9.64 7.64zM6 8c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm0 12c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm6-7.5c-.28 0-.5-.22-.5-.5s.22-.5.5-.5.5.22.5.5-.22.5-.5.5zM19 3l-6 6 2 2 7-7V3z"
	}), 'ContentCut');
	default_1$6 = ContentCut["default"] = _default$6;

	var Remove = {};

	var _interopRequireDefault$5 = interopRequireDefault.exports;
	Object.defineProperty(Remove, "__esModule", {
	  value: true
	});
	var default_1$5 = Remove["default"] = void 0;
	var _createSvgIcon$5 = /*#__PURE__*/_interopRequireDefault$5(createSvgIcon);
	var _jsxRuntime$5 = require$$2__default["default"];
	var _default$5 = /*#__PURE__*/(0, _createSvgIcon$5["default"])( /*#__PURE__*/(0, _jsxRuntime$5.jsx)("path", {
	  d: "M19 13H5v-2h14v2z"
	}), 'Remove');
	default_1$5 = Remove["default"] = _default$5;

	const StyledTextField = newStyled(NumberTextField)(() => ({
	    '&.MuiFormControl-root': {
	        marginTop: 0,
	        marginBottom: 0,
	        width: '100%',
	    },
	    '& .MuiInputBase-input': {
	        fontSize: 12,
	        height: 20,
	        padding: 1,
	        paddingLeft: 10,
	    },
	}));
	const SequenceContainer = newStyled('div')({
	    display: 'flex',
	    justifyContent: 'center',
	    alignItems: 'center',
	    textAlign: 'left',
	    width: '100%',
	    overflowWrap: 'break-word',
	    wordWrap: 'break-word',
	    wordBreak: 'break-all',
	    '& span': {
	        fontSize: 12,
	    },
	});
	const Strand = (props) => {
	    const { strand } = props;
	    return (React__default["default"].createElement("div", null, strand === 1 ? (React__default["default"].createElement(default_1$p, null)) : strand === -1 ? (React__default["default"].createElement(default_1$5, null)) : (React__default["default"].createElement(material.Typography, { component: 'span' }, "N/A"))));
	};
	const minMaxExonTranscriptLocation = (transcript, featureTypeOntology) => {
	    const { transcriptExonParts } = transcript;
	    const exonParts = transcriptExonParts
	        .filter((part) => featureTypeOntology.isTypeOf(part.type, 'exon'))
	        .sort(({ min: a }, { min: b }) => a - b);
	    const exonMin = exonParts[0]?.min;
	    const exonMax = exonParts[exonParts.length - 1]?.max;
	    return [exonMin, exonMax];
	};
	const TranscriptWidgetEditLocation = mobxReact.observer(function TranscriptWidgetEditLocation({ assembly, feature, refName, session, }) {
	    const { notify } = session;
	    const currentAssembly = session.apolloDataStore.assemblies.get(assembly);
	    const refData = currentAssembly?.getByRefName(refName);
	    const { changeManager } = session.apolloDataStore;
	    const seqRef = React.useRef(null);
	    if (!refData) {
	        return null;
	    }
	    const { apolloDataStore } = session;
	    const { featureTypeOntology } = apolloDataStore.ontologyManager;
	    if (!featureTypeOntology.isTypeOf(feature.type, 'transcript') &&
	        !featureTypeOntology.isTypeOf(feature.type, 'pseudogenic_transcript')) {
	        throw new Error('Feature is not a transcript or equivalent');
	    }
	    const { cdsLocations, transcriptExonParts, strand } = feature;
	    const [firstCDSLocation] = cdsLocations;
	    const [exonMin, exonMax] = minMaxExonTranscriptLocation(feature, featureTypeOntology);
	    let cdsMin = exonMin;
	    let cdsMax = exonMax;
	    const cdsPresent = firstCDSLocation.length > 0;
	    if (cdsPresent) {
	        const sortedCDSLocations = firstCDSLocation.toSorted(({ min: a }, { min: b }) => a - b);
	        cdsMin = sortedCDSLocations[0].min;
	        cdsMax = sortedCDSLocations[sortedCDSLocations.length - 1].max;
	    }
	    function handleCDSLocationChange(oldLocation, newLocation, feature, isMin) {
	        if (!feature.children) {
	            throw new Error('Transcript should have child features');
	        }
	        const overlappingExon = getOverlappingExonForCDS(feature, featureTypeOntology, oldLocation, isMin);
	        if (!overlappingExon) {
	            notify('No matching exon found', 'error');
	            return;
	        }
	        const oldExonLocation = isMin ? overlappingExon.min : overlappingExon.max;
	        const { prevExon, nextExon } = getNeighboringExonParts(feature, featureTypeOntology, oldExonLocation, isMin);
	        // Start location should be less than end location
	        if (isMin && newLocation >= overlappingExon.max) {
	            notify('Start location should be less than overlapping exon end location', 'error');
	            return;
	        }
	        // End location should be greater than start location
	        if (!isMin && newLocation <= overlappingExon.min) {
	            notify('End location should be greater than overlapping exon start location', 'error');
	            return;
	        }
	        // Changed location should be greater than end location of previous exon - give 2bp buffer
	        if (prevExon && prevExon.max + 2 > newLocation) {
	            notify('Start location should be greater than previous exon end location', 'error');
	            return;
	        }
	        // Changed location should be less than start location of next exon
	        if (nextExon && nextExon.min - 2 < newLocation) {
	            notify('End location should be less than next exon start location', 'error');
	            return;
	        }
	        const cdsFeature = getMatchingCDSFeature(feature, featureTypeOntology, oldLocation, isMin);
	        if (!cdsFeature) {
	            notify('No matching CDS feature found', 'error');
	            return;
	        }
	        if (!isMin && newLocation <= cdsFeature.min) {
	            notify('End location should be greater than CDS start location', 'error');
	            return;
	        }
	        if (isMin && newLocation >= cdsFeature.max) {
	            notify('Start location should be less than CDS end location', 'error');
	            return;
	        }
	        const overlappingExonFeature = getExonFeature(feature, overlappingExon.min, overlappingExon.max, featureTypeOntology);
	        if (!overlappingExonFeature) {
	            notify('No matching exon feature found', 'error');
	            return;
	        }
	        if (isMin && newLocation !== cdsFeature.min) {
	            const startChange = new dist$2.LocationStartChange({
	                typeName: 'LocationStartChange',
	                changedIds: [],
	                changes: [],
	                assembly,
	            });
	            if (newLocation < overlappingExon.min) {
	                if (prevExon) {
	                    // update exon start location
	                    appendStartLocationChange(overlappingExonFeature, startChange, newLocation);
	                    // update CDS start location
	                    appendStartLocationChange(cdsFeature, startChange, newLocation);
	                }
	                else {
	                    const transcriptStart = feature.min;
	                    const gene = feature.parent;
	                    if (newLocation < transcriptStart) {
	                        if (gene && newLocation < gene.min) {
	                            // update gene start location
	                            appendStartLocationChange(gene, startChange, newLocation);
	                        }
	                        // update transcript start location
	                        appendStartLocationChange(feature, startChange, newLocation);
	                        // update exon start location
	                        appendStartLocationChange(overlappingExonFeature, startChange, newLocation);
	                        // update CDS start location
	                        appendStartLocationChange(cdsFeature, startChange, newLocation);
	                    }
	                }
	            }
	            else {
	                // update CDS start location
	                appendStartLocationChange(cdsFeature, startChange, newLocation);
	            }
	            void changeManager.submit(startChange).catch(() => {
	                notify('Error updating feature CDS start position', 'error');
	            });
	        }
	        if (!isMin && newLocation !== cdsFeature.max) {
	            const endChange = new dist$2.LocationEndChange({
	                typeName: 'LocationEndChange',
	                changedIds: [],
	                changes: [],
	                assembly,
	            });
	            if (newLocation > overlappingExon.max) {
	                if (nextExon) {
	                    // update exon end location
	                    appendEndLocationChange(overlappingExonFeature, endChange, newLocation);
	                    // update CDS end location
	                    appendEndLocationChange(cdsFeature, endChange, newLocation);
	                }
	                else {
	                    const transcriptEnd = feature.max;
	                    const gene = feature.parent;
	                    if (newLocation > transcriptEnd) {
	                        if (gene && newLocation > gene.max) {
	                            // update gene end location
	                            appendEndLocationChange(gene, endChange, newLocation);
	                        }
	                        // update transcript end location
	                        appendEndLocationChange(feature, endChange, newLocation);
	                        // update exon end location
	                        appendEndLocationChange(overlappingExonFeature, endChange, newLocation);
	                        // update CDS end location
	                        appendEndLocationChange(cdsFeature, endChange, newLocation);
	                    }
	                }
	            }
	            else {
	                // update CDS end location
	                appendEndLocationChange(cdsFeature, endChange, newLocation);
	            }
	            void changeManager.submit(endChange).catch(() => {
	                notify('Error updating feature CDS end position', 'error');
	            });
	        }
	    }
	    const updateCDSLocation = (oldLocation, newLocation, feature, isMin, onComplete) => {
	        if (!feature.children) {
	            throw new Error('Transcript should have child features');
	        }
	        if (oldLocation === newLocation) {
	            return;
	        }
	        const cdsFeature = getMatchingCDSFeature(feature, featureTypeOntology, oldLocation, isMin);
	        if (!cdsFeature) {
	            notify('No matching CDS feature found', 'error');
	            return;
	        }
	        const change = isMin
	            ? new dist$2.LocationStartChange({
	                typeName: 'LocationStartChange',
	                changedIds: [cdsFeature._id],
	                featureId: cdsFeature._id,
	                oldStart: cdsFeature.min,
	                newStart: newLocation,
	                assembly,
	            })
	            : new dist$2.LocationEndChange({
	                typeName: 'LocationEndChange',
	                changedIds: [cdsFeature._id],
	                featureId: cdsFeature._id,
	                oldEnd: cdsFeature.max,
	                newEnd: newLocation,
	                assembly,
	            });
	        void changeManager
	            .submit(change)
	            .then(() => {
	            if (onComplete) {
	                onComplete();
	            }
	        })
	            .catch(() => {
	            notify('Error updating feature CDS position', 'error');
	        });
	    };
	    function handleExonLocationChange(oldLocation, newLocation, feature, isMin) {
	        if (!feature.children) {
	            throw new Error('Transcript should have child features');
	        }
	        const { matchingExon, prevExon, nextExon } = getNeighboringExonParts(feature, featureTypeOntology, oldLocation, isMin);
	        if (!matchingExon) {
	            notify('No matching exon found', 'error');
	            return;
	        }
	        // Start location should be less than end location
	        if (isMin && newLocation >= matchingExon.max) {
	            notify(`Start location should be less than end location`, 'error');
	            return;
	        }
	        // End location should be greater than start location
	        if (!isMin && newLocation <= matchingExon.min) {
	            notify(`End location should be greater than start location`, 'error');
	            return;
	        }
	        // Changed location should be greater than end location of previous exon - give 2bp buffer
	        if (prevExon && prevExon.max + 2 > newLocation) {
	            notify(`Error while changing start location`, 'error');
	            return;
	        }
	        // Changed location should be less than start location of next exon - give 2bp buffer
	        if (nextExon && nextExon.min - 2 < newLocation) {
	            notify(`Error while changing end location`, 'error');
	            return;
	        }
	        const exonFeature = getExonFeature(feature, matchingExon.min, matchingExon.max, featureTypeOntology);
	        if (!exonFeature) {
	            notify('No matching exon feature found', 'error');
	            return;
	        }
	        const cdsFeature = getFirstCDSFeature(feature, featureTypeOntology);
	        // START LOCATION CHANGE
	        if (isMin && newLocation !== matchingExon.min) {
	            const startChange = new dist$2.LocationStartChange({
	                typeName: 'LocationStartChange',
	                changedIds: [],
	                changes: [],
	                assembly,
	            });
	            if (prevExon) {
	                // update exon start location
	                appendStartLocationChange(exonFeature, startChange, newLocation);
	            }
	            else {
	                const transcriptStart = feature.min;
	                const gene = feature.parent;
	                if (newLocation < transcriptStart) {
	                    if (gene && newLocation < gene.min) {
	                        // update gene start location
	                        appendStartLocationChange(gene, startChange, newLocation);
	                    }
	                    // update transcript start location
	                    appendStartLocationChange(feature, startChange, newLocation);
	                    // update exon start location
	                    appendStartLocationChange(exonFeature, startChange, newLocation);
	                }
	                else if (newLocation > transcriptStart) {
	                    // update exon start location
	                    appendStartLocationChange(exonFeature, startChange, newLocation);
	                    // update transcript start location
	                    appendStartLocationChange(feature, startChange, newLocation);
	                    if (gene) {
	                        const [geneMinWithNewLoc] = geneMinMaxWithNewLocation(gene, feature, newLocation, featureTypeOntology, isMin);
	                        if (gene.min != geneMinWithNewLoc) {
	                            // update gene start location
	                            appendStartLocationChange(gene, startChange, geneMinWithNewLoc);
	                        }
	                    }
	                }
	            }
	            // When we change the start location of the exon overlapping with start location of the CDS
	            // and the new start location is greater than the CDS start location then we need to update the CDS start location
	            if (cdsFeature &&
	                cdsFeature.min >= matchingExon.min &&
	                cdsFeature.min <= matchingExon.max &&
	                newLocation > cdsFeature.min) {
	                // update CDS start location
	                appendStartLocationChange(cdsFeature, startChange, newLocation);
	            }
	            void changeManager.submit(startChange).catch(() => {
	                notify('Error updating feature exon start position', 'error');
	            });
	        }
	        // END LOCATION CHANGE
	        if (!isMin && newLocation !== matchingExon.max) {
	            const endChange = new dist$2.LocationEndChange({
	                typeName: 'LocationEndChange',
	                changedIds: [],
	                changes: [],
	                assembly,
	            });
	            if (nextExon) {
	                // update exon end location
	                appendEndLocationChange(exonFeature, endChange, newLocation);
	            }
	            else {
	                const transcriptEnd = feature.max;
	                const gene = feature.parent;
	                if (newLocation > transcriptEnd) {
	                    if (gene && newLocation > gene.max) {
	                        // update gene end location
	                        appendEndLocationChange(gene, endChange, newLocation);
	                    }
	                    // update transcript end location
	                    appendEndLocationChange(feature, endChange, newLocation);
	                    // update exon end location
	                    appendEndLocationChange(exonFeature, endChange, newLocation);
	                }
	                else if (newLocation < transcriptEnd) {
	                    // update exon end location
	                    appendEndLocationChange(exonFeature, endChange, newLocation);
	                    // update transcript end location
	                    appendEndLocationChange(feature, endChange, newLocation);
	                    if (gene) {
	                        const [, geneMaxWithNewLoc] = geneMinMaxWithNewLocation(gene, feature, newLocation, featureTypeOntology, isMin);
	                        if (gene.max != geneMaxWithNewLoc) {
	                            // update gene end location
	                            appendEndLocationChange(gene, endChange, geneMaxWithNewLoc);
	                        }
	                    }
	                }
	            }
	            // When we change the end location of the exon overlapping with end location of the CDS
	            // and the new end location is less than the CDS end location then we need to update the CDS end location
	            if (cdsFeature &&
	                cdsFeature.max >= matchingExon.min &&
	                cdsFeature.max <= matchingExon.max &&
	                newLocation < cdsFeature.max) {
	                // update CDS end location
	                appendEndLocationChange(cdsFeature, endChange, newLocation);
	            }
	            void changeManager.submit(endChange).catch(() => {
	                notify('Error updating feature exon end position', 'error');
	            });
	        }
	    }
	    const appendEndLocationChange = (feature, change, newLocation) => {
	        change.changedIds.push(feature._id);
	        change.changes.push({
	            featureId: feature._id,
	            oldEnd: feature.max,
	            newEnd: newLocation,
	        });
	    };
	    const appendStartLocationChange = (feature, change, newLocation) => {
	        change.changedIds.push(feature._id);
	        change.changes.push({
	            featureId: feature._id,
	            oldStart: feature.min,
	            newStart: newLocation,
	        });
	    };
	    const getMatchingCDSFeature = (feature, featureTypeOntology, oldCDSLocation, isMin) => {
	        let cdsFeature;
	        for (const [, child] of feature.children ?? []) {
	            if (!featureTypeOntology.isTypeOf(child.type, 'CDS')) {
	                continue;
	            }
	            if (isMin && oldCDSLocation === child.min) {
	                cdsFeature = child;
	                break;
	            }
	            if (!isMin && oldCDSLocation === child.max) {
	                cdsFeature = child;
	                break;
	            }
	        }
	        return cdsFeature;
	    };
	    const getFirstCDSFeature = (feature, featureTypeOntology) => {
	        let cdsFeature;
	        for (const [, child] of feature.children ?? []) {
	            if (!featureTypeOntology.isTypeOf(child.type, 'CDS')) {
	                continue;
	            }
	            cdsFeature = child;
	            break;
	        }
	        return cdsFeature;
	    };
	    const getExonFeature = (feature, exonMin, exonMax, featureTypeOntology) => {
	        let exonFeature;
	        for (const [, child] of feature.children ?? []) {
	            if (!featureTypeOntology.isTypeOf(child.type, 'exon')) {
	                continue;
	            }
	            if (exonMin === child.min && exonMax === child.max) {
	                exonFeature = child;
	                break;
	            }
	        }
	        return exonFeature;
	    };
	    const geneMinMaxWithNewLocation = (gene, transcript, newLocation, featureTypeOntology, isMin) => {
	        const mins = [];
	        const maxs = [];
	        for (const [, t] of gene.children?.entries() ?? []) {
	            if (!featureTypeOntology.isTypeOf(t.type, 'transcript')) {
	                continue;
	            }
	            if (t._id === transcript._id) {
	                if (isMin) {
	                    mins.push(newLocation);
	                    maxs.push(t.max);
	                }
	                else {
	                    maxs.push(newLocation);
	                    mins.push(t.min);
	                }
	            }
	            else {
	                mins.push(t.min);
	                maxs.push(t.max);
	            }
	        }
	        const newMin = Math.min(...mins);
	        const newMax = Math.max(...maxs);
	        return [newMin, newMax];
	    };
	    const getOverlappingExonForCDS = (transcript, featureTypeOntology, oldCDSLocation, isMin) => {
	        const { transcriptExonParts } = transcript;
	        let overlappingExonPart;
	        for (const [, exonPart] of transcriptExonParts.entries()) {
	            if (!featureTypeOntology.isTypeOf(exonPart.type, 'exon')) {
	                continue;
	            }
	            if (!isMin &&
	                oldCDSLocation >= exonPart.min &&
	                oldCDSLocation <= exonPart.max) {
	                overlappingExonPart = exonPart;
	                break;
	            }
	            if (isMin &&
	                oldCDSLocation >= exonPart.min &&
	                oldCDSLocation <= exonPart.max) {
	                overlappingExonPart = exonPart;
	                break;
	            }
	        }
	        return overlappingExonPart;
	    };
	    const getNeighboringExonParts = (transcript, featureTypeOntology, oldExonLoc, isMin) => {
	        const { transcriptExonParts, strand } = transcript;
	        let matchingExon, matchingExonIdx, prevExon, nextExon;
	        for (const [i, exonPart] of transcriptExonParts.entries()) {
	            if (!featureTypeOntology.isTypeOf(exonPart.type, 'exon')) {
	                continue;
	            }
	            if (isMin && exonPart.min === oldExonLoc) {
	                matchingExon = exonPart;
	                matchingExonIdx = i;
	                break;
	            }
	            if (!isMin && exonPart.max === oldExonLoc) {
	                matchingExon = exonPart;
	                matchingExonIdx = i;
	                break;
	            }
	        }
	        if (matchingExon && matchingExonIdx !== undefined) {
	            if (strand === 1 && matchingExonIdx > 0) {
	                for (let i = matchingExonIdx - 1; i >= 0; i--) {
	                    const prevLoc = transcriptExonParts[i];
	                    if (featureTypeOntology.isTypeOf(prevLoc.type, 'exon')) {
	                        prevExon = prevLoc;
	                        break;
	                    }
	                }
	            }
	            if (strand === -1 && matchingExonIdx < transcriptExonParts.length - 1) {
	                for (let i = matchingExonIdx + 1; i < transcriptExonParts.length; i++) {
	                    const prevLoc = transcriptExonParts[i];
	                    if (featureTypeOntology.isTypeOf(prevLoc.type, 'exon')) {
	                        prevExon = prevLoc;
	                        break;
	                    }
	                }
	            }
	            if (strand === 1 && matchingExonIdx < transcriptExonParts.length - 1) {
	                for (let i = matchingExonIdx + 1; i < transcriptExonParts.length; i++) {
	                    const nextLoc = transcriptExonParts[i];
	                    if (featureTypeOntology.isTypeOf(nextLoc.type, 'exon')) {
	                        nextExon = nextLoc;
	                        break;
	                    }
	                }
	            }
	            if (strand === -1 && matchingExonIdx > 0) {
	                for (let i = matchingExonIdx - 1; i >= 0; i--) {
	                    const nextLoc = transcriptExonParts[i];
	                    if (featureTypeOntology.isTypeOf(nextLoc.type, 'exon')) {
	                        nextExon = nextLoc;
	                        break;
	                    }
	                }
	            }
	        }
	        return { matchingExon, prevExon, nextExon };
	    };
	    const getFivePrimeSpliceSite = (loc, prevLocIdx) => {
	        let spliceSite = '';
	        if (prevLocIdx > 0) {
	            const prevLoc = transcriptExonParts[prevLocIdx - 1];
	            if (strand === 1) {
	                if (prevLoc.type === 'intron') {
	                    spliceSite = refData.getSequence(loc.min - 2, loc.min);
	                }
	            }
	            else {
	                if (prevLoc.type === 'intron') {
	                    spliceSite = require$$1$2.revcom(refData.getSequence(loc.max, loc.max + 2));
	                }
	            }
	        }
	        return [
	            {
	                spliceSite,
	                color: spliceSite === 'AG' ? 'green' : 'red',
	            },
	        ];
	    };
	    const getThreePrimeSpliceSite = (loc, nextLocIdx) => {
	        let spliceSite = '';
	        if (nextLocIdx < transcriptExonParts.length - 1) {
	            const nextLoc = transcriptExonParts[nextLocIdx + 1];
	            if (strand === 1) {
	                if (nextLoc.type === 'intron') {
	                    spliceSite = refData.getSequence(loc.max, loc.max + 2);
	                }
	            }
	            else {
	                if (nextLoc.type === 'intron') {
	                    spliceSite = require$$1$2.revcom(refData.getSequence(loc.min - 2, loc.min));
	                }
	            }
	        }
	        return [
	            {
	                spliceSite,
	                color: spliceSite === 'GT' ? 'green' : 'red',
	            },
	        ];
	    };
	    const getTranslationSequence = () => {
	        let wholeSequence = '';
	        const [firstLocation] = cdsLocations;
	        const sortedCDSLocations = firstLocation.toSorted(({ min: a }, { min: b }) => a - b);
	        for (const loc of sortedCDSLocations) {
	            wholeSequence += refData.getSequence(loc.min, loc.max);
	        }
	        if (strand === -1) {
	            // Original: ACGCAT
	            // Complement: TGCGTA
	            // Reverse complement: ATGCGT
	            wholeSequence = require$$1$2.revcom(wholeSequence);
	        }
	        const elements = [];
	        for (let codonGenomicPos = 0; codonGenomicPos < wholeSequence.length; codonGenomicPos += 3) {
	            const codonSeq = wholeSequence
	                .slice(codonGenomicPos, codonGenomicPos + 3)
	                .toUpperCase();
	            const protein = require$$1$2.defaultCodonTable[codonSeq] || '&';
	            // highlight start codon and stop codons
	            if (codonSeq === 'ATG') {
	                elements.push(React__default["default"].createElement(material.Typography, { component: 'span', style: {
	                        backgroundColor: 'yellow',
	                        cursor: 'pointer',
	                        border: '1px solid black',
	                    }, key: codonGenomicPos, onClick: () => {
	                        // NOTE: codonGenomicPos is important here for calculating the genomic location
	                        // of the start codon. We are using the codonGenomicPos as the key in the typography
	                        // elements to maintain the genomic postion of the codon start
	                        const startCodonGenomicLocation = getCodonGenomicLocation(codonGenomicPos);
	                        if (startCodonGenomicLocation !== cdsMin && strand === 1) {
	                            updateCDSLocation(cdsMin, startCodonGenomicLocation, feature, true);
	                        }
	                        if (startCodonGenomicLocation !== cdsMax && strand === -1) {
	                            updateCDSLocation(cdsMax, startCodonGenomicLocation, feature, false);
	                        }
	                    } }, protein));
	            }
	            else if (['TAA', 'TAG', 'TGA'].includes(codonSeq)) {
	                elements.push(React__default["default"].createElement(material.Typography, { style: { backgroundColor: 'red', color: 'white' }, component: 'span', 
	                    // Pass the codonGenomicPos as the key to maintain the genomic position of the codon
	                    key: codonGenomicPos }, protein));
	            }
	            else {
	                elements.push(
	                // Pass the codonGenomicPos as the key to maintain the genomic position of the codon
	                React__default["default"].createElement(material.Typography, { component: 'span', key: codonGenomicPos }, protein));
	            }
	        }
	        return elements;
	    };
	    // Codon position is the index of the start codon in the CDS genomic sequence
	    // Calculate the genomic location of the start codon based on the codon position in the CDS
	    const getCodonGenomicLocation = (codonGenomicPosition) => {
	        const [firstLocation] = cdsLocations;
	        let cdsLen = 0;
	        const sortedCDSLocations = firstLocation.toSorted(({ min: a }, { min: b }) => a - b);
	        // Suppose CDS locations are [{min: 0, max: 10}, {min: 20, max: 30}, {min: 40, max: 50}]
	        // and codonGenomicPosition is 25
	        // ((10 - 0) + (30 - 20) + (50 - 40)) > 25
	        // So, start codon is in (40, 50)
	        // 40 + (25-20) = 45 is the genomic location of the start codon
	        if (strand === 1) {
	            for (const loc of sortedCDSLocations) {
	                const locLength = loc.max - loc.min;
	                if (cdsLen + locLength > codonGenomicPosition) {
	                    return loc.min + (codonGenomicPosition - cdsLen);
	                }
	                cdsLen += locLength;
	            }
	        }
	        else if (strand === -1) {
	            for (let i = sortedCDSLocations.length - 1; i >= 0; i--) {
	                const loc = sortedCDSLocations[i];
	                const locLength = loc.max - loc.min;
	                if (cdsLen + locLength > codonGenomicPosition) {
	                    return loc.max - (codonGenomicPosition - cdsLen);
	                }
	                cdsLen += locLength;
	            }
	        }
	        if (strand === 1) {
	            return cdsMin;
	        }
	        return cdsMax;
	    };
	    const trimTranslationSequence = () => {
	        const sequenceElements = getTranslationSequence();
	        const translationSequence = sequenceElements
	            .map((el) => el.props.children)
	            .join('');
	        if (translationSequence.startsWith('M') &&
	            translationSequence.endsWith('*')) {
	            return;
	        }
	        // NOTE: We are maintaining the genomic location of the codon start as the "key"
	        // in typography elements. See getTranslationSequence function
	        const translSeqCodonStartGenomicPosArr = [];
	        for (const el of sequenceElements) {
	            translSeqCodonStartGenomicPosArr.push({
	                codonGenomicPos: el.key,
	                sequenceLetter: el.props.children,
	            });
	        }
	        if (translSeqCodonStartGenomicPosArr.length === 0) {
	            return;
	        }
	        // Trim any sequence before first start codon and after stop codon
	        const startCodonIndex = translationSequence.indexOf('M');
	        const stopCodonIndex = translationSequence.indexOf('*') + 1;
	        const startCodonPos = translSeqCodonStartGenomicPosArr[startCodonIndex].codonGenomicPos;
	        const stopCodonPos = translSeqCodonStartGenomicPosArr[stopCodonIndex].codonGenomicPos;
	        if (!startCodonPos || !stopCodonPos) {
	            return;
	        }
	        const startCodonGenomicLoc = getCodonGenomicLocation(startCodonPos);
	        const stopCodonGenomicLoc = getCodonGenomicLocation(stopCodonPos);
	        if (strand === 1) {
	            if (startCodonGenomicLoc > stopCodonGenomicLoc) {
	                notify('Start codon genomic location should be less than stop codon genomic location', 'error');
	                return;
	            }
	            let promise;
	            if (startCodonGenomicLoc !== cdsMin) {
	                promise = new Promise((resolve) => {
	                    updateCDSLocation(cdsMin, startCodonGenomicLoc, feature, true, () => {
	                        resolve(true);
	                    });
	                });
	            }
	            if (stopCodonGenomicLoc !== cdsMax) {
	                if (promise) {
	                    void promise.then(() => {
	                        updateCDSLocation(cdsMax, stopCodonGenomicLoc, feature, false);
	                    });
	                }
	                else {
	                    updateCDSLocation(cdsMax, stopCodonGenomicLoc, feature, false);
	                }
	            }
	        }
	        if (strand === -1) {
	            // reverse strand
	            if (startCodonGenomicLoc < stopCodonGenomicLoc) {
	                notify('Start codon genomic location should be less than stop codon genomic location', 'error');
	                return;
	            }
	            let promise;
	            if (startCodonGenomicLoc !== cdsMax) {
	                promise = new Promise((resolve) => {
	                    updateCDSLocation(cdsMax, startCodonGenomicLoc, feature, false, () => {
	                        resolve(true);
	                    });
	                });
	            }
	            if (stopCodonGenomicLoc !== cdsMin) {
	                if (promise) {
	                    void promise.then(() => {
	                        updateCDSLocation(cdsMin, stopCodonGenomicLoc, feature, true);
	                    });
	                }
	                else {
	                    updateCDSLocation(cdsMin, stopCodonGenomicLoc, feature, true);
	                }
	            }
	        }
	        notify('Translation sequence trimmed to start and stop codons', 'success');
	    };
	    const onCopyClick = () => {
	        const seqDiv = seqRef.current;
	        if (!seqDiv) {
	            return;
	        }
	        void copyToClipboard(seqDiv);
	    };
	    return (React__default["default"].createElement("div", null,
	        cdsPresent && (React__default["default"].createElement("div", null,
	            React__default["default"].createElement(material.Accordion, null,
	                React__default["default"].createElement(StyledAccordionSummary, { expandIcon: React__default["default"].createElement(default_1$a, { style: { color: 'white' } }), "aria-controls": "panel1-content", id: "panel1-header" },
	                    React__default["default"].createElement(material.Typography, { component: "span", fontWeight: 'bold' }, "Translation")),
	                React__default["default"].createElement(material.AccordionDetails, null,
	                    React__default["default"].createElement(SequenceContainer, null,
	                        React__default["default"].createElement(material.Typography, { component: 'span', ref: seqRef, style: { maxHeight: 120, overflowY: 'scroll' } }, getTranslationSequence())),
	                    React__default["default"].createElement("div", { style: {
	                            marginTop: 10,
	                            display: 'flex',
	                            flexDirection: 'row',
	                            alignItems: 'center',
	                            gap: 10,
	                        } },
	                        React__default["default"].createElement(material.Tooltip, { title: "Copy" },
	                            React__default["default"].createElement(default_1$i, { style: { fontSize: 15, cursor: 'pointer' }, onClick: onCopyClick })),
	                        React__default["default"].createElement(material.Tooltip, { title: "Trim" },
	                            React__default["default"].createElement(default_1$6, { style: { fontSize: 15, cursor: 'pointer' }, onClick: trimTranslationSequence }))))),
	            React__default["default"].createElement(material.Grid2, { container: true, justifyContent: "center", alignItems: "center", style: { textAlign: 'center', marginTop: 10 } },
	                React__default["default"].createElement(material.Grid2, { size: 1 }),
	                strand === 1 ? (React__default["default"].createElement(material.Grid2, { size: 4 },
	                    React__default["default"].createElement(StyledTextField, { margin: "dense", variant: "outlined", value: cdsMin + 1, onChangeCommitted: (newLocation) => {
	                            handleCDSLocationChange(cdsMin, newLocation - 1, feature, true);
	                        }, style: { border: '1px solid black', borderRadius: 5 } }))) : (React__default["default"].createElement(material.Grid2, { size: 4 },
	                    React__default["default"].createElement(StyledTextField, { margin: "dense", variant: "outlined", value: cdsMax, onChangeCommitted: (newLocation) => {
	                            handleCDSLocationChange(cdsMax, newLocation, feature, false);
	                        }, style: { border: '1px solid black', borderRadius: 5 } }))),
	                React__default["default"].createElement(material.Grid2, { size: 2 },
	                    React__default["default"].createElement(material.Typography, { component: 'span' }, "CDS")),
	                strand === 1 ? (React__default["default"].createElement(material.Grid2, { size: 4 },
	                    React__default["default"].createElement(StyledTextField, { margin: "dense", variant: "outlined", value: cdsMax, onChangeCommitted: (newLocation) => {
	                            handleCDSLocationChange(cdsMax, newLocation, feature, false);
	                        }, style: { border: '1px solid black', borderRadius: 5 } }))) : (React__default["default"].createElement(material.Grid2, { size: 4 },
	                    React__default["default"].createElement(StyledTextField, { margin: "dense", variant: "outlined", value: cdsMin + 1, onChangeCommitted: (newLocation) => {
	                            handleCDSLocationChange(cdsMin, newLocation - 1, feature, true);
	                        }, style: { border: '1px solid black', borderRadius: 5 } }))),
	                React__default["default"].createElement(material.Grid2, { size: 1 })))),
	        React__default["default"].createElement("div", { style: { marginTop: 5 } }, transcriptExonParts.map((loc, index) => {
	            return (React__default["default"].createElement("div", { key: index }, loc.type === 'exon' && (React__default["default"].createElement(material.Grid2, { container: true, justifyContent: "center", alignItems: "center", style: { textAlign: 'center' } },
	                React__default["default"].createElement(material.Grid2, { size: 1 }, index !== 0 &&
	                    getFivePrimeSpliceSite(loc, index).map((site, idx) => (React__default["default"].createElement(material.Typography, { key: idx, component: 'span', color: site.color }, site.spliceSite)))),
	                strand === 1 ? (React__default["default"].createElement(material.Grid2, { size: 4, style: { padding: 0 } },
	                    React__default["default"].createElement(StyledTextField, { margin: "dense", variant: "outlined", value: loc.min + 1, onChangeCommitted: (newLocation) => {
	                            handleExonLocationChange(loc.min, newLocation - 1, feature, true);
	                        } }))) : (React__default["default"].createElement(material.Grid2, { size: 4, style: { padding: 0 } },
	                    React__default["default"].createElement(StyledTextField, { margin: "dense", variant: "outlined", value: loc.max, onChangeCommitted: (newLocation) => {
	                            handleExonLocationChange(loc.max, newLocation, feature, false);
	                        } }))),
	                React__default["default"].createElement(material.Grid2, { size: 2 },
	                    React__default["default"].createElement(Strand, { strand: feature.strand })),
	                strand === 1 ? (React__default["default"].createElement(material.Grid2, { size: 4, style: { padding: 0 } },
	                    React__default["default"].createElement(StyledTextField, { margin: "dense", variant: "outlined", value: loc.max, onChangeCommitted: (newLocation) => {
	                            handleExonLocationChange(loc.max, newLocation, feature, false);
	                        } }))) : (React__default["default"].createElement(material.Grid2, { size: 4, style: { padding: 0 } },
	                    React__default["default"].createElement(StyledTextField, { margin: "dense", variant: "outlined", value: loc.min + 1, onChangeCommitted: (newLocation) => {
	                            handleExonLocationChange(loc.min, newLocation - 1, feature, true);
	                        } }))),
	                React__default["default"].createElement(material.Grid2, { size: 1 }, index !== transcriptExonParts.length - 1 &&
	                    getThreePrimeSpliceSite(loc, index).map((site, idx) => (React__default["default"].createElement(material.Typography, { key: idx, component: 'span', color: site.color }, site.spliceSite))))))));
	        }))));
	});

	const HeaderTableCell = newStyled(material.TableCell)(() => ({
	    fontWeight: 'bold',
	}));
	const TranscriptWidgetSummary = mobxReact.observer(function TranscriptWidgetSummary(props) {
	    const { feature } = props;
	    const name = getFeatureName$1(feature);
	    const id = getFeatureId$2(feature);
	    return (React__default["default"].createElement(material.Table, { size: "small", sx: { fontSize: '0.75rem', '& .MuiTableCell-root': { padding: '4px' } } },
	        React__default["default"].createElement(material.TableBody, null,
	            name !== '' && (React__default["default"].createElement(material.TableRow, null,
	                React__default["default"].createElement(HeaderTableCell, null, "Name"),
	                React__default["default"].createElement(material.TableCell, null, getFeatureName$1(feature)))),
	            id !== '' && (React__default["default"].createElement(material.TableRow, null,
	                React__default["default"].createElement(HeaderTableCell, null, "ID"),
	                React__default["default"].createElement(material.TableCell, null, getFeatureId$2(feature)))),
	            React__default["default"].createElement(material.TableRow, null,
	                React__default["default"].createElement(HeaderTableCell, null, "Apollo ID"),
	                React__default["default"].createElement(material.TableCell, null, feature._id)),
	            React__default["default"].createElement(material.TableRow, null,
	                React__default["default"].createElement(HeaderTableCell, null, "Type"),
	                React__default["default"].createElement(material.TableCell, null, feature.type)),
	            React__default["default"].createElement(material.TableRow, null,
	                React__default["default"].createElement(HeaderTableCell, null, "Location"),
	                React__default["default"].createElement(material.TableCell, null,
	                    props.refName,
	                    ":",
	                    feature.min,
	                    "..",
	                    feature.max)),
	            React__default["default"].createElement(material.TableRow, null,
	                React__default["default"].createElement(HeaderTableCell, null, "Strand"),
	                React__default["default"].createElement(material.TableCell, null, getStrand(feature.strand))))));
	});

	const useStyles$8 = mui.makeStyles()((theme) => ({
	    root: {
	        padding: theme.spacing(2),
	    },
	}));
	const StyledAccordionSummary = newStyled(material.AccordionSummary)(() => ({
	    minHeight: 30,
	    maxHeight: 30,
	    '&.Mui-expanded': {
	        minHeight: 30,
	        maxHeight: 30,
	    },
	}));
	function NoOpCustomComponent(_props) {
	    return null;
	}
	const ApolloTranscriptDetailsWidget = mobxReact.observer(function ApolloTranscriptDetails(props) {
	    const { classes } = useStyles$8();
	    const DEFAULT_PANELS = ['summary', 'location'];
	    const [panelState, setPanelState] = React.useState(DEFAULT_PANELS);
	    const { model } = props;
	    const { assembly, feature, refName } = model;
	    React.useEffect(() => {
	        setPanelState(DEFAULT_PANELS);
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [feature]);
	    const session = require$$1$2.getSession(model);
	    const { pluginManager } = require$$1$2.getEnv(session);
	    const apolloSession = require$$1$2.getSession(model);
	    const currentAssembly = apolloSession.apolloDataStore.assemblies.get(assembly);
	    const { internetAccounts } = require$$1$3.getRoot(session);
	    const apolloInternetAccount = internetAccounts.find((ia) => ia.type === 'ApolloInternetAccount');
	    const token = apolloInternetAccount?.retrieveToken();
	    const role = apolloInternetAccount ? apolloInternetAccount.role : 'admin';
	    const editable = ['admin', 'user'].includes(role ?? '');
	    if (!(feature && currentAssembly)) {
	        return null;
	    }
	    const refSeq = currentAssembly.getByRefName(refName);
	    if (!refSeq) {
	        return null;
	    }
	    const { max, min } = feature;
	    const sequence = refSeq.getSequence(min, max);
	    if (!sequence) {
	        void apolloSession.apolloDataStore.loadRefSeq([
	            { assemblyName: assembly, refName, start: min, end: max },
	        ]);
	    }
	    function handlePanelChange(expanded, panel) {
	        if (expanded) {
	            setPanelState([...panelState, panel]);
	        }
	        else {
	            setPanelState(panelState.filter((p) => p !== panel));
	        }
	    }
	    const CustomComponent = pluginManager.evaluateExtensionPoint('Apollo-TranscriptDetailsCustomComponent', NoOpCustomComponent, props);
	    const CustomTypesComponent = pluginManager.evaluateExtensionPoint('Apollo-TranscriptDetailsCustomTypesComponent', () => null, {
	        feature,
	        session,
	    });
	    const CustomSaveComponent = pluginManager.evaluateExtensionPoint('Apollo-TranscriptDetailsCustomSaveComponent', () => null, {
	        feature,
	        session,
	        token,
	    });
	    const CustomAttributesComponent = pluginManager.evaluateExtensionPoint('Apollo-TranscriptDetailsCustomAttributesComponent', () => null, {
	        feature,
	        session,
	    });
	    return (React__default["default"].createElement("div", { className: classes.root },
	        React__default["default"].createElement(material.Accordion, { expanded: panelState.includes('summary'), onChange: (e, expanded) => {
	                handlePanelChange(expanded, 'summary');
	            } },
	            React__default["default"].createElement(StyledAccordionSummary, { expandIcon: React__default["default"].createElement(default_1$a, { style: { color: 'white' } }), "aria-controls": "panel1-content", id: "panel1-header" },
	                React__default["default"].createElement(material.Typography, { component: "span", fontWeight: 'bold' }, "Summary")),
	            React__default["default"].createElement(material.AccordionDetails, null,
	                React__default["default"].createElement(TranscriptWidgetSummary, { feature: feature, refName: refName }))),
	        React__default["default"].createElement(CustomComponent, { session: session, feature: feature }),
	        React__default["default"].createElement(material.Accordion, { style: { marginTop: 5 }, expanded: panelState.includes('location'), onChange: (e, expanded) => {
	                handlePanelChange(expanded, 'location');
	            } },
	            React__default["default"].createElement(StyledAccordionSummary, { expandIcon: React__default["default"].createElement(default_1$a, { style: { color: 'white' } }), "aria-controls": "panel2-content", id: "panel2-header" },
	                React__default["default"].createElement(material.Typography, { component: "span", fontWeight: 'bold' }, "Location")),
	            React__default["default"].createElement(material.AccordionDetails, null,
	                React__default["default"].createElement(TranscriptWidgetEditLocation, { feature: feature, refName: refName, session: apolloSession, assembly: currentAssembly._id || '' }),
	                React__default["default"].createElement(CustomTypesComponent, { feature: feature, session: session }),
	                React__default["default"].createElement(CustomAttributesComponent, { feature: feature, session: session }))),
	        React__default["default"].createElement(material.Accordion, { style: { marginTop: 5 }, expanded: panelState.includes('attrs'), onChange: (e, expanded) => {
	                handlePanelChange(expanded, 'attrs');
	            } },
	            React__default["default"].createElement(StyledAccordionSummary, { expandIcon: React__default["default"].createElement(default_1$a, { style: { color: 'white' } }), "aria-controls": "panel3-content", id: "panel3-header" },
	                React__default["default"].createElement("div", { style: { display: 'flex', alignItems: 'center' } },
	                    React__default["default"].createElement(material.Typography, { component: "span", fontWeight: 'bold' },
	                        "Attributes",
	                        ' '),
	                    React__default["default"].createElement(material.Tooltip, { title: "Separate multiple values for the attribute with commas" },
	                        React__default["default"].createElement(default_1$o, { style: { color: 'white', fontSize: 15, marginLeft: 10 } })))),
	            React__default["default"].createElement(material.AccordionDetails, null,
	                React__default["default"].createElement(Attributes, { feature: feature, session: apolloSession, assembly: currentAssembly._id || '', editable: editable }))),
	        React__default["default"].createElement(material.Accordion, { style: { marginTop: 5 }, expanded: panelState.includes('sequence'), onChange: (e, expanded) => {
	                handlePanelChange(expanded, 'sequence');
	            } },
	            React__default["default"].createElement(StyledAccordionSummary, { expandIcon: React__default["default"].createElement(default_1$a, { style: { color: 'white' } }), "aria-controls": "panel4-content", id: "panel4-header" },
	                React__default["default"].createElement(material.Typography, { component: "span", fontWeight: 'bold' }, "Sequence")),
	            React__default["default"].createElement(material.AccordionDetails, null, panelState.includes('sequence') && (React__default["default"].createElement(TranscriptSequence, { feature: feature, session: apolloSession, assembly: currentAssembly._id || '', refName: refName })))),
	        React__default["default"].createElement(CustomSaveComponent, { feature: feature, session: session, token: token })));
	});

	const configSchema$1 = configuration.ConfigurationSchema('LinearApolloDisplay', {}, { explicitIdentifier: 'displayId', explicitlyTyped: true });

	function handleFeatureTypeChange(changeManager, feature, oldType, newType) {
	    const featureId = feature._id;
	    const change = new dist$2.TypeChange({
	        typeName: 'TypeChange',
	        changedIds: [featureId],
	        featureId,
	        oldType: String(oldType),
	        newType: String(newType),
	        assembly: feature.assemblyId,
	    });
	    return changeManager.submit(change);
	}
	function handleFeatureStartChange(changeManager, feature, oldStart, newStart) {
	    const featureId = feature._id;
	    const change = new dist$2.LocationStartChange({
	        typeName: 'LocationStartChange',
	        changedIds: [featureId],
	        featureId,
	        oldStart,
	        newStart,
	        assembly: feature.assemblyId,
	    });
	    return changeManager.submit(change);
	}
	function handleFeatureEndChange(changeManager, feature, oldEnd, newEnd) {
	    const featureId = feature._id;
	    const change = new dist$2.LocationEndChange({
	        typeName: 'LocationEndChange',
	        changedIds: [featureId],
	        featureId,
	        oldEnd,
	        newEnd,
	        assembly: feature.assemblyId,
	    });
	    return changeManager.submit(change);
	}

	const useStyles$7 = mui.makeStyles()({
	    highlighted: {
	        background: 'orange',
	    },
	});
	const Highlight = ({ highlight, text, }) => {
	    const { classes } = useStyles$7();
	    if (!highlight) {
	        return React__default["default"].createElement(React__default["default"].Fragment, null, text);
	    }
	    const split = text.split(highlight);
	    if (split.length === 1) {
	        return React__default["default"].createElement(React__default["default"].Fragment, null, text);
	    }
	    const highlighted = [];
	    for (let i = 0; i < split.length - 1; i++) {
	        highlighted.push(split[i], React__default["default"].createElement("span", { className: classes.highlighted }, highlight));
	    }
	    return (React__default["default"].createElement(React__default["default"].Fragment, null,
	        highlighted,
	        split.at(-1)));
	};

	const FeatureAttributes = mobxReact.observer(function FeatureAttributes({ feature, filterText, }) {
	    const attrString = [...feature.attributes.entries()]
	        .map(([key, value]) => {
	        if (key.startsWith('gff_')) {
	            const newKey = key.slice(4);
	            const capitalizedKey = newKey.charAt(0).toUpperCase() + newKey.slice(1);
	            return [capitalizedKey, require$$1$3.getSnapshot(value)];
	        }
	        if (key === '_id') {
	            return ['ID', require$$1$3.getSnapshot(value)];
	        }
	        return [key, require$$1$3.getSnapshot(value)];
	    })
	        .filter(([key]) => key) // Leave empty keys off
	        .map(([key, values]) => `${key}=${Array.isArray(values) ? values.join(', ') : values}`)
	        .join(', ');
	    return React__default["default"].createElement(Highlight, { text: attrString, highlight: filterText });
	});

	/* eslint-disable @typescript-eslint/unbound-method */
	const useStyles$6 = mui.makeStyles()((theme) => ({
	    inputWrapper: {
	        position: 'relative',
	    },
	    hiddenWidthSpan: {
	        padding: theme.spacing(0.5),
	        color: 'transparent',
	    },
	    numberTextInput: {
	        border: 'none',
	        background: 'inherit',
	        font: 'inherit',
	        position: 'absolute',
	        width: '100%',
	        left: 0,
	    },
	}));
	const NumberCell = mobxReact.observer(function NumberCell({ initialValue, notifyError, onChangeCommitted, }) {
	    const [value, setValue] = React.useState(initialValue);
	    const [blur, setBlur] = React.useState(false);
	    const [inputNode, setInputNode] = React.useState(null);
	    const { classes } = useStyles$6();
	    React.useEffect(() => {
	        if (initialValue !== value) {
	            setValue(initialValue);
	        }
	        // eslint-disable-next-line react-hooks/exhaustive-deps
	    }, [initialValue]);
	    React.useEffect(() => {
	        if (blur) {
	            inputNode?.blur();
	            setBlur(false);
	        }
	    }, [blur, inputNode]);
	    function onChange(event) {
	        const newValue = Number(event.target.value);
	        if (!Number.isNaN(newValue)) {
	            setValue(newValue);
	        }
	    }
	    return (React__default["default"].createElement("span", { className: classes.inputWrapper },
	        React__default["default"].createElement("span", { className: classes.hiddenWidthSpan, "aria-hidden": true }, value),
	        React__default["default"].createElement("input", { type: "text", value: value, className: classes.numberTextInput, onChange: onChange, onKeyDown: (event) => {
	                if (event.key === 'Enter') {
	                    inputNode?.blur();
	                }
	                else if (event.key === 'Escape') {
	                    setValue(initialValue);
	                    setBlur(true);
	                }
	            }, onBlur: () => {
	                if (value !== initialValue) {
	                    onChangeCommitted(value).catch(notifyError);
	                }
	            }, ref: (node) => {
	                setInputNode(node);
	            } })));
	});

	function featureContextMenuItems(feature, region, getAssemblyId, selectedFeature, setSelectedFeature, session, changeManager, filteredTranscripts, updateFilteredTranscripts) {
	    const internetAccount = getApolloInternetAccount(session);
	    const role = internetAccount ? internetAccount.role : 'admin';
	    const admin = role === 'admin';
	    const readOnly = !(role && ['admin', 'user'].includes(role));
	    const menuItems = [];
	    if (feature) {
	        const featureID = feature.attributes.get('gff_id')?.toString();
	        const sourceAssemblyId = getAssemblyId(region.assemblyName);
	        const currentAssemblyId = getAssemblyId(region.assemblyName);
	        menuItems.push({
	            label: 'Edit feature details',
	            onClick: () => {
	                const apolloFeatureWidget = session.addWidget('ApolloFeatureDetailsWidget', 'apolloFeatureDetailsWidget', {
	                    feature,
	                    assembly: currentAssemblyId,
	                    refName: region.refName,
	                });
	                session.showWidget(apolloFeatureWidget);
	            },
	        }, {
	            label: 'Add child feature',
	            disabled: readOnly,
	            onClick: () => {
	                session.queueDialog((doneCallback) => [
	                    AddChildFeature,
	                    {
	                        session,
	                        handleClose: () => {
	                            doneCallback();
	                        },
	                        changeManager,
	                        sourceFeature: feature,
	                        sourceAssemblyId,
	                        internetAccount,
	                    },
	                ]);
	            },
	        }, {
	            label: 'Copy features and annotations',
	            disabled: readOnly,
	            onClick: () => {
	                session.queueDialog((doneCallback) => [
	                    CopyFeature,
	                    {
	                        session,
	                        handleClose: () => {
	                            doneCallback();
	                        },
	                        changeManager,
	                        sourceFeature: feature,
	                        sourceAssemblyId: currentAssemblyId,
	                    },
	                ]);
	            },
	        }, {
	            label: 'Delete feature',
	            disabled: !admin,
	            onClick: () => {
	                session.queueDialog((doneCallback) => [
	                    DeleteFeature,
	                    {
	                        session,
	                        handleClose: () => {
	                            doneCallback();
	                        },
	                        changeManager,
	                        sourceFeature: feature,
	                        sourceAssemblyId: currentAssemblyId,
	                        selectedFeature,
	                        setSelectedFeature,
	                    },
	                ]);
	            },
	        }, {
	            label: 'Merge transcripts',
	            disabled: !admin,
	            onClick: () => {
	                session.queueDialog((doneCallback) => [
	                    MergeTranscripts,
	                    {
	                        session,
	                        handleClose: () => {
	                            doneCallback();
	                        },
	                        changeManager,
	                        sourceFeature: feature,
	                        sourceAssemblyId: currentAssemblyId,
	                        selectedFeature,
	                        setSelectedFeature,
	                    },
	                ]);
	            },
	        }, {
	            label: 'Merge exons',
	            disabled: !admin,
	            onClick: () => {
	                session.queueDialog((doneCallback) => [
	                    MergeExons,
	                    {
	                        session,
	                        handleClose: () => {
	                            doneCallback();
	                        },
	                        changeManager,
	                        sourceFeature: feature,
	                        sourceAssemblyId: currentAssemblyId,
	                        selectedFeature,
	                        setSelectedFeature,
	                    },
	                ]);
	            },
	        }, {
	            label: 'Split exon',
	            disabled: !admin,
	            onClick: () => {
	                session.queueDialog((doneCallback) => [
	                    SplitExon,
	                    {
	                        session,
	                        handleClose: () => {
	                            doneCallback();
	                        },
	                        changeManager,
	                        sourceFeature: feature,
	                        sourceAssemblyId: currentAssemblyId,
	                        selectedFeature,
	                        setSelectedFeature,
	                    },
	                ]);
	            },
	        });
	        const { featureTypeOntology } = session.apolloDataStore.ontologyManager;
	        if (!featureTypeOntology) {
	            throw new Error('featureTypeOntology is undefined');
	        }
	        if ((featureTypeOntology.isTypeOf(feature.type, 'transcript') ||
	            featureTypeOntology.isTypeOf(feature.type, 'pseudogenic_transcript')) &&
	            require$$1$2.isSessionModelWithWidgets(session)) {
	            menuItems.push({
	                label: 'Edit transcript details',
	                onClick: () => {
	                    const apolloTranscriptWidget = session.addWidget('ApolloTranscriptDetails', 'apolloTranscriptDetails', {
	                        feature,
	                        assembly: currentAssemblyId,
	                        changeManager,
	                        refName: region.refName,
	                    });
	                    session.showWidget(apolloTranscriptWidget);
	                },
	            }, {
	                label: 'Visible',
	                type: 'checkbox',
	                checked: featureID && filteredTranscripts.includes(featureID) ? false : true,
	                onClick: () => {
	                    if (featureID) {
	                        const newForms = filteredTranscripts.includes(featureID)
	                            ? filteredTranscripts.filter((form) => form !== featureID)
	                            : [...filteredTranscripts, featureID];
	                        updateFilteredTranscripts(newForms);
	                    }
	                },
	            });
	        }
	    }
	    return menuItems;
	}

	/* eslint-disable unicorn/no-nested-ternary */
	const useStyles$5 = mui.makeStyles()((theme) => ({
	    typeContent: {
	        display: 'inline-block',
	        width: '174px',
	        height: '100%',
	        cursor: 'text',
	    },
	    feature: {
	        td: {
	            position: 'relative',
	            verticalAlign: 'top',
	            paddingLeft: '0.5em',
	        },
	    },
	    arrow: {
	        display: 'inline-block',
	        width: '1.6em',
	        textAlign: 'center',
	        cursor: 'pointer',
	    },
	    arrowExpanded: {
	        transform: 'rotate(90deg)',
	    },
	    hoveredFeature: {
	        backgroundColor: theme.palette.action.hover,
	    },
	    typeInputElement: {
	        border: 'none',
	        background: 'none',
	    },
	    typeErrorMessage: {
	        color: 'red',
	    },
	}));
	function makeContextMenuItems(display, feature) {
	    const { changeManager, getAssemblyId, regions, selectedFeature, session, setSelectedFeature, filteredTranscripts, updateFilteredTranscripts, } = display;
	    return featureContextMenuItems(feature, regions[0], getAssemblyId, selectedFeature, setSelectedFeature, session, changeManager, filteredTranscripts, updateFilteredTranscripts);
	}
	function getTopLevelFeature(feature) {
	    let cur = feature;
	    while (cur.parent) {
	        cur = cur.parent;
	    }
	    return cur;
	}
	const Feature = mobxReact.observer(function Feature({ depth, feature, isHovered, isSelected, model: displayState, selectedFeatureClass, setContextMenu, }) {
	    const { classes } = useStyles$5();
	    const { apolloHover, changeManager, selectedFeature, session, tabularEditor: tabularEditorState, } = displayState;
	    const { featureCollapsed, filterText } = tabularEditorState;
	    const { _id, children, max, min, strand, type } = feature;
	    const expanded = !featureCollapsed.get(_id);
	    const toggleExpanded = (e) => {
	        e.stopPropagation();
	        tabularEditorState.setFeatureCollapsed(_id, expanded);
	    };
	    // pop up a snackbar in the session notifying user of an error
	    const notifyError = (e) => {
	        session.notify(e.message, 'error');
	    };
	    return (React__default["default"].createElement(React__default["default"].Fragment, null,
	        React__default["default"].createElement("tr", { onMouseEnter: (_e) => {
	                displayState.setApolloHover({
	                    feature,
	                    topLevelFeature: getTopLevelFeature(feature),
	                    // @ts-expect-error TODO fix in future when moving hover logic to session.
	                    glyph: displayState.getGlyph(getTopLevelFeature(feature)),
	                });
	            }, className: classes.feature +
	                (isSelected
	                    ? ` ${selectedFeatureClass}`
	                    : isHovered
	                        ? ` ${classes.hoveredFeature}`
	                        : ''), onClick: (e) => {
	                e.stopPropagation();
	                displayState.setSelectedFeature(feature);
	            }, onContextMenu: (e) => {
	                e.preventDefault();
	                setContextMenu({
	                    position: { left: e.clientX + 2, top: e.clientY - 6 },
	                    items: makeContextMenuItems(displayState, feature),
	                });
	                return false;
	            } },
	            React__default["default"].createElement("td", { style: {
	                    whiteSpace: 'nowrap',
	                    borderLeft: `${depth * 2}em solid transparent`,
	                } },
	                children?.size ? (
	                // TODO: a11y
	                // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
	                React__default["default"].createElement("div", { onClick: toggleExpanded, className: classes.arrow + (expanded ? ` ${classes.arrowExpanded}` : '') }, "\u276F")) : null,
	                React__default["default"].createElement("div", { className: classes.typeContent },
	                    React__default["default"].createElement(OntologyTermAutocomplete, { session: session, ontologyName: "Sequence Ontology", style: { width: 170 }, value: type, filterTerms: isOntologyClass, fetchValidTerms: fetchValidTypeTerms.bind(null, feature), renderInput: (params) => {
	                            return (React__default["default"].createElement("div", { ref: params.InputProps.ref },
	                                React__default["default"].createElement("input", { type: "text", ...params.inputProps, className: classes.typeInputElement, style: { width: 170 } }),
	                                params.error ? (React__default["default"].createElement("div", { className: classes.typeErrorMessage }, params.errorMessage ?? 'unknown error')) : null));
	                        }, onChange: (oldValue, newValue) => {
	                            if (newValue) {
	                                handleFeatureTypeChange(changeManager, feature, oldValue, newValue).catch(notifyError);
	                            }
	                        } }))),
	            React__default["default"].createElement("td", null,
	                React__default["default"].createElement(NumberCell, { initialValue: min + 1, notifyError: notifyError, onChangeCommitted: (newStart) => handleFeatureStartChange(changeManager, feature, min, newStart - 1) })),
	            React__default["default"].createElement("td", null,
	                React__default["default"].createElement(NumberCell, { initialValue: max, notifyError: notifyError, onChangeCommitted: (newEnd) => handleFeatureEndChange(changeManager, feature, max, newEnd) })),
	            React__default["default"].createElement("td", null, strand === 1 ? '+' : strand === -1 ? '-' : undefined),
	            React__default["default"].createElement("td", null,
	                React__default["default"].createElement(FeatureAttributes, { filterText: filterText, feature: feature }))),
	        expanded && children
	            ? [...children.entries()]
	                .filter((entry) => {
	                if (!filterText) {
	                    return true;
	                }
	                const [, childFeature] = entry;
	                // search feature and its subfeatures for the text
	                const text = JSON.stringify(childFeature);
	                return text.includes(filterText);
	            })
	                .map(([featureId, childFeature]) => {
	                const childHovered = apolloHover?.feature._id === childFeature._id;
	                const childSelected = selectedFeature?._id === childFeature._id;
	                return (React__default["default"].createElement(Feature, { isHovered: childHovered, isSelected: childSelected, selectedFeatureClass: selectedFeatureClass, key: featureId, depth: (depth || 0) + 1, feature: childFeature, model: displayState, setContextMenu: setContextMenu }));
	            })
	            : null));
	});
	async function fetchValidTypeTerms(feature, ontologyStore, _signal) {
	    const { parent: parentFeature } = feature;
	    if (parentFeature) {
	        // if this is a child of an existing feature, restrict the autocomplete choices to valid
	        // parts of that feature
	        const parentTypeTerms = await ontologyStore.getTermsWithLabelOrSynonym(parentFeature.type, { includeSubclasses: false });
	        // eslint-disable-next-line unicorn/no-array-callback-reference
	        const parentTypeClassTerms = parentTypeTerms.filter(isOntologyClass);
	        if (parentTypeClassTerms.length > 0) {
	            const subpartTerms = await ontologyStore.getClassesThat('part_of', parentTypeClassTerms);
	            return subpartTerms;
	        }
	    }
	    return;
	}

	const useStyles$4 = mui.makeStyles()((theme) => ({
	    scrollableTable: {
	        width: '100%',
	        height: '100%',
	        th: {
	            position: 'sticky',
	            top: 0,
	            zIndex: 2,
	            textAlign: 'left',
	            background: theme.palette.background.paper,
	            paddingTop: '3.2em',
	        },
	        td: { whiteSpace: 'normal' },
	    },
	    selectedFeature: {
	        backgroundColor: theme.palette.action.selected,
	    },
	}));
	const HybridGrid = mobxReact.observer(function HybridGrid({ model, }) {
	    const { apolloHover, seenFeatures, selectedFeature, tabularEditor } = model;
	    const theme = material.useTheme();
	    const { classes } = useStyles$4();
	    const scrollContainerRef = React.useRef(null);
	    const [contextMenu, setContextMenu] = React.useState(null);
	    const { filterText } = tabularEditor;
	    // scrolls to selected feature if one is selected and it's not already visible
	    React.useEffect(() => {
	        const scrollContainer = scrollContainerRef.current;
	        if (scrollContainer && selectedFeature) {
	            const selectedRow = scrollContainer.querySelector(`.${classes.selectedFeature}`);
	            if (selectedRow) {
	                const currScroll = scrollContainer.scrollTop;
	                const newScrollTop = selectedRow.offsetTop - 25;
	                const isVisible = newScrollTop > currScroll &&
	                    newScrollTop < currScroll + scrollContainer.offsetHeight;
	                if (!isVisible) {
	                    scrollContainer.scroll({ top: newScrollTop - 40, behavior: 'smooth' });
	                }
	            }
	        }
	    }, [selectedFeature, seenFeatures, classes.selectedFeature]);
	    return (React__default["default"].createElement("div", { ref: scrollContainerRef, style: { width: '100%', overflowY: 'auto', height: '100%' } },
	        React__default["default"].createElement("table", { className: classes.scrollableTable },
	            React__default["default"].createElement("thead", null,
	                React__default["default"].createElement("tr", null,
	                    React__default["default"].createElement("th", null, "Type"),
	                    React__default["default"].createElement("th", null, "Start"),
	                    React__default["default"].createElement("th", null, "End"),
	                    React__default["default"].createElement("th", null, "Strand"),
	                    React__default["default"].createElement("th", null, "Attributes"))),
	            React__default["default"].createElement("tbody", null, [...seenFeatures.entries()]
	                .filter((entry) => {
	                if (!filterText) {
	                    return true;
	                }
	                const [, feature] = entry;
	                // search feature and its subfeatures for the text
	                const text = JSON.stringify(feature);
	                return text.includes(filterText);
	            })
	                .sort((a, b) => {
	                return a[1].min - b[1].min;
	            })
	                .map(([featureId, feature]) => {
	                const isSelected = selectedFeature?._id === featureId;
	                const isHovered = apolloHover?.feature._id === featureId;
	                return (React__default["default"].createElement(Feature, { key: featureId, isSelected: isSelected, isHovered: isHovered, selectedFeatureClass: classes.selectedFeature, feature: feature, model: model, depth: 0, setContextMenu: setContextMenu }));
	            }))),
	        React__default["default"].createElement(ui.Menu, { open: Boolean(contextMenu), onMenuItemClick: (_, callback) => {
	                callback();
	                setContextMenu(null);
	            }, onClose: () => {
	                setContextMenu(null);
	            }, TransitionProps: {
	                onExit: () => {
	                    setContextMenu(null);
	                },
	            }, style: { zIndex: theme.zIndex.tooltip }, menuItems: contextMenu?.items ?? [], anchorReference: "anchorPosition", anchorPosition: contextMenu?.position })));
	});

	var Clear = {};

	var _interopRequireDefault$4 = interopRequireDefault.exports;
	Object.defineProperty(Clear, "__esModule", {
	  value: true
	});
	var default_1$4 = Clear["default"] = void 0;
	var _createSvgIcon$4 = /*#__PURE__*/_interopRequireDefault$4(createSvgIcon);
	var _jsxRuntime$4 = require$$2__default["default"];
	var _default$4 = /*#__PURE__*/(0, _createSvgIcon$4["default"])( /*#__PURE__*/(0, _jsxRuntime$4.jsx)("path", {
	  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
	}), 'Clear');
	default_1$4 = Clear["default"] = _default$4;

	var UnfoldLess = {};

	var _interopRequireDefault$3 = interopRequireDefault.exports;
	Object.defineProperty(UnfoldLess, "__esModule", {
	  value: true
	});
	var default_1$3 = UnfoldLess["default"] = void 0;
	var _createSvgIcon$3 = /*#__PURE__*/_interopRequireDefault$3(createSvgIcon);
	var _jsxRuntime$3 = require$$2__default["default"];
	var _default$3 = /*#__PURE__*/(0, _createSvgIcon$3["default"])( /*#__PURE__*/(0, _jsxRuntime$3.jsx)("path", {
	  d: "M7.41 18.59 8.83 20 12 16.83 15.17 20l1.41-1.41L12 14l-4.59 4.59zm9.18-13.18L15.17 4 12 7.17 8.83 4 7.41 5.41 12 10l4.59-4.59z"
	}), 'UnfoldLess');
	default_1$3 = UnfoldLess["default"] = _default$3;

	/* eslint-disable @typescript-eslint/unbound-method */
	const useStyles$3 = mui.makeStyles()({
	    toolbar: {
	        width: '100%',
	        display: 'flex',
	        paddingRight: '2em',
	        flexDirection: 'row',
	        justifyContent: 'space-between',
	        position: 'absolute',
	        zIndex: 4,
	    },
	    filterText: {},
	});
	const ToolBar = mobxReact.observer(function ToolBar({ model: displayState, }) {
	    const model = displayState.tabularEditor;
	    const { classes } = useStyles$3();
	    return (React__default["default"].createElement("div", { className: classes.toolbar },
	        React__default["default"].createElement(material.Tooltip, { title: "Collapse all" },
	            React__default["default"].createElement(material.IconButton, { "aria-label": "collapse", sx: { marginTop: 0 }, onClick: model.collapseAllFeatures },
	                React__default["default"].createElement(default_1$3, null))),
	        React__default["default"].createElement(material.TextField, { className: classes.filterText, label: "Filter features", value: model.filterText, sx: { marginTop: 0 }, variant: "outlined", onChange: (event) => {
	                model.setFilterText(event.target.value);
	            }, slotProps: {
	                input: {
	                    endAdornment: (React__default["default"].createElement(material.InputAdornment, { position: "end" },
	                        React__default["default"].createElement(material.IconButton, { onClick: () => {
	                                model.clearFilterText();
	                            } },
	                            React__default["default"].createElement(default_1$4, null)))),
	                },
	            } })));
	});

	function stopPropagation(e) {
	    e.stopPropagation();
	}
	const TabularEditorPane = mobxReact.observer(function TabularEditorPane({ model: displayState, }) {
	    const model = displayState.tabularEditor;
	    if (!model.isShown) {
	        return null;
	    }
	    return (
	    // TODO: a11y
	    // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
	    React__default["default"].createElement("div", { onMouseDown: stopPropagation, onClick: stopPropagation, style: { width: '100%', height: '100%', position: 'relative' } },
	        React__default["default"].createElement(ToolBar, { model: displayState }),
	        React__default["default"].createElement(HybridGrid, { model: displayState })));
	});

	const TabularEditorStateModelType = require$$1$3.types
	    .model('TabularEditor', {
	    isShown: true,
	    featureCollapsed: require$$1$3.types.map(require$$1$3.types.boolean),
	    filterText: '',
	})
	    .actions((self) => ({
	    setFeatureCollapsed(id, state) {
	        self.featureCollapsed.set(id, state);
	    },
	    setFilterText(text) {
	        self.filterText = text;
	    },
	    clearFilterText() {
	        self.filterText = '';
	    },
	    collapseAllFeatures() {
	        // iterate over all seen features and set them to collapsed
	        const display = require$$1$3.getParent(self);
	        for (const [featureId] of display.seenFeatures.entries()) {
	            self.featureCollapsed.set(featureId, true);
	        }
	    },
	    togglePane() {
	        self.isShown = !self.isShown;
	    },
	    hidePane() {
	        self.isShown = false;
	    },
	    showPane() {
	        self.isShown = true;
	    },
	    // onPatch(patch: any) {
	    //   console.log(patch)
	    // },
	}));

	function drawBoxOutline(ctx, x, y, width, height, color) {
	    drawBox(ctx, x, y, width, height, color);
	    if (width <= 2) {
	        return;
	    }
	    ctx.clearRect(x + 1, y + 1, width - 2, height - 2);
	}
	function drawBoxFill(ctx, x, y, width, height, color) {
	    drawBox(ctx, x + 1, y + 1, width - 2, height - 2, color);
	}
	function drawBoxText(ctx, x, y, width, color, text) {
	    ctx.fillStyle = color;
	    const textStart = Math.max(x + 1, 0);
	    const textWidth = x - 1 + width - textStart;
	    ctx.fillText(text, textStart, y + 11, textWidth);
	}
	function draw$3(ctx, feature, row, stateModel, displayedRegionIndex) {
	    const { apolloRowHeight: heightPx, lgv, session, theme } = stateModel;
	    const { bpPerPx, displayedRegions, offsetPx } = lgv;
	    const displayedRegion = displayedRegions[displayedRegionIndex];
	    const minX = (lgv.bpToPx({
	        refName: displayedRegion.refName,
	        coord: feature.min,
	        regionNumber: displayedRegionIndex,
	    })?.offsetPx ?? 0) - offsetPx;
	    const { reversed } = displayedRegion;
	    const { apolloSelectedFeature } = session;
	    const widthPx = feature.length / bpPerPx;
	    const startPx = reversed ? minX - widthPx : minX;
	    const top = row * heightPx;
	    const isSelected = isSelectedFeature$1(feature, apolloSelectedFeature);
	    const backgroundColor = getBackgroundColor(theme, isSelected);
	    const textColor = getTextColor(theme, isSelected);
	    const featureBox = [
	        startPx,
	        top,
	        widthPx,
	        heightPx,
	    ];
	    drawBoxOutline(ctx, ...featureBox, textColor);
	    if (widthPx <= 2) {
	        // Don't need to add details if the feature is too small to see them
	        return;
	    }
	    drawBoxFill(ctx, startPx, top, widthPx, heightPx, backgroundColor);
	    drawBoxText(ctx, startPx, top, widthPx, textColor, feature.type);
	}
	function drawDragPreview$3(stateModel, overlayCtx) {
	    const { apolloDragging, apolloRowHeight, lgv, theme } = stateModel;
	    const { bpPerPx, displayedRegions, offsetPx } = lgv;
	    if (!apolloDragging) {
	        return;
	    }
	    const { current, edge, feature, start } = apolloDragging;
	    const row = Math.floor(start.y / apolloRowHeight);
	    const region = displayedRegions[start.regionNumber];
	    const rowCount = getRowCount$2();
	    const featureEdgeBp = region.reversed
	        ? region.end - feature[edge]
	        : feature[edge] - region.start;
	    const featureEdgePx = featureEdgeBp / bpPerPx - offsetPx;
	    const rectX = Math.min(current.x, featureEdgePx);
	    const rectY = row * apolloRowHeight;
	    const rectWidth = Math.abs(current.x - featureEdgePx);
	    const rectHeight = apolloRowHeight * rowCount;
	    overlayCtx.strokeStyle = theme?.palette.info.main ?? 'rgb(255,0,0)';
	    overlayCtx.setLineDash([6]);
	    overlayCtx.strokeRect(rectX, rectY, rectWidth, rectHeight);
	    overlayCtx.fillStyle = material.alpha(theme?.palette.info.main ?? 'rgb(255,0,0)', 0.2);
	    overlayCtx.fillRect(rectX, rectY, rectWidth, rectHeight);
	}
	function drawHover$3(stateModel, ctx) {
	    const { apolloHover, apolloRowHeight, lgv, theme } = stateModel;
	    if (!apolloHover) {
	        return;
	    }
	    const { feature } = apolloHover;
	    const position = stateModel.getFeatureLayoutPosition(feature);
	    if (!position) {
	        return;
	    }
	    const { bpPerPx, displayedRegions, offsetPx } = lgv;
	    const { layoutIndex, layoutRow } = position;
	    const displayedRegion = displayedRegions[layoutIndex];
	    const { refName, reversed } = displayedRegion;
	    const { length, max, min } = feature;
	    const startPx = (lgv.bpToPx({
	        refName,
	        coord: reversed ? max : min,
	        regionNumber: layoutIndex,
	    })?.offsetPx ?? 0) - offsetPx;
	    const top = layoutRow * apolloRowHeight;
	    const widthPx = length / bpPerPx;
	    ctx.fillStyle = theme?.palette.action.focus ?? 'rgba(0,0,0,0.04)';
	    ctx.fillRect(startPx, top, widthPx, apolloRowHeight);
	}
	function drawTooltip$3(display, context) {
	    const { apolloHover, apolloRowHeight, lgv, theme } = display;
	    if (!apolloHover) {
	        return;
	    }
	    const { feature } = apolloHover;
	    const position = display.getFeatureLayoutPosition(feature);
	    if (!position) {
	        return;
	    }
	    const { featureRow, layoutIndex, layoutRow } = position;
	    const { bpPerPx, displayedRegions, offsetPx } = lgv;
	    const displayedRegion = displayedRegions[layoutIndex];
	    const { refName, reversed } = displayedRegion;
	    let location = 'Loc: ';
	    const { length, max, min } = feature;
	    location += `${min + 1}–${max}`;
	    let startPx = (lgv.bpToPx({
	        refName,
	        coord: reversed ? max : min,
	        regionNumber: layoutIndex,
	    })?.offsetPx ?? 0) - offsetPx;
	    const top = (layoutRow + featureRow) * apolloRowHeight;
	    const widthPx = length / bpPerPx;
	    const featureType = `Type: ${feature.type}`;
	    const { attributes } = feature;
	    const featureName = attributes.get('gff_name')?.find((name) => name !== '');
	    const textWidth = [
	        context.measureText(featureType).width,
	        context.measureText(location).width,
	    ];
	    if (featureName) {
	        textWidth.push(context.measureText(`Name: ${featureName}`).width);
	    }
	    const maxWidth = Math.max(...textWidth);
	    startPx = startPx + widthPx + 5;
	    context.fillStyle = material.alpha(theme?.palette.text.primary ?? 'rgb(1, 1, 1)', 0.7);
	    context.fillRect(startPx, top, maxWidth + 4, textWidth.length === 3 ? 45 : 35);
	    context.beginPath();
	    context.moveTo(startPx, top);
	    context.lineTo(startPx - 5, top + 5);
	    context.lineTo(startPx, top + 10);
	    context.fill();
	    context.fillStyle = theme?.palette.background.default ?? 'rgba(255, 255, 255)';
	    let textTop = top + 12;
	    context.fillText(featureType, startPx + 2, textTop);
	    if (featureName) {
	        textTop = textTop + 12;
	        context.fillText(`Name: ${featureName}`, startPx + 2, textTop);
	    }
	    textTop = textTop + 12;
	    context.fillText(location, startPx + 2, textTop);
	}
	function isSelectedFeature$1(feature, selectedFeature) {
	    return Boolean(selectedFeature && feature._id === selectedFeature._id);
	}
	function getBackgroundColor(theme, selected) {
	    return selected
	        ? theme?.palette.text.primary ?? 'black'
	        : theme?.palette.background.default ?? 'white';
	}
	function getTextColor(theme, selected) {
	    return selected
	        ? theme?.palette.getContrastText(getBackgroundColor(theme, selected)) ??
	            'white'
	        : theme?.palette.text.primary ?? 'black';
	}
	function drawBox(ctx, x, y, width, height, color) {
	    ctx.fillStyle = color;
	    ctx.fillRect(x, y, width, height);
	}
	function getContextMenuItems$3(display) {
	    const { apolloHover } = display;
	    if (!apolloHover) {
	        return [];
	    }
	    const { feature: sourceFeature } = apolloHover;
	    return getContextMenuItemsForFeature$2(display, sourceFeature);
	}
	function makeFeatureLabel(feature) {
	    let name;
	    if (feature.attributes.get('gff_name')) {
	        name = feature.attributes.get('gff_name')?.join(',');
	    }
	    else if (feature.attributes.get('gff_id')) {
	        name = feature.attributes.get('gff_id')?.join(',');
	    }
	    else {
	        name = feature._id;
	    }
	    const coords = `(${(feature.min + 1).toLocaleString('en')}..${feature.max.toLocaleString('en')})`;
	    const maxLen = 60;
	    if (name && name.length + coords.length > maxLen + 5) {
	        const trim = maxLen - coords.length;
	        name = trim > 0 ? name.slice(0, trim) : '';
	        name = `${name}[...]`;
	    }
	    return `${name} ${coords}`;
	}
	function getContextMenuItemsForFeature$2(display, sourceFeature) {
	    const { apolloInternetAccount: internetAccount, changeManager, regions, selectedFeature, session, } = display;
	    const menuItems = [];
	    const role = internetAccount ? internetAccount.role : 'admin';
	    const admin = role === 'admin';
	    const readOnly = !(role && ['admin', 'user'].includes(role));
	    const [region] = regions;
	    const sourceAssemblyId = display.getAssemblyId(region.assemblyName);
	    const currentAssemblyId = display.getAssemblyId(region.assemblyName);
	    const { featureTypeOntology } = session.apolloDataStore.ontologyManager;
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    // Add only relevant options
	    menuItems.push({
	        label: makeFeatureLabel(sourceFeature),
	        type: 'subHeader',
	    }, {
	        label: 'Add child feature',
	        disabled: readOnly,
	        onClick: () => {
	            session.queueDialog((doneCallback) => [
	                AddChildFeature,
	                {
	                    session,
	                    handleClose: () => {
	                        doneCallback();
	                    },
	                    changeManager,
	                    sourceFeature,
	                    sourceAssemblyId,
	                    internetAccount,
	                },
	            ]);
	        },
	    }, {
	        label: 'Copy features and annotations',
	        disabled: readOnly,
	        onClick: () => {
	            session.queueDialog((doneCallback) => [
	                CopyFeature,
	                {
	                    session,
	                    handleClose: () => {
	                        doneCallback();
	                    },
	                    changeManager,
	                    sourceFeature,
	                    sourceAssemblyId: currentAssemblyId,
	                },
	            ]);
	        },
	    }, {
	        label: 'Delete feature',
	        disabled: !admin,
	        onClick: () => {
	            session.queueDialog((doneCallback) => [
	                DeleteFeature,
	                {
	                    session,
	                    handleClose: () => {
	                        doneCallback();
	                    },
	                    changeManager,
	                    sourceFeature,
	                    sourceAssemblyId: currentAssemblyId,
	                    selectedFeature,
	                    setSelectedFeature: (feature) => {
	                        display.setSelectedFeature(feature);
	                    },
	                },
	            ]);
	        },
	    });
	    return menuItems;
	}
	function getFeatureFromLayout$2(feature, _bp, _row) {
	    return feature;
	}
	function getRowCount$2(_feature) {
	    return 1;
	}
	function getRowForFeature$2(_feature, _childFeature) {
	    return 0;
	}
	function onMouseDown$3(stateModel, currentMousePosition, event) {
	    const { featureAndGlyphUnderMouse } = currentMousePosition;
	    // swallow the mouseDown if we are on the edge of the feature so that we
	    // don't start dragging the view if we try to drag the feature edge
	    const { feature } = featureAndGlyphUnderMouse;
	    const edge = isMouseOnFeatureEdge(currentMousePosition, feature, stateModel);
	    if (edge) {
	        event.stopPropagation();
	        stateModel.startDrag(currentMousePosition, feature, edge);
	    }
	}
	function onMouseLeave$3() {
	    return;
	}
	function onMouseMove$3(stateModel, mousePosition) {
	    if (isMousePositionWithFeatureAndGlyph$1(mousePosition)) {
	        const { featureAndGlyphUnderMouse } = mousePosition;
	        stateModel.setApolloHover(featureAndGlyphUnderMouse);
	        const { feature } = featureAndGlyphUnderMouse;
	        const edge = isMouseOnFeatureEdge(mousePosition, feature, stateModel);
	        if (edge) {
	            stateModel.setCursor('col-resize');
	            return;
	        }
	    }
	    stateModel.setCursor();
	}
	function onMouseUp$3(stateModel, mousePosition) {
	    if (stateModel.apolloDragging) {
	        return;
	    }
	    const { featureAndGlyphUnderMouse } = mousePosition;
	    if (!featureAndGlyphUnderMouse) {
	        return;
	    }
	    const { feature } = featureAndGlyphUnderMouse;
	    stateModel.setSelectedFeature(feature);
	    stateModel.showFeatureDetailsWidget(feature);
	}
	/** @returns undefined if mouse not on the edge of this feature, otherwise 'start' or 'end' depending on which edge */
	function isMouseOnFeatureEdge(mousePosition, feature, stateModel) {
	    const { refName, regionNumber, x } = mousePosition;
	    const { lgv } = stateModel;
	    const { offsetPx } = lgv;
	    const minPxInfo = lgv.bpToPx({ refName, coord: feature.min, regionNumber });
	    const maxPxInfo = lgv.bpToPx({ refName, coord: feature.max, regionNumber });
	    if (minPxInfo !== undefined && maxPxInfo !== undefined) {
	        const minPx = minPxInfo.offsetPx - offsetPx;
	        const maxPx = maxPxInfo.offsetPx - offsetPx;
	        if (Math.abs(maxPx - minPx) < 8) {
	            return;
	        }
	        if (Math.abs(minPx - x) < 4) {
	            return 'min';
	        }
	        if (Math.abs(maxPx - x) < 4) {
	            return 'max';
	        }
	    }
	    return;
	}
	const boxGlyph = {
	    draw: draw$3,
	    drawDragPreview: drawDragPreview$3,
	    drawHover: drawHover$3,
	    drawTooltip: drawTooltip$3,
	    getContextMenuItemsForFeature: getContextMenuItemsForFeature$2,
	    getContextMenuItems: getContextMenuItems$3,
	    getFeatureFromLayout: getFeatureFromLayout$2,
	    getRowCount: getRowCount$2,
	    getRowForFeature: getRowForFeature$2,
	    onMouseDown: onMouseDown$3,
	    onMouseLeave: onMouseLeave$3,
	    onMouseMove: onMouseMove$3,
	    onMouseUp: onMouseUp$3,
	};

	let forwardFillLight$1 = null;
	let backwardFillLight$1 = null;
	let forwardFillDark$1 = null;
	let backwardFillDark$1 = null;
	const canvas$1 = globalThis.document.createElement('canvas');
	// @ts-expect-error getContext is undefined in the web worker
	// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	if (canvas$1?.getContext) {
	    for (const direction of ['forward', 'backward']) {
	        for (const themeMode of ['light', 'dark']) {
	            const canvas = document.createElement('canvas');
	            const canvasSize = 10;
	            canvas.width = canvas.height = canvasSize;
	            const ctx = canvas.getContext('2d');
	            if (ctx) {
	                const stripeColor1 = themeMode === 'light' ? 'rgba(0,0,0,0)' : 'rgba(0,0,0,0.75)';
	                const stripeColor2 = themeMode === 'light' ? 'rgba(255,255,255,0.25)' : 'rgba(0,0,0,0.50)';
	                const gradient = direction === 'forward'
	                    ? ctx.createLinearGradient(0, canvasSize, canvasSize, 0)
	                    : ctx.createLinearGradient(0, 0, canvasSize, canvasSize);
	                gradient.addColorStop(0, stripeColor1);
	                gradient.addColorStop(0.25, stripeColor1);
	                gradient.addColorStop(0.25, stripeColor2);
	                gradient.addColorStop(0.5, stripeColor2);
	                gradient.addColorStop(0.5, stripeColor1);
	                gradient.addColorStop(0.75, stripeColor1);
	                gradient.addColorStop(0.75, stripeColor2);
	                gradient.addColorStop(1, stripeColor2);
	                ctx.fillStyle = gradient;
	                ctx.fillRect(0, 0, 10, 10);
	                if (direction === 'forward') {
	                    if (themeMode === 'light') {
	                        forwardFillLight$1 = ctx.createPattern(canvas, 'repeat');
	                    }
	                    else {
	                        forwardFillDark$1 = ctx.createPattern(canvas, 'repeat');
	                    }
	                }
	                else {
	                    if (themeMode === 'light') {
	                        backwardFillLight$1 = ctx.createPattern(canvas, 'repeat');
	                    }
	                    else {
	                        backwardFillDark$1 = ctx.createPattern(canvas, 'repeat');
	                    }
	                }
	            }
	        }
	    }
	}
	function draw$2(ctx, feature, row, stateModel, displayedRegionIndex) {
	    const { apolloRowHeight, lgv, session, theme } = stateModel;
	    const { bpPerPx, displayedRegions, offsetPx } = lgv;
	    const displayedRegion = displayedRegions[displayedRegionIndex];
	    const { refName, reversed } = displayedRegion;
	    const rowHeight = apolloRowHeight;
	    const cdsHeight = Math.round(0.9 * rowHeight);
	    const { children, min, strand } = feature;
	    if (!children) {
	        return;
	    }
	    const { apolloSelectedFeature } = session;
	    const { apolloDataStore } = session;
	    const { featureTypeOntology } = apolloDataStore.ontologyManager;
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    // Draw background for gene
	    const topLevelFeatureMinX = (lgv.bpToPx({
	        refName,
	        coord: min,
	        regionNumber: displayedRegionIndex,
	    })?.offsetPx ?? 0) - offsetPx;
	    const topLevelFeatureWidthPx = feature.length / bpPerPx;
	    const topLevelFeatureStartPx = reversed
	        ? topLevelFeatureMinX - topLevelFeatureWidthPx
	        : topLevelFeatureMinX;
	    const topLevelFeatureTop = row * rowHeight;
	    const topLevelFeatureHeight = getRowCount$1(feature, featureTypeOntology) * rowHeight;
	    ctx.fillStyle = material.alpha(theme?.palette.background.paper ?? '#ffffff', 0.6);
	    ctx.fillRect(topLevelFeatureStartPx, topLevelFeatureTop, topLevelFeatureWidthPx, topLevelFeatureHeight);
	    // Draw lines on different rows for each transcript
	    let currentRow = 0;
	    for (const [, transcript] of children) {
	        const isTranscript = featureTypeOntology.isTypeOf(transcript.type, 'transcript') ||
	            featureTypeOntology.isTypeOf(transcript.type, 'pseudogenic_transcript');
	        if (!isTranscript) {
	            currentRow += 1;
	            continue;
	        }
	        const { children: transcriptChildren } = transcript;
	        if (!transcriptChildren) {
	            continue;
	        }
	        const cdsCount = getCDSCount(transcript, featureTypeOntology);
	        for (const [, childFeature] of transcriptChildren) {
	            if (!featureTypeOntology.isTypeOf(childFeature.type, 'CDS')) {
	                continue;
	            }
	            drawLine(ctx, stateModel, displayedRegionIndex, row, transcript, currentRow);
	            currentRow += 1;
	        }
	        if (cdsCount === 0) {
	            drawLine(ctx, stateModel, displayedRegionIndex, row, transcript, currentRow);
	            currentRow += 1;
	        }
	    }
	    const forwardFill = theme?.palette.mode === 'dark' ? forwardFillDark$1 : forwardFillLight$1;
	    const backwardFill = theme?.palette.mode === 'dark' ? backwardFillDark$1 : backwardFillLight$1;
	    // Draw exon and CDS for each transcript
	    currentRow = 0;
	    for (const [, child] of children) {
	        if (!(featureTypeOntology.isTypeOf(child.type, 'transcript') ||
	            featureTypeOntology.isTypeOf(child.type, 'pseudogenic_transcript'))) {
	            boxGlyph.draw(ctx, child, row, stateModel, displayedRegionIndex);
	            currentRow += 1;
	            continue;
	        }
	        const cdsCount = getCDSCount(child, featureTypeOntology);
	        if (cdsCount != 0) {
	            for (const cdsRow of child.cdsLocations) {
	                const { _id, children: transcriptChildren } = child;
	                if (!transcriptChildren) {
	                    continue;
	                }
	                for (const [, exon] of transcriptChildren) {
	                    if (!featureTypeOntology.isTypeOf(exon.type, 'exon')) {
	                        continue;
	                    }
	                    drawExon(ctx, stateModel, displayedRegionIndex, row, exon, currentRow, strand, forwardFill, backwardFill);
	                }
	                for (const cds of cdsRow) {
	                    const cdsWidthPx = (cds.max - cds.min) / bpPerPx;
	                    const minX = (lgv.bpToPx({
	                        refName,
	                        coord: cds.min,
	                        regionNumber: displayedRegionIndex,
	                    })?.offsetPx ?? 0) - offsetPx;
	                    const cdsStartPx = reversed ? minX - cdsWidthPx : minX;
	                    ctx.fillStyle = theme?.palette.text.primary ?? 'black';
	                    const cdsTop = (row + currentRow) * rowHeight + (rowHeight - cdsHeight) / 2;
	                    ctx.fillRect(cdsStartPx, cdsTop, cdsWidthPx, cdsHeight);
	                    if (cdsWidthPx > 2) {
	                        ctx.clearRect(cdsStartPx + 1, cdsTop + 1, cdsWidthPx - 2, cdsHeight - 2);
	                        const frame = require$$1$2.getFrame(cds.min, cds.max, child.strand ?? 1, cds.phase);
	                        const frameColor = theme?.palette.framesCDS.at(frame)?.main;
	                        const cdsColorCode = frameColor ?? 'rgb(171,71,188)';
	                        ctx.fillStyle =
	                            apolloSelectedFeature && _id === apolloSelectedFeature._id
	                                ? 'rgb(0,0,0)'
	                                : cdsColorCode;
	                        ctx.fillRect(cdsStartPx + 1, cdsTop + 1, cdsWidthPx - 2, cdsHeight - 2);
	                        if (forwardFill && backwardFill && strand) {
	                            const reversal = reversed ? -1 : 1;
	                            const [topFill, bottomFill] = strand * reversal === 1
	                                ? [forwardFill, backwardFill]
	                                : [backwardFill, forwardFill];
	                            ctx.fillStyle = topFill;
	                            ctx.fillRect(cdsStartPx + 1, cdsTop + 1, cdsWidthPx - 2, (cdsHeight - 2) / 2);
	                            ctx.fillStyle = bottomFill;
	                            ctx.fillRect(cdsStartPx + 1, cdsTop + (cdsHeight - 2) / 2, cdsWidthPx - 2, (cdsHeight - 2) / 2);
	                        }
	                    }
	                }
	                currentRow += 1;
	            }
	        }
	        const { children: transcriptChildren } = child;
	        // Draw exons for non-coding genes
	        if (cdsCount === 0 && transcriptChildren) {
	            for (const [, exon] of transcriptChildren) {
	                if (!featureTypeOntology.isTypeOf(exon.type, 'exon')) {
	                    continue;
	                }
	                drawExon(ctx, stateModel, displayedRegionIndex, row, exon, currentRow, strand, forwardFill, backwardFill);
	            }
	            currentRow += 1;
	        }
	    }
	}
	function drawExon(ctx, stateModel, displayedRegionIndex, row, exon, currentRow, strand, forwardFill, backwardFill) {
	    const { apolloRowHeight, lgv, session, theme } = stateModel;
	    const { bpPerPx, displayedRegions, offsetPx } = lgv;
	    const displayedRegion = displayedRegions[displayedRegionIndex];
	    const { refName, reversed } = displayedRegion;
	    const { apolloSelectedFeature } = session;
	    const minX = (lgv.bpToPx({
	        refName,
	        coord: exon.min,
	        regionNumber: displayedRegionIndex,
	    })?.offsetPx ?? 0) - offsetPx;
	    const widthPx = exon.length / bpPerPx;
	    const startPx = reversed ? minX - widthPx : minX;
	    const top = (row + currentRow) * apolloRowHeight;
	    const exonHeight = Math.round(0.6 * apolloRowHeight);
	    const exonTop = top + (apolloRowHeight - exonHeight) / 2;
	    ctx.fillStyle = theme?.palette.text.primary ?? 'black';
	    ctx.fillRect(startPx, exonTop, widthPx, exonHeight);
	    if (widthPx > 2) {
	        ctx.clearRect(startPx + 1, exonTop + 1, widthPx - 2, exonHeight - 2);
	        ctx.fillStyle =
	            apolloSelectedFeature && exon._id === apolloSelectedFeature._id
	                ? 'rgb(0,0,0)'
	                : 'rgb(211,211,211)';
	        ctx.fillRect(startPx + 1, exonTop + 1, widthPx - 2, exonHeight - 2);
	        if (forwardFill && backwardFill && strand) {
	            const reversal = reversed ? -1 : 1;
	            const [topFill, bottomFill] = strand * reversal === 1
	                ? [forwardFill, backwardFill]
	                : [backwardFill, forwardFill];
	            ctx.fillStyle = topFill;
	            ctx.fillRect(startPx + 1, exonTop + 1, widthPx - 2, (exonHeight - 2) / 2);
	            ctx.fillStyle = bottomFill;
	            ctx.fillRect(startPx + 1, exonTop + 1 + (exonHeight - 2) / 2, widthPx - 2, (exonHeight - 2) / 2);
	        }
	    }
	}
	function drawLine(ctx, stateModel, displayedRegionIndex, row, transcript, currentRow) {
	    const { apolloRowHeight, lgv, theme } = stateModel;
	    const { bpPerPx, displayedRegions, offsetPx } = lgv;
	    const displayedRegion = displayedRegions[displayedRegionIndex];
	    const { refName, reversed } = displayedRegion;
	    const minX = (lgv.bpToPx({
	        refName,
	        coord: transcript.min,
	        regionNumber: displayedRegionIndex,
	    })?.offsetPx ?? 0) - offsetPx;
	    const widthPx = transcript.length / bpPerPx;
	    const startPx = reversed ? minX - widthPx : minX;
	    const height = Math.round((currentRow + 1 / 2) * apolloRowHeight) + row * apolloRowHeight;
	    ctx.strokeStyle = theme?.palette.text.primary ?? 'black';
	    ctx.beginPath();
	    ctx.moveTo(startPx, height);
	    ctx.lineTo(startPx + widthPx, height);
	    ctx.stroke();
	}
	function drawDragPreview$2(stateModel, overlayCtx) {
	    const { apolloDragging, apolloRowHeight, lgv, theme } = stateModel;
	    const { bpPerPx, displayedRegions, offsetPx } = lgv;
	    if (!apolloDragging) {
	        return;
	    }
	    const { current, edge, feature, start } = apolloDragging;
	    const row = Math.floor(start.y / apolloRowHeight);
	    const region = displayedRegions[start.regionNumber];
	    const rowCount = 1;
	    const featureEdgeBp = region.reversed
	        ? region.end - feature[edge]
	        : feature[edge] - region.start;
	    const featureEdgePx = featureEdgeBp / bpPerPx - offsetPx;
	    const rectX = Math.min(current.x, featureEdgePx);
	    const rectY = row * apolloRowHeight;
	    const rectWidth = Math.abs(current.x - featureEdgePx);
	    const rectHeight = apolloRowHeight * rowCount;
	    overlayCtx.strokeStyle = theme?.palette.info.main ?? 'rgb(255,0,0)';
	    overlayCtx.setLineDash([6]);
	    overlayCtx.strokeRect(rectX, rectY, rectWidth, rectHeight);
	    overlayCtx.fillStyle = material.alpha(theme?.palette.info.main ?? 'rgb(255,0,0)', 0.2);
	    overlayCtx.fillRect(rectX, rectY, rectWidth, rectHeight);
	}
	function drawHover$2(stateModel, ctx) {
	    const { apolloHover, apolloRowHeight, lgv, session, theme } = stateModel;
	    const { featureTypeOntology } = session.apolloDataStore.ontologyManager;
	    if (!apolloHover) {
	        return;
	    }
	    const { feature } = apolloHover;
	    const position = stateModel.getFeatureLayoutPosition(feature);
	    if (!position) {
	        return;
	    }
	    const { bpPerPx, displayedRegions, offsetPx } = lgv;
	    const { featureRow, layoutIndex, layoutRow } = position;
	    const displayedRegion = displayedRegions[layoutIndex];
	    const { refName, reversed } = displayedRegion;
	    const { length, max, min } = feature;
	    const startPx = (lgv.bpToPx({
	        refName,
	        coord: reversed ? max : min,
	        regionNumber: layoutIndex,
	    })?.offsetPx ?? 0) - offsetPx;
	    const row = layoutRow + featureRow;
	    const top = row * apolloRowHeight;
	    const widthPx = length / bpPerPx;
	    ctx.fillStyle = theme?.palette.action.selected ?? 'rgba(0,0,0,04)';
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    ctx.fillRect(startPx, top, widthPx, apolloRowHeight * getRowCount$1(feature, featureTypeOntology));
	}
	function getFeatureFromLayout$1(feature, bp, row, featureTypeOntology) {
	    const featureInThisRow = featuresForRow$1(feature, featureTypeOntology)[row] || [];
	    for (const f of featureInThisRow) {
	        let featureObj;
	        if (bp >= f.min && bp <= f.max && f.parent) {
	            featureObj = f;
	        }
	        if (!featureObj) {
	            continue;
	        }
	        if (featureTypeOntology.isTypeOf(featureObj.type, 'CDS') &&
	            featureObj.parent &&
	            (featureTypeOntology.isTypeOf(featureObj.parent.type, 'transcript') ||
	                featureTypeOntology.isTypeOf(featureObj.parent.type, 'pseudogenic_transcript'))) {
	            const { cdsLocations } = featureObj.parent;
	            for (const cdsLoc of cdsLocations) {
	                for (const loc of cdsLoc) {
	                    if (bp >= loc.min && bp <= loc.max) {
	                        return featureObj;
	                    }
	                }
	            }
	            // If mouse position is in the intron region, return the transcript
	            return featureObj.parent;
	        }
	        // If mouse position is in a feature that is not a CDS, return the feature
	        return featureObj;
	    }
	    return feature;
	}
	function getCDSCount(feature, featureTypeOntology) {
	    const { children, type } = feature;
	    if (!children) {
	        return 0;
	    }
	    const isMrna = featureTypeOntology.isTypeOf(type, 'transcript');
	    let cdsCount = 0;
	    if (isMrna) {
	        for (const [, child] of children) {
	            if (featureTypeOntology.isTypeOf(child.type, 'CDS')) {
	                cdsCount += 1;
	            }
	        }
	    }
	    return cdsCount;
	}
	function getRowCount$1(feature, featureTypeOntology, _bpPerPx) {
	    const { children, type } = feature;
	    if (!children) {
	        return 1;
	    }
	    const isTranscript = featureTypeOntology.isTypeOf(type, 'transcript') ||
	        featureTypeOntology.isTypeOf(type, 'pseudogenic_transcript');
	    let rowCount = 0;
	    if (isTranscript) {
	        for (const [, child] of children) {
	            if (featureTypeOntology.isTypeOf(child.type, 'CDS')) {
	                rowCount += 1;
	            }
	        }
	        // return 1 if there are no CDSs for non coding genes
	        return rowCount === 0 ? 1 : rowCount;
	    }
	    for (const [, child] of children) {
	        rowCount += getRowCount$1(child, featureTypeOntology);
	    }
	    return rowCount;
	}
	/**
	 * A list of all the subfeatures for each row for a given feature, as well as
	 * the feature itself.
	 * If the row contains a transcript, the order is CDS -\> exon -\> transcript -\> gene
	 * If the row does not contain an transcript, the order is subfeature -\> gene
	 */
	function featuresForRow$1(feature, featureTypeOntology) {
	    const isGene = featureTypeOntology.isTypeOf(feature.type, 'gene') ||
	        featureTypeOntology.isTypeOf(feature.type, 'pseudogene');
	    if (!isGene) {
	        throw new Error('Top level feature for GeneGlyph must have type "gene"');
	    }
	    const { children } = feature;
	    if (!children) {
	        return [[feature]];
	    }
	    const features = [];
	    for (const [, child] of children) {
	        if (!(featureTypeOntology.isTypeOf(child.type, 'transcript') ||
	            featureTypeOntology.isTypeOf(child.type, 'pseudogenic_transcript'))) {
	            features.push([child, feature]);
	            continue;
	        }
	        if (!child.children) {
	            continue;
	        }
	        const cdss = [];
	        const exons = [];
	        for (const [, grandchild] of child.children) {
	            if (featureTypeOntology.isTypeOf(grandchild.type, 'CDS')) {
	                cdss.push(grandchild);
	            }
	            else if (featureTypeOntology.isTypeOf(grandchild.type, 'exon')) {
	                exons.push(grandchild);
	            }
	        }
	        for (const cds of cdss) {
	            features.push([cds, ...exons, child, feature]);
	        }
	        if (cdss.length === 0) {
	            features.push([...exons, child, feature]);
	        }
	    }
	    return features;
	}
	function getRowForFeature$1(feature, childFeature, featureTypeOntology) {
	    const rows = featuresForRow$1(feature, featureTypeOntology);
	    for (const [idx, row] of rows.entries()) {
	        if (row.some((feature) => feature._id === childFeature._id)) {
	            return idx;
	        }
	    }
	    return;
	}
	function onMouseDown$2(stateModel, currentMousePosition, event) {
	    const { featureAndGlyphUnderMouse } = currentMousePosition;
	    // swallow the mouseDown if we are on the edge of the feature so that we
	    // don't start dragging the view if we try to drag the feature edge
	    const { feature } = featureAndGlyphUnderMouse;
	    const draggableFeature = getDraggableFeatureInfo$1(currentMousePosition, feature, stateModel);
	    if (draggableFeature) {
	        event.stopPropagation();
	        stateModel.startDrag(currentMousePosition, draggableFeature.feature, draggableFeature.edge, true);
	    }
	}
	function onMouseMove$2(stateModel, mousePosition) {
	    if (isMousePositionWithFeatureAndGlyph$1(mousePosition)) {
	        const { featureAndGlyphUnderMouse } = mousePosition;
	        stateModel.setApolloHover(featureAndGlyphUnderMouse);
	        const { feature } = featureAndGlyphUnderMouse;
	        const draggableFeature = getDraggableFeatureInfo$1(mousePosition, feature, stateModel);
	        if (draggableFeature) {
	            stateModel.setCursor('col-resize');
	            return;
	        }
	    }
	    stateModel.setCursor();
	}
	function onMouseUp$2(stateModel, mousePosition) {
	    if (stateModel.apolloDragging) {
	        return;
	    }
	    const { featureAndGlyphUnderMouse } = mousePosition;
	    if (!featureAndGlyphUnderMouse) {
	        return;
	    }
	    const { feature } = featureAndGlyphUnderMouse;
	    stateModel.setSelectedFeature(feature);
	    const { session } = stateModel;
	    const { apolloDataStore } = session;
	    const { featureTypeOntology } = apolloDataStore.ontologyManager;
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    let containsCDSOrExon = false;
	    for (const [, child] of feature.children ?? []) {
	        if (featureTypeOntology.isTypeOf(child.type, 'CDS') ||
	            featureTypeOntology.isTypeOf(child.type, 'exon')) {
	            containsCDSOrExon = true;
	            break;
	        }
	    }
	    if ((featureTypeOntology.isTypeOf(feature.type, 'transcript') ||
	        featureTypeOntology.isTypeOf(feature.type, 'pseudogenic_transcript')) &&
	        containsCDSOrExon) {
	        stateModel.showFeatureDetailsWidget(feature, [
	            'ApolloTranscriptDetails',
	            'apolloTranscriptDetails',
	        ]);
	    }
	    else {
	        stateModel.showFeatureDetailsWidget(feature);
	    }
	}
	function getDraggableFeatureInfo$1(mousePosition, feature, stateModel) {
	    const { session } = stateModel;
	    const { apolloDataStore } = session;
	    const { featureTypeOntology } = apolloDataStore.ontologyManager;
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    const isGene = featureTypeOntology.isTypeOf(feature.type, 'gene') ||
	        featureTypeOntology.isTypeOf(feature.type, 'pseudogene');
	    const isTranscript = featureTypeOntology.isTypeOf(feature.type, 'transcript') ||
	        featureTypeOntology.isTypeOf(feature.type, 'pseudogenic_transcript');
	    const isCDS = featureTypeOntology.isTypeOf(feature.type, 'CDS');
	    if (isGene || isTranscript) {
	        // For gene glyphs, the sizes of genes and transcripts are determined by
	        // their child exons, so we don't make them draggable
	        return;
	    }
	    // So now the type of feature is either CDS or exon. If an exon and CDS edge
	    // are in the same place, we want to prioritize dragging the exon. If the
	    // feature we're on is a CDS, let's find any exon it may overlap.
	    const { bp, refName, regionNumber, x } = mousePosition;
	    const { lgv } = stateModel;
	    if (isCDS) {
	        const transcript = feature.parent;
	        if (!transcript?.children) {
	            return;
	        }
	        const exonChildren = [];
	        for (const child of transcript.children.values()) {
	            const childIsExon = featureTypeOntology.isTypeOf(child.type, 'exon');
	            if (childIsExon) {
	                exonChildren.push(child);
	            }
	        }
	        const overlappingExon = exonChildren.find((child) => {
	            const [start, end] = require$$1$2.intersection2(bp - 1, bp, child.min, child.max);
	            return start !== undefined && end !== undefined;
	        });
	        if (overlappingExon) {
	            // We are on an exon, are we on the edge of it?
	            const minMax = getMinAndMaxPx(overlappingExon, refName, regionNumber, lgv);
	            if (minMax) {
	                const overlappingEdge = getOverlappingEdge(overlappingExon, x, minMax);
	                if (overlappingEdge) {
	                    return overlappingEdge;
	                }
	            }
	        }
	    }
	    // End of special cases, let's see if we're on the edge of this CDS or exon
	    const minMax = getMinAndMaxPx(feature, refName, regionNumber, lgv);
	    if (minMax) {
	        const overlappingEdge = getOverlappingEdge(feature, x, minMax);
	        if (overlappingEdge) {
	            return overlappingEdge;
	        }
	    }
	    return;
	}
	function isTranscriptFeature(feature, session) {
	    const { featureTypeOntology } = session.apolloDataStore.ontologyManager;
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    return (featureTypeOntology.isTypeOf(feature.type, 'transcript') ||
	        featureTypeOntology.isTypeOf(feature.type, 'pseudogenic_transcript'));
	}
	function isExonFeature(feature, session) {
	    const { featureTypeOntology } = session.apolloDataStore.ontologyManager;
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    return featureTypeOntology.isTypeOf(feature.type, 'exon');
	}
	function isCDSFeature(feature, session) {
	    const { featureTypeOntology } = session.apolloDataStore.ontologyManager;
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    return featureTypeOntology.isTypeOf(feature.type, 'CDS');
	}
	function getContextMenuItems$2(display, mousePosition) {
	    const { apolloInternetAccount: internetAccount, apolloHover, changeManager, regions, selectedFeature, session, } = display;
	    const [region] = regions;
	    const currentAssemblyId = display.getAssemblyId(region.assemblyName);
	    const menuItems = [];
	    const role = internetAccount ? internetAccount.role : 'admin';
	    const admin = role === 'admin';
	    if (!apolloHover) {
	        return menuItems;
	    }
	    let featuresUnderClick = getFeaturesUnderClick(mousePosition);
	    if (isCDSFeature(mousePosition.featureAndGlyphUnderMouse.feature, session)) {
	        featuresUnderClick = getFeaturesUnderClick(mousePosition, true);
	    }
	    for (const feature of featuresUnderClick) {
	        const contextMenuItemsForFeature = boxGlyph.getContextMenuItemsForFeature(display, feature);
	        if (isExonFeature(feature, session)) {
	            contextMenuItemsForFeature.push({
	                label: 'Merge exons',
	                disabled: !admin,
	                onClick: () => {
	                    session.queueDialog((doneCallback) => [
	                        MergeExons,
	                        {
	                            session,
	                            handleClose: () => {
	                                doneCallback();
	                            },
	                            changeManager,
	                            sourceFeature: feature,
	                            sourceAssemblyId: currentAssemblyId,
	                            selectedFeature,
	                            setSelectedFeature: (feature) => {
	                                display.setSelectedFeature(feature);
	                            },
	                        },
	                    ]);
	                },
	            }, {
	                label: 'Split exon',
	                disabled: !admin,
	                onClick: () => {
	                    session.queueDialog((doneCallback) => [
	                        SplitExon,
	                        {
	                            session,
	                            handleClose: () => {
	                                doneCallback();
	                            },
	                            changeManager,
	                            sourceFeature: feature,
	                            sourceAssemblyId: currentAssemblyId,
	                            selectedFeature,
	                            setSelectedFeature: (feature) => {
	                                display.setSelectedFeature(feature);
	                            },
	                        },
	                    ]);
	                },
	            });
	        }
	        if (isTranscriptFeature(feature, session)) {
	            contextMenuItemsForFeature.push({
	                label: 'Merge transcript',
	                onClick: () => {
	                    session.queueDialog((doneCallback) => [
	                        MergeTranscripts,
	                        {
	                            session,
	                            handleClose: () => {
	                                doneCallback();
	                            },
	                            changeManager,
	                            sourceFeature: feature,
	                            sourceAssemblyId: currentAssemblyId,
	                            selectedFeature,
	                            setSelectedFeature: (feature) => {
	                                display.setSelectedFeature(feature);
	                            },
	                        },
	                    ]);
	                },
	            });
	            if (require$$1$2.isSessionModelWithWidgets(session)) {
	                contextMenuItemsForFeature.push({
	                    label: 'Open transcript details',
	                    onClick: () => {
	                        const apolloTranscriptWidget = session.addWidget('ApolloTranscriptDetails', 'apolloTranscriptDetails', {
	                            feature,
	                            assembly: currentAssemblyId,
	                            changeManager,
	                            refName: region.refName,
	                        });
	                        session.showWidget(apolloTranscriptWidget);
	                    },
	                });
	            }
	        }
	        menuItems.push({
	            label: feature.type,
	            subMenu: contextMenuItemsForFeature,
	        });
	    }
	    return menuItems;
	}
	// False positive here, none of these functions use "this"
	/* eslint-disable @typescript-eslint/unbound-method */
	const { drawTooltip: drawTooltip$2, getContextMenuItemsForFeature: getContextMenuItemsForFeature$1, onMouseLeave: onMouseLeave$2 } = boxGlyph;
	/* eslint-enable @typescript-eslint/unbound-method */
	const geneGlyph$1 = {
	    draw: draw$2,
	    drawDragPreview: drawDragPreview$2,
	    drawHover: drawHover$2,
	    drawTooltip: drawTooltip$2,
	    getContextMenuItems: getContextMenuItems$2,
	    getContextMenuItemsForFeature: getContextMenuItemsForFeature$1,
	    getFeatureFromLayout: getFeatureFromLayout$1,
	    getRowCount: getRowCount$1,
	    getRowForFeature: getRowForFeature$1,
	    onMouseDown: onMouseDown$2,
	    onMouseLeave: onMouseLeave$2,
	    onMouseMove: onMouseMove$2,
	    onMouseUp: onMouseUp$2,
	};

	function featuresForRow(feature) {
	    const features = [[feature]];
	    if (feature.children) {
	        for (const [, child] of feature.children) {
	            features.push(...featuresForRow(child));
	        }
	    }
	    return features;
	}
	function getRowCount(feature) {
	    return featuresForRow(feature).length;
	}
	function draw$1(ctx, feature, row, stateModel, displayedRegionIndex) {
	    for (let i = 0; i < getRowCount(feature); i++) {
	        drawRow(ctx, feature, row + i, row, stateModel, displayedRegionIndex);
	    }
	}
	function drawRow(ctx, topLevelFeature, row, topRow, stateModel, displayedRegionIndex) {
	    const features = featuresForRow(topLevelFeature)[row - topRow];
	    for (const feature of features) {
	        drawFeature(ctx, feature, row, stateModel, displayedRegionIndex);
	    }
	}
	function drawFeature(ctx, feature, row, stateModel, displayedRegionIndex) {
	    const { apolloRowHeight: heightPx, lgv, session } = stateModel;
	    const { bpPerPx, displayedRegions, offsetPx } = lgv;
	    const displayedRegion = displayedRegions[displayedRegionIndex];
	    const minX = (lgv.bpToPx({
	        refName: displayedRegion.refName,
	        coord: feature.min,
	        regionNumber: displayedRegionIndex,
	    })?.offsetPx ?? 0) - offsetPx;
	    const { reversed } = displayedRegion;
	    const { apolloSelectedFeature } = session;
	    const widthPx = feature.length / bpPerPx;
	    const startPx = reversed ? minX - widthPx : minX;
	    const top = row * heightPx;
	    const rowCount = getRowCount(feature);
	    const isSelected = isSelectedFeature$1(feature, apolloSelectedFeature);
	    const groupingColor = isSelected ? 'rgba(130,0,0,0.45)' : 'rgba(255,0,0,0.25)';
	    if (rowCount > 1) {
	        // draw background that encapsulates all child features
	        const featureHeight = rowCount * heightPx;
	        drawBox(ctx, startPx, top, widthPx, featureHeight, groupingColor);
	    }
	    boxGlyph.draw(ctx, feature, row, stateModel, displayedRegionIndex);
	}
	function drawHover$1(stateModel, ctx) {
	    const { apolloHover, apolloRowHeight, lgv } = stateModel;
	    if (!apolloHover) {
	        return;
	    }
	    const { feature } = apolloHover;
	    const position = stateModel.getFeatureLayoutPosition(feature);
	    if (!position) {
	        return;
	    }
	    const { featureRow, layoutIndex, layoutRow } = position;
	    const { bpPerPx, displayedRegions, offsetPx } = lgv;
	    const displayedRegion = displayedRegions[layoutIndex];
	    const { refName, reversed } = displayedRegion;
	    const { length, max, min } = feature;
	    const startPx = (lgv.bpToPx({
	        refName,
	        coord: reversed ? max : min,
	        regionNumber: layoutIndex,
	    })?.offsetPx ?? 0) - offsetPx;
	    const top = (layoutRow + featureRow) * apolloRowHeight;
	    const widthPx = length / bpPerPx;
	    ctx.fillStyle = 'rgba(0,0,0,0.2)';
	    ctx.fillRect(startPx, top, widthPx, apolloRowHeight * getRowCount(feature));
	}
	function getFeatureFromLayout(feature, bp, row) {
	    const layoutRow = featuresForRow(feature)[row];
	    return layoutRow.find((f) => bp >= f.min && bp <= f.max);
	}
	function getRowForFeature(feature, childFeature) {
	    const rows = featuresForRow(feature);
	    for (const [idx, row] of rows.entries()) {
	        if (row.some((feature) => feature._id === childFeature._id)) {
	            return idx;
	        }
	    }
	    return;
	}
	function getContextMenuItems$1(display, mousePosition) {
	    const { apolloHover, session } = display;
	    const menuItems = [];
	    if (!apolloHover) {
	        return menuItems;
	    }
	    const { feature: sourceFeature } = apolloHover;
	    const { featureTypeOntology } = session.apolloDataStore.ontologyManager;
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    const sourceFeatureMenuItems = boxGlyph.getContextMenuItems(display, mousePosition);
	    menuItems.push({
	        label: sourceFeature.type,
	        subMenu: sourceFeatureMenuItems,
	    });
	    for (const relative of getFeaturesUnderClick(mousePosition)) {
	        if (relative._id === sourceFeature._id) {
	            continue;
	        }
	        const contextMenuItemsForFeature = boxGlyph.getContextMenuItemsForFeature(display, relative);
	        menuItems.push({
	            label: relative.type,
	            subMenu: contextMenuItemsForFeature,
	        });
	    }
	    return menuItems;
	}
	// False positive here, none of these functions use "this"
	/* eslint-disable @typescript-eslint/unbound-method */
	const { drawDragPreview: drawDragPreview$1, drawTooltip: drawTooltip$1, getContextMenuItemsForFeature, onMouseDown: onMouseDown$1, onMouseLeave: onMouseLeave$1, onMouseMove: onMouseMove$1, onMouseUp: onMouseUp$1, } = boxGlyph;
	/* eslint-enable @typescript-eslint/unbound-method */
	const genericChildGlyph = {
	    draw: draw$1,
	    drawDragPreview: drawDragPreview$1,
	    drawHover: drawHover$1,
	    drawTooltip: drawTooltip$1,
	    getContextMenuItemsForFeature,
	    getContextMenuItems: getContextMenuItems$1,
	    getFeatureFromLayout,
	    getRowCount,
	    getRowForFeature,
	    onMouseDown: onMouseDown$1,
	    onMouseLeave: onMouseLeave$1,
	    onMouseMove: onMouseMove$1,
	    onMouseUp: onMouseUp$1,
	};

	const FilterFeatures = mobxReact.observer(function FilterFeatures({ featureTypes, handleClose, onUpdate, session, }) {
	    const [type, setType] = React.useState('');
	    const [selectedFeatureTypes, setSelectedFeatureTypes] = React.useState(featureTypes);
	    const handleChange = (value) => {
	        setType(value);
	    };
	    const handleAddFeatureType = () => {
	        if (type) {
	            if (selectedFeatureTypes.includes(type)) {
	                return;
	            }
	            onUpdate([...selectedFeatureTypes, type]);
	            setSelectedFeatureTypes([...selectedFeatureTypes, type]);
	        }
	    };
	    const handleFeatureTypeDelete = (value) => {
	        const newTypes = selectedFeatureTypes.filter((type) => type !== value);
	        onUpdate(newTypes);
	        setSelectedFeatureTypes(newTypes);
	    };
	    return (React__default["default"].createElement(Dialog, { open: true, maxWidth: false, "data-testid": "filter-features-dialog", title: "Filter features by type", handleClose: handleClose },
	        React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, null, "Select the feature types you want to display in the apollo track"),
	            React__default["default"].createElement(material.Grid2, { container: true, spacing: 2 },
	                React__default["default"].createElement(material.Grid2, { size: 8 },
	                    React__default["default"].createElement(OntologyTermAutocomplete, { session: session, ontologyName: "Sequence Ontology", style: { width: '100%' }, value: type, filterTerms: isOntologyClass, renderInput: (params) => (React__default["default"].createElement(material.TextField, { ...params, label: "Feature type", variant: "outlined", fullWidth: true })), onChange: (oldValue, newValue) => {
	                            if (newValue) {
	                                handleChange(newValue);
	                            }
	                        } })),
	                React__default["default"].createElement(material.Grid2, { size: 4 },
	                    React__default["default"].createElement(material.Button, { variant: "contained", onClick: handleAddFeatureType, disabled: !type, style: { marginTop: 9 }, size: "medium" }, "Add"))),
	            selectedFeatureTypes.length > 0 && (React__default["default"].createElement("div", null,
	                React__default["default"].createElement("hr", null),
	                React__default["default"].createElement("div", { style: { width: 300 } },
	                    React__default["default"].createElement(material.DialogContentText, null, "Selected feature types:"),
	                    React__default["default"].createElement(material.Box, { sx: { display: 'flex', flexWrap: 'wrap', gap: 0.5 } }, selectedFeatureTypes.map((value) => (React__default["default"].createElement(material.Chip, { key: value, label: value, onDelete: () => {
	                            handleFeatureTypeDelete(value);
	                        } }))))))))));
	});

	const minDisplayHeight$1 = 20;
	function baseModelFactory$1(_pluginManager, configSchema) {
	    return pluggableElementTypes.BaseDisplay.named('BaseLinearApolloDisplay')
	        .props({
	        type: require$$1$3.types.literal('LinearApolloDisplay'),
	        configuration: configuration.ConfigurationReference(configSchema),
	        graphical: true,
	        table: false,
	        showStartCodons: false,
	        showStopCodons: true,
	        highContrast: false,
	        heightPreConfig: require$$1$3.types.maybe(require$$1$3.types.refinement('displayHeight', require$$1$3.types.number, (n) => n >= minDisplayHeight$1)),
	        filteredFeatureTypes: require$$1$3.types.array(require$$1$3.types.string),
	        loadingState: false,
	    })
	        .views((self) => {
	        const { configuration, renderProps: superRenderProps } = self;
	        return {
	            renderProps() {
	                return {
	                    ...superRenderProps(),
	                    ...tracks.getParentRenderProps(self),
	                    config: configuration.renderer,
	                };
	            },
	        };
	    })
	        .volatile(() => ({
	        scrollTop: 0,
	    }))
	        .views((self) => ({
	        get lgv() {
	            return require$$1$2.getContainingView(self);
	        },
	        get height() {
	            if (self.heightPreConfig) {
	                return self.heightPreConfig;
	            }
	            if (self.graphical && self.table) {
	                return 500;
	            }
	            if (self.graphical) {
	                return 200;
	            }
	            return 300;
	        },
	        get loading() {
	            return self.loadingState;
	        },
	    }))
	        .views((self) => ({
	        get rendererTypeName() {
	            return self.configuration.renderer.type;
	        },
	        get session() {
	            return require$$1$2.getSession(self);
	        },
	        get regions() {
	            const regions = self.lgv.dynamicBlocks.contentBlocks.map(({ assemblyName, end, refName, start }) => ({
	                assemblyName,
	                refName,
	                start: Math.round(start),
	                end: Math.round(end),
	            }));
	            return regions;
	        },
	        regionCannotBeRendered( /* region */) {
	            if (self.lgv && self.lgv.bpPerPx >= 200) {
	                return 'Zoom in to see annotations';
	            }
	            return;
	        },
	    }))
	        .views((self) => ({
	        get apolloInternetAccount() {
	            const [region] = self.regions;
	            const { internetAccounts } = require$$1$3.getRoot(self);
	            const { assemblyName } = region;
	            const { assemblyManager } = self.session;
	            const assembly = assemblyManager.get(assemblyName);
	            if (!assembly) {
	                throw new Error(`No assembly found with name ${assemblyName}`);
	            }
	            const { internetAccountConfigId } = configuration.getConf(assembly, [
	                'sequence',
	                'metadata',
	            ]);
	            return internetAccounts.find((ia) => configuration.getConf(ia, 'internetAccountId') === internetAccountConfigId);
	        },
	        get changeManager() {
	            return self.session.apolloDataStore
	                .changeManager;
	        },
	        getAssemblyId(assemblyName) {
	            const { assemblyManager } = self.session;
	            const assembly = assemblyManager.get(assemblyName);
	            if (!assembly) {
	                throw new Error(`Could not find assembly named ${assemblyName}`);
	            }
	            return assembly.name;
	        },
	        get selectedFeature() {
	            return self.session
	                .apolloSelectedFeature;
	        },
	    }))
	        .actions((self) => ({
	        setScrollTop(scrollTop) {
	            self.scrollTop = scrollTop;
	        },
	        setHeight(displayHeight) {
	            self.heightPreConfig = Math.max(displayHeight, minDisplayHeight$1);
	            return self.height;
	        },
	        resizeHeight(distance) {
	            const oldHeight = self.height;
	            const newHeight = this.setHeight(self.height + distance);
	            return newHeight - oldHeight;
	        },
	        showGraphicalOnly() {
	            self.graphical = true;
	            self.table = false;
	        },
	        showTableOnly() {
	            self.graphical = false;
	            self.table = true;
	        },
	        showGraphicalAndTable() {
	            self.graphical = true;
	            self.table = true;
	        },
	        toggleShowStartCodons() {
	            self.showStartCodons = !self.showStartCodons;
	        },
	        toggleShowStopCodons() {
	            self.showStopCodons = !self.showStopCodons;
	        },
	        toggleHighContrast() {
	            self.highContrast = !self.highContrast;
	        },
	        updateFilteredFeatureTypes(types) {
	            self.filteredFeatureTypes = require$$1$3.cast(types);
	        },
	        setLoading(loading) {
	            self.loadingState = loading;
	        },
	    }))
	        .views((self) => {
	        const { filteredFeatureTypes, trackMenuItems: superTrackMenuItems } = self;
	        return {
	            trackMenuItems() {
	                const { graphical, table, showStartCodons, showStopCodons, highContrast, } = self;
	                return [
	                    ...superTrackMenuItems(),
	                    {
	                        type: 'subMenu',
	                        label: 'Appearance',
	                        subMenu: [
	                            {
	                                label: 'Show graphical display',
	                                type: 'radio',
	                                checked: graphical && !table,
	                                onClick: () => {
	                                    self.showGraphicalOnly();
	                                },
	                            },
	                            {
	                                label: 'Show table display',
	                                type: 'radio',
	                                checked: table && !graphical,
	                                onClick: () => {
	                                    self.showTableOnly();
	                                },
	                            },
	                            {
	                                label: 'Show both graphical and table display',
	                                type: 'radio',
	                                checked: table && graphical,
	                                onClick: () => {
	                                    self.showGraphicalAndTable();
	                                },
	                            },
	                            {
	                                label: 'Show start codons',
	                                type: 'checkbox',
	                                checked: showStartCodons,
	                                onClick: () => {
	                                    self.toggleShowStartCodons();
	                                },
	                            },
	                            {
	                                label: 'Show stop codons',
	                                type: 'checkbox',
	                                checked: showStopCodons,
	                                onClick: () => {
	                                    self.toggleShowStopCodons();
	                                },
	                            },
	                            {
	                                label: 'Use high contrast colors',
	                                type: 'checkbox',
	                                checked: highContrast,
	                                onClick: () => {
	                                    self.toggleHighContrast();
	                                },
	                            },
	                        ],
	                    },
	                    {
	                        label: 'Filter features by type',
	                        onClick: () => {
	                            const session = self.session;
	                            self.session.queueDialog((doneCallback) => [
	                                FilterFeatures,
	                                {
	                                    session,
	                                    handleClose: () => {
	                                        doneCallback();
	                                    },
	                                    featureTypes: require$$1$3.getSnapshot(filteredFeatureTypes),
	                                    onUpdate: (types) => {
	                                        self.updateFilteredFeatureTypes(types);
	                                    },
	                                },
	                            ]);
	                        },
	                    },
	                ];
	            },
	        };
	    })
	        .actions((self) => ({
	        setSelectedFeature(feature) {
	            self.session.apolloSetSelectedFeature(feature);
	        },
	        showFeatureDetailsWidget(feature, customWidgetNameAndId) {
	            const [region] = self.regions;
	            const { assemblyName, refName } = region;
	            const assembly = self.getAssemblyId(assemblyName);
	            if (!assembly) {
	                return;
	            }
	            const { session } = self;
	            const { changeManager } = session.apolloDataStore;
	            const [widgetName, widgetId] = customWidgetNameAndId ?? [
	                'ApolloFeatureDetailsWidget',
	                'apolloFeatureDetailsWidget',
	            ];
	            const apolloFeatureWidget = session.addWidget(widgetName, widgetId, {
	                feature,
	                assembly,
	                refName,
	                changeManager,
	            });
	            session.showWidget(apolloFeatureWidget);
	        },
	        afterAttach() {
	            require$$1$3.addDisposer(self, mobx.autorun(() => {
	                if (!self.lgv.initialized || self.regionCannotBeRendered()) {
	                    return;
	                }
	                self.setLoading(true);
	                void self.session.apolloDataStore
	                    .loadFeatures(self.regions)
	                    .then(() => {
	                    setTimeout(() => {
	                        self.setLoading(false);
	                    }, 1000);
	                });
	                if (self.lgv.bpPerPx <= 3) {
	                    void self.session.apolloDataStore.loadRefSeq(self.regions);
	                }
	            }, { name: 'LinearApolloDisplayLoadFeatures', delay: 1000 }));
	        },
	    }));
	}

	/* eslint-disable @typescript-eslint/no-unnecessary-condition */
	function getRowsForFeature(startingRow, rowCount, filledRowLocations) {
	    const rowsForFeature = [];
	    for (let i = startingRow; i < startingRow + rowCount; i++) {
	        const row = filledRowLocations.get(i);
	        if (row) {
	            rowsForFeature.push(row);
	        }
	    }
	    return rowsForFeature;
	}
	function canPlaceFeatureInRows(rowsForFeature, feature) {
	    for (const rowForFeature of rowsForFeature) {
	        for (const [rowStart, rowEnd] of rowForFeature) {
	            if (require$$1$2.doesIntersect2(feature.min, feature.max, rowStart, rowEnd) ||
	                require$$1$2.doesIntersect2(rowStart, rowEnd, feature.min, feature.max)) {
	                return false;
	            }
	        }
	    }
	    return true;
	}
	function layoutsModelFactory$1(pluginManager, configSchema) {
	    const BaseLinearApolloDisplay = baseModelFactory$1(pluginManager, configSchema);
	    return BaseLinearApolloDisplay.named('LinearApolloDisplayLayouts')
	        .props({
	        cleanupBoundary: 200_000,
	    })
	        .volatile(() => ({
	        seenFeatures: mobx.observable.map(),
	    }))
	        .views((self) => ({
	        getAnnotationFeatureById(id) {
	            return self.seenFeatures.get(id);
	        },
	        getGlyph(feature) {
	            if (feature.looksLikeGene) {
	                return geneGlyph$1;
	            }
	            if (feature.children?.size) {
	                return genericChildGlyph;
	            }
	            return boxGlyph;
	        },
	    }))
	        .actions((self) => ({
	        addSeenFeature(feature) {
	            self.seenFeatures.set(feature._id, feature);
	        },
	        deleteSeenFeature(featureId) {
	            self.seenFeatures.delete(featureId);
	        },
	    }))
	        .views((self) => ({
	        get featureLayouts() {
	            const { assemblyManager } = self.session;
	            return self.lgv.displayedRegions.map((region) => {
	                const assembly = assemblyManager.get(region.assemblyName);
	                const featureLayout = new Map();
	                // Track the occupied coordinates in each row
	                const filledRowLocations = new Map();
	                const { end, refName, start } = region;
	                for (const [id, feature] of self.seenFeatures.entries()) {
	                    if (!require$$1$3.isAlive(feature)) {
	                        self.deleteSeenFeature(id);
	                        continue;
	                    }
	                    if (refName !== assembly?.getCanonicalRefName(feature.refSeq) ||
	                        !require$$1$2.doesIntersect2(start, end, feature.min, feature.max) ||
	                        (self.filteredFeatureTypes.length > 0 &&
	                            !self.filteredFeatureTypes.includes(feature.type))) {
	                        continue;
	                    }
	                    const { featureTypeOntology } = self.session.apolloDataStore.ontologyManager;
	                    if (!featureTypeOntology) {
	                        throw new Error('featureTypeOntology is undefined');
	                    }
	                    const rowCount = self
	                        .getGlyph(feature)
	                        .getRowCount(feature, featureTypeOntology, self.lgv.bpPerPx);
	                    let startingRow = 0;
	                    let placed = false;
	                    while (!placed) {
	                        let rowsForFeature = getRowsForFeature(startingRow, rowCount, filledRowLocations);
	                        if (rowsForFeature.length < rowCount) {
	                            for (let i = 0; i < rowCount - rowsForFeature.length; i++) {
	                                const newRowNumber = filledRowLocations.size;
	                                filledRowLocations.set(newRowNumber, []);
	                                featureLayout.set(newRowNumber, []);
	                            }
	                            rowsForFeature = getRowsForFeature(startingRow, rowCount, filledRowLocations);
	                        }
	                        if (!canPlaceFeatureInRows(rowsForFeature, feature)) {
	                            startingRow += 1;
	                            continue;
	                        }
	                        for (let rowNum = startingRow; rowNum < startingRow + rowCount; rowNum++) {
	                            filledRowLocations.get(rowNum)?.push([feature.min, feature.max]);
	                            const layoutRow = featureLayout.get(rowNum);
	                            layoutRow?.push([rowNum - startingRow, feature._id]);
	                        }
	                        placed = true;
	                    }
	                }
	                return featureLayout;
	            });
	        },
	        getFeatureLayoutPosition(feature) {
	            const { featureLayouts } = this;
	            const { featureTypeOntology } = self.session.apolloDataStore.ontologyManager;
	            for (const [idx, layout] of featureLayouts.entries()) {
	                for (const [layoutRowNum, layoutRow] of layout) {
	                    for (const [featureRowNum, layoutFeatureId] of layoutRow) {
	                        if (featureRowNum !== 0) {
	                            // Same top-level feature in all feature rows, so only need to
	                            // check the first one
	                            continue;
	                        }
	                        const layoutFeature = self.getAnnotationFeatureById(layoutFeatureId);
	                        if (!layoutFeature) {
	                            continue;
	                        }
	                        if (feature._id === layoutFeature._id) {
	                            return {
	                                layoutIndex: idx,
	                                layoutRow: layoutRowNum,
	                                featureRow: featureRowNum,
	                            };
	                        }
	                        if (layoutFeature.hasDescendant(feature._id)) {
	                            if (!featureTypeOntology) {
	                                throw new Error('featureTypeOntology is undefined');
	                            }
	                            const row = self
	                                .getGlyph(layoutFeature)
	                                .getRowForFeature(layoutFeature, feature, featureTypeOntology);
	                            if (row !== undefined) {
	                                return {
	                                    layoutIndex: idx,
	                                    layoutRow: layoutRowNum,
	                                    featureRow: row,
	                                };
	                            }
	                        }
	                    }
	                }
	            }
	            return;
	        },
	    }))
	        .views((self) => ({
	        get highestRow() {
	            return Math.max(0, ...self.featureLayouts.map((layout) => Math.max(...layout.keys())));
	        },
	    }))
	        .actions((self) => ({
	        afterAttach() {
	            require$$1$3.addDisposer(self, mobx.autorun(() => {
	                if (!self.lgv.initialized || self.regionCannotBeRendered()) {
	                    return;
	                }
	                // Clear out features that are no longer in the view and out of the cleanup boundary
	                // cleanup boundary + region boundary + cleanup boundary
	                for (const [id, feature] of self.seenFeatures.entries()) {
	                    let shouldKeep = false;
	                    for (const region of self.regions) {
	                        const extendedStart = region.start - self.cleanupBoundary;
	                        const extendedEnd = region.end + self.cleanupBoundary;
	                        if (require$$1$2.doesIntersect2(extendedStart, extendedEnd, feature.min, feature.max)) {
	                            shouldKeep = true;
	                            break;
	                        }
	                    }
	                    if (!shouldKeep) {
	                        self.deleteSeenFeature(id);
	                    }
	                }
	                // Add features that are in the current view
	                for (const region of self.regions) {
	                    const assembly = self.session.apolloDataStore.assemblies.get(region.assemblyName);
	                    const ref = assembly?.getByRefName(region.refName);
	                    const features = ref?.features;
	                    if (!features) {
	                        continue;
	                    }
	                    for (const [, feature] of features) {
	                        if (require$$1$2.doesIntersect2(region.start, region.end, feature.min, feature.max) &&
	                            !self.seenFeatures.has(feature._id)) {
	                            self.addSeenFeature(feature);
	                        }
	                    }
	                }
	            }, { name: 'LinearApolloDisplaySetSeenFeatures', delay: 1000 }));
	        },
	    }));
	}

	function renderingModelIntermediateFactory$1(pluginManager, configSchema) {
	    const LinearApolloDisplayLayouts = layoutsModelFactory$1(pluginManager, configSchema);
	    return LinearApolloDisplayLayouts.named('LinearApolloDisplayRendering')
	        .props({
	        sequenceRowHeight: 15,
	        apolloRowHeight: 20,
	        detailsMinHeight: 200,
	        detailsHeight: 200,
	        lastRowTooltipBufferHeight: 40,
	        isShown: true,
	        filteredTranscripts: require$$1$3.types.array(require$$1$3.types.string),
	    })
	        .volatile(() => ({
	        canvas: null,
	        overlayCanvas: null,
	        collaboratorCanvas: null,
	        seqTrackCanvas: null,
	        seqTrackOverlayCanvas: null,
	        theme: undefined,
	    }))
	        .views((self) => ({
	        get featuresHeight() {
	            return ((self.highestRow + 1) * self.apolloRowHeight +
	                self.lastRowTooltipBufferHeight);
	        },
	    }))
	        .actions((self) => ({
	        toggleShown() {
	            self.isShown = !self.isShown;
	        },
	        setDetailsHeight(newHeight) {
	            self.detailsHeight = self.isShown
	                ? Math.max(Math.min(newHeight, self.height - 100), Math.min(self.height, self.detailsMinHeight))
	                : newHeight;
	        },
	        setCanvas(canvas) {
	            self.canvas = canvas;
	        },
	        setOverlayCanvas(canvas) {
	            self.overlayCanvas = canvas;
	        },
	        setCollaboratorCanvas(canvas) {
	            self.collaboratorCanvas = canvas;
	        },
	        setSeqTrackCanvas(canvas) {
	            self.seqTrackCanvas = canvas;
	        },
	        setSeqTrackOverlayCanvas(canvas) {
	            self.seqTrackOverlayCanvas = canvas;
	        },
	        setTheme(theme) {
	            self.theme = theme;
	        },
	        afterAttach() {
	            require$$1$3.addDisposer(self, mobx.autorun(() => {
	                if (!self.lgv.initialized || self.regionCannotBeRendered()) {
	                    return;
	                }
	                const ctx = self.collaboratorCanvas?.getContext('2d');
	                if (!ctx) {
	                    return;
	                }
	                ctx.clearRect(0, 0, self.lgv.dynamicBlocks.totalWidthPx, self.featuresHeight);
	                for (const collaborator of self.session.collaborators) {
	                    const { locations } = collaborator;
	                    if (locations.length === 0) {
	                        continue;
	                    }
	                    let idx = 0;
	                    for (const displayedRegion of self.lgv.displayedRegions) {
	                        for (const location of locations) {
	                            if (location.refSeq !== displayedRegion.refName) {
	                                continue;
	                            }
	                            const { end, refSeq, start } = location;
	                            const locationStartPxInfo = self.lgv.bpToPx({
	                                refName: refSeq,
	                                coord: start,
	                                regionNumber: idx,
	                            });
	                            if (!locationStartPxInfo) {
	                                continue;
	                            }
	                            const locationStartPx = locationStartPxInfo.offsetPx - self.lgv.offsetPx;
	                            const locationWidthPx = (end - start) / self.lgv.bpPerPx;
	                            ctx.fillStyle = 'rgba(0,255,0,.2)';
	                            ctx.fillRect(locationStartPx, 1, locationWidthPx, 100);
	                            ctx.fillStyle = 'black';
	                            ctx.fillText(collaborator.name, locationStartPx + 1, 11, locationWidthPx - 2);
	                        }
	                        idx++;
	                    }
	                }
	            }, { name: 'LinearApolloDisplayRenderCollaborators' }));
	        },
	    }));
	}
	function colorCode(letter, theme) {
	    return (theme?.palette.bases[letter.toUpperCase()].main.toString() ?? 'lightgray');
	}
	function codonColorCode(letter, highContrast) {
	    const colorMap = {
	        M: '#33ee33',
	        '*': highContrast ? '#000000' : '#f44336',
	    };
	    return colorMap[letter.toUpperCase()];
	}
	function reverseCodonSeq(seq) {
	    // disable because sequence is all ascii
	    // eslint-disable-next-line @typescript-eslint/no-misused-spread
	    return [...seq]
	        .map((c) => require$$1$2.revcom(c))
	        .reverse()
	        .join('');
	}
	function drawLetter(seqTrackctx, startPx, widthPx, letter, textY) {
	    const fontSize = Math.min(widthPx, 10);
	    seqTrackctx.fillStyle = '#000';
	    seqTrackctx.font = `${fontSize}px`;
	    const textWidth = seqTrackctx.measureText(letter).width;
	    const textX = startPx + (widthPx - textWidth) / 2;
	    seqTrackctx.fillText(letter, textX, textY + 10);
	}
	function drawTranslation(seqTrackctx, bpPerPx, trnslStartPx, trnslY, trnslWidthPx, sequenceRowHeight, seq, i, reverse, showStartCodons, showStopCodons, highContrast) {
	    let codonSeq = seq.slice(i, i + 3).toUpperCase();
	    if (reverse) {
	        codonSeq = reverseCodonSeq(codonSeq);
	    }
	    const codonLetter = require$$1$2.defaultCodonTable[codonSeq];
	    if (!codonLetter) {
	        return;
	    }
	    const fillColor = codonColorCode(codonLetter, highContrast);
	    if (fillColor &&
	        ((showStopCodons && codonLetter == '*') ||
	            (showStartCodons && codonLetter != '*'))) {
	        seqTrackctx.fillStyle = fillColor;
	        seqTrackctx.fillRect(trnslStartPx, trnslY, trnslWidthPx, sequenceRowHeight);
	    }
	    if (bpPerPx <= 0.1) {
	        seqTrackctx.rect(trnslStartPx, trnslY, trnslWidthPx, sequenceRowHeight);
	        seqTrackctx.stroke();
	        drawLetter(seqTrackctx, trnslStartPx, trnslWidthPx, codonLetter, trnslY);
	    }
	}
	function sequenceRenderingModelFactory(pluginManager, configSchema) {
	    const LinearApolloDisplayRendering = renderingModelIntermediateFactory$1(pluginManager, configSchema);
	    return LinearApolloDisplayRendering.actions((self) => ({
	        afterAttach() {
	            require$$1$3.addDisposer(self, mobx.autorun(() => {
	                const { theme } = self;
	                if (!self.lgv.initialized || self.regionCannotBeRendered()) {
	                    return;
	                }
	                const trnslWidthPx = 3 / self.lgv.bpPerPx;
	                if (trnslWidthPx < 1) {
	                    return;
	                }
	                const seqTrackctx = self.seqTrackCanvas?.getContext('2d');
	                if (!seqTrackctx) {
	                    return;
	                }
	                seqTrackctx.clearRect(0, 0, self.lgv.dynamicBlocks.totalWidthPx, self.lgv.bpPerPx <= 1 ? 125 : 95);
	                const frames = self.lgv.bpPerPx <= 1
	                    ? [3, 2, 1, 0, 0, -1, -2, -3]
	                    : [3, 2, 1, -1, -2, -3];
	                let height = 0;
	                if (theme) {
	                    for (const frame of frames) {
	                        let frameColor = theme.palette.framesCDS.at(frame)?.main;
	                        if (frameColor) {
	                            let offsetPx = 0;
	                            if (self.highContrast) {
	                                frameColor = 'white';
	                                offsetPx = 1;
	                                // eslint-disable-next-line prefer-destructuring
	                                seqTrackctx.fillStyle = theme.palette.grey[200];
	                                seqTrackctx.fillRect(0, height, self.lgv.dynamicBlocks.totalWidthPx, self.sequenceRowHeight);
	                            }
	                            seqTrackctx.fillStyle = frameColor;
	                            seqTrackctx.fillRect(0 + offsetPx, height + offsetPx, self.lgv.dynamicBlocks.totalWidthPx - 2 * offsetPx, self.sequenceRowHeight - 2 * offsetPx);
	                        }
	                        height += self.sequenceRowHeight;
	                    }
	                }
	                for (const [idx, region] of self.regions.entries()) {
	                    const { apolloDataStore } = self.session;
	                    const assembly = apolloDataStore.assemblies.get(region.assemblyName);
	                    const ref = assembly?.getByRefName(region.refName);
	                    const seq = ref?.getSequence(region.start, region.end);
	                    if (!seq) {
	                        return;
	                    }
	                    // disable because sequence is all ascii
	                    // eslint-disable-next-line @typescript-eslint/no-misused-spread
	                    for (const [i, letter] of [...seq].entries()) {
	                        const trnslXOffset = (self.lgv.bpToPx({
	                            refName: region.refName,
	                            coord: region.start + i,
	                            regionNumber: idx,
	                        })?.offsetPx ?? 0) - self.lgv.offsetPx;
	                        const trnslStartPx = self.lgv.displayedRegions[idx].reversed
	                            ? trnslXOffset - trnslWidthPx
	                            : trnslXOffset;
	                        // Draw translation forward
	                        for (let j = 2; j >= 0; j--) {
	                            if ((region.start + i) % 3 === j) {
	                                drawTranslation(seqTrackctx, self.lgv.bpPerPx, trnslStartPx, self.sequenceRowHeight * (2 - j), trnslWidthPx, self.sequenceRowHeight, seq, i, false, self.showStartCodons, self.showStopCodons, self.highContrast);
	                            }
	                        }
	                        if (self.lgv.bpPerPx <= 1) {
	                            const xOffset = (self.lgv.bpToPx({
	                                refName: region.refName,
	                                coord: region.start + i,
	                                regionNumber: idx,
	                            })?.offsetPx ?? 0) - self.lgv.offsetPx;
	                            const widthPx = 1 / self.lgv.bpPerPx;
	                            const startPx = self.lgv.displayedRegions[idx].reversed
	                                ? xOffset - widthPx
	                                : xOffset;
	                            // Draw forward
	                            seqTrackctx.beginPath();
	                            seqTrackctx.fillStyle = colorCode(letter, self.theme);
	                            seqTrackctx.rect(startPx, self.sequenceRowHeight * 3, widthPx, self.sequenceRowHeight);
	                            seqTrackctx.fill();
	                            if (self.lgv.bpPerPx <= 0.1) {
	                                seqTrackctx.stroke();
	                                drawLetter(seqTrackctx, startPx, widthPx, letter, self.sequenceRowHeight * 3);
	                            }
	                            // Draw reverse
	                            const revLetter = require$$1$2.revcom(letter);
	                            seqTrackctx.beginPath();
	                            seqTrackctx.fillStyle = colorCode(revLetter, self.theme);
	                            seqTrackctx.rect(startPx, self.sequenceRowHeight * 4, widthPx, self.sequenceRowHeight);
	                            seqTrackctx.fill();
	                            if (self.lgv.bpPerPx <= 0.1) {
	                                seqTrackctx.stroke();
	                                drawLetter(seqTrackctx, startPx, widthPx, revLetter, self.sequenceRowHeight * 4);
	                            }
	                        }
	                        // Draw translation reverse
	                        for (let k = 0; k <= 2; k++) {
	                            const rowOffset = self.lgv.bpPerPx <= 1 ? 5 : 3;
	                            if ((region.start + i) % 3 === k) {
	                                drawTranslation(seqTrackctx, self.lgv.bpPerPx, trnslStartPx, self.sequenceRowHeight * (rowOffset + k), trnslWidthPx, self.sequenceRowHeight, seq, i, true, self.showStartCodons, self.showStopCodons, self.highContrast);
	                            }
	                        }
	                    }
	                }
	            }, { name: 'LinearApolloDisplayRenderSequence' }));
	        },
	    }));
	}
	function renderingModelFactory$1(pluginManager, configSchema) {
	    const LinearApolloDisplayRendering = sequenceRenderingModelFactory(pluginManager, configSchema);
	    return LinearApolloDisplayRendering.actions((self) => ({
	        afterAttach() {
	            require$$1$3.addDisposer(self, mobx.autorun(() => {
	                const { canvas, featureLayouts, featuresHeight, lgv } = self;
	                if (!lgv.initialized || self.regionCannotBeRendered()) {
	                    return;
	                }
	                const { displayedRegions, dynamicBlocks } = lgv;
	                const ctx = canvas?.getContext('2d');
	                if (!ctx) {
	                    return;
	                }
	                ctx.clearRect(0, 0, dynamicBlocks.totalWidthPx, featuresHeight);
	                for (const [idx, featureLayout] of featureLayouts.entries()) {
	                    const displayedRegion = displayedRegions[idx];
	                    for (const [row, featureLayoutRow] of featureLayout.entries()) {
	                        for (const [featureRow, featureId] of featureLayoutRow) {
	                            const feature = self.getAnnotationFeatureById(featureId);
	                            if (featureRow > 0 || !feature) {
	                                continue;
	                            }
	                            if (!require$$1$2.doesIntersect2(displayedRegion.start, displayedRegion.end, feature.min, feature.max)) {
	                                continue;
	                            }
	                            self.getGlyph(feature).draw(ctx, feature, row, self, idx);
	                        }
	                    }
	                }
	            }, { name: 'LinearApolloDisplayRenderFeatures' }));
	        },
	    }));
	}

	function isMousePositionWithFeatureAndGlyph$1(mousePosition) {
	    return 'featureAndGlyphUnderMouse' in mousePosition;
	}
	function getMousePosition$1(event, lgv) {
	    const canvas = event.currentTarget;
	    const { clientX, clientY } = event;
	    const { left, top } = canvas.getBoundingClientRect();
	    const x = clientX - left;
	    const y = clientY - top;
	    const { coord: bp, index: regionNumber, refName } = lgv.pxToBp(x);
	    return { x, y, refName, bp, regionNumber };
	}
	function getTranslationRow(frame, bpPerPx) {
	    const offset = bpPerPx <= 1 ? 2 : 0;
	    switch (frame) {
	        case 3: {
	            return 0;
	        }
	        case 2: {
	            return 1;
	        }
	        case 1: {
	            return 2;
	        }
	        case -1: {
	            return 3 + offset;
	        }
	        case -2: {
	            return 4 + offset;
	        }
	        case -3: {
	            return 5 + offset;
	        }
	    }
	}
	function getSeqRow(strand, bpPerPx) {
	    if (bpPerPx > 1 || strand === undefined) {
	        return;
	    }
	    return strand === 1 ? 3 : 4;
	}
	function highlightSeq(seqTrackOverlayctx, theme, startPx, sequenceRowHeight, row, widthPx) {
	    if (row !== undefined) {
	        seqTrackOverlayctx.fillStyle =
	            theme?.palette.action.focus ?? 'rgba(0,0,0,0.04)';
	        seqTrackOverlayctx.fillRect(startPx, sequenceRowHeight * row, widthPx, sequenceRowHeight);
	    }
	}
	function mouseEventsModelIntermediateFactory$1(pluginManager, configSchema) {
	    const LinearApolloDisplayRendering = renderingModelFactory$1(pluginManager, configSchema);
	    return LinearApolloDisplayRendering.named('LinearApolloDisplayMouseEvents')
	        .volatile(() => ({
	        apolloDragging: null,
	        cursor: undefined,
	        apolloHover: undefined,
	    }))
	        .views((self) => ({
	        getMousePosition(event) {
	            const mousePosition = getMousePosition$1(event, self.lgv);
	            const { bp, regionNumber, y } = mousePosition;
	            const row = Math.floor(y / self.apolloRowHeight);
	            const featureLayout = self.featureLayouts[regionNumber];
	            const layoutRow = featureLayout.get(row);
	            if (!layoutRow) {
	                return mousePosition;
	            }
	            const foundFeature = layoutRow.find((f) => {
	                const feature = self.getAnnotationFeatureById(f[1]);
	                return feature && bp >= feature.min && bp <= feature.max;
	            });
	            if (!foundFeature) {
	                return mousePosition;
	            }
	            const [featureRow, topLevelFeatureId] = foundFeature;
	            const topLevelFeature = self.getAnnotationFeatureById(topLevelFeatureId);
	            if (!topLevelFeature) {
	                return mousePosition;
	            }
	            const glyph = self.getGlyph(topLevelFeature);
	            const { featureTypeOntology } = self.session.apolloDataStore.ontologyManager;
	            if (!featureTypeOntology) {
	                throw new Error('featureTypeOntology is undefined');
	            }
	            const feature = glyph.getFeatureFromLayout(topLevelFeature, bp, featureRow, featureTypeOntology);
	            if (!feature) {
	                return mousePosition;
	            }
	            return {
	                ...mousePosition,
	                featureAndGlyphUnderMouse: { feature, topLevelFeature, glyph },
	            };
	        },
	    }))
	        .actions((self) => ({
	        continueDrag(mousePosition, event) {
	            if (!self.apolloDragging) {
	                throw new Error('continueDrag() called with no current drag in progress');
	            }
	            event.stopPropagation();
	            self.apolloDragging = { ...self.apolloDragging, current: mousePosition };
	        },
	        setDragging(dragInfo) {
	            self.apolloDragging = dragInfo ?? null;
	        },
	    }))
	        .actions((self) => ({
	        setApolloHover(n) {
	            self.apolloHover = n;
	        },
	        setCursor(cursor) {
	            if (self.cursor !== cursor) {
	                self.cursor = cursor;
	            }
	        },
	        // eslint-disable-next-line @typescript-eslint/no-unused-vars
	        updateFilteredTranscripts(forms) {
	            return;
	        },
	    }))
	        .actions(() => ({
	        // onClick(event: CanvasMouseEvent) {
	        onClick() {
	            // TODO: set the selected feature
	        },
	    }));
	}
	function mouseEventsSeqHightlightModelFactory(pluginManager, configSchema) {
	    const LinearApolloDisplayRendering = mouseEventsModelIntermediateFactory$1(pluginManager, configSchema);
	    return LinearApolloDisplayRendering.actions((self) => ({
	        afterAttach() {
	            require$$1$3.addDisposer(self, mobx.autorun(() => {
	                // This type is wrong in @jbrowse/core
	                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	                if (!self.lgv.initialized || self.regionCannotBeRendered()) {
	                    return;
	                }
	                const seqTrackOverlayctx = self.seqTrackOverlayCanvas?.getContext('2d');
	                if (!seqTrackOverlayctx) {
	                    return;
	                }
	                seqTrackOverlayctx.clearRect(0, 0, self.lgv.dynamicBlocks.totalWidthPx, self.lgv.bpPerPx <= 1 ? 125 : 95);
	                const { apolloHover, lgv, regions, sequenceRowHeight, session, theme, } = self;
	                if (!apolloHover) {
	                    return;
	                }
	                const { feature } = apolloHover;
	                const { featureTypeOntology } = session.apolloDataStore.ontologyManager;
	                if (!featureTypeOntology) {
	                    throw new Error('featureTypeOntology is undefined');
	                }
	                for (const [idx, region] of regions.entries()) {
	                    if (featureTypeOntology.isTypeOf(feature.type, 'CDS')) {
	                        const parentFeature = feature.parent;
	                        if (!parentFeature) {
	                            continue;
	                        }
	                        const cdsLocs = parentFeature.cdsLocations.find((loc) => feature.min === loc.at(0)?.min &&
	                            feature.max === loc.at(-1)?.max);
	                        if (!cdsLocs) {
	                            continue;
	                        }
	                        for (const dl of cdsLocs) {
	                            const frame = require$$1$2.getFrame(dl.min, dl.max, feature.strand ?? 1, dl.phase);
	                            const row = getTranslationRow(frame, lgv.bpPerPx);
	                            const offset = (lgv.bpToPx({
	                                refName: region.refName,
	                                coord: dl.min,
	                                regionNumber: idx,
	                            })?.offsetPx ?? 0) - lgv.offsetPx;
	                            const widthPx = (dl.max - dl.min) / lgv.bpPerPx;
	                            const startPx = lgv.displayedRegions[idx].reversed
	                                ? offset - widthPx
	                                : offset;
	                            highlightSeq(seqTrackOverlayctx, theme, startPx, sequenceRowHeight, row, widthPx);
	                        }
	                    }
	                    else {
	                        const row = getSeqRow(feature.strand, lgv.bpPerPx);
	                        const offset = (lgv.bpToPx({
	                            refName: region.refName,
	                            coord: feature.min,
	                            regionNumber: idx,
	                        })?.offsetPx ?? 0) - lgv.offsetPx;
	                        const widthPx = feature.length / lgv.bpPerPx;
	                        const startPx = lgv.displayedRegions[idx].reversed
	                            ? offset - widthPx
	                            : offset;
	                        highlightSeq(seqTrackOverlayctx, theme, startPx, sequenceRowHeight, row, widthPx);
	                    }
	                }
	            }, { name: 'LinearApolloDisplayRenderSeqHighlight' }));
	        },
	    }));
	}
	function mouseEventsModelFactory$1(pluginManager, configSchema) {
	    const LinearApolloDisplayMouseEvents = mouseEventsSeqHightlightModelFactory(pluginManager, configSchema);
	    return LinearApolloDisplayMouseEvents.views((self) => ({
	        contextMenuItems(event) {
	            const { apolloHover } = self;
	            if (!apolloHover) {
	                return [];
	            }
	            const mousePosition = self.getMousePosition(event);
	            const { topLevelFeature } = apolloHover;
	            const glyph = self.getGlyph(topLevelFeature);
	            if (isMousePositionWithFeatureAndGlyph$1(mousePosition)) {
	                return glyph.getContextMenuItems(self, mousePosition);
	            }
	            return [];
	        },
	    }))
	        .actions((self) => ({
	        // explicitly pass in a feature in case it's not the same as the one in
	        // mousePosition (e.g. if features are drawn overlapping).
	        startDrag(mousePosition, feature, edge, shrinkParent = false) {
	            self.apolloDragging = {
	                start: mousePosition,
	                current: mousePosition,
	                feature,
	                edge,
	                shrinkParent,
	            };
	        },
	        endDrag() {
	            if (!self.apolloDragging) {
	                throw new Error('endDrag() called with no current drag in progress');
	            }
	            const { current, edge, feature, start, shrinkParent } = self.apolloDragging;
	            // don't do anything if it was only dragged a tiny bit
	            if (Math.abs(current.x - start.x) <= 4) {
	                self.setDragging();
	                self.setCursor();
	                return;
	            }
	            const { displayedRegions } = self.lgv;
	            const region = displayedRegions[start.regionNumber];
	            const assembly = self.getAssemblyId(region.assemblyName);
	            const changes = getPropagatedLocationChanges(feature, current.bp, edge, shrinkParent);
	            const change = edge === 'max'
	                ? new dist$2.LocationEndChange({
	                    typeName: 'LocationEndChange',
	                    changedIds: changes.map((c) => c.featureId),
	                    changes: changes.map((c) => ({
	                        featureId: c.featureId,
	                        oldEnd: c.oldLocation,
	                        newEnd: c.newLocation,
	                    })),
	                    assembly,
	                })
	                : new dist$2.LocationStartChange({
	                    typeName: 'LocationStartChange',
	                    changedIds: changes.map((c) => c.featureId),
	                    changes: changes.map((c) => ({
	                        featureId: c.featureId,
	                        oldStart: c.oldLocation,
	                        newStart: c.newLocation,
	                    })),
	                    assembly,
	                });
	            void self.changeManager.submit(change);
	            self.setDragging();
	            self.setCursor();
	        },
	    }))
	        .actions((self) => ({
	        onMouseDown(event) {
	            const mousePosition = self.getMousePosition(event);
	            if (isMousePositionWithFeatureAndGlyph$1(mousePosition)) {
	                mousePosition.featureAndGlyphUnderMouse.glyph.onMouseDown(self, mousePosition, event);
	            }
	        },
	        onMouseMove(event) {
	            const mousePosition = self.getMousePosition(event);
	            if (self.apolloDragging) {
	                self.setCursor('col-resize');
	                self.continueDrag(mousePosition, event);
	                return;
	            }
	            if (isMousePositionWithFeatureAndGlyph$1(mousePosition)) {
	                mousePosition.featureAndGlyphUnderMouse.glyph.onMouseMove(self, mousePosition, event);
	            }
	            else {
	                self.setApolloHover();
	                self.setCursor();
	            }
	        },
	        onMouseLeave(event) {
	            self.setDragging();
	            self.setApolloHover();
	            const mousePosition = self.getMousePosition(event);
	            if (isMousePositionWithFeatureAndGlyph$1(mousePosition)) {
	                mousePosition.featureAndGlyphUnderMouse.glyph.onMouseLeave(self, mousePosition, event);
	            }
	        },
	        onMouseUp(event) {
	            const mousePosition = self.getMousePosition(event);
	            if (isMousePositionWithFeatureAndGlyph$1(mousePosition)) {
	                mousePosition.featureAndGlyphUnderMouse.glyph.onMouseUp(self, mousePosition, event);
	            }
	            else {
	                self.setSelectedFeature();
	            }
	            if (self.apolloDragging) {
	                self.endDrag();
	            }
	        },
	    }))
	        .actions((self) => ({
	        afterAttach() {
	            require$$1$3.addDisposer(self, mobx.autorun(() => {
	                // This type is wrong in @jbrowse/core
	                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	                if (!self.lgv.initialized || self.regionCannotBeRendered()) {
	                    return;
	                }
	                const ctx = self.overlayCanvas?.getContext('2d');
	                if (!ctx) {
	                    return;
	                }
	                ctx.clearRect(0, 0, self.lgv.dynamicBlocks.totalWidthPx, self.featuresHeight);
	                const { apolloDragging, apolloHover } = self;
	                if (!apolloHover) {
	                    return;
	                }
	                const { glyph } = apolloHover;
	                // draw mouseover hovers
	                glyph.drawHover(self, ctx);
	                // draw tooltip on hover
	                glyph.drawTooltip(self, ctx);
	                // dragging previews
	                if (apolloDragging) {
	                    // NOTE: the glyph where the drag started is responsible for drawing the preview.
	                    // it can call methods in other glyphs to help with this though.
	                    const glyph = self.getGlyph(apolloDragging.feature.topLevelFeature);
	                    glyph.drawDragPreview(self, ctx);
	                }
	            }, { name: 'LinearApolloDisplayRenderMouseoverAndDrag' }));
	        },
	    }));
	}

	function stateModelFactory$1(pluginManager, configSchema) {
	    // TODO: this needs to be refactored so that the final composition of the
	    // state model mixins happens here in one central place
	    return mouseEventsModelFactory$1(pluginManager, configSchema)
	        .props({ tabularEditor: require$$1$3.types.optional(TabularEditorStateModelType, {}) })
	        .named('LinearApolloDisplay');
	}

	const configSchema = configuration.ConfigurationSchema('LinearApolloSixFrameDisplay', {}, { explicitIdentifier: 'displayId', explicitlyTyped: true });

	const FilterTranscripts = mobxReact.observer(function FilterTranscripts({ sourceFeature, filteredTranscripts, handleClose, onUpdate, }) {
	    const allTranscripts = [];
	    if (sourceFeature.children) {
	        for (const [, child] of sourceFeature.children) {
	            const childID = child.attributes
	                .get('gff_id')
	                ?.toString();
	            if (childID) {
	                allTranscripts.push(childID);
	            }
	        }
	    }
	    const [excludedTranscripts, setExcludedTranscripts] = React.useState(filteredTranscripts);
	    const handleChange = (value) => {
	        const newForms = excludedTranscripts.includes(value)
	            ? excludedTranscripts.filter((form) => form !== value)
	            : [...excludedTranscripts, value];
	        onUpdate(newForms);
	        setExcludedTranscripts(newForms);
	    };
	    return (React__default["default"].createElement(Dialog, { open: true, maxWidth: false, "data-testid": "filter-transcripts-dialog", title: "Filter transcripts by ID", handleClose: handleClose },
	        React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, null, "Select the alternate transcripts you want to display in the apollo track"),
	            React__default["default"].createElement(material.Grid2, { container: true, spacing: 2 },
	                React__default["default"].createElement(material.Grid2, { size: 8 },
	                    React__default["default"].createElement(material.FormGroup, null, allTranscripts.map((item) => (
	                    // eslint-disable-next-line react/jsx-key
	                    React__default["default"].createElement(material.FormControlLabel, { control: React__default["default"].createElement(material.Checkbox, { checked: !excludedTranscripts.includes(item), onChange: () => {
	                                handleChange(item);
	                            }, inputProps: { 'aria-label': 'controlled' } }), label: item })))))))));
	});

	let forwardFillLight = null;
	let backwardFillLight = null;
	let forwardFillDark = null;
	let backwardFillDark = null;
	const canvas = globalThis.document.createElement('canvas');
	// @ts-expect-error getContext is undefined in the web worker
	// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	if (canvas?.getContext) {
	    for (const direction of ['forward', 'backward']) {
	        for (const themeMode of ['light', 'dark']) {
	            const canvas = document.createElement('canvas');
	            const canvasSize = 10;
	            canvas.width = canvas.height = canvasSize;
	            const ctx = canvas.getContext('2d');
	            if (ctx) {
	                const stripeColor1 = themeMode === 'light' ? 'rgba(0,0,0,0)' : 'rgba(0,0,0,0.75)';
	                const stripeColor2 = themeMode === 'light' ? 'rgba(255,255,255,0.25)' : 'rgba(0,0,0,0.50)';
	                const gradient = direction === 'forward'
	                    ? ctx.createLinearGradient(0, canvasSize, canvasSize, 0)
	                    : ctx.createLinearGradient(0, 0, canvasSize, canvasSize);
	                gradient.addColorStop(0, stripeColor1);
	                gradient.addColorStop(0.25, stripeColor1);
	                gradient.addColorStop(0.25, stripeColor2);
	                gradient.addColorStop(0.5, stripeColor2);
	                gradient.addColorStop(0.5, stripeColor1);
	                gradient.addColorStop(0.75, stripeColor1);
	                gradient.addColorStop(0.75, stripeColor2);
	                gradient.addColorStop(1, stripeColor2);
	                ctx.fillStyle = gradient;
	                ctx.fillRect(0, 0, 10, 10);
	                if (direction === 'forward') {
	                    if (themeMode === 'light') {
	                        forwardFillLight = ctx.createPattern(canvas, 'repeat');
	                    }
	                    else {
	                        forwardFillDark = ctx.createPattern(canvas, 'repeat');
	                    }
	                }
	                else {
	                    if (themeMode === 'light') {
	                        backwardFillLight = ctx.createPattern(canvas, 'repeat');
	                    }
	                    else {
	                        backwardFillDark = ctx.createPattern(canvas, 'repeat');
	                    }
	                }
	            }
	        }
	    }
	}
	function deepSetHas(set, item) {
	    for (const elem of set) {
	        if (es6(elem, item)) {
	            return true;
	        }
	    }
	    return false;
	}
	function drawTextLabels(ctx, labelArray, font = '10px sans-serif') {
	    for (let i = labelArray.length - 1; i >= 0; --i) {
	        const label = labelArray[i];
	        ctx.fillStyle = label.color;
	        const labelRowX = Math.max(label.x + 1, 0);
	        const labelRowY = label.y + label.h;
	        const textWidth = require$$1$2.measureText(label.text, 10);
	        if (label.isSelected) {
	            ctx.clearRect(labelRowX - 5, labelRowY, textWidth + 10, label.h);
	            ctx.font = 'bold '.concat(font);
	        }
	        if (label.text) {
	            ctx.fillText(label.text, labelRowX, labelRowY + 11, textWidth);
	            ctx.font = font;
	        }
	    }
	}
	function draw(ctx, topLevelFeature, _row, stateModel, displayedRegionIndex) {
	    const { apolloRowHeight, lgv, session, theme, highestRow, filteredTranscripts, showFeatureLabels, } = stateModel;
	    const { bpPerPx, displayedRegions, offsetPx } = lgv;
	    const displayedRegion = displayedRegions[displayedRegionIndex];
	    const { refName, reversed } = displayedRegion;
	    const rowHeight = apolloRowHeight;
	    const exonHeight = rowHeight;
	    const cdsHeight = rowHeight;
	    const topLevelFeatureHeight = rowHeight;
	    const featureLabelSpacer = showFeatureLabels ? 2 : 1;
	    const textColor = theme?.palette.text.primary ?? 'black';
	    const { attributes, children, min, strand } = topLevelFeature;
	    if (!children) {
	        return;
	    }
	    const { apolloSelectedFeature } = session;
	    const { apolloDataStore } = session;
	    const { featureTypeOntology } = apolloDataStore.ontologyManager;
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    const labelArray = [];
	    // Draw background for gene
	    const topLevelFeatureMinX = (lgv.bpToPx({
	        refName,
	        coord: min,
	        regionNumber: displayedRegionIndex,
	    })?.offsetPx ?? 0) - offsetPx;
	    const topLevelFeatureWidthPx = topLevelFeature.length / bpPerPx;
	    const topLevelFeatureStartPx = reversed
	        ? topLevelFeatureMinX - topLevelFeatureWidthPx
	        : topLevelFeatureMinX;
	    const topLevelRow = (strand == 1 ? 3 : 4) * featureLabelSpacer;
	    const topLevelFeatureTop = topLevelRow * rowHeight;
	    ctx.fillStyle = theme?.palette.text.primary ?? 'black';
	    ctx.fillRect(topLevelFeatureStartPx, topLevelFeatureTop, topLevelFeatureWidthPx, topLevelFeatureHeight);
	    ctx.fillStyle = isSelectedFeature(topLevelFeature, apolloSelectedFeature)
	        ? material.alpha('rgb(0,0,0)', 0.7)
	        : material.alpha(theme?.palette.background.paper ?? '#ffffff', 0.7);
	    ctx.fillRect(topLevelFeatureStartPx + 1, topLevelFeatureTop + 1, topLevelFeatureWidthPx - 2, topLevelFeatureHeight - 2);
	    const isSelected = isSelectedFeature(topLevelFeature, apolloSelectedFeature);
	    const label = {
	        x: topLevelFeatureStartPx,
	        y: topLevelFeatureTop,
	        h: topLevelFeatureHeight,
	        text: attributes.get('gff_id')?.toString(),
	        color: textColor,
	        isSelected,
	    };
	    if (isSelected) {
	        labelArray.unshift(label);
	    }
	    else {
	        labelArray.push(label);
	    }
	    const forwardFill = theme?.palette.mode === 'dark' ? forwardFillDark : forwardFillLight;
	    const backwardFill = theme?.palette.mode === 'dark' ? backwardFillDark : backwardFillLight;
	    const reversal = reversed ? -1 : 1;
	    let topFill = null, bottomFill = null;
	    if (strand) {
	        [topFill, bottomFill] =
	            strand * reversal === 1
	                ? [forwardFill, backwardFill]
	                : [backwardFill, forwardFill];
	    }
	    if (topFill && bottomFill) {
	        ctx.fillStyle = topFill;
	        ctx.fillRect(topLevelFeatureStartPx + 1, topLevelFeatureTop + 1, topLevelFeatureWidthPx - 2, (topLevelFeatureHeight - 2) / 2);
	        ctx.fillStyle = bottomFill;
	        ctx.fillRect(topLevelFeatureStartPx + 1, topLevelFeatureTop + (topLevelFeatureHeight - 2) / 2, topLevelFeatureWidthPx - 2, (topLevelFeatureHeight - 2) / 2);
	    }
	    const renderedCDS = new Set();
	    // Draw exon and CDS for each mRNA
	    for (const [, child] of children) {
	        if (!(featureTypeOntology.isTypeOf(child.type, 'transcript') ||
	            featureTypeOntology.isTypeOf(child.type, 'pseudogenic_transcript'))) {
	            continue;
	        }
	        const { children: childrenOfmRNA, cdsLocations } = child;
	        if (!childrenOfmRNA) {
	            continue;
	        }
	        const childID = child.attributes
	            .get('gff_id')
	            ?.toString();
	        if (childID && filteredTranscripts.includes(childID)) {
	            continue;
	        }
	        for (const [, exon] of childrenOfmRNA) {
	            if (!featureTypeOntology.isTypeOf(exon.type, 'exon')) {
	                continue;
	            }
	            const minX = (lgv.bpToPx({
	                refName,
	                coord: exon.min,
	                regionNumber: displayedRegionIndex,
	            })?.offsetPx ?? 0) - offsetPx;
	            const widthPx = exon.length / bpPerPx;
	            const startPx = reversed ? minX - widthPx : minX;
	            const exonTop = topLevelFeatureTop + (topLevelFeatureHeight - exonHeight) / 2;
	            const isSelected = isSelectedFeature(exon, apolloSelectedFeature);
	            ctx.fillStyle = theme?.palette.text.primary ?? 'black';
	            ctx.fillRect(startPx, exonTop, widthPx, exonHeight);
	            if (widthPx > 2) {
	                ctx.clearRect(startPx + 1, exonTop + 1, widthPx - 2, exonHeight - 2);
	                ctx.fillStyle = isSelected ? 'rgb(0,0,0)' : material.alpha('#f5f500', 0.6);
	                ctx.fillRect(startPx + 1, exonTop + 1, widthPx - 2, exonHeight - 2);
	                if (topFill && bottomFill) {
	                    ctx.fillStyle = topFill;
	                    ctx.fillRect(startPx + 1, exonTop + 1, widthPx - 2, (exonHeight - 2) / 2);
	                    ctx.fillStyle = bottomFill;
	                    ctx.fillRect(startPx + 1, exonTop + 1 + (exonHeight - 2) / 2, widthPx - 2, (exonHeight - 2) / 2);
	                }
	                const label = {
	                    x: startPx,
	                    y: exonTop,
	                    h: exonHeight,
	                    text: exon.attributes.get('gff_id')?.toString(),
	                    color: textColor,
	                    isSelected,
	                };
	                if (isSelected) {
	                    labelArray.unshift(label);
	                }
	                else {
	                    labelArray.push(label);
	                }
	            }
	        }
	        const isSelected = isSelectedFeature(child, apolloSelectedFeature?.parent);
	        let cdsStartPx = 0;
	        let cdsTop = 0;
	        for (const cdsRow of cdsLocations) {
	            let prevCDSTop = 0;
	            let prevCDSEndPx = 0;
	            let counter = 1;
	            for (const cds of cdsRow.sort((a, b) => a.max - b.max)) {
	                if ((apolloSelectedFeature &&
	                    isSelected &&
	                    featureTypeOntology.isTypeOf(apolloSelectedFeature.type, 'CDS')) ||
	                    !deepSetHas(renderedCDS, cds)) {
	                    const cdsWidthPx = (cds.max - cds.min) / bpPerPx;
	                    const minX = (lgv.bpToPx({
	                        refName,
	                        coord: cds.min,
	                        regionNumber: displayedRegionIndex,
	                    })?.offsetPx ?? 0) - offsetPx;
	                    cdsStartPx = reversed ? minX - cdsWidthPx : minX;
	                    ctx.fillStyle = theme?.palette.text.primary ?? 'black';
	                    const frame = require$$1$2.getFrame(cds.min, cds.max, child.strand ?? 1, cds.phase);
	                    const frameAdjust = (frame < 0 ? -1 * frame + 5 : frame) * featureLabelSpacer;
	                    cdsTop = (frameAdjust - featureLabelSpacer) * rowHeight;
	                    ctx.fillRect(cdsStartPx, cdsTop, cdsWidthPx, cdsHeight);
	                    if (cdsWidthPx > 2) {
	                        ctx.clearRect(cdsStartPx + 1, cdsTop + 1, cdsWidthPx - 2, cdsHeight - 2);
	                        const frameColor = theme?.palette.framesCDS.at(frame)?.main;
	                        const cdsColorCode = frameColor ?? 'rgb(171,71,188)';
	                        ctx.fillStyle = cdsColorCode;
	                        ctx.fillStyle =
	                            apolloSelectedFeature &&
	                                isSelected &&
	                                featureTypeOntology.isTypeOf(apolloSelectedFeature.type, 'CDS')
	                                ? 'rgb(0,0,0)'
	                                : cdsColorCode;
	                        ctx.fillRect(cdsStartPx + 1, cdsTop + 1, cdsWidthPx - 2, cdsHeight - 2);
	                        // Draw lines to connect CDS features with shared mRNA parent
	                        if (counter > 1) {
	                            // Mid-point for intron line "hat"
	                            const midPoint = [
	                                (cdsStartPx - prevCDSEndPx) / 2 + prevCDSEndPx,
	                                Math.max(frame < 0
	                                    ? rowHeight * featureLabelSpacer * highestRow + 1
	                                    : 1, // Avoid render ceiling
	                                Math.min(prevCDSTop, cdsTop) - rowHeight / 2),
	                            ];
	                            ctx.strokeStyle = 'rgb(0, 128, 128)';
	                            ctx.beginPath();
	                            ctx.moveTo(prevCDSEndPx, prevCDSTop);
	                            ctx.lineTo(...midPoint);
	                            ctx.stroke();
	                            ctx.moveTo(...midPoint);
	                            ctx.lineTo(cdsStartPx, cdsTop + rowHeight / 2);
	                            ctx.stroke();
	                        }
	                        prevCDSEndPx = cdsStartPx + cdsWidthPx;
	                        prevCDSTop = cdsTop + rowHeight / 2;
	                        counter += 1;
	                        if (topFill && bottomFill) {
	                            ctx.fillStyle = topFill;
	                            ctx.fillRect(cdsStartPx + 1, cdsTop + 1, cdsWidthPx - 2, (cdsHeight - 2) / 2);
	                            ctx.fillStyle = bottomFill;
	                            ctx.fillRect(cdsStartPx + 1, cdsTop + (cdsHeight - 2) / 2, cdsWidthPx - 2, (cdsHeight - 2) / 2);
	                        }
	                    }
	                    renderedCDS.add(cds);
	                }
	            }
	        }
	        const label = {
	            x: cdsStartPx,
	            y: cdsTop,
	            h: cdsHeight,
	            text: child.attributes.get('gff_id')?.toString(),
	            color: textColor,
	            isSelected,
	        };
	        if (isSelected) {
	            labelArray.unshift(label);
	        }
	        else {
	            labelArray.push(label);
	        }
	    }
	    if (showFeatureLabels) {
	        drawTextLabels(ctx, labelArray);
	    }
	}
	function drawDragPreview(stateModel, overlayCtx) {
	    const { apolloDragging, apolloRowHeight, lgv, theme } = stateModel;
	    const { bpPerPx, displayedRegions, offsetPx } = lgv;
	    if (!apolloDragging) {
	        return;
	    }
	    const { current, edge, feature, start } = apolloDragging;
	    const row = Math.floor(start.y / apolloRowHeight);
	    const region = displayedRegions[start.regionNumber];
	    const rowCount = 1;
	    const featureEdgeBp = region.reversed
	        ? region.end - feature[edge]
	        : feature[edge] - region.start;
	    const featureEdgePx = featureEdgeBp / bpPerPx - offsetPx;
	    const rectX = Math.min(current.x, featureEdgePx);
	    const rectY = row * apolloRowHeight;
	    const rectWidth = Math.abs(current.x - featureEdgePx);
	    const rectHeight = apolloRowHeight * rowCount;
	    overlayCtx.strokeStyle = theme?.palette.info.main ?? 'rgb(255,0,0)';
	    overlayCtx.setLineDash([6]);
	    overlayCtx.strokeRect(rectX, rectY, rectWidth, rectHeight);
	    overlayCtx.fillStyle = material.alpha(theme?.palette.info.main ?? 'rgb(255,0,0)', 0.2);
	    overlayCtx.fillRect(rectX, rectY, rectWidth, rectHeight);
	}
	function drawHover(stateModel, ctx) {
	    const { apolloHover, apolloRowHeight, filteredTranscripts, lgv, highestRow, session, showFeatureLabels, } = stateModel;
	    if (!apolloHover) {
	        return;
	    }
	    const { apolloDataStore } = session;
	    const { featureTypeOntology } = apolloDataStore.ontologyManager;
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    const { feature } = apolloHover;
	    if (!featureTypeOntology.isTypeOf(feature.type, 'transcript')) {
	        return;
	    }
	    const featureID = feature.attributes
	        .get('gff_id')
	        ?.toString();
	    if (featureID && filteredTranscripts.includes(featureID)) {
	        return;
	    }
	    const position = stateModel.getFeatureLayoutPosition(feature);
	    if (!position) {
	        return;
	    }
	    const { bpPerPx, displayedRegions, offsetPx } = lgv;
	    const { layoutIndex } = position;
	    const displayedRegion = displayedRegions[layoutIndex];
	    const { refName, reversed } = displayedRegion;
	    const rowHeight = apolloRowHeight;
	    const cdsHeight = rowHeight;
	    const featureLabelSpacer = showFeatureLabels ? 2 : 1;
	    const { cdsLocations, strand } = feature;
	    for (const cdsRow of cdsLocations) {
	        let prevCDSTop = 0;
	        let prevCDSEndPx = 0;
	        let counter = 1;
	        for (const cds of cdsRow.sort((a, b) => a.max - b.max)) {
	            const cdsWidthPx = (cds.max - cds.min) / bpPerPx;
	            if (cdsWidthPx > 2) {
	                const minX = (lgv.bpToPx({
	                    refName,
	                    coord: cds.min,
	                    regionNumber: layoutIndex,
	                })?.offsetPx ?? 0) - offsetPx;
	                const cdsStartPx = reversed ? minX - cdsWidthPx : minX;
	                const frame = require$$1$2.getFrame(cds.min, cds.max, strand ?? 1, cds.phase);
	                const frameAdjust = (frame < 0 ? -1 * frame + 5 : frame) * featureLabelSpacer;
	                const cdsTop = (frameAdjust - featureLabelSpacer) * rowHeight;
	                ctx.fillStyle = 'rgba(255,0,0,0.6)';
	                ctx.fillRect(cdsStartPx, cdsTop, cdsWidthPx, cdsHeight);
	                if (counter > 1) {
	                    // Mid-point for intron line "hat"
	                    const midPoint = [
	                        (cdsStartPx - prevCDSEndPx) / 2 + prevCDSEndPx,
	                        Math.max(frame < 0 ? rowHeight * featureLabelSpacer * highestRow + 1 : 1, // Avoid render ceiling
	                        Math.min(prevCDSTop, cdsTop) - rowHeight / 2),
	                    ];
	                    ctx.strokeStyle = 'rgb(0, 0, 0)';
	                    ctx.lineWidth = 2;
	                    ctx.beginPath();
	                    ctx.moveTo(prevCDSEndPx, prevCDSTop);
	                    ctx.lineTo(...midPoint);
	                    ctx.stroke();
	                    ctx.moveTo(...midPoint);
	                    ctx.lineTo(cdsStartPx, cdsTop + rowHeight / 2);
	                    ctx.stroke();
	                }
	                prevCDSEndPx = cdsStartPx + cdsWidthPx;
	                prevCDSTop = cdsTop + rowHeight / 2;
	                counter += 1;
	            }
	        }
	    }
	}
	function onMouseDown(stateModel, currentMousePosition, event) {
	    const { featureAndGlyphUnderMouse } = currentMousePosition;
	    // swallow the mouseDown if we are on the edge of the feature so that we
	    // don't start dragging the view if we try to drag the feature edge
	    const { cds, feature } = featureAndGlyphUnderMouse;
	    const draggableFeature = getDraggableFeatureInfo(currentMousePosition, cds, feature, stateModel);
	    if (draggableFeature) {
	        event.stopPropagation();
	        stateModel.startDrag(currentMousePosition, draggableFeature.feature, draggableFeature.edge, true);
	    }
	}
	function onMouseMove(stateModel, mousePosition) {
	    if (isMousePositionWithFeatureAndGlyph(mousePosition)) {
	        const { featureAndGlyphUnderMouse } = mousePosition;
	        stateModel.setApolloHover(featureAndGlyphUnderMouse);
	        const { cds, feature } = featureAndGlyphUnderMouse;
	        const draggableFeature = getDraggableFeatureInfo(mousePosition, cds, feature, stateModel);
	        if (draggableFeature) {
	            stateModel.setCursor('col-resize');
	            return;
	        }
	    }
	    stateModel.setCursor();
	}
	function onMouseUp(stateModel, mousePosition) {
	    if (stateModel.apolloDragging) {
	        return;
	    }
	    const { featureAndGlyphUnderMouse } = mousePosition;
	    const { session } = stateModel;
	    const { apolloDataStore } = session;
	    const { featureTypeOntology } = apolloDataStore.ontologyManager;
	    if (!featureAndGlyphUnderMouse) {
	        return;
	    }
	    const { feature } = featureAndGlyphUnderMouse;
	    stateModel.setSelectedFeature(feature);
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    let containsCDSOrExon = false;
	    for (const [, child] of feature.children ?? []) {
	        if (featureTypeOntology.isTypeOf(child.type, 'CDS') ||
	            featureTypeOntology.isTypeOf(child.type, 'exon')) {
	            containsCDSOrExon = true;
	            break;
	        }
	    }
	    if ((featureTypeOntology.isTypeOf(feature.type, 'transcript') ||
	        featureTypeOntology.isTypeOf(feature.type, 'pseudogenic_transcript')) &&
	        containsCDSOrExon) {
	        stateModel.showFeatureDetailsWidget(feature, [
	            'ApolloTranscriptDetails',
	            'apolloTranscriptDetails',
	        ]);
	    }
	    else {
	        stateModel.showFeatureDetailsWidget(feature);
	    }
	}
	function isSelectedFeature(feature, selectedFeature) {
	    return Boolean(selectedFeature && feature._id === selectedFeature._id);
	}
	function getDraggableFeatureInfo(mousePosition, cds, feature, stateModel) {
	    const { filteredTranscripts, session } = stateModel;
	    const { apolloDataStore } = session;
	    const { featureTypeOntology } = apolloDataStore.ontologyManager;
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    const isTranscript = featureTypeOntology.isTypeOf(feature.type, 'transcript');
	    if (cds === null) {
	        return;
	    }
	    const featureID = feature.attributes
	        .get('gff_id')
	        ?.toString();
	    if (featureID && filteredTranscripts.includes(featureID)) {
	        return;
	    }
	    const { bp, refName, regionNumber, x } = mousePosition;
	    const { lgv } = stateModel;
	    if (isTranscript) {
	        const transcript = feature;
	        if (!transcript.children) {
	            return;
	        }
	        const exonChildren = [];
	        const cdsChildren = [];
	        for (const child of transcript.children.values()) {
	            const childIsExon = featureTypeOntology.isTypeOf(child.type, 'exon');
	            const childIsCDS = featureTypeOntology.isTypeOf(child.type, 'CDS');
	            if (childIsExon) {
	                exonChildren.push(child);
	            }
	            else if (childIsCDS) {
	                cdsChildren.push(child);
	            }
	        }
	        const overlappingExon = exonChildren.find((child) => {
	            const [start, end] = require$$1$2.intersection2(bp, bp + 1, child.min, child.max);
	            return start !== undefined && end !== undefined;
	        });
	        if (overlappingExon) {
	            // We are on an exon, are we on the edge of it?
	            const minMax = getMinAndMaxPx(overlappingExon, refName, regionNumber, lgv);
	            if (minMax) {
	                const overlappingEdge = getOverlappingEdge(overlappingExon, x, minMax);
	                if (overlappingEdge) {
	                    return overlappingEdge;
	                }
	            }
	        }
	        // End of special cases, let's see if we're on the edge of this CDS or exon
	        const minMax = getMinAndMaxPx(cds, refName, regionNumber, lgv);
	        if (minMax) {
	            const overlappingCDS = cdsChildren.find((child) => {
	                const [start, end] = require$$1$2.intersection2(bp, bp + 1, child.min, child.max);
	                return start !== undefined && end !== undefined;
	            });
	            if (overlappingCDS) {
	                const overlappingEdge = getOverlappingEdge(overlappingCDS, x, minMax);
	                if (overlappingEdge) {
	                    return overlappingEdge;
	                }
	            }
	        }
	    }
	    return;
	}
	function drawTooltip(display, context) {
	    const { apolloHover, apolloRowHeight, filteredTranscripts, lgv, theme } = display;
	    if (!apolloHover) {
	        return;
	    }
	    const { cds, feature } = apolloHover;
	    if (!cds) {
	        return;
	    }
	    const position = display.getFeatureLayoutPosition(feature);
	    if (!position) {
	        return;
	    }
	    const featureID = feature.attributes
	        .get('gff_id')
	        ?.toString();
	    if (featureID && filteredTranscripts.includes(featureID)) {
	        return;
	    }
	    const { layoutIndex } = position;
	    const { bpPerPx, displayedRegions, offsetPx } = lgv;
	    const displayedRegion = displayedRegions[layoutIndex];
	    const { refName, reversed } = displayedRegion;
	    const rowHeight = apolloRowHeight;
	    const cdsHeight = Math.round(0.7 * rowHeight);
	    let location = 'Loc: ';
	    const { strand } = feature;
	    const { max, min, phase } = cds;
	    location += `${min + 1}–${max}`;
	    let startPx = (lgv.bpToPx({
	        refName,
	        coord: reversed ? max : min,
	        regionNumber: layoutIndex,
	    })?.offsetPx ?? 0) - offsetPx;
	    const frame = require$$1$2.getFrame(min, max, strand ?? 1, phase);
	    const frameAdjust = frame < 0 ? -1 * frame + 5 : frame;
	    const cdsTop = (frameAdjust - 1) * rowHeight + (rowHeight - cdsHeight) / 2;
	    const cdsWidthPx = (max - min) / bpPerPx;
	    const featureType = `Type: ${cds.type}`;
	    const { attributes } = feature;
	    const featureName = attributes.get('gff_name')?.find((name) => name !== '');
	    const textWidth = [
	        context.measureText(featureType).width,
	        context.measureText(location).width,
	    ];
	    if (featureName) {
	        textWidth.push(context.measureText(`Parent Type: ${feature.type}`).width, context.measureText(`Parent Name: ${featureName}`).width);
	    }
	    const maxWidth = Math.max(...textWidth);
	    startPx = startPx + cdsWidthPx + 5;
	    context.fillStyle = material.alpha(theme?.palette.text.primary ?? 'rgb(1, 1, 1)', 0.7);
	    context.fillRect(startPx, cdsTop, maxWidth + 4, textWidth.length === 4 ? 55 : 35);
	    context.beginPath();
	    context.moveTo(startPx, cdsTop);
	    context.lineTo(startPx - 5, cdsTop + 5);
	    context.lineTo(startPx, cdsTop + 10);
	    context.fill();
	    context.fillStyle = theme?.palette.background.default ?? 'rgba(255, 255, 255)';
	    let textTop = cdsTop + 12;
	    context.fillText(featureType, startPx + 2, textTop);
	    if (featureName) {
	        textTop = textTop + 12;
	        context.fillText(`Parent Type: ${feature.type}`, startPx + 2, textTop);
	        textTop = textTop + 12;
	        context.fillText(`Parent Name: ${featureName}`, startPx + 2, textTop);
	    }
	    textTop = textTop + 12;
	    context.fillText(location, startPx + 2, textTop);
	}
	function getContextMenuItems(display) {
	    const { apolloHover, apolloInternetAccount: internetAccount, changeManager, filteredTranscripts, regions, selectedFeature, session, } = display;
	    const menuItems = [];
	    if (!apolloHover) {
	        return menuItems;
	    }
	    const { feature: sourceFeature } = apolloHover;
	    const role = internetAccount ? internetAccount.role : 'admin';
	    const admin = role === 'admin';
	    const readOnly = !(role && ['admin', 'user'].includes(role));
	    const [region] = regions;
	    const sourceAssemblyId = display.getAssemblyId(region.assemblyName);
	    const currentAssemblyId = display.getAssemblyId(region.assemblyName);
	    menuItems.push({
	        label: 'Add child feature',
	        disabled: readOnly,
	        onClick: () => {
	            session.queueDialog((doneCallback) => [
	                AddChildFeature,
	                {
	                    session,
	                    handleClose: () => {
	                        doneCallback();
	                    },
	                    changeManager,
	                    sourceFeature,
	                    sourceAssemblyId,
	                    internetAccount,
	                },
	            ]);
	        },
	    }, {
	        label: 'Copy features and annotations',
	        disabled: readOnly,
	        onClick: () => {
	            session.queueDialog((doneCallback) => [
	                CopyFeature,
	                {
	                    session,
	                    handleClose: () => {
	                        doneCallback();
	                    },
	                    changeManager,
	                    sourceFeature,
	                    sourceAssemblyId: currentAssemblyId,
	                },
	            ]);
	        },
	    }, {
	        label: 'Delete feature',
	        disabled: !admin,
	        onClick: () => {
	            session.queueDialog((doneCallback) => [
	                DeleteFeature,
	                {
	                    session,
	                    handleClose: () => {
	                        doneCallback();
	                    },
	                    changeManager,
	                    sourceFeature,
	                    sourceAssemblyId: currentAssemblyId,
	                    selectedFeature,
	                    setSelectedFeature: (feature) => {
	                        display.setSelectedFeature(feature);
	                    },
	                },
	            ]);
	        },
	    });
	    const { featureTypeOntology } = session.apolloDataStore.ontologyManager;
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    if (featureTypeOntology.isTypeOf(sourceFeature.type, 'gene')) {
	        menuItems.push({
	            label: 'Filter alternate transcripts',
	            onClick: () => {
	                session.queueDialog((doneCallback) => [
	                    FilterTranscripts,
	                    {
	                        handleClose: () => {
	                            doneCallback();
	                        },
	                        sourceFeature,
	                        filteredTranscripts: require$$1$3.getSnapshot(filteredTranscripts),
	                        onUpdate: (forms) => {
	                            display.updateFilteredTranscripts(forms);
	                        },
	                    },
	                ]);
	            },
	        });
	    }
	    return menuItems;
	}
	function onMouseLeave() {
	    return;
	}
	const geneGlyph = {
	    draw,
	    drawDragPreview,
	    drawHover,
	    drawTooltip,
	    getContextMenuItems,
	    onMouseDown,
	    onMouseLeave,
	    onMouseMove,
	    onMouseUp,
	};

	const minDisplayHeight = 20;
	function baseModelFactory(_pluginManager, configSchema) {
	    return pluggableElementTypes.BaseDisplay.named('BaseLinearApolloSixFrameDisplay')
	        .props({
	        type: require$$1$3.types.literal('LinearApolloSixFrameDisplay'),
	        configuration: configuration.ConfigurationReference(configSchema),
	        graphical: true,
	        table: false,
	        showFeatureLabels: true,
	        heightPreConfig: require$$1$3.types.maybe(require$$1$3.types.refinement('displayHeight', require$$1$3.types.number, (n) => n >= minDisplayHeight)),
	        filteredFeatureTypes: require$$1$3.types.array(require$$1$3.types.string),
	    })
	        .views((self) => {
	        const { configuration, renderProps: superRenderProps } = self;
	        return {
	            renderProps() {
	                return {
	                    ...superRenderProps(),
	                    ...tracks.getParentRenderProps(self),
	                    config: configuration.renderer,
	                };
	            },
	        };
	    })
	        .volatile(() => ({
	        scrollTop: 0,
	    }))
	        .views((self) => ({
	        get lgv() {
	            return require$$1$2.getContainingView(self);
	        },
	        get height() {
	            if (self.heightPreConfig) {
	                return self.heightPreConfig;
	            }
	            if (self.graphical && self.table) {
	                return 500;
	            }
	            if (self.graphical) {
	                return 200;
	            }
	            return 300;
	        },
	    }))
	        .views((self) => ({
	        get rendererTypeName() {
	            return self.configuration.renderer.type;
	        },
	        get session() {
	            return require$$1$2.getSession(self);
	        },
	        get regions() {
	            const regions = self.lgv.dynamicBlocks.contentBlocks.map(({ assemblyName, end, refName, start }) => ({
	                assemblyName,
	                refName,
	                start: Math.round(start),
	                end: Math.round(end),
	            }));
	            return regions;
	        },
	        regionCannotBeRendered( /* region */) {
	            if (self.lgv && self.lgv.bpPerPx >= 200) {
	                return 'Zoom in to see annotations';
	            }
	            return;
	        },
	    }))
	        .views((self) => ({
	        get apolloInternetAccount() {
	            const [region] = self.regions;
	            const { internetAccounts } = require$$1$3.getRoot(self);
	            const { assemblyName } = region;
	            const { assemblyManager } = self.session;
	            const assembly = assemblyManager.get(assemblyName);
	            if (!assembly) {
	                throw new Error(`No assembly found with name ${assemblyName}`);
	            }
	            const { internetAccountConfigId } = configuration.getConf(assembly, [
	                'sequence',
	                'metadata',
	            ]);
	            return internetAccounts.find((ia) => configuration.getConf(ia, 'internetAccountId') === internetAccountConfigId);
	        },
	        get changeManager() {
	            return self.session.apolloDataStore
	                .changeManager;
	        },
	        getAssemblyId(assemblyName) {
	            const { assemblyManager } = self.session;
	            const assembly = assemblyManager.get(assemblyName);
	            if (!assembly) {
	                throw new Error(`Could not find assembly named ${assemblyName}`);
	            }
	            return assembly.name;
	        },
	        get selectedFeature() {
	            return self.session
	                .apolloSelectedFeature;
	        },
	    }))
	        .actions((self) => ({
	        setScrollTop(scrollTop) {
	            self.scrollTop = scrollTop;
	        },
	        setHeight(displayHeight) {
	            self.heightPreConfig = Math.max(displayHeight, minDisplayHeight);
	            return self.height;
	        },
	        resizeHeight(distance) {
	            const oldHeight = self.height;
	            const newHeight = this.setHeight(self.height + distance);
	            return newHeight - oldHeight;
	        },
	        showGraphicalOnly() {
	            self.graphical = true;
	            self.table = false;
	        },
	        showTableOnly() {
	            self.graphical = false;
	            self.table = true;
	        },
	        showGraphicalAndTable() {
	            self.graphical = true;
	            self.table = true;
	        },
	        toggleShowFeatureLabels() {
	            self.showFeatureLabels = !self.showFeatureLabels;
	        },
	        updateFilteredFeatureTypes(types) {
	            self.filteredFeatureTypes = require$$1$3.cast(types);
	        },
	    }))
	        .views((self) => {
	        const { filteredFeatureTypes, trackMenuItems: superTrackMenuItems } = self;
	        return {
	            trackMenuItems() {
	                const { graphical, table, showFeatureLabels } = self;
	                return [
	                    ...superTrackMenuItems(),
	                    {
	                        type: 'subMenu',
	                        label: 'Appearance',
	                        subMenu: [
	                            {
	                                label: 'Show graphical display',
	                                type: 'radio',
	                                checked: graphical && !table,
	                                onClick: () => {
	                                    self.showGraphicalOnly();
	                                },
	                            },
	                            {
	                                label: 'Show table display',
	                                type: 'radio',
	                                checked: table && !graphical,
	                                onClick: () => {
	                                    self.showTableOnly();
	                                },
	                            },
	                            {
	                                label: 'Show both graphical and table display',
	                                type: 'radio',
	                                checked: table && graphical,
	                                onClick: () => {
	                                    self.showGraphicalAndTable();
	                                },
	                            },
	                            {
	                                label: 'Feature Labels',
	                                type: 'checkbox',
	                                checked: showFeatureLabels,
	                                onClick: () => {
	                                    self.toggleShowFeatureLabels();
	                                },
	                            },
	                        ],
	                    },
	                    {
	                        label: 'Filter features by type',
	                        onClick: () => {
	                            const session = self.session;
	                            self.session.queueDialog((doneCallback) => [
	                                FilterFeatures,
	                                {
	                                    session,
	                                    handleClose: () => {
	                                        doneCallback();
	                                    },
	                                    featureTypes: require$$1$3.getSnapshot(filteredFeatureTypes),
	                                    onUpdate: (types) => {
	                                        self.updateFilteredFeatureTypes(types);
	                                    },
	                                },
	                            ]);
	                        },
	                    },
	                ];
	            },
	        };
	    })
	        .actions((self) => ({
	        setSelectedFeature(feature) {
	            self.session.apolloSetSelectedFeature(feature);
	        },
	        showFeatureDetailsWidget(feature, customWidgetNameAndId) {
	            const [region] = self.regions;
	            const { assemblyName, refName } = region;
	            const assembly = self.getAssemblyId(assemblyName);
	            if (!assembly) {
	                return;
	            }
	            const { session } = self;
	            const { changeManager } = session.apolloDataStore;
	            const [widgetName, widgetId] = customWidgetNameAndId ?? [
	                'ApolloFeatureDetailsWidget',
	                'apolloFeatureDetailsWidget',
	            ];
	            const apolloFeatureWidget = session.addWidget(widgetName, widgetId, {
	                feature,
	                assembly,
	                refName,
	                changeManager,
	            });
	            session.showWidget(apolloFeatureWidget);
	        },
	        afterAttach() {
	            require$$1$3.addDisposer(self, mobx.autorun(() => {
	                if (!self.lgv.initialized || self.regionCannotBeRendered()) {
	                    return;
	                }
	                void self.session.apolloDataStore.loadFeatures(self.regions);
	                if (self.lgv.bpPerPx <= 3) {
	                    void self.session.apolloDataStore.loadRefSeq(self.regions);
	                }
	            }, { name: 'LinearApolloSixFrameDisplayLoadFeatures', delay: 1000 }));
	        },
	    }));
	}

	/* eslint-disable @typescript-eslint/no-unnecessary-condition */
	function layoutsModelFactory(pluginManager, configSchema) {
	    const BaseLinearApolloSixFrameDisplay = baseModelFactory(pluginManager, configSchema);
	    return BaseLinearApolloSixFrameDisplay.named('LinearApolloSixFrameDisplayLayouts')
	        .props({
	        featuresMinMaxLimit: 500_000,
	    })
	        .volatile(() => ({
	        seenFeatures: mobx.observable.map(),
	    }))
	        .views((self) => ({
	        get featuresMinMax() {
	            const { assemblyManager } = self.session;
	            return self.lgv.displayedRegions.map((region) => {
	                const assembly = assemblyManager.get(region.assemblyName);
	                let min;
	                let max;
	                const { end, refName, start } = region;
	                for (const [, feature] of self.seenFeatures) {
	                    if (refName !== assembly?.getCanonicalRefName(feature.refSeq) ||
	                        !require$$1$2.doesIntersect2(start, end, feature.min, feature.max) ||
	                        feature.length > self.featuresMinMaxLimit) {
	                        continue;
	                    }
	                    if (min === undefined) {
	                        ({ min } = feature);
	                    }
	                    if (max === undefined) {
	                        ({ max } = feature);
	                    }
	                    if (feature.minWithChildren < min) {
	                        ({ min } = feature);
	                    }
	                    if (feature.maxWithChildren > max) {
	                        ({ max } = feature);
	                    }
	                }
	                if (min !== undefined && max !== undefined) {
	                    return [min, max];
	                }
	                return;
	            });
	        },
	        getGlyph(_feature) {
	            return geneGlyph;
	        },
	        featureLabelSpacer(elem) {
	            return self.showFeatureLabels ? elem * 2 - 1 : elem;
	        },
	    }))
	        .actions((self) => ({
	        addSeenFeature(feature) {
	            self.seenFeatures.set(feature._id, feature);
	        },
	        deleteSeenFeature(featureId) {
	            self.seenFeatures.delete(featureId);
	        },
	    }))
	        .views((self) => ({
	        get geneTrackRowNums() {
	            return [4, 5].map((elem) => self.featureLabelSpacer(elem));
	        },
	    }))
	        .views((self) => ({
	        get featureLayouts() {
	            const { assemblyManager } = self.session;
	            return self.lgv.displayedRegions.map((region, idx) => {
	                const assembly = assemblyManager.get(region.assemblyName);
	                const featureLayout = new Map();
	                const minMax = self.featuresMinMax[idx];
	                if (!minMax) {
	                    return featureLayout;
	                }
	                const { end, refName, start } = region;
	                for (const [id, feature] of self.seenFeatures.entries()) {
	                    if (!require$$1$3.isAlive(feature)) {
	                        self.deleteSeenFeature(id);
	                        continue;
	                    }
	                    if (refName !== assembly?.getCanonicalRefName(feature.refSeq) ||
	                        !require$$1$2.doesIntersect2(start, end, feature.min, feature.max)) {
	                        continue;
	                    }
	                    const { featureTypeOntology } = self.session.apolloDataStore.ontologyManager;
	                    if (!featureTypeOntology) {
	                        throw new Error('featureTypeOntology is undefined');
	                    }
	                    if (feature.looksLikeGene) {
	                        const rowNum = feature.strand == 1
	                            ? self.geneTrackRowNums[0]
	                            : self.geneTrackRowNums[1];
	                        if (!featureLayout.get(rowNum)) {
	                            featureLayout.set(rowNum, []);
	                        }
	                        const layoutRow = featureLayout.get(rowNum);
	                        layoutRow?.push({ rowNum, feature, cds: null });
	                        const { children } = feature;
	                        if (!children) {
	                            continue;
	                        }
	                        for (const [, child] of children) {
	                            if (featureTypeOntology.isTypeOf(child.type, 'transcript')) {
	                                const { cdsLocations, strand, children: childrenOfmRNA, } = child;
	                                if (childrenOfmRNA) {
	                                    for (const [, exon] of childrenOfmRNA) {
	                                        if (!featureTypeOntology.isTypeOf(exon.type, 'exon')) {
	                                            continue;
	                                        }
	                                        const rowNum = exon.strand == 1
	                                            ? self.geneTrackRowNums[0]
	                                            : self.geneTrackRowNums[1];
	                                        const layoutRow = featureLayout.get(rowNum);
	                                        layoutRow?.push({ rowNum, feature: exon, cds: null });
	                                    }
	                                }
	                                for (const cdsRow of cdsLocations) {
	                                    for (const cds of cdsRow) {
	                                        let rowNum = require$$1$2.getFrame(cds.min, cds.max, strand ?? 1, cds.phase);
	                                        rowNum = self.featureLabelSpacer(rowNum < 0 ? -1 * rowNum + 5 : rowNum);
	                                        if (!featureLayout.get(rowNum)) {
	                                            featureLayout.set(rowNum, []);
	                                        }
	                                        const layoutRow = featureLayout.get(rowNum);
	                                        layoutRow?.push({ rowNum, feature: child, cds });
	                                    }
	                                }
	                            }
	                        }
	                    }
	                    else {
	                        continue;
	                    }
	                }
	                return featureLayout;
	            });
	        },
	        getFeatureLayoutPosition(feature) {
	            const { featureLayouts } = this;
	            for (const [idx, layout] of featureLayouts.entries()) {
	                for (const [, layoutRow] of layout) {
	                    for (const { feature: layoutFeature } of layoutRow) {
	                        if (feature._id === layoutFeature._id) {
	                            return {
	                                layoutIndex: idx,
	                                layoutRow: 0,
	                                featureRow: 0,
	                            };
	                        }
	                    }
	                }
	            }
	            return;
	        },
	    }))
	        .views((_self) => ({
	        get highestRow() {
	            return 5;
	        },
	    }))
	        .actions((self) => ({
	        afterAttach() {
	            require$$1$3.addDisposer(self, mobx.autorun(() => {
	                if (!self.lgv.initialized || self.regionCannotBeRendered()) {
	                    return;
	                }
	                for (const region of self.regions) {
	                    const assembly = self.session.apolloDataStore.assemblies.get(region.assemblyName);
	                    const ref = assembly?.getByRefName(region.refName);
	                    const features = ref?.features;
	                    if (!features) {
	                        continue;
	                    }
	                    for (const [, feature] of features) {
	                        if (require$$1$2.doesIntersect2(region.start, region.end, feature.min, feature.max) &&
	                            !self.seenFeatures.has(feature._id)) {
	                            self.addSeenFeature(feature);
	                        }
	                    }
	                }
	            }, { name: 'LinearApolloSixFrameDisplaySetSeenFeatures', delay: 1000 }));
	        },
	    }));
	}

	function renderingModelIntermediateFactory(pluginManager, configSchema) {
	    const LinearApolloSixFrameDisplayLayouts = layoutsModelFactory(pluginManager, configSchema);
	    return LinearApolloSixFrameDisplayLayouts.named('LinearApolloSixFrameDisplayRendering')
	        .props({
	        sequenceRowHeight: 15,
	        apolloRowHeight: 20,
	        detailsMinHeight: 200,
	        detailsHeight: 200,
	        lastRowTooltipBufferHeight: 80,
	        isShown: true,
	        filteredTranscripts: require$$1$3.types.array(require$$1$3.types.string),
	    })
	        .volatile(() => ({
	        canvas: null,
	        overlayCanvas: null,
	        collaboratorCanvas: null,
	        theme: undefined,
	    }))
	        .views((self) => ({
	        get featuresHeight() {
	            const featureLabelSpacer = self.showFeatureLabels ? 2 : 1;
	            return (featureLabelSpacer * ((self.highestRow + 1) * self.apolloRowHeight) +
	                self.lastRowTooltipBufferHeight);
	        },
	    }))
	        .actions((self) => ({
	        toggleShown() {
	            self.isShown = !self.isShown;
	        },
	        setDetailsHeight(newHeight) {
	            self.detailsHeight = self.isShown
	                ? Math.max(Math.min(newHeight, self.height - 100), Math.min(self.height, self.detailsMinHeight))
	                : newHeight;
	        },
	        setCanvas(canvas) {
	            self.canvas = canvas;
	        },
	        setOverlayCanvas(canvas) {
	            self.overlayCanvas = canvas;
	        },
	        setCollaboratorCanvas(canvas) {
	            self.collaboratorCanvas = canvas;
	        },
	        setTheme(theme) {
	            self.theme = theme;
	        },
	        afterAttach() {
	            require$$1$3.addDisposer(self, mobx.autorun(() => {
	                if (!self.lgv.initialized || self.regionCannotBeRendered()) {
	                    return;
	                }
	                const ctx = self.collaboratorCanvas?.getContext('2d');
	                if (!ctx) {
	                    return;
	                }
	                ctx.clearRect(0, 0, self.lgv.dynamicBlocks.totalWidthPx, self.featuresHeight);
	                for (const collaborator of self.session.collaborators) {
	                    const { locations } = collaborator;
	                    if (locations.length === 0) {
	                        continue;
	                    }
	                    let idx = 0;
	                    for (const displayedRegion of self.lgv.displayedRegions) {
	                        for (const location of locations) {
	                            if (location.refSeq !== displayedRegion.refName) {
	                                continue;
	                            }
	                            const { end, refSeq, start } = location;
	                            const locationStartPxInfo = self.lgv.bpToPx({
	                                refName: refSeq,
	                                coord: start,
	                                regionNumber: idx,
	                            });
	                            if (!locationStartPxInfo) {
	                                continue;
	                            }
	                            const locationStartPx = locationStartPxInfo.offsetPx - self.lgv.offsetPx;
	                            const locationWidthPx = (end - start) / self.lgv.bpPerPx;
	                            ctx.fillStyle = 'rgba(0,255,0,.2)';
	                            ctx.fillRect(locationStartPx, 1, locationWidthPx, 100);
	                            ctx.fillStyle = 'black';
	                            ctx.fillText(collaborator.name, locationStartPx + 1, 11, locationWidthPx - 2);
	                        }
	                        idx++;
	                    }
	                }
	            }, { name: 'LinearApolloSixFrameDisplayRenderCollaborators' }));
	        },
	    }));
	}
	function renderingModelFactory(pluginManager, configSchema) {
	    const LinearApolloSixFrameDisplayRendering = renderingModelIntermediateFactory(pluginManager, configSchema);
	    return LinearApolloSixFrameDisplayRendering.actions((self) => ({
	        afterAttach() {
	            require$$1$3.addDisposer(self, mobx.autorun(() => {
	                const { canvas, featureLayouts, featuresHeight, lgv } = self;
	                if (!lgv.initialized || self.regionCannotBeRendered()) {
	                    return;
	                }
	                const { displayedRegions, dynamicBlocks } = lgv;
	                const ctx = canvas?.getContext('2d');
	                if (!ctx) {
	                    return;
	                }
	                ctx.clearRect(0, 0, dynamicBlocks.totalWidthPx, featuresHeight);
	                for (const [idx, featureLayout] of featureLayouts.entries()) {
	                    const displayedRegion = displayedRegions[idx];
	                    for (const [row, featureLayoutRow] of featureLayout.entries()) {
	                        for (const { feature } of featureLayoutRow) {
	                            if (!feature.looksLikeGene) {
	                                continue;
	                            }
	                            if (!require$$1$2.doesIntersect2(displayedRegion.start, displayedRegion.end, feature.min, feature.max)) {
	                                continue;
	                            }
	                            const { topLevelFeature } = feature;
	                            const glyph = self.getGlyph(topLevelFeature);
	                            if (glyph !== undefined) {
	                                glyph.draw(ctx, topLevelFeature, row, self, idx);
	                            }
	                        }
	                    }
	                }
	            }, { name: 'LinearApolloSixFrameDisplayRenderFeatures' }));
	        },
	    }));
	}

	function isMousePositionWithFeatureAndGlyph(mousePosition) {
	    return 'featureAndGlyphUnderMouse' in mousePosition;
	}
	function getMousePosition(event, lgv) {
	    const canvas = event.currentTarget;
	    const { clientX, clientY } = event;
	    const { left, top } = canvas.getBoundingClientRect();
	    const x = clientX - left;
	    const y = clientY - top;
	    const { coord: bp, index: regionNumber, refName } = lgv.pxToBp(x);
	    return { x, y, refName, bp, regionNumber };
	}
	function mouseEventsModelIntermediateFactory(pluginManager, configSchema) {
	    const LinearApolloSixFrameDisplayRendering = renderingModelFactory(pluginManager, configSchema);
	    return LinearApolloSixFrameDisplayRendering.named('LinearApolloSixFrameDisplayMouseEvents')
	        .volatile(() => ({
	        apolloDragging: null,
	        cursor: undefined,
	        apolloHover: undefined,
	    }))
	        .views((self) => ({
	        getMousePosition(event) {
	            const mousePosition = getMousePosition(event, self.lgv);
	            const { bp, regionNumber, y } = mousePosition;
	            const row = Math.floor(y / self.apolloRowHeight) + 1;
	            const featureLayout = self.featureLayouts[regionNumber];
	            const layoutRow = featureLayout.get(row);
	            if (!layoutRow) {
	                return mousePosition;
	            }
	            let foundFeature;
	            if (self.geneTrackRowNums.includes(row)) {
	                foundFeature = layoutRow.find((f) => f.feature.type == 'exon' &&
	                    bp >= f.feature.min &&
	                    bp <= f.feature.max);
	                if (!foundFeature) {
	                    foundFeature = layoutRow.find((f) => bp >= f.feature.min && bp <= f.feature.max);
	                }
	            }
	            else {
	                foundFeature = layoutRow.find((f) => {
	                    const featureID = f.feature.attributes.get('gff_id')?.toString();
	                    return (f.cds != null &&
	                        bp >= f.cds.min &&
	                        bp <= f.cds.max &&
	                        (featureID === undefined ||
	                            !self.filteredTranscripts.includes(featureID)));
	                });
	            }
	            if (!foundFeature) {
	                return mousePosition;
	            }
	            const { feature, cds } = foundFeature;
	            const { topLevelFeature } = feature;
	            const glyph = self.getGlyph(feature);
	            return {
	                ...mousePosition,
	                featureAndGlyphUnderMouse: { cds, feature, topLevelFeature, glyph },
	            };
	        },
	    }))
	        .actions((self) => ({
	        continueDrag(mousePosition, event) {
	            if (!self.apolloDragging) {
	                throw new Error('continueDrag() called with no current drag in progress');
	            }
	            event.stopPropagation();
	            self.apolloDragging = { ...self.apolloDragging, current: mousePosition };
	        },
	        setDragging(dragInfo) {
	            self.apolloDragging = dragInfo ?? null;
	        },
	    }))
	        .actions((self) => ({
	        setApolloHover(n) {
	            self.apolloHover = n;
	        },
	        setCursor(cursor) {
	            if (self.cursor !== cursor) {
	                self.cursor = cursor;
	            }
	        },
	        updateFilteredTranscripts(forms) {
	            self.filteredTranscripts = require$$1$3.cast(forms);
	        },
	    }))
	        .actions(() => ({
	        // onClick(event: CanvasMouseEvent) {
	        onClick() {
	            // TODO: set the selected feature
	        },
	    }));
	}
	function mouseEventsModelFactory(pluginManager, configSchema) {
	    const LinearApolloSixFrameDisplayMouseEvents = mouseEventsModelIntermediateFactory(pluginManager, configSchema);
	    return LinearApolloSixFrameDisplayMouseEvents.views((self) => ({
	        contextMenuItems(contextCoord) {
	            const { apolloHover } = self;
	            if (!(apolloHover && contextCoord)) {
	                return [];
	            }
	            const { topLevelFeature } = apolloHover;
	            const glyph = self.getGlyph(topLevelFeature);
	            return glyph.getContextMenuItems(self);
	        },
	    }))
	        .actions((self) => ({
	        // explicitly pass in a feature in case it's not the same as the one in
	        // mousePosition (e.g. if features are drawn overlapping).
	        startDrag(mousePosition, feature, edge, shrinkParent = false) {
	            self.apolloDragging = {
	                start: mousePosition,
	                current: mousePosition,
	                feature,
	                edge,
	                shrinkParent,
	            };
	        },
	        endDrag() {
	            if (!self.apolloDragging) {
	                throw new Error('endDrag() called with no current drag in progress');
	            }
	            const { current, edge, feature, start, shrinkParent } = self.apolloDragging;
	            // don't do anything if it was only dragged a tiny bit
	            if (Math.abs(current.x - start.x) <= 4) {
	                self.setDragging();
	                self.setCursor();
	                return;
	            }
	            const { displayedRegions } = self.lgv;
	            const region = displayedRegions[start.regionNumber];
	            const assembly = self.getAssemblyId(region.assemblyName);
	            const changes = getPropagatedLocationChanges(feature, current.bp, edge, shrinkParent);
	            const change = edge === 'max'
	                ? new dist$2.LocationEndChange({
	                    typeName: 'LocationEndChange',
	                    changedIds: changes.map((c) => c.featureId),
	                    changes: changes.map((c) => ({
	                        featureId: c.featureId,
	                        oldEnd: c.oldLocation,
	                        newEnd: c.newLocation,
	                    })),
	                    assembly,
	                })
	                : new dist$2.LocationStartChange({
	                    typeName: 'LocationStartChange',
	                    changedIds: changes.map((c) => c.featureId),
	                    changes: changes.map((c) => ({
	                        featureId: c.featureId,
	                        oldStart: c.oldLocation,
	                        newStart: c.newLocation,
	                    })),
	                    assembly,
	                });
	            void self.changeManager.submit(change);
	            self.setDragging();
	            self.setCursor();
	        },
	    }))
	        .actions((self) => ({
	        onMouseDown(event) {
	            const mousePosition = self.getMousePosition(event);
	            if (isMousePositionWithFeatureAndGlyph(mousePosition)) {
	                mousePosition.featureAndGlyphUnderMouse.glyph.onMouseDown(self, mousePosition, event);
	            }
	        },
	        onMouseMove(event) {
	            const mousePosition = self.getMousePosition(event);
	            if (self.apolloDragging) {
	                self.setCursor('col-resize');
	                self.continueDrag(mousePosition, event);
	                return;
	            }
	            if (isMousePositionWithFeatureAndGlyph(mousePosition)) {
	                mousePosition.featureAndGlyphUnderMouse.glyph.onMouseMove(self, mousePosition, event);
	            }
	            else {
	                self.setApolloHover();
	                self.setCursor();
	            }
	        },
	        onMouseLeave(event) {
	            self.setDragging();
	            self.setApolloHover();
	            const mousePosition = self.getMousePosition(event);
	            if (isMousePositionWithFeatureAndGlyph(mousePosition)) {
	                mousePosition.featureAndGlyphUnderMouse.glyph.onMouseLeave(self, mousePosition, event);
	            }
	        },
	        onMouseUp(event) {
	            const mousePosition = self.getMousePosition(event);
	            if (isMousePositionWithFeatureAndGlyph(mousePosition)) {
	                mousePosition.featureAndGlyphUnderMouse.glyph.onMouseUp(self, mousePosition, event);
	            }
	            else {
	                self.setSelectedFeature();
	            }
	            if (self.apolloDragging) {
	                self.endDrag();
	            }
	        },
	    }))
	        .actions((self) => ({
	        afterAttach() {
	            require$$1$3.addDisposer(self, mobx.autorun(() => {
	                // This type is wrong in @jbrowse/core
	                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	                if (!self.lgv.initialized || self.regionCannotBeRendered()) {
	                    return;
	                }
	                const ctx = self.overlayCanvas?.getContext('2d');
	                if (!ctx) {
	                    return;
	                }
	                ctx.clearRect(0, 0, self.lgv.dynamicBlocks.totalWidthPx, self.featuresHeight);
	                const { apolloDragging, apolloHover } = self;
	                if (!apolloHover) {
	                    return;
	                }
	                const { glyph } = apolloHover;
	                // draw mouseover hovers
	                glyph.drawHover(self, ctx);
	                // draw tooltip on hover
	                glyph.drawTooltip(self, ctx);
	                // dragging previews
	                if (apolloDragging) {
	                    // NOTE: the glyph where the drag started is responsible for drawing the preview.
	                    // it can call methods in other glyphs to help with this though.
	                    const glyph = self.getGlyph(apolloDragging.feature.topLevelFeature);
	                    glyph.drawDragPreview(self, ctx);
	                }
	            }, { name: 'LinearApolloSixFrameDisplayRenderMouseoverAndDrag' }));
	        },
	    }));
	}

	function stateModelFactory(pluginManager, configSchema) {
	    // TODO: this needs to be refactored so that the final composition of the
	    // state model mixins happens here in one central place
	    return mouseEventsModelFactory(pluginManager, configSchema)
	        .props({ tabularEditor: require$$1$3.types.optional(TabularEditorStateModelType, {}) })
	        .named('LinearApolloSixFrameDisplay');
	}

	const ApolloPluginConfigurationSchema = configuration.ConfigurationSchema('ApolloPlugin', {
	    ontologies: require$$1$3.types.array(OntologyRecordConfiguration),
	    featureTypeOntologyName: {
	        description: 'Name of the feature type ontology',
	        type: 'string',
	        defaultValue: 'Sequence Ontology',
	    },
	    hasRole: {
	        description: 'Flag used internally by jbrowse-plugin-apollo',
	        type: 'boolean',
	        defaultValue: false,
	    },
	});

	/* eslint-disable react-hooks/exhaustive-deps */
	const isGeneOrTranscript = (annotationFeature, apolloSessionModel) => {
	    const { featureTypeOntology } = apolloSessionModel.apolloDataStore.ontologyManager;
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    return (featureTypeOntology.isTypeOf(annotationFeature.type, 'gene') ||
	        featureTypeOntology.isTypeOf(annotationFeature.type, 'transcript') ||
	        featureTypeOntology.isTypeOf(annotationFeature.type, 'pseudogene') ||
	        featureTypeOntology.isTypeOf(annotationFeature.type, 'pseudogenic_transcript'));
	};
	const isGene = (annotationFeature, apolloSessionModel) => {
	    const { featureTypeOntology } = apolloSessionModel.apolloDataStore.ontologyManager;
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    return (featureTypeOntology.isTypeOf(annotationFeature.type, 'gene') ||
	        featureTypeOntology.isTypeOf(annotationFeature.type, 'pseudogene'));
	};
	const isTranscript = (annotationFeature, apolloSessionModel) => {
	    const { featureTypeOntology } = apolloSessionModel.apolloDataStore.ontologyManager;
	    if (!featureTypeOntology) {
	        throw new Error('featureTypeOntology is undefined');
	    }
	    return (featureTypeOntology.isTypeOf(annotationFeature.type, 'transcript') ||
	        featureTypeOntology.isTypeOf(annotationFeature.type, 'pseudogenic_transcript'));
	};
	function getFeatureName(feature) {
	    const { attributes } = feature;
	    const keys = ['name', 'gff_name', 'transcript_name', 'gene_name'];
	    for (const key of keys) {
	        const value = attributes?.[key];
	        if (value?.[0]) {
	            return value[0];
	        }
	    }
	    return '';
	}
	function getGeneNameOrId(feature) {
	    const { attributes } = feature;
	    const keys = ['gene_name', 'gene_id', 'gene_stable_id'];
	    for (const key of keys) {
	        const value = attributes?.[key];
	        if (value?.[0]) {
	            return value[0];
	        }
	    }
	    return '';
	}
	function getFeatureId(feature) {
	    const { attributes } = feature;
	    const keys = [
	        'id',
	        'gff_id',
	        'transcript_id',
	        'gene_id',
	        'gene_stable_id',
	        'stable_id',
	    ];
	    for (const key of keys) {
	        const value = attributes?.[key];
	        if (value?.[0]) {
	            return value[0];
	        }
	    }
	    return '';
	}
	const getFeatureNameOrId = (feature) => {
	    const name = getFeatureName(feature);
	    const id = getFeatureId(feature);
	    if (name) {
	        return `${feature.type} - ${name}`;
	    }
	    if (id) {
	        return `${feature.type} - ${id}`;
	    }
	    return feature.type;
	};
	function CreateApolloAnnotation({ annotationFeature, assembly, handleClose, refSeqId, session, region, }) {
	    const apolloSessionModel = session;
	    const { featureTypeOntology } = apolloSessionModel.apolloDataStore.ontologyManager;
	    const childIds = React.useMemo(() => Object.keys(annotationFeature.children ?? {}), [annotationFeature]);
	    const [parentFeatureChecked, setParentFeatureChecked] = React.useState(true);
	    const [checkedChildrens, setCheckedChildrens] = React.useState(childIds);
	    const [errorMessage, setErrorMessage] = React.useState('');
	    const [destinationFeatures, setDestinationFeatures] = React.useState([]);
	    const [createNewGene, setCreateNewGene] = React.useState(false);
	    const [selectedDestinationFeature, setSelectedDestinationFeature] = React.useState();
	    const apolloAssembly = apolloSessionModel.apolloDataStore.assemblies.get(assembly.name);
	    const refSeq = apolloAssembly?.refSeqs.get(refSeqId);
	    const features = refSeq?.getFeatures(region.start, region.end);
	    const getDestinationFeatures = () => {
	        const filteredFeatures = [];
	        for (const f of features ?? []) {
	            if (f.min > region.end || f.max < region.start) {
	                continue;
	            }
	            // Destination feature should be of type gene amd should be on the same strand as the source feature
	            if (featureTypeOntology?.isTypeOf(f.type, 'gene') &&
	                f.strand === annotationFeature.strand) {
	                const featureSnapshot = require$$1$3.getSnapshot(f);
	                filteredFeatures.push(featureSnapshot);
	            }
	        }
	        return filteredFeatures;
	    };
	    React.useEffect(() => {
	        setErrorMessage('');
	        const features = getDestinationFeatures();
	        setDestinationFeatures(features);
	        setSelectedDestinationFeature(features[0]);
	    }, [checkedChildrens, parentFeatureChecked, region]);
	    const handleParentFeatureCheck = (event) => {
	        const isChecked = event.target.checked;
	        setParentFeatureChecked(isChecked);
	        setCheckedChildrens(isChecked ? childIds : []);
	    };
	    const handleChildFeatureCheck = (event, child) => {
	        setCheckedChildrens((prevChecked) => event.target.checked
	            ? [...prevChecked, child._id]
	            : prevChecked.filter((childId) => childId !== child._id));
	    };
	    const handleDestinationFeatureChange = (e) => {
	        const selectedFeature = destinationFeatures.find((f) => f._id === e.target.value);
	        setSelectedDestinationFeature(selectedFeature);
	    };
	    const handleCreateApolloAnnotation = async () => {
	        if (parentFeatureChecked) {
	            // IF SOURCE FEATURE IS GENE
	            if (isGene(annotationFeature, apolloSessionModel)) {
	                await copyGeneFeature();
	                session.notify('Successfully copied selected gene and transcript(s)', 'success');
	            }
	            if (isTranscript(annotationFeature, apolloSessionModel)) {
	                // IF THE SOURCE IS TRANSCRIPT AND THE DESTINATION IS SELECTED AND CREATE NEW GENE IS NOT CHECKED
	                if (selectedDestinationFeature && !createNewGene) {
	                    const transcripts = {};
	                    transcripts[annotationFeature._id] = annotationFeature;
	                    // If source trancript doesn't overlap with destination gene
	                    // If not overlapping, then extend the destination gene to include the transcript
	                    if (selectedDestinationFeature.max < annotationFeature.max ||
	                        selectedDestinationFeature.min > annotationFeature.min) {
	                        const newMin = Math.min(selectedDestinationFeature.min, annotationFeature.min);
	                        const newMax = Math.max(selectedDestinationFeature.max, annotationFeature.max);
	                        await extendSelectedDestinationFeatureLocation(newMin, newMax);
	                        await copyTranscriptsToDestinationGene(transcripts);
	                    }
	                    else {
	                        await copyTranscriptsToDestinationGene(transcripts);
	                    }
	                    session.notify('Successfully copied selected transcripts to destination gene', 'success');
	                }
	                else {
	                    // IF THERE IS NO DESTINATION GENE SELECTED AND CREATE NEW GENE IS CHECKED
	                    const childrens = {};
	                    childrens[annotationFeature._id] = annotationFeature;
	                    await createNewGeneFeatureWithTranscripts(childrens);
	                    session.notify('Successfully created a new gene with selected transcripts', 'success');
	                }
	            }
	        }
	        else {
	            // IF PARENT (GENE) FEATURE IS NOT CHECKED AND WE ARE COPYING CHILDREN (TRANSCRIPTS)
	            if (!annotationFeature.children) {
	                return;
	            }
	            // IF DESTINATION IS SELECTED AND CREATE NEW GENE IS NOT CHECKED
	            if (selectedDestinationFeature && !createNewGene) {
	                const childrens = {};
	                for (const childId of checkedChildrens) {
	                    childrens[childId] = annotationFeature.children[childId];
	                }
	                const min = Math.min(...Object.values(childrens).map((child) => child.min));
	                const max = Math.max(...Object.values(childrens).map((child) => child.max));
	                // If source trancript doesn't overlap with destination gene
	                // If not overlapping, then extend the destination gene to include the transcript
	                if (selectedDestinationFeature.min > min ||
	                    selectedDestinationFeature.max < max) {
	                    const newMin = Math.min(selectedDestinationFeature.min, min);
	                    const newMax = Math.max(selectedDestinationFeature.max, max);
	                    await extendSelectedDestinationFeatureLocation(newMin, newMax);
	                    await copyTranscriptsToDestinationGene(childrens);
	                }
	                else {
	                    await copyTranscriptsToDestinationGene(childrens);
	                }
	                session.notify('Successfully copied transcript to destination gene', 'success');
	            }
	            else {
	                // IF THERE IS NO DESTINATION GENE SELECTED AND CREATE NEW GENE IS CHECKED
	                const childrens = {};
	                for (const childId of checkedChildrens) {
	                    childrens[childId] = annotationFeature.children[childId];
	                }
	                await createNewGeneFeatureWithTranscripts(childrens);
	                session.notify('Successfully created a new gene with selected transcript', 'success');
	            }
	        }
	        handleClose();
	    };
	    // Copies gene feature along with its selected children
	    const copyGeneFeature = async () => {
	        let change;
	        if (annotationFeature.children &&
	            checkedChildrens.length !==
	                Object.values(annotationFeature.children).length) {
	            // IF SOME CHILDREN ARE CHECKED
	            const childrens = {};
	            for (const childId of checkedChildrens) {
	                childrens[childId] = annotationFeature.children[childId];
	            }
	            change = new dist$2.AddFeatureChange({
	                changedIds: [annotationFeature._id],
	                typeName: 'AddFeatureChange',
	                assembly: assembly.name,
	                addedFeature: {
	                    ...annotationFeature,
	                    children: childrens,
	                },
	            });
	        }
	        else {
	            // IF PARENT AND ALL CHILDREN ARE CHECKED
	            change = new dist$2.AddFeatureChange({
	                changedIds: [annotationFeature._id],
	                typeName: 'AddFeatureChange',
	                assembly: assembly.name,
	                addedFeature: annotationFeature,
	            });
	        }
	        await submitChange(change);
	    };
	    const copyTranscriptsToDestinationGene = async (transcripts) => {
	        if (!selectedDestinationFeature) {
	            return;
	        }
	        for (const transcriptId of Object.keys(transcripts)) {
	            const transcript = transcripts[transcriptId];
	            const change = new dist$2.AddFeatureChange({
	                parentFeatureId: selectedDestinationFeature._id,
	                changedIds: [selectedDestinationFeature._id],
	                typeName: 'AddFeatureChange',
	                assembly: assembly.name,
	                addedFeature: transcript,
	            });
	            await submitChange(change);
	        }
	    };
	    const createNewGeneFeatureWithTranscripts = async (childrens) => {
	        const newGeneId = new objectid().toHexString();
	        const min = Math.min(...Object.values(childrens).map((child) => child.min));
	        const max = Math.max(...Object.values(childrens).map((child) => child.max));
	        const change = new dist$2.AddFeatureChange({
	            changedIds: [newGeneId],
	            typeName: 'AddFeatureChange',
	            assembly: assembly.name,
	            addedFeature: {
	                _id: newGeneId,
	                refSeq: refSeqId,
	                min,
	                max,
	                strand: annotationFeature.strand,
	                type: 'gene',
	                children: childrens,
	                attributes: {
	                    name: [getGeneNameOrId(annotationFeature)],
	                    gene_name: [getGeneNameOrId(annotationFeature)],
	                },
	            },
	        });
	        await submitChange(change);
	    };
	    const extendSelectedDestinationFeatureLocation = async (newMin, newMax) => {
	        if (!selectedDestinationFeature) {
	            return;
	        }
	        const changes = [];
	        if (newMin !== selectedDestinationFeature.min) {
	            changes.push(new dist$2.LocationStartChange({
	                typeName: 'LocationStartChange',
	                changedIds: [selectedDestinationFeature._id],
	                featureId: selectedDestinationFeature._id,
	                assembly: assembly.name,
	                oldStart: selectedDestinationFeature.min,
	                newStart: newMin,
	            }));
	        }
	        if (newMax !== selectedDestinationFeature.max) {
	            changes.push(new dist$2.LocationEndChange({
	                typeName: 'LocationEndChange',
	                changedIds: [selectedDestinationFeature._id],
	                featureId: selectedDestinationFeature._id,
	                assembly: assembly.name,
	                oldEnd: selectedDestinationFeature.max,
	                newEnd: newMax,
	            }));
	        }
	        for (const change of changes) {
	            await submitChange(change);
	        }
	    };
	    const submitChange = async (change) => {
	        await apolloSessionModel.apolloDataStore.changeManager.submit(change);
	    };
	    const handleCreateNewGeneChange = (e) => {
	        setCreateNewGene(e.target.checked);
	    };
	    return (React__default["default"].createElement(Dialog, { open: true, title: "Create Apollo Annotation", handleClose: handleClose, fullWidth: true, maxWidth: "sm" },
	        React__default["default"].createElement(material.DialogTitle, { fontSize: 15 }, "Select the feature to be copied to apollo track"),
	        React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.Box, { sx: { ml: 3 } },
	                isGeneOrTranscript(annotationFeature, apolloSessionModel) && (React__default["default"].createElement(material.FormControlLabel, { control: React__default["default"].createElement(material.Checkbox, { size: "small", checked: parentFeatureChecked, onChange: handleParentFeatureCheck }), label: `${getFeatureNameOrId(annotationFeature)} (${annotationFeature.min + 1}..${annotationFeature.max})` })),
	                annotationFeature.children && (React__default["default"].createElement(material.Box, { sx: { display: 'flex', flexDirection: 'column', ml: 3 } }, Object.values(annotationFeature.children)
	                    .filter((child) => isTranscript(child, apolloSessionModel))
	                    .map((child) => (React__default["default"].createElement(material.FormControlLabel, { key: child._id, control: React__default["default"].createElement(material.Checkbox, { size: "small", checked: checkedChildrens.includes(child._id), onChange: (e) => {
	                            handleChildFeatureCheck(e, child);
	                        } }), label: `${getFeatureNameOrId(child)} (${child.min + 1}..${child.max})` })))))),
	            destinationFeatures.length > 0 &&
	                ((!parentFeatureChecked && checkedChildrens.length > 0) ||
	                    (parentFeatureChecked &&
	                        isTranscript(annotationFeature, apolloSessionModel))) && (React__default["default"].createElement("div", { style: {
	                    border: '1px solid #ccc',
	                    marginTop: 20,
	                    padding: 10,
	                    borderRadius: 5,
	                } },
	                React__default["default"].createElement(material.Box, { sx: { ml: 3 } },
	                    React__default["default"].createElement(material.Typography, { variant: "caption", fontSize: 12 }, "Select the destination feature to copy the selected features"),
	                    React__default["default"].createElement(material.Box, { sx: { mt: 1 } },
	                        React__default["default"].createElement(material.Select, { labelId: "label", style: { width: '100%' }, value: selectedDestinationFeature?._id ?? '', onChange: handleDestinationFeatureChange, disabled: createNewGene }, destinationFeatures.map((f) => (React__default["default"].createElement(material.MenuItem, { key: f._id, value: f._id }, `${getFeatureNameOrId(f)} (${f.min + 1}..${f.max})`)))))),
	                React__default["default"].createElement(material.Box, { sx: { ml: 3 } },
	                    React__default["default"].createElement(material.FormGroup, null,
	                        React__default["default"].createElement(material.FormControlLabel, { control: React__default["default"].createElement(material.Checkbox, { checked: createNewGene, onChange: handleCreateNewGeneChange }), label: "Create new gene" })))))),
	        React__default["default"].createElement(material.DialogActions, null,
	            React__default["default"].createElement(material.Button, { variant: "contained", type: "submit", disabled: checkedChildrens.length === 0 ||
	                    (!parentFeatureChecked &&
	                        checkedChildrens.length > 0 &&
	                        !selectedDestinationFeature), onClick: handleCreateApolloAnnotation }, "Create"),
	            React__default["default"].createElement(material.Button, { variant: "outlined", type: "submit", onClick: handleClose }, "Cancel")),
	        errorMessage ? (React__default["default"].createElement(material.DialogContent, null,
	            React__default["default"].createElement(material.DialogContentText, { color: "error" }, errorMessage))) : null));
	}

	function parseCigar(cigar) {
	    const regex = /(\d+)([MIDNSHPX=])/g;
	    const result = [];
	    let match;
	    while ((match = regex.exec(cigar)) !== null) {
	        result.push([match[2], Number.parseInt(match[1], 10)]);
	    }
	    return result;
	}
	function annotationFromPileup(pluggableElement) {
	    if (pluggableElement.name !== 'LinearPileupDisplay') {
	        return pluggableElement;
	    }
	    const { stateModel } = pluggableElement;
	    const newStateModel = stateModel
	        .views((self) => ({
	        getFirstRegion() {
	            const lgv = require$$1$2.getContainingView(self);
	            return lgv.dynamicBlocks.contentBlocks[0];
	        },
	        getAssembly() {
	            const firstRegion = self.getFirstRegion();
	            const session = require$$1$2.getSession(self);
	            const { assemblyManager } = session;
	            const { assemblyName } = firstRegion;
	            const assembly = assemblyManager.get(assemblyName);
	            if (!assembly) {
	                throw new Error(`Could not find assembly named ${assemblyName}`);
	            }
	            return assembly;
	        },
	        getRefSeqId(assembly) {
	            const firstRegion = self.getFirstRegion();
	            const { refName } = firstRegion;
	            const { refNameAliases } = assembly;
	            if (!refNameAliases) {
	                throw new Error(`Could not find aliases for ${assembly.name}`);
	            }
	            const newRefNames = [...Object.entries(refNameAliases)]
	                .filter(([id, refName]) => id !== refName)
	                .map(([id, refName]) => ({
	                _id: id,
	                name: refName,
	            }));
	            const refSeqId = newRefNames.find((item) => item.name === refName)?._id;
	            if (!refSeqId) {
	                throw new Error(`Could not find refSeqId named ${refName}`);
	            }
	            return refSeqId;
	        },
	        getAnnotationFeature() {
	            const feature = self.contextMenuFeature;
	            const assembly = self.getAssembly();
	            const refSeqId = self.getRefSeqId(assembly);
	            const start = feature.get('start');
	            const end = feature.get('end');
	            const strand = feature.get('strand');
	            const name = feature.get('name');
	            const cigarData = feature.get('CIGAR');
	            const ops = parseCigar(cigarData);
	            let position = start;
	            let currentExonStart;
	            const exons = [];
	            // Example: [[96,S], [4,M], [4216,N], [357,M], [1,I], [628,M], [94,S]]
	            // Results in 2 exons
	            // M, = and X are matches -> exon
	            // N is a gap in the reference sequence -> intron
	            // I, S, H and P -> not counted in reference position
	            for (const [op, len] of ops) {
	                switch (op) {
	                    case 'M':
	                    case '=':
	                    case 'X': {
	                        if (currentExonStart === undefined) {
	                            currentExonStart = position;
	                        }
	                        position += len;
	                        break;
	                    }
	                    case 'N': {
	                        if (currentExonStart !== undefined) {
	                            exons.push({
	                                start: currentExonStart,
	                                end: position,
	                            });
	                            currentExonStart = undefined;
	                        }
	                        position += len;
	                        break;
	                    }
	                    case 'D': {
	                        position += len;
	                        break;
	                    }
	                    case 'I':
	                    case 'S':
	                    case 'H':
	                    case 'P': {
	                        // These operations do not affect the position in the reference sequence
	                        break;
	                    }
	                    default: {
	                        throw new Error(`Unknown CIGAR operation: ${op}`);
	                    }
	                }
	            }
	            // If still in exon at end
	            if (currentExonStart !== undefined) {
	                exons.push({
	                    start: currentExonStart,
	                    end: position,
	                });
	            }
	            const newFeature = {
	                _id: objectid().toHexString(),
	                refSeq: refSeqId,
	                min: start,
	                max: end,
	                type: 'mRNA',
	                strand,
	                attributes: {
	                    name: [name],
	                },
	            };
	            if (exons.length === 0) {
	                return newFeature;
	            }
	            const children = {};
	            newFeature.children = children;
	            for (const exon of exons) {
	                const newExon = {
	                    _id: objectid().toHexString(),
	                    refSeq: refSeqId,
	                    min: exon.start,
	                    max: exon.end,
	                    type: 'exon',
	                    strand,
	                };
	                newFeature.children[newExon._id] = newExon;
	            }
	            return newFeature;
	        },
	    }))
	        .views((self) => {
	        const superContextMenuItems = self.contextMenuItems;
	        return {
	            contextMenuItems() {
	                const session = require$$1$2.getSession(self);
	                const assembly = self.getAssembly();
	                const region = self.getFirstRegion();
	                const feature = self.contextMenuFeature;
	                if (!feature) {
	                    return superContextMenuItems();
	                }
	                return [
	                    ...superContextMenuItems(),
	                    {
	                        label: 'Create Apollo annotation',
	                        icon: default_1$p,
	                        onClick: () => {
	                            session.queueDialog((doneCallback) => [
	                                CreateApolloAnnotation,
	                                {
	                                    session,
	                                    handleClose: () => {
	                                        doneCallback();
	                                    },
	                                    annotationFeature: self.getAnnotationFeature(assembly),
	                                    assembly,
	                                    refSeqId: self.getRefSeqId(assembly),
	                                    region,
	                                },
	                            ]);
	                        },
	                    },
	                ];
	            },
	        };
	    });
	    pluggableElement.stateModel = newStateModel;
	    return pluggableElement;
	}

	function simpleFeatureToGFF3Feature(feature, refSeqId) {
	    // eslint-disable-next-line unicorn/prefer-structured-clone
	    const xfeature = JSON.parse(JSON.stringify(feature));
	    const children = xfeature.subfeatures;
	    const gff3Feature = [
	        {
	            start: xfeature.start + 1,
	            end: xfeature.end,
	            seq_id: refSeqId,
	            source: xfeature.source ?? null,
	            type: xfeature.type ?? null,
	            score: xfeature.score ?? null,
	            strand: xfeature.strand ? (xfeature.strand === 1 ? '+' : '-') : null,
	            phase: xfeature.phase !== null || xfeature.phase !== undefined
	                ? xfeature.phase
	                : null,
	            attributes: convertFeatureAttributes(xfeature),
	            derived_features: [],
	            child_features: children
	                ? children.map((x) => simpleFeatureToGFF3Feature(x, refSeqId))
	                : [],
	        },
	    ];
	    return gff3Feature;
	}
	function jbrowseFeatureToAnnotationFeature(feature, refSeqId) {
	    return dist$2.gff3ToAnnotationFeature(simpleFeatureToGFF3Feature(feature, refSeqId));
	}
	function convertFeatureAttributes(feature) {
	    const attributes = {};
	    const defaultFields = new Set([
	        'start',
	        'end',
	        'type',
	        'strand',
	        'refName',
	        'subfeatures',
	        'derived_features',
	        'phase',
	        'source',
	        'score',
	    ]);
	    for (const [key, value] of Object.entries(feature)) {
	        if (defaultFields.has(key)) {
	            continue;
	        }
	        attributes[key] = Array.isArray(value) ? value.map(String) : [String(value)];
	    }
	    return attributes;
	}
	function annotationFromJBrowseFeature(pluggableElement) {
	    if (pluggableElement.name !== 'LinearBasicDisplay') {
	        return pluggableElement;
	    }
	    const { stateModel } = pluggableElement;
	    const newStateModel = stateModel
	        .views((self) => ({
	        getFirstRegion() {
	            const lgv = require$$1$2.getContainingView(self);
	            return lgv.dynamicBlocks.contentBlocks[0];
	        },
	        getAssembly() {
	            const firstRegion = self.getFirstRegion();
	            const session = require$$1$2.getSession(self);
	            const { assemblyManager } = session;
	            const { assemblyName } = firstRegion;
	            const assembly = assemblyManager.get(assemblyName);
	            if (!assembly) {
	                throw new Error(`Could not find assembly named ${assemblyName}`);
	            }
	            return assembly;
	        },
	        getRefSeqId(assembly) {
	            const firstRegion = self.getFirstRegion();
	            const { refName } = firstRegion;
	            const { refNameAliases } = assembly;
	            if (!refNameAliases) {
	                throw new Error(`Could not find aliases for ${assembly.name}`);
	            }
	            const newRefNames = [...Object.entries(refNameAliases)]
	                .filter(([id, refName]) => id !== refName)
	                .map(([id, refName]) => ({
	                _id: id,
	                name: refName,
	            }));
	            const refSeqId = newRefNames.find((item) => item.name === refName)?._id;
	            if (!refSeqId) {
	                throw new Error(`Could not find refSeqId named ${refName}`);
	            }
	            return refSeqId;
	        },
	        getAnnotationFeature(assembly) {
	            const refSeqId = self.getRefSeqId(assembly);
	            const sfeature = self.contextMenuFeature.data;
	            return jbrowseFeatureToAnnotationFeature(sfeature, refSeqId);
	        },
	    }))
	        .views((self) => {
	        const superContextMenuItems = self.contextMenuItems;
	        return {
	            contextMenuItems() {
	                const session = require$$1$2.getSession(self);
	                const assembly = self.getAssembly();
	                const region = self.getFirstRegion();
	                const feature = self.contextMenuFeature;
	                if (!feature) {
	                    return superContextMenuItems();
	                }
	                return [
	                    ...superContextMenuItems(),
	                    {
	                        label: 'Create Apollo annotation',
	                        icon: default_1$p,
	                        onClick: () => {
	                            session.queueDialog((doneCallback) => [
	                                CreateApolloAnnotation,
	                                {
	                                    session,
	                                    handleClose: () => {
	                                        doneCallback();
	                                    },
	                                    annotationFeature: self.getAnnotationFeature(assembly),
	                                    assembly,
	                                    refSeqId: self.getRefSeqId(assembly),
	                                    region,
	                                },
	                            ]);
	                        },
	                    },
	                ];
	            },
	        };
	    });
	    pluggableElement.stateModel = newStateModel;
	    return pluggableElement;
	}

	var ExpandLess = {};

	var _interopRequireDefault$2 = interopRequireDefault.exports;
	Object.defineProperty(ExpandLess, "__esModule", {
	  value: true
	});
	var default_1$2 = ExpandLess["default"] = void 0;
	var _createSvgIcon$2 = /*#__PURE__*/_interopRequireDefault$2(createSvgIcon);
	var _jsxRuntime$2 = require$$2__default["default"];
	var _default$2 = /*#__PURE__*/(0, _createSvgIcon$2["default"])( /*#__PURE__*/(0, _jsxRuntime$2.jsx)("path", {
	  d: "m12 8-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z"
	}), 'ExpandLess');
	default_1$2 = ExpandLess["default"] = _default$2;

	var _Error = {};

	var _interopRequireDefault$1 = interopRequireDefault.exports;
	Object.defineProperty(_Error, "__esModule", {
	  value: true
	});
	var default_1$1 = _Error["default"] = void 0;
	var _createSvgIcon$1 = /*#__PURE__*/_interopRequireDefault$1(createSvgIcon);
	var _jsxRuntime$1 = require$$2__default["default"];
	var _default$1 = /*#__PURE__*/(0, _createSvgIcon$1["default"])( /*#__PURE__*/(0, _jsxRuntime$1.jsx)("path", {
	  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"
	}), 'Error');
	default_1$1 = _Error["default"] = _default$1;

	/* eslint-disable @typescript-eslint/unbound-method */
	const useStyles$2 = mui.makeStyles()((theme) => ({
	    canvasContainer: {
	        position: 'relative',
	        left: 0,
	    },
	    canvas: {
	        position: 'absolute',
	        left: 0,
	    },
	    ellipses: {
	        textOverflow: 'ellipsis',
	        overflow: 'hidden',
	    },
	    avatar: {
	        position: 'absolute',
	        color: theme.palette.warning.light,
	        backgroundColor: theme.palette.warning.contrastText,
	    },
	    loading: {
	        position: 'absolute',
	        right: theme.spacing(3),
	        zIndex: 10,
	        pointerEvents: 'none',
	        textAlign: 'right',
	    },
	}));
	const LinearApolloDisplay = mobxReact.observer(function LinearApolloDisplay(props) {
	    const theme = material.useTheme();
	    const { model } = props;
	    const { loading, apolloDragging, apolloRowHeight, contextMenuItems: getContextMenuItems, cursor, featuresHeight, isShown, onMouseDown, onMouseLeave, onMouseMove, onMouseUp, regionCannotBeRendered, session, setCanvas, setCollaboratorCanvas, setOverlayCanvas, setSeqTrackCanvas, setSeqTrackOverlayCanvas, setTheme, } = model;
	    const { classes } = useStyles$2();
	    const lgv = require$$1$2.getContainingView(model);
	    React.useEffect(() => {
	        setTheme(theme);
	    }, [theme, setTheme]);
	    const [contextCoord, setContextCoord] = React.useState();
	    const [contextMenuItems, setContextMenuItems] = React.useState([]);
	    const message = regionCannotBeRendered();
	    if (!isShown) {
	        return null;
	    }
	    const { assemblyManager } = session;
	    return (React__default["default"].createElement(React__default["default"].Fragment, null,
	        3 / lgv.bpPerPx >= 1 ? (React__default["default"].createElement("div", { className: classes.canvasContainer, style: {
	                width: lgv.dynamicBlocks.totalWidthPx,
	                height: lgv.bpPerPx <= 1 ? 125 : 95,
	            } },
	            React__default["default"].createElement("canvas", { ref: async (node) => {
	                    await Promise.resolve();
	                    setSeqTrackCanvas(node);
	                }, width: lgv.dynamicBlocks.totalWidthPx, height: lgv.bpPerPx <= 1 ? 125 : 95, className: classes.canvas, "data-testid": "seqTrackCanvas" }),
	            React__default["default"].createElement("canvas", { ref: async (node) => {
	                    await Promise.resolve();
	                    setSeqTrackOverlayCanvas(node);
	                }, width: lgv.dynamicBlocks.totalWidthPx, height: lgv.bpPerPx <= 1 ? 125 : 95, className: classes.canvas, "data-testid": "seqTrackOverlayCanvas" }))) : null,
	        React__default["default"].createElement("div", { className: classes.canvasContainer, style: {
	                width: lgv.dynamicBlocks.totalWidthPx,
	                height: featuresHeight,
	            }, onContextMenu: (event) => {
	                event.preventDefault();
	                if (contextMenuItems.length > 0) {
	                    // There's already a context menu open, so close it
	                    setContextMenuItems([]);
	                }
	                else {
	                    const coord = [event.clientX, event.clientY];
	                    setContextCoord(coord);
	                    setContextMenuItems(getContextMenuItems(event));
	                }
	            } },
	            loading ? (React__default["default"].createElement("div", { className: classes.loading },
	                React__default["default"].createElement(material.CircularProgress, { size: "18px" }))) : null,
	            message ? (React__default["default"].createElement(material.Alert, { severity: "warning", classes: { message: classes.ellipses } },
	                React__default["default"].createElement(material.Tooltip, { title: message },
	                    React__default["default"].createElement("div", null, message)))) : (
	            // Promise.resolve() in these 3 callbacks is to avoid infinite rendering loop
	            // https://github.com/mobxjs/mobx/issues/3728#issuecomment-1715400931
	            React__default["default"].createElement(React__default["default"].Fragment, null,
	                React__default["default"].createElement("canvas", { ref: async (node) => {
	                        await Promise.resolve();
	                        setCollaboratorCanvas(node);
	                    }, width: lgv.dynamicBlocks.totalWidthPx, height: featuresHeight, className: classes.canvas, "data-testid": "collaboratorCanvas" }),
	                React__default["default"].createElement("canvas", { ref: async (node) => {
	                        await Promise.resolve();
	                        setCanvas(node);
	                    }, width: lgv.dynamicBlocks.totalWidthPx, height: featuresHeight, className: classes.canvas, "data-testid": "canvas" }),
	                React__default["default"].createElement("canvas", { ref: async (node) => {
	                        await Promise.resolve();
	                        setOverlayCanvas(node);
	                    }, width: lgv.dynamicBlocks.totalWidthPx, height: featuresHeight, onMouseMove: onMouseMove, onMouseLeave: onMouseLeave, onMouseDown: onMouseDown, onMouseUp: onMouseUp, className: classes.canvas, style: { cursor: cursor ?? 'default' }, "data-testid": "overlayCanvas" }),
	                lgv.displayedRegions.flatMap((region, idx) => {
	                    const assembly = assemblyManager.get(region.assemblyName);
	                    return [...session.apolloDataStore.checkResults.values()]
	                        .filter((checkResult) => assembly?.isValidRefName(checkResult.refSeq) &&
	                        assembly.getCanonicalRefName(checkResult.refSeq) ===
	                            region.refName &&
	                        require$$1$2.doesIntersect2(region.start, region.end, checkResult.start, checkResult.end))
	                        .map((checkResult) => {
	                        const left = (lgv.bpToPx({
	                            refName: region.refName,
	                            coord: checkResult.start,
	                            regionNumber: idx,
	                        })?.offsetPx ?? 0) - lgv.offsetPx;
	                        const [feature] = checkResult.ids;
	                        if (!feature) {
	                            return null;
	                        }
	                        let row = 0;
	                        const featureLayout = model.getFeatureLayoutPosition(feature);
	                        if (featureLayout) {
	                            row = featureLayout.layoutRow + featureLayout.featureRow;
	                        }
	                        const top = row * apolloRowHeight;
	                        const height = apolloRowHeight;
	                        return (React__default["default"].createElement(material.Tooltip, { key: checkResult._id, title: checkResult.message },
	                            React__default["default"].createElement(material.Avatar, { className: classes.avatar, style: {
	                                    top,
	                                    left,
	                                    height,
	                                    width: height,
	                                    pointerEvents: apolloDragging ? 'none' : 'auto',
	                                } },
	                                React__default["default"].createElement(default_1$1, { "data-testid": "ErrorIcon" }))));
	                    });
	                }),
	                React__default["default"].createElement(ui.Menu, { open: contextMenuItems.length > 0, onMenuItemClick: (_, callback) => {
	                        callback();
	                        setContextMenuItems([]);
	                    }, onClose: () => {
	                        setContextMenuItems([]);
	                    }, TransitionProps: {
	                        onExit: () => {
	                            setContextMenuItems([]);
	                        },
	                    }, anchorReference: "anchorPosition", anchorPosition: contextCoord
	                        ? { top: contextCoord[1], left: contextCoord[0] }
	                        : undefined, style: { zIndex: theme.zIndex.tooltip }, menuItems: contextMenuItems }))))));
	});

	const TrackLines = mobxReact.observer(function TrackLines({ model, hrStyle = { margin: 0, top: 0, color: 'black' }, idx = 0, }) {
	    const { apolloRowHeight, highestRow, showFeatureLabels } = model;
	    const featureLabelSpacer = showFeatureLabels ? 2 : 1;
	    return (React__default["default"].createElement("div", { style: {
	            position: 'absolute',
	            left: 0,
	            top: (apolloRowHeight * featureLabelSpacer * (highestRow + 1)) / 2 +
	                idx * featureLabelSpacer * apolloRowHeight,
	            width: '100%',
	        } },
	        React__default["default"].createElement("hr", { style: hrStyle })));
	});

	/* eslint-disable @typescript-eslint/unbound-method */
	const useStyles$1 = mui.makeStyles()((theme) => ({
	    canvasContainer: {
	        position: 'relative',
	        left: 0,
	    },
	    canvas: {
	        position: 'absolute',
	        left: 0,
	    },
	    ellipses: {
	        textOverflow: 'ellipsis',
	        overflow: 'hidden',
	    },
	    avatar: {
	        position: 'absolute',
	        color: theme.palette.warning.light,
	        backgroundColor: theme.palette.warning.contrastText,
	    },
	}));
	const LinearApolloSixFrameDisplay = mobxReact.observer(function LinearApolloSixFrameDisplay(props) {
	    const theme = material.useTheme();
	    const { model } = props;
	    const { apolloRowHeight, contextMenuItems: getContextMenuItems, cursor, featuresHeight, isShown, onMouseDown, onMouseLeave, onMouseMove, onMouseUp, regionCannotBeRendered, session, setCanvas, setCollaboratorCanvas, setOverlayCanvas, setTheme, } = model;
	    const { classes } = useStyles$1();
	    const lgv = require$$1$2.getContainingView(model);
	    React.useEffect(() => {
	        setTheme(theme);
	    }, [theme, setTheme]);
	    const [contextCoord, setContextCoord] = React.useState();
	    const [contextMenuItems, setContextMenuItems] = React.useState([]);
	    const message = regionCannotBeRendered();
	    if (!isShown) {
	        return null;
	    }
	    const { assemblyManager } = session;
	    return (React__default["default"].createElement(React__default["default"].Fragment, null,
	        React__default["default"].createElement("div", { className: classes.canvasContainer, style: {
	                width: lgv.dynamicBlocks.totalWidthPx,
	                height: featuresHeight,
	            }, onContextMenu: (event) => {
	                event.preventDefault();
	                if (contextMenuItems.length > 0) {
	                    // There's already a context menu open, so close it
	                    setContextMenuItems([]);
	                }
	                else {
	                    const coord = [event.clientX, event.clientY];
	                    setContextCoord(coord);
	                    setContextMenuItems(getContextMenuItems(coord));
	                }
	            } }, message ? (React__default["default"].createElement(material.Alert, { severity: "warning", classes: { message: classes.ellipses } },
	            React__default["default"].createElement(material.Tooltip, { title: message },
	                React__default["default"].createElement("div", null, message)))) : (
	        // Promise.resolve() in these 3 callbacks is to avoid infinite rendering loop
	        // https://github.com/mobxjs/mobx/issues/3728#issuecomment-1715400931
	        React__default["default"].createElement(React__default["default"].Fragment, null,
	            React__default["default"].createElement(TrackLines, { model: model, idx: 0 }),
	            React__default["default"].createElement(TrackLines, { model: model, hrStyle: { margin: 0, top: 0, color: 'grey', opacity: 0.4 }, idx: 1 }),
	            React__default["default"].createElement(TrackLines, { model: model, idx: 2 }),
	            React__default["default"].createElement("canvas", { ref: async (node) => {
	                    await Promise.resolve();
	                    setCollaboratorCanvas(node);
	                }, width: lgv.dynamicBlocks.totalWidthPx, height: featuresHeight, className: classes.canvas, "data-testid": "collaboratorCanvas" }),
	            React__default["default"].createElement("canvas", { ref: async (node) => {
	                    await Promise.resolve();
	                    setCanvas(node);
	                }, width: lgv.dynamicBlocks.totalWidthPx, height: featuresHeight, className: classes.canvas, "data-testid": "canvas" }),
	            React__default["default"].createElement("canvas", { ref: async (node) => {
	                    await Promise.resolve();
	                    setOverlayCanvas(node);
	                }, width: lgv.dynamicBlocks.totalWidthPx, height: featuresHeight, onMouseMove: onMouseMove, onMouseLeave: onMouseLeave, onMouseDown: onMouseDown, onMouseUp: onMouseUp, className: classes.canvas, style: { cursor: cursor ?? 'default' }, "data-testid": "overlayCanvas" }),
	            lgv.displayedRegions.flatMap((region, idx) => {
	                const assembly = assemblyManager.get(region.assemblyName);
	                return [...session.apolloDataStore.checkResults.values()]
	                    .filter((checkResult) => assembly?.isValidRefName(checkResult.refSeq) &&
	                    assembly.getCanonicalRefName(checkResult.refSeq) ===
	                        region.refName &&
	                    require$$1$2.doesIntersect2(region.start, region.end, checkResult.start, checkResult.end))
	                    .map((checkResult) => {
	                    const left = (lgv.bpToPx({
	                        refName: region.refName,
	                        coord: checkResult.start,
	                        regionNumber: idx,
	                    })?.offsetPx ?? 0) - lgv.offsetPx;
	                    const [feature] = checkResult.ids;
	                    if (!feature || !feature.parent?.looksLikeGene) {
	                        return null;
	                    }
	                    const top = 0;
	                    const height = apolloRowHeight;
	                    return (React__default["default"].createElement(material.Tooltip, { key: checkResult._id, title: checkResult.message },
	                        React__default["default"].createElement(material.Avatar, { className: classes.avatar, style: { top, left, height, width: height } },
	                            React__default["default"].createElement(default_1$1, null))));
	                });
	            }),
	            React__default["default"].createElement(ui.Menu, { open: contextMenuItems.length > 0, onMenuItemClick: (_, callback) => {
	                    callback();
	                    setContextMenuItems([]);
	                }, onClose: () => {
	                    setContextMenuItems([]);
	                }, TransitionProps: {
	                    onExit: () => {
	                        setContextMenuItems([]);
	                    },
	                }, anchorReference: "anchorPosition", anchorPosition: contextCoord
	                    ? { top: contextCoord[1], left: contextCoord[0] }
	                    : undefined, style: { zIndex: theme.zIndex.tooltip }, menuItems: contextMenuItems }))))));
	});

	/* eslint-disable @typescript-eslint/unbound-method */
	const accordionControlHeight = 12;
	const useStyles = mui.makeStyles()((theme) => ({
	    shading: {
	        background: material.alpha(theme.palette.primary.main, 0.2),
	        overflowY: 'scroll',
	        overflowX: 'hidden',
	    },
	    details: {
	        background: theme.palette.background.paper,
	    },
	    accordionControl: {
	        height: accordionControlHeight,
	        width: '100%',
	        '&:hover': {
	            background: theme.palette.action.hover,
	        },
	        display: 'flex',
	        alignItems: 'center',
	        justifyContent: 'center',
	    },
	    accordionRoot: {
	        background: theme.palette.divider,
	    },
	    resizeHandle: {
	        width: '100%',
	        height: 4,
	        position: 'absolute',
	        cursor: 'row-resize',
	        zIndex: 100,
	    },
	    expandIcon: {
	    // position: 'relative',
	    },
	    title: {
	        // position: 'relative',
	        userSelect: 'none',
	    },
	    alertContainer: {
	        display: 'flex',
	        alignItems: 'center',
	        justifyContent: 'center',
	    },
	}));
	function scrollSelectedFeatureIntoView(model, scrollContainerRef) {
	    const { apolloRowHeight, selectedFeature } = model;
	    if (scrollContainerRef.current && selectedFeature) {
	        const position = model.getFeatureLayoutPosition(selectedFeature);
	        if (position) {
	            const row = position.layoutRow + position.featureRow;
	            const top = row * apolloRowHeight;
	            scrollContainerRef.current.scroll({ top, behavior: 'smooth' });
	        }
	    }
	}
	const ResizeHandle = ({ onResize, }) => {
	    const { classes } = useStyles();
	    const mouseMove = React.useCallback((event) => {
	        event.stopPropagation();
	        event.preventDefault();
	        onResize(event.movementY);
	    }, [onResize]);
	    const cancelDrag = React.useCallback((event) => {
	        event.stopPropagation();
	        event.preventDefault();
	        globalThis.removeEventListener('mousemove', mouseMove);
	        globalThis.removeEventListener('mouseup', cancelDrag);
	        globalThis.removeEventListener('mouseleave', cancelDrag);
	    }, [mouseMove]);
	    return (
	    // TODO: a11y
	    // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
	    React__default["default"].createElement("div", { onMouseDown: (event) => {
	            event.stopPropagation();
	            globalThis.addEventListener('mousemove', mouseMove);
	            globalThis.addEventListener('mouseup', cancelDrag);
	            globalThis.addEventListener('mouseleave', cancelDrag);
	        }, onClick: (e) => {
	            e.stopPropagation();
	            e.preventDefault();
	        }, className: classes.resizeHandle }));
	};
	const AccordionControl = mobxReact.observer(function AccordionControl({ onClick, onResize, open, title, }) {
	    const { classes } = useStyles();
	    return (React__default["default"].createElement("div", { className: classes.accordionRoot },
	        open && onResize ? React__default["default"].createElement(ResizeHandle, { onResize: onResize }) : null,
	        React__default["default"].createElement("div", { className: classes.accordionControl, onClick: onClick },
	            open ? (React__default["default"].createElement(default_1$2, { className: classes.expandIcon })) : (React__default["default"].createElement(default_1$a, { className: classes.expandIcon })),
	            title ? (React__default["default"].createElement(material.Typography, { className: classes.title, variant: "caption", component: "span" }, title)) : null)));
	});
	const LinearApolloDisplayComponent = mobxReact.observer(function DisplayComponent({ model, ...other }) {
	    const session = require$$1$2.getSession(model);
	    const { ontologyManager } = session.apolloDataStore;
	    const { featureTypeOntology } = ontologyManager;
	    const ontologyStore = featureTypeOntology?.dataStore;
	    const { classes } = useStyles();
	    const { graphical, height: overallHeight, isShown, selectedFeature, table, tabularEditor, toggleShown, } = model;
	    const canvasScrollContainerRef = React.useRef(null);
	    React.useEffect(() => {
	        scrollSelectedFeatureIntoView(model, canvasScrollContainerRef);
	    }, [model, selectedFeature]);
	    const onDetailsResize = (delta) => {
	        model.setDetailsHeight(model.detailsHeight - delta);
	    };
	    if (!ontologyStore) {
	        return (React__default["default"].createElement("div", { className: classes.alertContainer },
	            React__default["default"].createElement(material.Alert, { severity: "error" }, "Could not load feature type ontology.")));
	    }
	    if (graphical && table) {
	        const tabularHeight = tabularEditor.isShown ? model.detailsHeight : 0;
	        const featureAreaHeight = isShown
	            ? overallHeight - model.detailsHeight - accordionControlHeight * 2
	            : 0;
	        return (React__default["default"].createElement("div", { style: { height: overallHeight } },
	            React__default["default"].createElement(AccordionControl, { open: isShown, title: "Graphical", onClick: toggleShown }),
	            React__default["default"].createElement("div", { className: classes.shading, ref: canvasScrollContainerRef, style: { height: featureAreaHeight } },
	                React__default["default"].createElement(LinearApolloDisplay, { model: model, ...other })),
	            React__default["default"].createElement(AccordionControl, { title: "Table", open: tabularEditor.isShown, onClick: tabularEditor.togglePane, onResize: onDetailsResize }),
	            React__default["default"].createElement("div", { className: classes.details, style: { height: tabularHeight } },
	                React__default["default"].createElement(TabularEditorPane, { model: model }))));
	    }
	    if (graphical) {
	        return (React__default["default"].createElement("div", { className: classes.shading, ref: canvasScrollContainerRef, style: { height: overallHeight } },
	            React__default["default"].createElement(LinearApolloDisplay, { model: model, ...other })));
	    }
	    return (React__default["default"].createElement("div", { className: classes.details, style: { height: overallHeight } },
	        React__default["default"].createElement(TabularEditorPane, { model: model })));
	});
	const LinearApolloSixFrameDisplayComponent = mobxReact.observer(function DisplayComponent({ model, ...other }) {
	    const session = require$$1$2.getSession(model);
	    const { ontologyManager } = session.apolloDataStore;
	    const { featureTypeOntology } = ontologyManager;
	    const ontologyStore = featureTypeOntology?.dataStore;
	    const { classes } = useStyles();
	    const { detailsHeight, graphical, height: overallHeight, isShown, selectedFeature, table, tabularEditor, toggleShown, } = model;
	    const canvasScrollContainerRef = React.useRef(null);
	    React.useEffect(() => {
	        scrollSelectedFeatureIntoView(model, canvasScrollContainerRef);
	    }, [model, selectedFeature]);
	    const onDetailsResize = (delta) => {
	        model.setDetailsHeight(detailsHeight - delta);
	    };
	    if (!ontologyStore) {
	        return (React__default["default"].createElement("div", { className: classes.alertContainer },
	            React__default["default"].createElement(material.Alert, { severity: "error" }, "Could not load feature type ontology.")));
	    }
	    if (graphical && table) {
	        const tabularHeight = tabularEditor.isShown ? detailsHeight : 0;
	        const featureAreaHeight = isShown
	            ? overallHeight - detailsHeight - accordionControlHeight * 2
	            : 0;
	        return (React__default["default"].createElement("div", { style: { height: overallHeight } },
	            React__default["default"].createElement(AccordionControl, { open: isShown, title: "Graphical", onClick: toggleShown }),
	            React__default["default"].createElement("div", { className: classes.shading, ref: canvasScrollContainerRef, style: { height: featureAreaHeight } },
	                React__default["default"].createElement(LinearApolloSixFrameDisplay, { model: model, ...other })),
	            React__default["default"].createElement(AccordionControl, { title: "Table", open: tabularEditor.isShown, onClick: tabularEditor.togglePane, onResize: onDetailsResize }),
	            React__default["default"].createElement("div", { className: classes.details, style: { height: tabularHeight } },
	                React__default["default"].createElement(TabularEditorPane, { model: model }))));
	    }
	    if (graphical) {
	        return (React__default["default"].createElement("div", { className: classes.shading, ref: canvasScrollContainerRef, style: { height: overallHeight } },
	            React__default["default"].createElement(LinearApolloSixFrameDisplay, { model: model, ...other })));
	    }
	    return (React__default["default"].createElement("div", { className: classes.details, style: { height: overallHeight } },
	        React__default["default"].createElement(TabularEditorPane, { model: model })));
	});

	var Save = {};

	var _interopRequireDefault = interopRequireDefault.exports;
	Object.defineProperty(Save, "__esModule", {
	  value: true
	});
	var default_1 = Save["default"] = void 0;
	var _createSvgIcon = /*#__PURE__*/_interopRequireDefault(createSvgIcon);
	var _jsxRuntime = require$$2__default["default"];
	var _default = /*#__PURE__*/(0, _createSvgIcon["default"])( /*#__PURE__*/(0, _jsxRuntime.jsx)("path", {
	  d: "M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"
	}), 'Save');
	default_1 = Save["default"] = _default;

	/* eslint-disable @typescript-eslint/no-unsafe-assignment */
	const ApolloJobModel = require$$1$3.types
	    .model('JobsManager', {})
	    .views((self) => ({
	    get jobStatusWidget() {
	        const { widgets } = require$$1$2.getSession(self);
	        let jobStatusWidget = widgets.get('JobsList');
	        if (!jobStatusWidget) {
	            // @ts-expect-error: addWidget function not detected on the session
	            jobStatusWidget = require$$1$2.getSession(self).addWidget('JobsListWidget', 'JobsList');
	        }
	        return jobStatusWidget;
	    },
	}))
	    .actions((self) => ({
	    /**
	     * updates the status message and the progress percent of the provided job
	     * @param jobName - the name of the job to be updated
	     * @param statusMessage - the message to be communicated to the user
	     * @param progressPct - the percent through the run the job is
	     */
	    update(jobName, statusMessage, progressPct) {
	        self.jobStatusWidget.updateJobStatusMessage(jobName, statusMessage);
	        if (progressPct) {
	            self.jobStatusWidget.updateJobProgressPct(jobName, progressPct);
	        }
	    },
	    /**
	     * aborts the provided job with a message to the user
	     * @param jobName - the name of the job to be aborted
	     * @param msg - a message to communicate to the user about the abort operation
	     */
	    abortJob(jobName, msg) {
	        const session = require$$1$2.getSession(self);
	        if (require$$1$2.isSessionModelWithWidgets(session)) {
	            session.showWidget(self.jobStatusWidget);
	            self.jobStatusWidget.updateJobStatusMessage(jobName, msg ?? 'Aborted unexpectedly');
	            // this is done to avoid issues with reusing nodes from other state trees
	            const indx = self.jobStatusWidget.jobs.findIndex((job) => job.name === jobName);
	            const job = self.jobStatusWidget.jobs[indx];
	            // object needs to be shallow copied before it is removed from the state tree
	            self.jobStatusWidget.addAbortedJob({ ...job });
	            // removes the job from the state tree, this node is inaccessible thereafter
	            self.jobStatusWidget.removeJob(jobName);
	            session.notify('Job aborted', 'info');
	        }
	    },
	    /**
	     * opens the job status widget and adds the job to the running jobs
	     * @param job - the job to be run within the JobsManager
	     */
	    runJob(job) {
	        const session = require$$1$2.getSession(self);
	        if (require$$1$2.isSessionModelWithWidgets(session)) {
	            session.showWidget(self.jobStatusWidget);
	            self.jobStatusWidget.addJob(job);
	        }
	    },
	    /**
	     * sets the progress and status message of the provided job
	     * adds the finished jobs to the list of finished jobs
	     * clears the jobs manager of the now done job
	     * begins to run the next job if one is queued
	     * @param job - the job to be completed
	     */
	    done(job) {
	        const session = require$$1$2.getSession(self);
	        if (require$$1$2.isSessionModelWithWidgets(session)) {
	            session.showWidget(self.jobStatusWidget);
	            // this.setProgressPct(100)
	            self.jobStatusWidget.removeJob(job.name);
	            self.jobStatusWidget.addFinishedJob({
	                name: job.name,
	                statusMessage: 'All operations successful',
	                progressPct: 100,
	                cancelCallback: job.cancelCallback,
	            });
	        }
	    },
	}));

	class BackendDriver {
	    clientStore;
	    constructor(clientStore) {
	        this.clientStore = clientStore;
	    }
	}

	/* eslint-disable @typescript-eslint/no-unsafe-assignment */
	class ChangeManager {
	    dataStore;
	    constructor(dataStore) {
	        this.dataStore = dataStore;
	    }
	    recentChanges = [];
	    async submit(change, opts = {}) {
	        const { addToRecents = true, submitToBackend = true, updateJobsManager = false, } = opts;
	        // pre-validate
	        const session = require$$1$2.getSession(this.dataStore);
	        const controller = new AbortController();
	        const { jobsManager } = require$$1$2.getSession(this.dataStore);
	        const job = {
	            name: change.typeName,
	            statusMessage: 'Pre-validating',
	            progressPct: 0,
	            cancelCallback: () => {
	                controller.abort();
	            },
	        };
	        if (updateJobsManager) {
	            jobsManager.runJob(job);
	        }
	        const result = await dist$2.validationRegistry.frontendPreValidate(change);
	        if (!result.ok) {
	            const msg = `Pre-validation failed: "${result.resultsMessages}"`;
	            if (updateJobsManager) {
	                jobsManager.abortJob(job.name, msg);
	            }
	            session.notify(msg, 'error');
	            return;
	        }
	        try {
	            // submit to client data store
	            await change.execute(this.dataStore);
	        }
	        catch (error) {
	            if (updateJobsManager) {
	                jobsManager.abortJob(job.name, String(error));
	            }
	            console.error(error);
	            session.notify(`Error encountered in client: ${String(error)}. Data may be out of sync, please refresh the page`, 'error');
	            return;
	        }
	        // post-validate
	        const results2 = await dist$2.validationRegistry.frontendPostValidate(change, this.dataStore);
	        if (!results2.ok) {
	            // notify of invalid change and revert
	            await this.revert(change);
	        }
	        if (submitToBackend) {
	            if (updateJobsManager) {
	                jobsManager.update(job.name, 'Submitting to driver');
	            }
	            // submit to driver
	            const { collaborationServerDriver, getBackendDriver } = this.dataStore;
	            const backendDriver = dist$3.isAssemblySpecificChange(change)
	                ? getBackendDriver(change.assembly)
	                : collaborationServerDriver;
	            let backendResult;
	            try {
	                backendResult = await backendDriver.submitChange(change, opts);
	            }
	            catch (error) {
	                if (updateJobsManager) {
	                    jobsManager.abortJob(job.name, String(error));
	                }
	                console.error(error);
	                session.notify(String(error), 'error');
	                await this.revert(change, false);
	                return;
	            }
	            if (!backendResult.ok) {
	                const msg = `Post-validation failed: "${result.resultsMessages}"`;
	                if (updateJobsManager) {
	                    jobsManager.abortJob(job.name, msg);
	                }
	                session.notify(msg, 'error');
	                await this.revert(change, false);
	                return;
	            }
	            if (change.notification) {
	                session.notify(change.notification, 'success');
	            }
	            if (addToRecents) {
	                // Push the change into array
	                this.recentChanges.push(change);
	            }
	        }
	        if (updateJobsManager) {
	            jobsManager.done(job);
	        }
	    }
	    async revert(change, submitToBackend = true) {
	        const inverseChange = change.getInverse();
	        const opts = { submitToBackend, addToRecents: false };
	        return this.submit(inverseChange, opts);
	    }
	    /**
	     * Undo the last change
	     */
	    async revertLastChange() {
	        const lastChange = this.recentChanges.pop();
	        if (!lastChange) {
	            const session = require$$1$2.getSession(this.dataStore);
	            session.notify('No changes to undo!', 'warning');
	            return;
	        }
	        return this.revert(lastChange);
	    }
	}

	/* eslint-disable @typescript-eslint/no-base-to-string */
	class CollaborationServerDriver extends BackendDriver {
	    inFlight = new Map();
	    async fetch(internetAccount, info, init) {
	        const customFetch = internetAccount.getFetcher({
	            locationType: 'UriLocation',
	            uri: info.toString(),
	        });
	        return customFetch(info, init);
	    }
	    async searchFeatures(term, assemblies) {
	        const internetAccount = this.clientStore.getInternetAccount(assemblies[0]);
	        const { baseURL } = internetAccount;
	        const url = new URL('features/searchFeatures', baseURL);
	        const searchParams = new URLSearchParams({
	            assemblies: assemblies.join(','),
	            term,
	        });
	        url.search = searchParams.toString();
	        const uri = url.toString();
	        const response = await this.fetch(internetAccount, uri);
	        if (!response.ok) {
	            const errorMessage = await createFetchErrorMessage(response, 'searchFeatures failed');
	            throw new Error(errorMessage);
	        }
	        return response.json();
	    }
	    /**
	     * Call backend endpoint to get features by criteria
	     * @param region -  Searchable region containing refSeq, start and end
	     * @returns
	     */
	    async getFeatures(region) {
	        const { assemblyName, end, refName, start } = region;
	        const { assemblyManager } = require$$1$2.getSession(this.clientStore);
	        const assembly = assemblyManager.get(assemblyName);
	        if (!assembly) {
	            throw new Error(`Could not find assembly with name "${assemblyName}"`);
	        }
	        const { ids } = configuration.getConf(assembly, ['sequence', 'metadata']);
	        const refSeq = ids[refName];
	        if (!refSeq) {
	            throw new Error(`Could not find refSeq "${refName}"`);
	        }
	        const internetAccount = this.clientStore.getInternetAccount(assemblyName);
	        const { baseURL } = internetAccount;
	        const url = new URL('features/getFeatures', baseURL);
	        const searchParams = new URLSearchParams({
	            refSeq,
	            start: String(start),
	            end: String(end),
	        });
	        url.search = searchParams.toString();
	        const uri = url.toString();
	        const response = await this.fetch(internetAccount, uri);
	        if (!response.ok) {
	            const errorMessage = await createFetchErrorMessage(response, 'getFeatures failed');
	            throw new Error(errorMessage);
	        }
	        this.checkSocket(assemblyName, refName, internetAccount);
	        return response.json();
	    }
	    async getFeatureById(featureId, assemblyName, topLevel) {
	        const internetAccount = this.clientStore.getInternetAccount(assemblyName);
	        const { baseURL } = internetAccount;
	        const url = new URL(`features/${featureId}`, baseURL);
	        const searchParams = new URLSearchParams({
	            topLevel: String(topLevel),
	        });
	        url.search = searchParams.toString();
	        const response = await this.fetch(internetAccount, url.toString());
	        if (!response.ok) {
	            const errorMessage = await createFetchErrorMessage(response, 'getFeatureById failed');
	            throw new Error(errorMessage);
	        }
	        return response.json();
	    }
	    /**
	     * Checks if there is assembly-refSeq specific socket. If not, it opens one
	     * @param assembly - assemblyId
	     * @param refSeq - refSeqName
	     * @param internetAccount - internet account
	     */
	    checkSocket(assembly, refSeq, internetAccount) {
	        const { socket } = internetAccount;
	        const token = internetAccount.retrieveToken();
	        const channel = `${assembly}-${refSeq}`;
	        const changeManager = new ChangeManager(this.clientStore);
	        if (!socket.hasListeners(channel)) {
	            socket.on(channel, async (message) => {
	                // Save server last change sequence into session storage
	                internetAccount.setLastChangeSequenceNumber(Number(message.changeSequence));
	                if (message.userSessionId !== token && message.channel === channel) {
	                    const change = dist$3.Change.fromJSON(message.changeInfo);
	                    await changeManager.submit(change, { submitToBackend: false });
	                }
	            });
	        }
	    }
	    /**
	     * Call backend endpoint to get sequence by criteria
	     * @param region -  Searchable region containing refSeq, start and end
	     * @returns
	     */
	    async getSequence(region) {
	        const inFlightKey = `${region.refName}:${region.start}-${region.end}`;
	        const inFlightPromise = this.inFlight.get(inFlightKey);
	        const { assemblyName, end, refName, start } = region;
	        const { assemblyManager } = require$$1$2.getSession(this.clientStore);
	        const assembly = assemblyManager.get(assemblyName);
	        if (!assembly) {
	            throw new Error(`Could not find assembly with name "${assemblyName}"`);
	        }
	        const { ids } = configuration.getConf(assembly, ['sequence', 'metadata']);
	        const refSeq = ids[refName];
	        if (!refSeq) {
	            throw new Error(`Could not find refSeq "${refName}"`);
	        }
	        if (inFlightPromise) {
	            const seq = await inFlightPromise;
	            return { seq, refSeq };
	        }
	        let apolloAssembly = this.clientStore.assemblies.get(assemblyName);
	        if (!apolloAssembly) {
	            apolloAssembly = this.clientStore.addAssembly(assemblyName);
	        }
	        let apolloRefSeq = apolloAssembly.refSeqs.get(refSeq);
	        if (!apolloRefSeq) {
	            apolloRefSeq = apolloAssembly.addRefSeq(refSeq, refName);
	        }
	        const clientStoreSequence = apolloRefSeq.getSequence(start, end);
	        if (clientStoreSequence.length === end - start) {
	            return { seq: clientStoreSequence, refSeq };
	        }
	        const internetAccount = this.clientStore.getInternetAccount(assemblyName);
	        const { baseURL } = internetAccount;
	        const url = new URL('sequence', baseURL);
	        const searchParams = new URLSearchParams({
	            refSeq,
	            start: String(start),
	            end: String(end),
	        });
	        url.search = searchParams.toString();
	        const uri = url.toString();
	        const seqPromise = this.getSeqFromServer(internetAccount, uri, apolloRefSeq, start, end);
	        this.inFlight.set(inFlightKey, seqPromise);
	        const seq = await seqPromise;
	        this.checkSocket(assemblyName, refName, internetAccount);
	        this.inFlight.delete(inFlightKey);
	        return { seq, refSeq };
	    }
	    async getSeqFromServer(internetAccount, uri, apolloRefSeq, start, stop) {
	        const response = await this.fetch(internetAccount, uri);
	        if (!response.ok) {
	            let errorMessage;
	            try {
	                errorMessage = await response.text();
	            }
	            catch {
	                errorMessage = '';
	            }
	            throw new Error(`getSequence failed: ${response.status} (${response.statusText})${errorMessage ? ` (${errorMessage})` : ''}`);
	        }
	        const seq = await response.text();
	        apolloRefSeq.addSequence({ sequence: seq, start, stop });
	        return seq;
	    }
	    async getRefNameAliases(assemblyName) {
	        const { assemblyManager } = require$$1$2.getSession(this.clientStore);
	        const assembly = assemblyManager.get(assemblyName);
	        if (!assembly) {
	            throw new Error(`Could not find assembly with name "${assemblyName}"`);
	        }
	        const internetAccount = this.clientStore.getInternetAccount(assemblyName);
	        const { baseURL } = internetAccount;
	        const url = new URL('refSeqs', baseURL);
	        const searchParams = new URLSearchParams({ assembly: assemblyName });
	        url.search = searchParams.toString();
	        const uri = url.toString();
	        const response = await this.fetch(internetAccount, uri);
	        if (!response.ok) {
	            let errorMessage;
	            try {
	                errorMessage = await response.text();
	            }
	            catch {
	                errorMessage = '';
	            }
	            throw new Error(`getRefNameAliases failed: ${response.status} (${response.statusText})${errorMessage ? ` (${errorMessage})` : ''}`);
	        }
	        const refSeqs = (await response.json());
	        return refSeqs.map((refSeq) => {
	            return {
	                refName: refSeq.name,
	                aliases: [refSeq._id, ...refSeq.aliases],
	                uniqueId: `alias-${refSeq._id}`,
	            };
	        });
	    }
	    async getRegions(assemblyName) {
	        const { assemblyManager } = require$$1$2.getSession(this.clientStore);
	        const assembly = assemblyManager.get(assemblyName);
	        if (!assembly) {
	            throw new Error(`Could not find assembly with name "${assemblyName}"`);
	        }
	        const internetAccount = this.clientStore.getInternetAccount(assemblyName);
	        const { baseURL } = internetAccount;
	        const url = new URL('refSeqs', baseURL);
	        const searchParams = new URLSearchParams({ assembly: assemblyName });
	        url.search = searchParams.toString();
	        const uri = url.toString();
	        const response = await this.fetch(internetAccount, uri);
	        if (!response.ok) {
	            let errorMessage;
	            try {
	                errorMessage = await response.text();
	            }
	            catch {
	                errorMessage = '';
	            }
	            throw new Error(`getRegions failed: ${response.status} (${response.statusText})${errorMessage ? ` (${errorMessage})` : ''}`);
	        }
	        const refSeqs = await response.json();
	        return refSeqs.map((refSeq) => ({
	            refName: refSeq.name,
	            start: 0,
	            end: refSeq.length,
	        }));
	    }
	    getAssemblies(internetAccountId) {
	        const { assemblyManager } = require$$1$2.getSession(this.clientStore);
	        return assemblyManager.assemblies.filter((assembly) => {
	            const sequenceMetadata = configuration.getConf(assembly, ['sequence', 'metadata']);
	            if (sequenceMetadata &&
	                sequenceMetadata.apollo &&
	                sequenceMetadata.internetAccountConfigId) {
	                if (internetAccountId) {
	                    return sequenceMetadata.internetAccountConfigId === internetAccountId;
	                }
	                return true;
	            }
	            return false;
	        });
	    }
	    async submitChange(change, opts = {}) {
	        const { internetAccountId } = opts;
	        const internetAccount = this.clientStore.getInternetAccount('assembly' in change ? change.assembly : undefined, internetAccountId);
	        const { baseURL } = internetAccount;
	        const url = new URL('changes', baseURL).href;
	        const response = await this.fetch(internetAccount, url, {
	            method: 'POST',
	            body: JSON.stringify(change.toJSON()),
	            headers: { 'Content-Type': 'application/json' },
	        });
	        if (!response.ok) {
	            const errorMessage = await createFetchErrorMessage(response, 'submitChange failed');
	            throw new Error(errorMessage);
	        }
	        const results = new dist$2.ValidationResultSet();
	        if (!response.ok) {
	            results.ok = false;
	        }
	        return results;
	    }
	}

	class InMemoryFileDriver extends BackendDriver {
	    getFeatureById(_featureId, _assemblyName, _topLevel) {
	        throw new Error('Method not implemented.');
	    }
	    async getFeatures() {
	        return [[], []];
	    }
	    async getSequence(region) {
	        const { assemblyName, end, refName, start } = region;
	        const assembly = this.clientStore.assemblies.get(assemblyName);
	        if (!assembly) {
	            return { seq: '', refSeq: refName };
	        }
	        const refSeq = assembly.refSeqs.get(refName);
	        if (!refSeq) {
	            return { seq: '', refSeq: refName };
	        }
	        const seq = refSeq.getSequence(start, end);
	        return { seq, refSeq: refName };
	    }
	    async getRefNameAliases(assemblyName) {
	        const assembly = this.clientStore.assemblies.get(assemblyName);
	        const refNameAliases = [];
	        if (!assembly) {
	            return refNameAliases;
	        }
	        for (const [, refSeq] of assembly.refSeqs) {
	            refNameAliases.push({
	                refName: refSeq.name,
	                aliases: [refSeq._id],
	                uniqueId: `alias-${refSeq._id}`,
	            });
	        }
	        return refNameAliases;
	    }
	    async getRegions(assemblyName) {
	        const assembly = this.clientStore.assemblies.get(assemblyName);
	        if (!assembly) {
	            return [];
	        }
	        const regions = [];
	        for (const [, refSeq] of assembly.refSeqs) {
	            regions.push({
	                assemblyName,
	                refName: refSeq.name,
	                start: refSeq.sequence[0].start,
	                end: refSeq.sequence[0].stop,
	            });
	        }
	        return regions;
	    }
	    getAssemblies() {
	        const { assemblyManager } = require$$1$2.getSession(this.clientStore);
	        return assemblyManager.assemblies.filter((assembly) => {
	            const sequenceMetadata = configuration.getConf(assembly, ['sequence', 'metadata']);
	            return Boolean(sequenceMetadata &&
	                sequenceMetadata.apollo &&
	                !sequenceMetadata.file &&
	                !sequenceMetadata.internetAccountConfigId);
	        });
	    }
	    async submitChange(_change, _opts = {}) {
	        const { clientStore } = this;
	        const { assemblies } = clientStore;
	        clientStore.clearCheckResults();
	        for (const [, assembly] of assemblies) {
	            if (assembly.backendDriverType === 'InMemoryFileDriver') {
	                const checkResults = await checkFeatures(assembly);
	                clientStore.addCheckResults(checkResults);
	            }
	        }
	        return new dist$2.ValidationResultSet();
	    }
	    async searchFeatures(_term, _assemblies) {
	        return [];
	    }
	}

	/* eslint-disable @typescript-eslint/require-await */
	class DesktopFileDriver extends BackendDriver {
	    getFeatureById(_featureId, _assemblyName, _topLevel) {
	        throw new Error('Method not implemented.');
	    }
	    async loadAssembly(assemblyName) {
	        const { assemblyManager } = require$$1$2.getSession(this.clientStore);
	        const assembly = assemblyManager.get(assemblyName);
	        if (!assembly) {
	            throw new Error(`Assembly ${assemblyName} not found`);
	        }
	        const { file } = configuration.getConf(assembly, ['sequence', 'metadata']);
	        // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/consistent-type-imports
	        const fs = require('node:fs');
	        const fileContents = await fs.promises.readFile(file, 'utf8');
	        return loadAssemblyIntoClient(assemblyName, fileContents, this.clientStore);
	    }
	    async getAssembly(assemblyName) {
	        let assembly = this.clientStore.assemblies.get(assemblyName);
	        if (!assembly) {
	            assembly = await this.loadAssembly(assemblyName);
	        }
	        return assembly;
	    }
	    async getRefNameAliases(assemblyName) {
	        const assembly = await this.getAssembly(assemblyName);
	        const refNameAliases = [];
	        for (const [, refSeq] of assembly.refSeqs) {
	            refNameAliases.push({
	                refName: refSeq.name,
	                aliases: [refSeq._id],
	                uniqueId: `alias-${refSeq._id}`,
	            });
	        }
	        return refNameAliases;
	    }
	    async getFeatures(region) {
	        await this.getAssembly(region.assemblyName);
	        return [[], []];
	    }
	    async getSequence(region) {
	        const { assemblyName, end, refName, start } = region;
	        const assembly = await this.getAssembly(assemblyName);
	        const refSeq = assembly.refSeqs.get(refName);
	        if (!refSeq) {
	            throw new Error(`refSeq ${refName} not found in client data store`);
	        }
	        const seq = refSeq.getSequence(start, end);
	        return { seq, refSeq: refName };
	    }
	    async getRegions(assemblyName) {
	        const assembly = await this.getAssembly(assemblyName);
	        const regions = [];
	        for (const [, refSeq] of assembly.refSeqs) {
	            regions.push({
	                assemblyName,
	                refName: refSeq.name,
	                start: refSeq.sequence[0].start,
	                end: refSeq.sequence[0].stop,
	            });
	        }
	        return regions;
	    }
	    getAssemblies() {
	        const { assemblyManager } = require$$1$2.getSession(this.clientStore);
	        return assemblyManager.assemblies.filter((assembly) => {
	            const sequenceMetadata = configuration.getConf(assembly, ['sequence', 'metadata']);
	            return Boolean(sequenceMetadata &&
	                sequenceMetadata.apollo &&
	                !sequenceMetadata.internetAccountConfigId &&
	                sequenceMetadata.file);
	        });
	    }
	    async submitChange(change) {
	        if (!dist$3.isAssemblySpecificChange(change)) {
	            throw new Error(`Cannot use this type of change with local file: "${change.typeName}"`);
	        }
	        const { assemblyManager } = require$$1$2.getSession(this.clientStore);
	        const assembly = assemblyManager.get(change.assembly);
	        if (!assembly) {
	            throw new Error(`Could not find assembly with name "${change.assembly}"`);
	        }
	        const { file } = configuration.getConf(assembly, ['sequence', 'metadata']);
	        const clientAssembly = this.clientStore.assemblies.get(change.assembly);
	        if (!clientAssembly) {
	            throw new Error(`Could not find assembly in client with name "${change.assembly}"`);
	        }
	        const refSeqs = new Set(...clientAssembly.refSeqs.keys());
	        const { checkResults } = this.clientStore;
	        for (const checkResult of checkResults.values()) {
	            if (refSeqs.has(checkResult.refSeq)) {
	                checkResults.delete(checkResult._id);
	            }
	        }
	        const newCheckResults = await checkFeatures(clientAssembly);
	        this.clientStore.addCheckResults(newCheckResults);
	        const gff3Items = [{ directive: 'gff-version', value: '3' }];
	        for (const [, refSeq] of clientAssembly.refSeqs) {
	            gff3Items.push({
	                directive: 'sequence-region',
	                value: `${refSeq.name} 1 ${refSeq.sequence[0].stop}`,
	            });
	        }
	        for (const comment of clientAssembly.comments) {
	            gff3Items.push({ comment });
	        }
	        for (const [, refSeq] of clientAssembly.refSeqs) {
	            const { features } = refSeq;
	            for (const [, feature] of features) {
	                gff3Items.push(dist$2.annotationFeatureToGFF3(require$$1$3.getSnapshot(feature)));
	            }
	        }
	        for (const [, refSeq] of clientAssembly.refSeqs) {
	            const [sequence] = refSeq.sequence;
	            const formattedSequence = dist$2.splitStringIntoChunks(sequence.sequence, 80).join('\n');
	            gff3Items.push({
	                id: refSeq.name,
	                description: refSeq.description,
	                sequence: formattedSequence,
	            });
	        }
	        const gff3Contents = gff.formatSync(gff3Items);
	        // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/consistent-type-imports
	        const fs = require('node:fs');
	        await fs.promises.writeFile(file, gff3Contents, 'utf8');
	        const results = new dist$2.ValidationResultSet();
	        return results;
	    }
	    async searchFeatures(_term, _assemblies) {
	        return [];
	    }
	}

	function clientDataStoreFactory(AnnotationFeatureExtended) {
	    return require$$1$3.types
	        .model('ClientDataStore', {
	        typeName: require$$1$3.types.optional(require$$1$3.types.literal('Client'), 'Client'),
	        assemblies: require$$1$3.types.map(dist.ApolloAssembly),
	        checkResults: require$$1$3.types.map(dist.CheckResult),
	        ontologyManager: require$$1$3.types.optional(OntologyManagerType, {}),
	    })
	        .views((self) => ({
	        get internetAccounts() {
	            return require$$1$3.getRoot(self).internetAccounts;
	        },
	        get pluginConfiguration() {
	            return require$$1$3.getRoot(self).jbrowse.configuration
	                .ApolloPlugin;
	        },
	        getFeature(featureId) {
	            return require$$1$3.resolveIdentifier(AnnotationFeatureExtended, self.assemblies, featureId);
	        },
	    }))
	        .actions((self) => ({
	        addAssembly(assemblyId, backendDriverType) {
	            const assemblySnapshot = {
	                _id: assemblyId,
	                refSeqs: {},
	            };
	            if (backendDriverType) {
	                assemblySnapshot.backendDriverType = backendDriverType;
	            }
	            return self.assemblies.put(assemblySnapshot);
	        },
	        addFeature(assemblyId, feature) {
	            const assembly = self.assemblies.get(assemblyId);
	            if (!assembly) {
	                throw new Error(`Could not find assembly "${assemblyId}" to add feature "${feature._id}"`);
	            }
	            const ref = assembly.refSeqs.get(feature.refSeq);
	            if (!ref) {
	                throw new Error(`Could not find refSeq "${feature.refSeq}" to add feature "${feature._id}"`);
	            }
	            ref.features.put(feature);
	        },
	        deleteFeature(featureId) {
	            const feature = self.getFeature(featureId);
	            if (!feature) {
	                throw new Error(`Could not find feature "${featureId}" to delete`);
	            }
	            const { _id, parent } = feature;
	            if (parent) {
	                parent.deleteChild(featureId);
	            }
	            else {
	                const refSeq = require$$1$3.getParentOfType(feature, dist.ApolloRefSeq);
	                refSeq.deleteFeature(_id);
	            }
	        },
	        deleteAssembly(assemblyId) {
	            self.assemblies.delete(assemblyId);
	        },
	        addCheckResult(checkResult) {
	            self.checkResults.put(checkResult);
	        },
	        addCheckResults(checkResults) {
	            for (const checkResult of checkResults) {
	                if (!self.checkResults.has(checkResult._id)) {
	                    self.checkResults.put(checkResult);
	                }
	            }
	        },
	        deleteCheckResult(checkResultId) {
	            self.checkResults.delete(checkResultId);
	        },
	        clearCheckResults() {
	            self.checkResults.clear();
	        },
	    }))
	        .volatile((self) => ({
	        changeManager: new ChangeManager(self),
	        collaborationServerDriver: new CollaborationServerDriver(self),
	        inMemoryFileDriver: new InMemoryFileDriver(self),
	        desktopFileDriver: require$$1$2.isElectron
	            ? new DesktopFileDriver(self)
	            : undefined,
	    }))
	        .actions((self) => ({
	        afterCreate() {
	            require$$1$3.addDisposer(self, mobx.autorun(() => {
	                // Merge in the ontologies from our plugin configuration.
	                // Ontologies of a given name that are already in the session
	                // take precedence over the ontologies in the configuration.
	                const { ontologyManager, pluginConfiguration } = self;
	                const configuredOntologies = pluginConfiguration.ontologies;
	                for (const ont of configuredOntologies || []) {
	                    const [name, version, source, indexFields] = [
	                        configuration.readConfObject(ont, 'name'),
	                        configuration.readConfObject(ont, 'version'),
	                        configuration.readConfObject(ont, 'source'),
	                        configuration.readConfObject(ont, 'textIndexFields'),
	                    ];
	                    if (!ontologyManager.findOntology(name)) {
	                        const session = require$$1$2.getSession(self);
	                        const { jobsManager } = session;
	                        const controller = new AbortController();
	                        const jobName = `Loading ontology "${name}"`;
	                        const job = {
	                            name: jobName,
	                            statusMessage: `Loading ontology "${name}", version "${version}", this may take a while`,
	                            progressPct: 0,
	                            cancelCallback: () => {
	                                controller.abort();
	                                jobsManager.abortJob(job.name);
	                            },
	                        };
	                        const update = (message, progress) => {
	                            if (progress === 0) {
	                                jobsManager.runJob(job);
	                                return;
	                            }
	                            if (progress === 100) {
	                                jobsManager.done(job);
	                                return;
	                            }
	                            jobsManager.update(jobName, message, progress);
	                            return;
	                        };
	                        ontologyManager.addOntology(name, version, source, {
	                            textIndexing: { indexFields },
	                            update,
	                        });
	                    }
	                }
	                // TODO: add in any configured ontology prefixes that we don't already
	                // have in the session (or hardcoded in the model)
	            }));
	        },
	    }))
	        .views((self) => ({
	        getBackendDriver(assemblyId) {
	            if (!assemblyId) {
	                return self.collaborationServerDriver;
	            }
	            const session = require$$1$2.getSession(self);
	            const { assemblyManager } = session;
	            const assembly = assemblyManager.get(assemblyId);
	            if (!assembly) {
	                return self.collaborationServerDriver;
	            }
	            const { file, internetAccountConfigId } = configuration.getConf(assembly, [
	                'sequence',
	                'metadata',
	            ]);
	            if (require$$1$2.isElectron && file) {
	                return self.desktopFileDriver;
	            }
	            if (internetAccountConfigId) {
	                return self.collaborationServerDriver;
	            }
	            return self.inMemoryFileDriver;
	        },
	        getInternetAccount(assemblyName, internetAccountId) {
	            if (!(assemblyName ?? internetAccountId)) {
	                throw new Error('Must provide either assemblyName or internetAccountId');
	            }
	            let configId = internetAccountId;
	            if (assemblyName && !configId) {
	                const { assemblyManager } = require$$1$2.getSession(self);
	                const assembly = assemblyManager.get(assemblyName);
	                if (!assembly) {
	                    throw new Error(`No assembly found with name ${assemblyName}`);
	                }
	                ({ internetAccountConfigId: configId } = configuration.getConf(assembly, [
	                    'sequence',
	                    'metadata',
	                ]));
	            }
	            const { internetAccounts } = self;
	            const internetAccount = internetAccounts.find((ia) => ia.internetAccountId === configId);
	            if (!internetAccount) {
	                throw new Error(`No InternetAccount found with config id ${internetAccountId}`);
	            }
	            return internetAccount;
	        },
	    }))
	        .actions((self) => ({
	        loadFeatures: require$$1$3.flow(function* loadFeatures(regions) {
	            for (const region of regions) {
	                const backendDriver = self.getBackendDriver(region.assemblyName);
	                if (!backendDriver) {
	                    return;
	                }
	                const [features, checkResults] = (yield backendDriver.getFeatures(region));
	                if (features.length === 0) {
	                    continue;
	                }
	                const { assemblyName, refName } = region;
	                let assembly = self.assemblies.get(assemblyName);
	                if (!assembly) {
	                    assembly = self.assemblies.put({ _id: assemblyName, refSeqs: {} });
	                }
	                const [firstFeature] = features;
	                let ref = assembly.refSeqs.get(firstFeature.refSeq);
	                if (!ref) {
	                    ref = assembly.refSeqs.put({
	                        _id: firstFeature.refSeq,
	                        name: refName,
	                        features: {},
	                    });
	                }
	                for (const feature of features) {
	                    if (!ref.features.has(feature._id)) {
	                        ref.features.put(feature);
	                    }
	                }
	                self.addCheckResults(checkResults);
	            }
	        }),
	        loadRefSeq: require$$1$3.flow(function* loadRefSeq(regions) {
	            for (const region of regions) {
	                const backendDriver = self.getBackendDriver(region.assemblyName);
	                if (!backendDriver) {
	                    return;
	                }
	                const { refSeq, seq } = yield backendDriver.getSequence(region);
	                const { assemblyName, end, refName, start } = region;
	                let assembly = self.assemblies.get(assemblyName);
	                if (!assembly) {
	                    assembly = self.assemblies.put({ _id: assemblyName, refSeqs: {} });
	                }
	                let ref = assembly.refSeqs.get(refSeq);
	                if (!ref) {
	                    ref = assembly.refSeqs.put({
	                        _id: refSeq,
	                        name: refName,
	                        sequence: [],
	                    });
	                }
	                ref.addSequence({ start, stop: end, sequence: seq });
	            }
	        }),
	    }));
	}

	function extendSession(pluginManager, sessionModel) {
	    const aborter = new AbortController();
	    const { signal } = aborter;
	    const AnnotationFeatureExtended = pluginManager.evaluateExtensionPoint('Apollo-extendAnnotationFeature', dist.AnnotationFeatureModel);
	    const ClientDataStore = clientDataStoreFactory(AnnotationFeatureExtended);
	    const sm = sessionModel
	        .props({
	        apolloDataStore: require$$1$3.types.optional(ClientDataStore, { typeName: 'Client' }),
	        apolloSelectedFeature: require$$1$3.types.safeReference(AnnotationFeatureExtended),
	        jobsManager: require$$1$3.types.optional(ApolloJobModel, {}),
	    })
	        .extend(() => {
	        const collabs = mobx.observable.array([]);
	        return {
	            views: {
	                get collaborators() {
	                    return collabs;
	                },
	            },
	            actions: {
	                addOrUpdateCollaborator(collaborator) {
	                    const existingCollaborator = collabs.find((obj) => obj.id === collaborator.id);
	                    if (existingCollaborator) {
	                        existingCollaborator.locations = collaborator.locations;
	                    }
	                    else {
	                        collabs.push(collaborator);
	                    }
	                },
	            },
	        };
	    })
	        .actions((self) => ({
	        apolloSetSelectedFeature(feature) {
	            // @ts-expect-error Not sure why TS thinks these MST types don't match
	            self.apolloSelectedFeature = feature;
	        },
	        addApolloTrackConfig(assembly, baseURL) {
	            const trackId = `apollo_track_${assembly.name}`;
	            const hasTrack = self.tracks.some((track) => track.trackId === trackId);
	            if (!hasTrack) {
	                self.addTrackConf({
	                    type: 'ApolloTrack',
	                    trackId,
	                    name: `Annotations (${
                    // @ts-expect-error getConf types don't quite work here for some reason
                    configuration.getConf(assembly, 'displayName') || assembly.name})`,
	                    assemblyNames: [assembly.name],
	                    textSearching: {
	                        textSearchAdapter: {
	                            type: 'ApolloTextSearchAdapter',
	                            trackId,
	                            assemblyNames: [assembly.name],
	                            textSearchAdapterId: `apollo_search_${assembly.name}`,
	                            ...(baseURL
	                                ? { baseURL: { uri: baseURL, locationType: 'UriLocation' } }
	                                : {}),
	                        },
	                    },
	                });
	            }
	        },
	        broadcastLocations() {
	            const { internetAccounts } = require$$1$3.getRoot(self);
	            const locations = [];
	            for (const view of self.views) {
	                if (view.type !== 'LinearGenomeView') {
	                    return;
	                }
	                const lgv = view;
	                if (lgv.initialized) {
	                    const { dynamicBlocks } = lgv;
	                    // eslint-disable-next-line unicorn/no-array-for-each
	                    dynamicBlocks.forEach((block) => {
	                        if (block.regionNumber !== undefined) {
	                            const { assemblyName, end, refName, start } = block;
	                            const assembly = self.apolloDataStore.assemblies.get(assemblyName);
	                            if (assembly &&
	                                assembly.backendDriverType === 'CollaborationServerDriver') {
	                                locations.push({ assemblyName, refName, start, end });
	                            }
	                        }
	                    });
	                }
	            }
	            if (locations.length === 0) {
	                for (const internetAccount of internetAccounts) {
	                    if ('baseURL' in internetAccount) {
	                        internetAccount.postUserLocation([]);
	                    }
	                }
	                return;
	            }
	            const allLocations = [];
	            for (const internetAccount of internetAccounts) {
	                if ('baseURL' in internetAccount) {
	                    for (const location of locations) {
	                        const tmpLoc = {
	                            assemblyId: location.assemblyName,
	                            refSeq: location.refName,
	                            start: location.start,
	                            end: location.end,
	                        };
	                        allLocations.push(tmpLoc);
	                    }
	                    internetAccount.postUserLocation(allLocations);
	                }
	            }
	        },
	    }))
	        .actions((self) => ({
	        afterCreate: require$$1$3.flow(function* afterCreate() {
	            mobx.autorun(() => {
	                // broadcastLocations() // **** This is not working and therefore we need to duplicate broadcastLocations() -method code here because autorun() does not observe changes otherwise
	                const locations = [];
	                for (const view of self
	                    .views) {
	                    if (view.type !== 'LinearGenomeView') {
	                        return;
	                    }
	                    const lgv = view;
	                    if (lgv.initialized) {
	                        const { dynamicBlocks } = lgv;
	                        // eslint-disable-next-line unicorn/no-array-for-each
	                        dynamicBlocks.forEach((block) => {
	                            if (block.regionNumber !== undefined) {
	                                const { assemblyName, end, refName, start } = block;
	                                const assembly = self.apolloDataStore.assemblies.get(assemblyName);
	                                if (assembly &&
	                                    assembly.backendDriverType === 'CollaborationServerDriver') {
	                                    locations.push({ assemblyName, refName, start, end });
	                                }
	                            }
	                        });
	                    }
	                }
	                if (locations.length === 0) {
	                    for (const internetAccount of internetAccounts) {
	                        if ('baseURL' in internetAccount) {
	                            internetAccount.postUserLocation([]);
	                        }
	                    }
	                    return;
	                }
	                const allLocations = [];
	                for (const internetAccount of internetAccounts) {
	                    if ('baseURL' in internetAccount) {
	                        for (const location of locations) {
	                            const tmpLoc = {
	                                assemblyId: location.assemblyName,
	                                refSeq: location.refName,
	                                start: location.start,
	                                end: location.end,
	                            };
	                            allLocations.push(tmpLoc);
	                        }
	                        internetAccount.postUserLocation(allLocations);
	                    }
	                }
	            }, { name: 'ApolloSession' });
	            // When the initial config.json loads, it doesn't include the Apollo
	            // tracks, which would result in a potentially invalid session snapshot
	            // if any tracks are open. Here we copy the session snapshot, apply an
	            // empty session snapshot, and then restore the original session
	            // snapshot after the updated config.json loads.
	            // @ts-expect-error type is missing on ApolloRootModel
	            const { internetAccounts, jbrowse, reloadPluginManagerCallback } = require$$1$3.getRoot(self);
	            const pluginConfiguration = 
	            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	            jbrowse.configuration.ApolloPlugin;
	            const hasRole = configuration.readConfObject(pluginConfiguration, 'hasRole');
	            if (hasRole) {
	                return;
	            }
	            const sessionSnapshot = require$$1$3.getSnapshot(self);
	            const { id, name } = sessionSnapshot;
	            require$$1$3.applySnapshot(self, { name, id });
	            // fetch and initialize assemblies for each of our Apollo internet accounts
	            for (const internetAccount of internetAccounts) {
	                if (internetAccount.type !== 'ApolloInternetAccount') {
	                    continue;
	                }
	                const { baseURL } = internetAccount;
	                const uri = new URL('jbrowse/config.json', baseURL).href;
	                const fetch = internetAccount.getFetcher({
	                    locationType: 'UriLocation',
	                    uri,
	                });
	                let response;
	                try {
	                    response = yield fetch(uri, { signal });
	                }
	                catch (error) {
	                    console.error(error);
	                    continue;
	                }
	                if (!response.ok) {
	                    const errorMessage = yield createFetchErrorMessage(response, 'Failed to fetch assemblies');
	                    console.error(errorMessage);
	                    continue;
	                }
	                let jbrowseConfig;
	                try {
	                    jbrowseConfig = yield response.json();
	                }
	                catch (error) {
	                    console.error(error);
	                    continue;
	                }
	                // eslint-disable-next-line @typescript-eslint/no-unsafe-call
	                reloadPluginManagerCallback(jbrowseConfig, sessionSnapshot);
	            }
	        }),
	        beforeDestroy() {
	            aborter.abort('destroying session model');
	        },
	    }))
	        .views((self) => {
	        const superTrackActionMenuItems = self.getTrackActionMenuItems;
	        return {
	            getTrackActionMenuItems(conf) {
	                if (conf.type === 'ApolloTrack' ||
	                    conf.type === 'ReferenceSequenceTrack') {
	                    return superTrackActionMenuItems?.(conf);
	                }
	                const trackId = configuration.readConfObject(conf, 'trackId');
	                const sessionTrackIdentifier = '-sessionTrack';
	                const isSessionTrack = trackId.endsWith(sessionTrackIdentifier);
	                return isSessionTrack
	                    ? [
	                        ...(superTrackActionMenuItems?.(conf) ?? []),
	                        {
	                            label: 'Save track to Apollo',
	                            onClick: async () => {
	                                const { internetAccounts, jbrowse } = require$$1$3.getRoot(self);
	                                const currentConfig = require$$1$3.getSnapshot(jbrowse);
	                                let filteredConfig;
	                                filteredConfig = dist$2.filterJBrowseConfig(currentConfig);
	                                if (Object.keys(filteredConfig).length === 0) {
	                                    filteredConfig = undefined;
	                                }
	                                const trackConfigSnapshot = require$$1$3.getSnapshot(conf);
	                                const newTrackId = trackId.slice(0, trackId.length - sessionTrackIdentifier.length);
	                                const newTrackConfigSnapshot = {
	                                    ...trackConfigSnapshot,
	                                    trackId: newTrackId,
	                                };
	                                for (const internetAccount of internetAccounts) {
	                                    if (internetAccount.type !== 'ApolloInternetAccount') {
	                                        continue;
	                                    }
	                                    const change = new dist$2.ImportJBrowseConfigChange({
	                                        typeName: 'ImportJBrowseConfigChange',
	                                        oldJBrowseConfig: filteredConfig,
	                                        newJBrowseConfig: {
	                                            ...filteredConfig,
	                                            tracks: filteredConfig?.tracks && [
	                                                ...filteredConfig.tracks,
	                                                newTrackConfigSnapshot,
	                                            ],
	                                        },
	                                    });
	                                    const { internetAccountId } = internetAccount;
	                                    await self.apolloDataStore.changeManager.submit(change, {
	                                        internetAccountId,
	                                    });
	                                    const { notify } = self;
	                                    notify('Track added', 'success');
	                                }
	                                // @ts-expect-error This method is missing in the JB types
	                                self.deleteTrackConf(conf);
	                                // eslint-disable-next-line @typescript-eslint/no-unsafe-call
	                                jbrowse.addTrackConf(newTrackConfigSnapshot);
	                            },
	                            icon: default_1,
	                        },
	                    ]
	                    : [
	                        ...(superTrackActionMenuItems?.(conf) ?? []),
	                        {
	                            label: 'Remove track from Apollo',
	                            onClick: async () => {
	                                const { internetAccounts, jbrowse } = require$$1$3.getRoot(self);
	                                const currentConfig = require$$1$3.getSnapshot(jbrowse);
	                                let filteredConfig;
	                                filteredConfig = dist$2.filterJBrowseConfig(currentConfig);
	                                if (Object.keys(filteredConfig).length === 0) {
	                                    filteredConfig = undefined;
	                                }
	                                const filteredTracks = filteredConfig?.tracks?.filter((t) => t.trackId !== trackId);
	                                for (const internetAccount of internetAccounts) {
	                                    if (internetAccount.type !== 'ApolloInternetAccount') {
	                                        continue;
	                                    }
	                                    const change = new dist$2.ImportJBrowseConfigChange({
	                                        typeName: 'ImportJBrowseConfigChange',
	                                        oldJBrowseConfig: filteredConfig,
	                                        newJBrowseConfig: {
	                                            ...filteredConfig,
	                                            tracks: filteredTracks,
	                                        },
	                                    });
	                                    const { internetAccountId } = internetAccount;
	                                    await self.apolloDataStore.changeManager.submit(change, {
	                                        internetAccountId,
	                                    });
	                                    const { notify } = self;
	                                    notify('Track removed', 'success');
	                                }
	                                // @ts-expect-error This method is missing in the JB types
	                                self.deleteTrackConf(conf);
	                                // eslint-disable-next-line @typescript-eslint/no-unsafe-call
	                                jbrowse.deleteTrackConf(conf);
	                            },
	                            icon: default_1,
	                        },
	                    ];
	            },
	        };
	    });
	    return require$$1$3.types.snapshotProcessor(sm, {
	        postProcessor(snap, node) {
	            snap.apolloSelectedFeature = undefined;
	            const assemblies = Object.fromEntries(Object.entries(snap.apolloDataStore.assemblies).filter(([, assembly]) => assembly.backendDriverType === 'InMemoryFileDriver'));
	            // @ts-expect-error ontologyManager isn't actually required
	            snap.apolloDataStore = {
	                typeName: 'Client',
	                assemblies,
	                checkResults: {},
	            };
	            if (!node) {
	                return snap;
	            }
	            const { apolloDataStore } = node;
	            const { checkResults } = apolloDataStore;
	            for (const [, cr] of checkResults) {
	                const [feature] = cr.ids;
	                if (!feature) {
	                    continue;
	                }
	                const assembly = apolloDataStore.assemblies.get(feature.assemblyId);
	                if (assembly && assembly.backendDriverType === 'InMemoryFileDriver') {
	                    snap.apolloDataStore.checkResults[cr._id] = require$$1$3.getSnapshot(cr);
	                }
	            }
	            return snap;
	        },
	    });
	}

	/* eslint-disable @typescript-eslint/unbound-method */
	function isApolloMessageData(data) {
	    return (typeof data === 'object' &&
	        data !== null &&
	        'apollo' in data &&
	        data.apollo === true);
	}
	const inWebWorker = 'WorkerGlobalScope' in globalThis;
	for (const [changeName, change] of Object.entries(dist$2.changes)) {
	    dist$3.changeRegistry.registerChange(changeName, change);
	}
	const cdsCheck = new dist$2.CDSCheck();
	dist$3.checkRegistry.registerCheck(cdsCheck.name, cdsCheck);
	dist$2.validationRegistry.registerValidation(new dist$2.CoreValidation());
	dist$2.validationRegistry.registerValidation(new dist$2.ParentChildValidation());
	class ApolloPlugin extends require$$1__default["default"] {
	    name = 'ApolloPlugin';
	    version = version;
	    configurationSchema = ApolloPluginConfigurationSchema;
	    install(pluginManager) {
	        installApolloSequenceAdapter(pluginManager);
	        installApolloRefNameAliasAdapter(pluginManager);
	        installApolloTextSearchAdapter(pluginManager);
	        pluginManager.addWidgetType(() => {
	            const configSchema = configuration.ConfigurationSchema('ApolloFeatureDetailsWidget', {});
	            const widgetType = new pluggableElementTypes.WidgetType({
	                name: 'ApolloFeatureDetailsWidget',
	                heading: 'Apollo feature details',
	                configSchema,
	                stateModel: ApolloFeatureDetailsWidgetModel,
	                ReactComponent: ApolloFeatureDetailsWidget,
	            });
	            return widgetType;
	        });
	        pluginManager.addWidgetType(() => {
	            const configSchema = configuration.ConfigurationSchema('ApolloTranscriptDetails', {});
	            const widgetType = new pluggableElementTypes.WidgetType({
	                name: 'ApolloTranscriptDetails',
	                heading: 'Apollo transcript details',
	                configSchema,
	                stateModel: ApolloTranscriptDetailsModel,
	                ReactComponent: ApolloTranscriptDetailsWidget,
	            });
	            return widgetType;
	        });
	        pluginManager.addTrackType(() => {
	            const configSchema = configuration.ConfigurationSchema('ApolloTrack', { adapter: '' }, {
	                baseConfiguration: pluggableElementTypes.createBaseTrackConfig(pluginManager),
	                explicitIdentifier: 'trackId',
	            });
	            return new pluggableElementTypes.TrackType({
	                name: 'ApolloTrack',
	                configSchema,
	                stateModel: pluggableElementTypes.createBaseTrackModel(pluginManager, 'ApolloTrack', configSchema),
	            });
	        });
	        pluginManager.addInternetAccountType(() => {
	            return new pluggableElementTypes.InternetAccountType({
	                name: 'ApolloInternetAccount',
	                configSchema: ApolloConfigSchema,
	                stateModel: stateModelFactory$2(ApolloConfigSchema),
	            });
	        });
	        pluginManager.addDisplayType(() => {
	            const configSchema = configSchema$1;
	            return new pluggableElementTypes.DisplayType({
	                name: 'LinearApolloDisplay',
	                configSchema,
	                stateModel: stateModelFactory$1(pluginManager, configSchema),
	                trackType: 'ApolloTrack',
	                viewType: 'LinearGenomeView',
	                ReactComponent: LinearApolloDisplayComponent,
	            });
	        });
	        pluginManager.addDisplayType(() => {
	            const configSchema$1 = configSchema;
	            return new pluggableElementTypes.DisplayType({
	                name: 'LinearApolloSixFrameDisplay',
	                configSchema: configSchema$1,
	                stateModel: stateModelFactory(pluginManager, configSchema$1),
	                trackType: 'ApolloTrack',
	                viewType: 'LinearGenomeView',
	                ReactComponent: LinearApolloSixFrameDisplayComponent,
	            });
	        });
	        pluginManager.addToExtensionPoint('Core-extendSession', 
	        // @ts-expect-error not sure how to deal with snapshot model types
	        extendSession.bind(this, pluginManager));
	        pluginManager.addToExtensionPoint('Core-extendPluggableElement', (pluggableElement) => {
	            if (pluggableElement.name === 'LinearGenomeView') {
	                const { stateModel } = pluggableElement;
	                const lgv = stateModel;
	                const newStateModel = lgv.views((self) => {
	                    const superRubberBandMenuItems = self.rubberBandMenuItems;
	                    return {
	                        rubberBandMenuItems() {
	                            return [
	                                ...superRubberBandMenuItems(),
	                                {
	                                    label: 'Add new feature',
	                                    icon: default_1$p,
	                                    onClick: () => {
	                                        const session = require$$1$2.getSession(self);
	                                        const { leftOffset, rightOffset } = self;
	                                        const selectedRegions = self.getSelectedRegions(leftOffset, rightOffset);
	                                        session.queueDialog((doneCallback) => [
	                                            AddFeature,
	                                            {
	                                                session,
	                                                handleClose: () => {
	                                                    doneCallback();
	                                                },
	                                                region: selectedRegions[0],
	                                                changeManager: session.apolloDataStore.changeManager,
	                                            },
	                                        ]);
	                                    },
	                                },
	                            ];
	                        },
	                    };
	                });
	                pluggableElement.stateModel = newStateModel;
	            }
	            return pluggableElement;
	        });
	        pluginManager.addToExtensionPoint('Core-extendPluggableElement', annotationFromPileup);
	        pluginManager.addToExtensionPoint('Core-extendPluggableElement', annotationFromJBrowseFeature);
	        if (!inWebWorker) {
	            pluginManager.addToExtensionPoint('Core-extendWorker', (handle) => {
	                if (!('on' in handle && handle.on)) {
	                    return handle;
	                }
	                handle.on('apollo', async (event) => {
	                    if (!isApolloMessageData(event)) {
	                        return;
	                    }
	                    const { apollo, messageId, method } = event;
	                    switch (method) {
	                        case 'getSequence': {
	                            const { region } = event;
	                            const { assemblyName } = region;
	                            const dataStore = pluginManager.rootModel?.session?.apolloDataStore;
	                            if (!dataStore) {
	                                break;
	                            }
	                            const backendDriver = dataStore.getBackendDriver(assemblyName);
	                            const { seq: sequence } = await backendDriver.getSequence(region);
	                            handle.workers[0].postMessage({
	                                apollo,
	                                messageId,
	                                sequence,
	                            });
	                            break;
	                        }
	                        case 'getRegions': {
	                            const { assembly } = event;
	                            const dataStore = pluginManager.rootModel?.session?.apolloDataStore;
	                            if (!dataStore) {
	                                break;
	                            }
	                            const backendDriver = dataStore.getBackendDriver(assembly);
	                            const regions = await backendDriver.getRegions(assembly);
	                            handle.workers[0].postMessage({
	                                apollo,
	                                messageId,
	                                regions,
	                            });
	                            break;
	                        }
	                        case 'getRefNameAliases': {
	                            const { assembly } = event;
	                            const dataStore = pluginManager.rootModel?.session?.apolloDataStore;
	                            if (!dataStore) {
	                                break;
	                            }
	                            const backendDriver = dataStore.getBackendDriver(assembly);
	                            const refNameAliases = await backendDriver.getRefNameAliases(assembly);
	                            handle.workers[0].postMessage({
	                                apollo,
	                                messageId,
	                                refNameAliases,
	                            });
	                            break;
	                        }
	                    }
	                });
	                return handle;
	            });
	        }
	    }
	    configure(pluginManager) {
	        if (require$$1$2.isAbstractMenuManager(pluginManager.rootModel)) {
	            pluginManager.rootModel.appendToMenu('Apollo', {
	                label: 'Download GFF3',
	                onClick: (session) => {
	                    session.queueDialog((doneCallback) => [
	                        DownloadGFF3,
	                        {
	                            session,
	                            handleClose: () => {
	                                doneCallback();
	                            },
	                        },
	                    ]);
	                },
	            });
	            pluginManager.rootModel.appendToMenu('Apollo', {
	                label: 'Manage Checks',
	                onClick: (session) => {
	                    session.queueDialog((doneCallback) => [
	                        ManageChecks,
	                        {
	                            session,
	                            handleClose: () => {
	                                doneCallback();
	                            },
	                        },
	                    ]);
	                },
	            });
	            pluginManager.rootModel.appendToMenu('Apollo', {
	                label: 'View Change Log',
	                onClick: (session) => {
	                    session.queueDialog((doneCallback) => [
	                        ViewChangeLog,
	                        {
	                            session,
	                            handleClose: () => {
	                                doneCallback();
	                            },
	                        },
	                    ]);
	                },
	            });
	            pluginManager.rootModel.appendToMenu('Apollo', {
	                label: 'Open local GFF3 file',
	                onClick: (session) => {
	                    session.queueDialog((doneCallback) => [
	                        OpenLocalFile,
	                        {
	                            session,
	                            handleClose: () => {
	                                doneCallback();
	                            },
	                            inMemoryFileDriver: session.apolloDataStore.inMemoryFileDriver,
	                        },
	                    ]);
	                },
	            });
	            pluginManager.rootModel.appendToMenu('Apollo', {
	                label: 'View check results',
	                onClick: (session) => {
	                    session.queueDialog((doneCallback) => [
	                        ViewCheckResults,
	                        {
	                            session,
	                            handleClose: () => {
	                                doneCallback();
	                            },
	                        },
	                    ]);
	                },
	            });
	            pluginManager.rootModel.appendToMenu('Apollo', {
	                label: 'Log out',
	                onClick: (session) => {
	                    session.queueDialog((doneCallback) => [
	                        LogOut,
	                        {
	                            session,
	                            handleClose: () => {
	                                doneCallback();
	                            },
	                        },
	                    ]);
	                },
	            });
	        }
	    }
	}

	exports["default"] = ApolloPlugin;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=jbrowse-plugin-apollo.umd.development.js.map
